from typing import List, Optional, Dict, Iterable, Any, overload

class AboveAverage:
    '''Describe the AboveAverage conditional formatting rule.
    This conditional formatting rule highlights cells that
    are above or below the average for all values in the range.'''

    def isEqualAverage(self) -> bool:
        '''Gets the flag indicating whether the 'aboveAverage' and 'belowAverage' criteria
        is inclusive of the average itself, or exclusive of that value.
        'true' indicates to include the average value in the criteria.
        Default value is false.'''
        raise NotImplementedError()

    def getStdDev(self) -> int:
        '''Gets the number of standard deviations to include above or below the average in the
        conditional formatting rule.
        The input value must between 0 and 3 (include 0 and 3).
        Setting this value to 0 means stdDev is not set.
        The default value is 0.'''
        raise NotImplementedError()

    def setEqualAverage(self, value : bool) -> None:
        '''Sets the flag indicating whether the 'aboveAverage' and 'belowAverage' criteria
        is inclusive of the average itself, or exclusive of that value.
        'true' indicates to include the average value in the criteria.
        Default value is false.
        :param value: '''
        raise NotImplementedError()

    def setStdDev(self, value : int) -> None:
        '''Sets the number of standard deviations to include above or below the average in the
        conditional formatting rule.
        The input value must between 0 and 3 (include 0 and 3).
        Setting this value to 0 means stdDev is not set.
        The default value is 0.
        :param value: '''
        raise NotImplementedError()

    def isAboveAverage(self) -> bool:
        '''Gets the flag indicating whether the rule is an "above average" rule.
        'true' indicates 'above average'.
        Default value is true.'''
        raise NotImplementedError()

    def setAboveAverage(self, value : bool) -> None:
        '''Sets the flag indicating whether the rule is an "above average" rule.
        'true' indicates 'above average'.
        Default value is true.
        :param value: '''
        raise NotImplementedError()


class AbstractCalculationEngine:
    '''Represents user's custom calculation engine to extend the default calculation engine of Aspose.Cells.'''

    def forceRecalculate(self, functionName : str) -> bool:
        '''Whether force given function to be recalculated always when calculating shared formulas.
        :param functionName: name of the function. Generally it is custom function's name.
        :returns: true if the specified function needs to be recalculated always.'''
        raise NotImplementedError()

    def isParamArrayModeRequired(self) -> bool:
        '''Indicates whether this engine needs the parameter to be calculated in array mode. Default value is false.
        If :meth:`CalculationData.getParamValueInArrayMode(int,int,int)` is required when calculating custom
        functions and user has not updated the definition for them
        (by :meth:`Workbook.updateCustomFunctionDefinition(CustomFunctionDefinition)`),
        this property needs to be set as true.'''
        raise NotImplementedError()

    def calculate(self, data : CalculationData) -> None:
        '''Calculates one function with given data.
        :param data: the required data to calculate function such as function name, parameters, ...etc.'''
        raise NotImplementedError()

    def isParamLiteralRequired(self) -> bool:
        '''Indicates whether this engine needs the literal text of parameter while doing calculation. Default value is false.'''
        raise NotImplementedError()

    def getProcessBuiltInFunctions(self) -> bool:
        '''Whether built-in functions that have been supported by the built-in engine
        should be checked and processed by this implementation.
        Default is false.'''
        raise NotImplementedError()


class AbstractCalculationMonitor:
    '''Monitor for user to track the progress of formula calculation.'''

    def afterCalculate(self, sheetIndex : int, rowIndex : int, colIndex : int) -> None:
        '''Implement this method to do business after one cell has been calculated.
        :param sheetIndex: Index of the sheet that the cell belongs to.
        :param rowIndex: Row index of the cell
        :param colIndex: Column index of the cell'''
        raise NotImplementedError()

    def getCalculatedValue(self) -> Object:
        '''Gets the newly calculated value of the cell.
        Should be used only in :meth:`AbstractCalculationMonitor.afterCalculate(int,int,int)`.'''
        raise NotImplementedError()

    def getValueChanged(self) -> bool:
        '''Whether the cell's value has been changed after the calculation.
        Should be used only in :meth:`AbstractCalculationMonitor.afterCalculate(int,int,int)`.'''
        raise NotImplementedError()

    def getOriginalValue(self) -> Object:
        '''Gets the old value of the calculated cell.
        Should be used only in :meth:`AbstractCalculationMonitor.beforeCalculate(int,int,int)` and :meth:`AbstractCalculationMonitor.afterCalculate(int,int,int)`.'''
        raise NotImplementedError()

    def onCircular(self, circularCellsData : Iterator) -> bool:
        '''Implement this method to do business when calculating formulas with circular references.
        :param circularCellsData: IEnumerator with :class:`CalculationCell` items representing cells that
        :returns: Whether the formula engine needs to calculate those cells in circular after this call. True to let the formula engine continue to do calculation for them. False to let the formula engine just mark those cells as Calculated.'''
        raise NotImplementedError()

    def beforeCalculate(self, sheetIndex : int, rowIndex : int, colIndex : int) -> None:
        '''Implement this method to do business before calculating one cell.
        :param sheetIndex: Index of the sheet that the cell belongs to.
        :param rowIndex: Row index of the cell
        :param colIndex: Column index of the cell'''
        raise NotImplementedError()


class AbstractFormulaChangeMonitor:
    '''Monitor for user to track the change of formulas during certain operations.'''

    def onCellFormulaChanged(self, sheetIndex : int, rowIndex : int, columnIndex : int) -> None:
        '''The event that will be triggered when the formula in a cell is changed.
        :param sheetIndex: The sheet index of the changed cell
        :param rowIndex: The row index of the changed cell
        :param columnIndex: The column index of the changed cell'''
        raise NotImplementedError()


class AbstractGlobalizationSettings:
    '''Represents the globalization settings.'''

    def getCollationKey(self, v : str, ignoreCase : bool) -> Comparable:
        '''Transforms the string into a comparable object according to certain collation rules.
        :param v: String value needs to be compared with others.
        :param ignoreCase: whether ignore case when comparing values
        :returns: Object can be used to compare or sort string values'''
        raise NotImplementedError()

    def compare(self, v1 : str, v2 : str, ignoreCase : bool) -> int:
        '''Compares two string values according to certain collation rules.
        :param v1: the first string
        :param v2: the second string
        :param ignoreCase: whether ignore case when comparing values
        :returns: Integer that indicates the lexical relationship between the two comparands'''
        raise NotImplementedError()



class AbstractInterruptMonitor:
    '''Monitor for interruption requests in all time-consuming operations.'''

    def getTerminateWithoutException(self) -> bool:
        '''When procedure is interrupted, whether terminate the procedure quietly or throw an Exception.
        Default is false, that is, when :meth:`AbstractInterruptMonitor.isInterruptionRequested()` is true,
        a :class:`CellsException` with code :attr:`ExceptionType.INTERRUPTED` will be thrown.'''
        raise NotImplementedError()

    def isInterruptionRequested(self) -> bool:
        '''Indicates whether interruption is requested for current operation.
        If true then current operation will be interrupted.
        Implementation should perform fast and efficient check here, otherwise it may become another bottleneck for the procedure.'''
        raise NotImplementedError()


class AbstractTextLoadOptions:
    '''Common options for loading text values'''

    def getLoadStyleStrategy(self) -> int:
        '''Indicates the strategy to apply style for parsed values when converting string value to number or datetime.
        See :class:`TxtLoadStyleStrategy`'''
        raise NotImplementedError()

    def setConvertNumericData(self, value : bool) -> None:
        '''Sets a value that indicates whether the string in text file is converted to numeric data.
        :param value: '''
        raise NotImplementedError()

    def setKeepPrecision(self, value : bool) -> None:
        '''Indicates whether not parsing a string value if the length is 15.
        :param value: '''
        raise NotImplementedError()

    def setEncoding(self, value : Encoding) -> None:
        '''Sets the default encoding. Only applies for csv file.
        :param value: '''
        raise NotImplementedError()

    def getConvertNumericData(self) -> bool:
        '''Gets a value that indicates whether the string in text file is converted to numeric data.'''
        raise NotImplementedError()

    def setConvertDateTimeData(self, value : bool) -> None:
        '''Sets a value that indicates whether the string in text file is converted to date data.
        :param value: '''
        raise NotImplementedError()

    def getKeepPrecision(self) -> bool:
        '''Indicates whether not parsing a string value if the length is 15.'''
        raise NotImplementedError()

    def getConvertDateTimeData(self) -> bool:
        '''Gets a value that indicates whether the string in text file is converted to date data.'''
        raise NotImplementedError()

    def getEncoding(self) -> Encoding:
        '''Gets the default encoding. Only applies for csv file.'''
        raise NotImplementedError()

    def setLoadStyleStrategy(self, value : int) -> None:
        '''Indicates the strategy to apply style for parsed values when converting string value to number or datetime.
        See :class:`TxtLoadStyleStrategy`
        :param value: '''
        raise NotImplementedError()


class AccentEquationNode:
    '''This class specifies an accent equation, consisting of a base component and a combining diacritic.'''

    def getAccentCharacter(self) -> str:
        '''This attribute specifies the type of combining diacritical mark attached to the base of the accent function. The default accent character is U+0302.
        It is strongly recommended to use attribute AccentType to set accent character.
        Use this property setting if you cannot find the character you need in a known type.'''
        raise NotImplementedError()

    def setAccentCharacter(self, value : str) -> None:
        '''This attribute specifies the type of combining diacritical mark attached to the base of the accent function. The default accent character is U+0302.
        It is strongly recommended to use attribute AccentType to set accent character.
        Use this property setting if you cannot find the character you need in a known type.
        :param value: '''
        raise NotImplementedError()

    def getAccentCharacterType(self) -> int:
        '''Specify combining characters by type value.
        See :class:`EquationCombiningCharacterType`'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()

    def setAccentCharacterType(self, value : int) -> None:
        '''Specify combining characters by type value.
        See :class:`EquationCombiningCharacterType`
        :param value: '''
        raise NotImplementedError()


class AccessCacheOptions:
    '''Cache options for data access. Can be combined with | operator for multiple options together.'''

    NONE : AccessCacheOptions
    '''No cache for any data access.'''

    ALL : AccessCacheOptions
    '''Apply all possible optimizations for all kinds of data access in the workbook.
    All settings and data should not be changed during the optimized access.'''

    POSITION_AND_SIZE : AccessCacheOptions
    '''Apply possible optimization for getting object(such as Shape)'s position and size.
    Row height and column width settings should not be changed during the optimized access.'''

    CELLS_DATA : AccessCacheOptions
    '''Apply possible optimization for getting cells' values.
    Cells data(data and settings of Cell, Row) should not be changed during
    the optimized access, no new Cell/Row objects should be created either(such as
    by :meth:`Cells.get(int,int)`).'''

    CELL_DISPLAY : AccessCacheOptions
    '''Apply possible optimization for getting display-related results of
    cells(:meth:`Cell.getDisplayStringValue()`, :meth:`Cell.getStyle()`, :meth:`Cell.getDisplayStyle()`, etc.).
    Cells data and style-related objects(Cell/Row/Column styles, column width, etc.) should not be changed
    during the optimized access.'''

    GET_FORMULA : AccessCacheOptions
    '''Apply possible optimization for getting formulas.
    All data and settings which may affect the formula expression(Worksheet's name, Name's text,
    table's column, etc.) should not be changed during the optimized access.'''

    SET_FORMULA : AccessCacheOptions
    '''Apply possible optimization for setting formulas.
    All data and settings which may affect the formula expression(Worksheet's name, Name's text,
    table's column, etc.) should not be changed during the optimized access.'''

    CALCULATE_FORMULA : AccessCacheOptions
    '''Apply possible optimization for calculating formulas.
    Cells data should not be changed during the optimized access, none new objects(Cell, Row, etc.)
    should be created either(such as by :meth:`Cells.get(int,int)`).'''

    CONDITIONAL_FORMATTING : AccessCacheOptions
    '''Apply possible optimization for getting formatting result of conditional formattings.
    All data and settings which may affect the result of conditional formattings(settings of
    conditional formattings, dependent cell values, etc.) should not be changed during the optimized access.'''

    VALIDATION : AccessCacheOptions
    '''Apply possible optimization for getting validation result.
    All data and settings which may affect the result of validation(settings of the validation,
    dependent cell values, etc.) should not be changed during the optimized access.'''


class ActiveXControl:
    '''Represents the ActiveX control.'''

    def isLocked(self) -> bool:
        '''Indicates whether data in the control is locked for editing.'''
        raise NotImplementedError()

    def isAutoSize(self) -> bool:
        '''Indicates whether the control will automatically resize to display its entire contents.'''
        raise NotImplementedError()

    def setIMEMode(self, value : int) -> None:
        '''Sets the default run-time mode of the Input Method Editor for the control as it receives focus.
        See :class:`InputMethodEditorMode`
        :param value: '''
        raise NotImplementedError()

    def getIMEMode(self) -> int:
        '''Gets the default run-time mode of the Input Method Editor for the control as it receives focus.
        See :class:`InputMethodEditorMode`'''
        raise NotImplementedError()

    def getFont(self) -> Font:
        '''Represents the font of the control.'''
        raise NotImplementedError()

    def setLocked(self, value : bool) -> None:
        '''Indicates whether data in the control is locked for editing.
        :param value: '''
        raise NotImplementedError()

    def setEnabled(self, value : bool) -> None:
        '''Indicates whether the control can receive the focus and respond to user-generated events.
        :param value: '''
        raise NotImplementedError()

    def setTextAlign(self, value : int) -> None:
        '''Represents how to align the text used by the control.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getData(self) -> list[int]:
        '''Gets the binary data of the control.'''
        raise NotImplementedError()

    def isTransparent(self) -> bool:
        '''Indicates whether the control is transparent.'''
        raise NotImplementedError()

    def setAutoSize(self, value : bool) -> None:
        '''Indicates whether the control will automatically resize to display its entire contents.
        :param value: '''
        raise NotImplementedError()

    def getTextAlign(self) -> int:
        '''Represents how to align the text used by the control.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def setTransparent(self, value : bool) -> None:
        '''Indicates whether the control is transparent.
        :param value: '''
        raise NotImplementedError()

    def isEnabled(self) -> bool:
        '''Indicates whether the control can receive the focus and respond to user-generated events.'''
        raise NotImplementedError()


class ActiveXControlBase:
    '''Represents the ActiveX control.'''

    def setListFillRange(self, value : str) -> None:
        '''Sets the list fill range.
        :param value: '''
        raise NotImplementedError()

    def setBackOleColor(self, value : int) -> None:
        '''Sets the ole color of the background.
        :param value: '''
        raise NotImplementedError()

    def setWidth(self, value : int) -> None:
        '''Sets the width of the control in unit of points.
        :param value: '''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Gets the width of the control in unit of points.'''
        raise NotImplementedError()

    def getShadow(self) -> bool:
        '''Indicates whether to show a shadow.'''
        raise NotImplementedError()

    def setHeight(self, value : int) -> None:
        '''Sets the height of the control in unit of points.
        :param value: '''
        raise NotImplementedError()

    def getWorkbook(self) -> Workbook:
        '''Gets the :class:`Workbook` object.'''
        raise NotImplementedError()

    def getBackOleColor(self) -> int:
        '''Gets the ole color of the background.'''
        raise NotImplementedError()

    def getLinkedCell(self) -> str:
        '''Gets the linked cell.'''
        raise NotImplementedError()

    def setLinkedCell(self, value : str) -> None:
        '''Sets the linked cell.
        :param value: '''
        raise NotImplementedError()

    def getData(self) -> list[int]:
        '''Gets the binary data of the control.'''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Gets the height of the control in unit of points.'''
        raise NotImplementedError()

    def setMousePointer(self, value : int) -> None:
        '''Sets the type of icon displayed as the mouse pointer for the control.
        See :class:`ControlMousePointerType`
        :param value: '''
        raise NotImplementedError()

    def getMouseIcon(self) -> list[int]:
        '''Gets a custom icon to display as the mouse pointer for the control.'''
        raise NotImplementedError()

    def setMouseIcon(self, value : list[int]) -> None:
        '''Sets a custom icon to display as the mouse pointer for the control.
        :param value: '''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Indicates whether this control is visible.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()

    def getListFillRange(self) -> str:
        '''Gets the list fill range.'''
        raise NotImplementedError()

    def setVisible(self, value : bool) -> None:
        '''Indicates whether this control is visible.
        :param value: '''
        raise NotImplementedError()

    def getForeOleColor(self) -> int:
        '''Gets the ole color of the foreground.'''
        raise NotImplementedError()

    def getMousePointer(self) -> int:
        '''Gets the type of icon displayed as the mouse pointer for the control.
        See :class:`ControlMousePointerType`'''
        raise NotImplementedError()

    def setForeOleColor(self, value : int) -> None:
        '''Sets the ole color of the foreground.
        :param value: '''
        raise NotImplementedError()

    def setShadow(self, value : bool) -> None:
        '''Indicates whether to show a shadow.
        :param value: '''
        raise NotImplementedError()


class ActiveXPersistenceType:
    '''Represents the persistence method to persist an ActiveX control.'''

    PROPERTY_BAG : ActiveXPersistenceType
    '''The data is stored as xml data.'''

    STORAGE : ActiveXPersistenceType
    '''The data is stored as a storage binary data.'''

    STREAM : ActiveXPersistenceType
    '''The data is stored as a stream binary data.'''

    STREAM_INIT : ActiveXPersistenceType
    '''The data is stored as a streaminit binary data.'''


class AdjustFontSizeForRowType:
    '''Represents which kind of rows should be ajusted.'''

    NONE : AdjustFontSizeForRowType
    '''No adjsut.'''

    EMPTY_ROWS : AdjustFontSizeForRowType
    '''If the row is empty, change font size to fit row height.'''


class AdvancedFilter:
    '''Represents the settings of advanced filter.'''

    def getCriteriaRange(self) -> str:
        '''Gets the criteria range of this advanced filter.'''
        raise NotImplementedError()

    def getListRange(self) -> str:
        '''Gets the list range of this advanced filter.'''
        raise NotImplementedError()

    def getCopyToRange(self) -> str:
        '''Gets the range where copying the resut of this advanced filter to.'''
        raise NotImplementedError()



class ArcShape:
    '''Represents the arc shape.'''

    def getEndArrowheadStyle(self) -> int:
        ''':deprecated: Use Shape.Line.EndArrowheadStyle property instead.'''
        raise NotImplementedError()

    def getEndArrowheadWidth(self) -> int:
        ''':deprecated: Use Shape.Line.EndArrowheadWidth property instead.'''
        raise NotImplementedError()

    def setEndArrowheadStyle(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.EndArrowheadStyle property instead.'''
        raise NotImplementedError()

    def setEndArrowheadWidth(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.EndArrowheadWidth property instead.'''
        raise NotImplementedError()

    def setEndArrowheadLength(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.EndArrowheadLength property instead.'''
        raise NotImplementedError()

    def getBeginArrowheadStyle(self) -> int:
        ''':deprecated: Use Shape.Line.BeginArrowheadStyle property instead.'''
        raise NotImplementedError()

    def getBeginArrowheadWidth(self) -> int:
        ''':deprecated: Use Shape.Line.BeginArrowheadWidth property instead.'''
        raise NotImplementedError()

    def setBeginArrowheadLength(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.BeginArrowheadLength property instead.'''
        raise NotImplementedError()

    def getBeginArrowheadLength(self) -> int:
        ''':deprecated: Use Shape.Line.BeginArrowheadLength property instead.'''
        raise NotImplementedError()

    def setBeginArrowheadStyle(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.BeginArrowheadStyle property instead.'''
        raise NotImplementedError()

    def setBeginArrowheadWidth(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.BeginArrowheadWidth property instead.'''
        raise NotImplementedError()

    def getEndArrowheadLength(self) -> int:
        ''':deprecated: Use Shape.Line.EndArrowheadLength property instead.'''
        raise NotImplementedError()


class Area:
    '''Encapsulates the object that represents an area format.'''

    def setTransparency(self, value : int) -> None:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def getInvertIfNegative(self) -> bool:
        '''If the property is true and the value of chart point is a negative number,
        the foreground color and background color will be exchanged.'''
        raise NotImplementedError()

    def setForegroundColor(self, value : Color) -> None:
        '''Sets the foreground :class:`Color`.
        :param value: '''
        raise NotImplementedError()

    def setInvertIfNegative(self, value : bool) -> None:
        '''If the property is true and the value of chart point is a negative number,
        the foreground color and background color will be exchanged.
        :param value: '''
        raise NotImplementedError()

    def getForegroundColor(self) -> Color:
        '''Gets the foreground :class:`Color`.'''
        raise NotImplementedError()

    def setBackgroundColor(self, value : Color) -> None:
        '''Sets the background :class:`Color` of the :class:`Area`.
        :param value: '''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()

    def getFormatting(self) -> int:
        '''Represents the formatting of the area.
        See :class:`FormattingType`'''
        raise NotImplementedError()

    def getBackgroundColor(self) -> Color:
        '''Gets the background :class:`Color` of the :class:`Area`.'''
        raise NotImplementedError()

    def setFormatting(self, value : int) -> None:
        '''Represents the formatting of the area.
        See :class:`FormattingType`
        :param value: '''
        raise NotImplementedError()

    def getFillFormat(self) -> FillFormat:
        '''Represents a :meth:`Area.getFillFormat()` object that contains fill formatting properties for the specified chart or shape.'''
        raise NotImplementedError()


class ArrayEquationNode:
    '''Specifies the Equation-Array function, an object consisting of one or more equations.'''

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class AutoFillType:
    '''Represents the auto fill type.'''

    COPY : AutoFillType
    '''Copies the value and format of the source area to the target area'''

    DEFAULT : AutoFillType
    '''Automatically fills the target area with the value and format.'''

    FORMATS : AutoFillType
    '''Copies only the format of the source area to the target area,'''

    SERIES : AutoFillType
    '''Extend the value in the source area to the target area in the form of a series and copy format to the target area.'''

    VALUES : AutoFillType
    '''Copies only the value of the source area to the target area,'''


class AutoFilter:
    '''Represents autofiltering for the specified worksheet.'''

    @overload
    def custom(self, fieldIndex : int, operatorType1 : int, criteria1 : Object) -> None:
        '''Filters a list with a custom criteria.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param operatorType1: :class:`FilterOperatorType`. The filter operator type
        :param criteria1: The custom criteria'''
        raise NotImplementedError()

    @overload
    def custom(self, fieldIndex : int, operatorType1 : int, criteria1 : Object, isAnd : bool, operatorType2 : int, criteria2 : Object) -> None:
        '''Filters a list with custom criteria.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param operatorType1: :class:`FilterOperatorType`. The filter operator type
        :param criteria1: The custom criteria
        :param isAnd: 
        :param operatorType2: :class:`FilterOperatorType`. The filter operator type
        :param criteria2: The custom criteria'''
        raise NotImplementedError()

    def addFilter(self, fieldIndex : int, criteria : str) -> None:
        '''Adds a filter for a filter column.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param criteria: The specified criteria (a string; for example, "101").'''
        raise NotImplementedError()

    def getShowFilterButton(self) -> bool:
        '''Indicates whether the AutoFilter button for this column is visible.'''
        raise NotImplementedError()

    def dynamicFilter(self, fieldIndex : int, dynamicFilterType : int) -> None:
        '''Adds a dynamic filter.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param dynamicFilterType: :class:`DynamicFilterType`.'''
        raise NotImplementedError()

    def matchNonBlanks(self, fieldIndex : int) -> None:
        '''Match all not blank cell in the list.
        :param fieldIndex: The integer offset of the field on which you want to base the filter'''
        raise NotImplementedError()

    def removeDateFilter(self, fieldIndex : int, dateTimeGroupingType : int, year : int, month : int, day : int, hour : int, minute : int, second : int) -> None:
        '''Removes a date filter.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param dateTimeGroupingType: :class:`DateTimeGroupingType`. The grouping type
        :param year: The year.
        :param month: The month.
        :param day: The day.
        :param hour: The hour.
        :param minute: The minute.
        :param second: The second.'''
        raise NotImplementedError()

    @overload
    def refresh(self) -> list[int]:
        '''Refresh auto filters to hide or unhide the rows.'''
        raise NotImplementedError()

    @overload
    def refresh(self, hideRows : bool) -> list[int]:
        '''Gets all hidden rows' indexes.
        :param hideRows: 
        :returns: Returns all hidden rows indexes.'''
        raise NotImplementedError()

    def setShowFilterButton(self, value : bool) -> None:
        '''Indicates whether the AutoFilter button for this column is visible.
        :param value: '''
        raise NotImplementedError()

    def addFillColorFilter(self, fieldIndex : int, pattern : int, foregroundColor : CellsColor, backgroundColor : CellsColor) -> None:
        '''Adds a fill color filter.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param pattern: :class:`BackgroundType`. The background pattern type.
        :param foregroundColor: The foreground color.
        :param backgroundColor: The background color.'''
        raise NotImplementedError()

    @overload
    def removeFilter(self, fieldIndex : int, criteria : str) -> None:
        '''Removes a filter for a filter column.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param criteria: The specified criteria (a string; for example, "101").'''
        raise NotImplementedError()

    @overload
    def removeFilter(self, fieldIndex : int) -> None:
        '''Remove the specific filter.
        :param fieldIndex: The specific filter index'''
        raise NotImplementedError()

    def getCellArea(self) -> CellArea:
        '''Gets the :class:`CellArea` where the specified AutoFilter applies to.'''
        raise NotImplementedError()

    def getFilterColumns(self) -> FilterColumnCollection:
        '''Gets the collection of the filter columns.'''
        raise NotImplementedError()

    def addIconFilter(self, fieldIndex : int, iconSetType : int, iconId : int) -> None:
        '''Adds an icon filter.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param iconSetType: :class:`IconSetType`. The icon set type.
        :param iconId: The icon id.'''
        raise NotImplementedError()

    def matchBlanks(self, fieldIndex : int) -> None:
        '''Match all blank cell in the list.
        :param fieldIndex: The integer offset of the field on which you want to base the filter'''
        raise NotImplementedError()

    def showAll(self) -> None:
        '''Unhide all rows.'''
        raise NotImplementedError()

    def addFontColorFilter(self, fieldIndex : int, color : CellsColor) -> None:
        '''Adds a font color filter.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param color: The :class:`CellsColor` object.'''
        raise NotImplementedError()

    def addDateFilter(self, fieldIndex : int, dateTimeGroupingType : int, year : int, month : int, day : int, hour : int, minute : int, second : int) -> None:
        '''Adds a date filter.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param dateTimeGroupingType: :class:`DateTimeGroupingType`. The grouping type
        :param year: The year.
        :param month: The month.
        :param day: The day.
        :param hour: The hour.
        :param minute: The minute.
        :param second: The second.'''
        raise NotImplementedError()

    def filter(self, fieldIndex : int, criteria : str) -> None:
        '''Filters a list with specified criteria.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param criteria: The specified criteria (a string; for example, "101").'''
        raise NotImplementedError()

    def getSorter(self) -> DataSorter:
        '''Gets the data sorter.'''
        raise NotImplementedError()

    def filterTop10(self, fieldIndex : int, isTop : bool, isPercent : bool, itemCount : int) -> None:
        '''Filter the top 10 item in the list
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :param isTop: Indicates whether filter from top or bottom
        :param isPercent: Indicates whether the items is percent or count
        :param itemCount: The item count'''
        raise NotImplementedError()

    @overload
    def setRange(self, row : int, startColumn : int, endColumn : int) -> None:
        '''Sets the range to which the specified AutoFilter applies.
        :param row: Row index.
        :param startColumn: Start column index.
        :param endColumn: End column Index.'''
        raise NotImplementedError()

    @overload
    def setRange(self, value : str) -> None:
        '''Represents the range to which the specified AutoFilter applies.
        :param value: '''
        raise NotImplementedError()

    def getRange(self) -> str:
        '''Represents the range to which the specified AutoFilter applies.'''
        raise NotImplementedError()


class AutoFitMergedCellsType:
    '''Represents the type of auto fitting merged cells.'''

    NONE : AutoFitMergedCellsType
    '''Ignore merged cells.'''

    FIRST_LINE : AutoFitMergedCellsType
    '''Only expands the height of the first row.'''

    LAST_LINE : AutoFitMergedCellsType
    '''Only expands the height of the last row.'''

    EACH_LINE : AutoFitMergedCellsType
    '''Expands the height of each row.'''


class AutoFitterOptions:
    '''Represents all auto fitter options.'''

    def getForRendering(self) -> bool:
        '''Indicates whether fit for rendering purpose.'''
        raise NotImplementedError()

    def getAutoFitMergedCellsType(self) -> int:
        '''Gets the type of auto fitting row height of merged cells.
        See :class:`AutoFitMergedCellsType`'''
        raise NotImplementedError()

    def getAutoFitWrappedTextType(self) -> int:
        '''Gets the type of auto fitting wrapped text.
        See :class:`AutoFitWrappedTextType`'''
        raise NotImplementedError()

    def getOnlyAuto(self) -> bool:
        '''Indicates whether only fit the rows which height are not customed.'''
        raise NotImplementedError()

    def setFormatStrategy(self, value : int) -> None:
        '''Sets the formatted strategy.
        See :class:`CellValueFormatStrategy`
        :param value: '''
        raise NotImplementedError()

    def setAutoFitMergedCellsType(self, value : int) -> None:
        '''Sets the type of auto fitting row height of merged cells.
        See :class:`AutoFitMergedCellsType`
        :param value: '''
        raise NotImplementedError()

    def setMaxRowHeight(self, value : int) -> None:
        '''Sets the max row height(in unit of Point) when autofitting rows.
        :param value: '''
        raise NotImplementedError()

    def getAutoFitMergedCells(self) -> bool:
        ''':deprecated: Use AutoFitterOptions.AutoFitMergedCellsType property, instead.'''
        raise NotImplementedError()

    def getMaxRowHeight(self) -> int:
        '''Gets the max row height(in unit of Point) when autofitting rows.'''
        raise NotImplementedError()

    def setForRendering(self, value : bool) -> None:
        '''Indicates whether fit for rendering purpose.
        :param value: '''
        raise NotImplementedError()

    def setDefaultEditLanguage(self, value : int) -> None:
        '''Sets default edit language.
        See :class:`DefaultEditLanguage`
        :param value: '''
        raise NotImplementedError()

    def getIgnoreHidden(self) -> bool:
        '''Ignores the hidden rows/columns.'''
        raise NotImplementedError()

    def setAutoFitWrappedTextType(self, value : int) -> None:
        '''Sets the type of auto fitting wrapped text.
        See :class:`AutoFitWrappedTextType`
        :param value: '''
        raise NotImplementedError()

    def setAutoFitMergedCells(self, value : bool) -> None:
        ''':deprecated: Use AutoFitterOptions.AutoFitMergedCellsType property, instead.'''
        raise NotImplementedError()

    def getFormatStrategy(self) -> int:
        '''Gets the formatted strategy.
        See :class:`CellValueFormatStrategy`'''
        raise NotImplementedError()

    def setOnlyAuto(self, value : bool) -> None:
        '''Indicates whether only fit the rows which height are not customed.
        :param value: '''
        raise NotImplementedError()

    def getDefaultEditLanguage(self) -> int:
        '''Gets default edit language.
        See :class:`DefaultEditLanguage`'''
        raise NotImplementedError()

    def setIgnoreHidden(self, value : bool) -> None:
        '''Ignores the hidden rows/columns.
        :param value: '''
        raise NotImplementedError()


class AutoFitWrappedTextType:
    '''Represents the type of auto fitting wrapped text.'''

    DEFAULT : AutoFitWrappedTextType
    '''Works as MS Excel.'''

    PARAGRAPH : AutoFitWrappedTextType
    '''Auto fit width with the longest paragraph.'''


class AutomaticFill:
    '''represents automatic fill.'''


class AutoNumberedBulletValue:
    '''Represents automatic numbered bullet.'''

    def setAutonumberScheme(self, value : int) -> None:
        '''Represents the scheme of automatic number.
        See :class:`TextAutonumberScheme`
        :param value: '''
        raise NotImplementedError()

    def setStartAt(self, value : int) -> None:
        '''Sets the starting number of the bullet.
        :param value: '''
        raise NotImplementedError()

    def getStartAt(self) -> int:
        '''Gets the starting number of the bullet.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the bullet.
        See :class:`BulletType`'''
        raise NotImplementedError()

    def getAutonumberScheme(self) -> int:
        '''Represents the scheme of automatic number.
        See :class:`TextAutonumberScheme`'''
        raise NotImplementedError()


class AutoShapeType:
    '''Represents all built-in auto shape type.'''

    NOT_PRIMITIVE : AutoShapeType
    ''''''

    RECTANGLE : AutoShapeType
    ''''''

    ROUNDED_RECTANGLE : AutoShapeType
    ''''''

    OVAL : AutoShapeType
    ''''''

    DIAMOND : AutoShapeType
    ''''''

    ISOSCELES_TRIANGLE : AutoShapeType
    ''''''

    RIGHT_TRIANGLE : AutoShapeType
    ''''''

    PARALLELOGRAM : AutoShapeType
    ''''''

    TRAPEZOID : AutoShapeType
    ''''''

    HEXAGON : AutoShapeType
    ''''''

    OCTAGON : AutoShapeType
    ''''''

    CROSS : AutoShapeType
    ''''''

    STAR_5 : AutoShapeType
    ''''''

    RIGHT_ARROW : AutoShapeType
    ''''''

    HOME_PLATE : AutoShapeType
    ''''''

    CUBE : AutoShapeType
    ''''''

    BALLOON : AutoShapeType
    ''''''

    SEAL : AutoShapeType
    ''''''

    ARC : AutoShapeType
    ''''''

    LINE : AutoShapeType
    ''''''

    PLAQUE : AutoShapeType
    ''''''

    CAN : AutoShapeType
    ''''''

    DONUT : AutoShapeType
    ''''''

    TEXT_SIMPLE : AutoShapeType
    ''''''

    TEXT_OCTAGON : AutoShapeType
    ''''''

    TEXT_HEXAGON : AutoShapeType
    ''''''

    TEXT_CURVE : AutoShapeType
    ''''''

    TEXT_WAVE : AutoShapeType
    ''''''

    TEXT_RING : AutoShapeType
    ''''''

    TEXT_ON_CURVE : AutoShapeType
    ''''''

    MSOSPT_TEXT_ON_RING : AutoShapeType
    ''''''

    STRAIGHT_CONNECTOR : AutoShapeType
    ''''''

    BENT_CONNECTOR_2 : AutoShapeType
    ''''''

    ELBOW_CONNECTOR : AutoShapeType
    ''''''

    BENT_CONNECTOR_4 : AutoShapeType
    ''''''

    BENT_CONNECTOR_5 : AutoShapeType
    ''''''

    CURVED_CONNECTOR_2 : AutoShapeType
    ''''''

    CURVED_CONNECTOR : AutoShapeType
    ''''''

    CURVED_CONNECTOR_4 : AutoShapeType
    ''''''

    CURVED_CONNECTOR_5 : AutoShapeType
    ''''''

    LINE_CALLOUT_NO_BORDER_2 : AutoShapeType
    ''''''

    LINE_CALLOUT_NO_BORDER_3 : AutoShapeType
    ''''''

    LINE_CALLOUT_NO_BORDER_4 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_ACCENT_BAR_2 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_ACCENT_BAR_3 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_ACCENT_BAR_4 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_BORDER_2 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_BORDER_3 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_BORDER_4 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_BORDER_AND_ACCENT_BAR_2 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_BORDER_AND_ACCENT_BAR_3 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_BORDER_AND_ACCENT_BAR_4 : AutoShapeType
    ''''''

    DOWN_RIBBON : AutoShapeType
    ''''''

    UP_RIBBON : AutoShapeType
    ''''''

    CHEVRON : AutoShapeType
    ''''''

    REGULAR_PENTAGON : AutoShapeType
    ''''''

    NO_SYMBOL : AutoShapeType
    ''''''

    STAR_8 : AutoShapeType
    ''''''

    STAR_16 : AutoShapeType
    ''''''

    STAR_32 : AutoShapeType
    ''''''

    RECTANGULAR_CALLOUT : AutoShapeType
    ''''''

    ROUNDED_RECTANGULAR_CALLOUT : AutoShapeType
    ''''''

    OVAL_CALLOUT : AutoShapeType
    ''''''

    WAVE : AutoShapeType
    ''''''

    FOLDED_CORNER : AutoShapeType
    ''''''

    LEFT_ARROW : AutoShapeType
    ''''''

    DOWN_ARROW : AutoShapeType
    ''''''

    UP_ARROW : AutoShapeType
    ''''''

    LEFT_RIGHT_ARROW : AutoShapeType
    ''''''

    UP_DOWN_ARROW : AutoShapeType
    ''''''

    EXPLOSION_1 : AutoShapeType
    ''''''

    EXPLOSION_2 : AutoShapeType
    ''''''

    LIGHTNING_BOLT : AutoShapeType
    ''''''

    HEART : AutoShapeType
    ''''''

    PICTURE_FRAME : AutoShapeType
    ''''''

    QUAD_ARROW : AutoShapeType
    ''''''

    LEFT_ARROW_CALLOUT : AutoShapeType
    ''''''

    RIGHT_ARROW_CALLOUT : AutoShapeType
    ''''''

    UP_ARROW_CALLOUT : AutoShapeType
    ''''''

    DOWN_ARROW_CALLOUT : AutoShapeType
    ''''''

    LEFT_RIGHT_ARROW_CALLOUT : AutoShapeType
    ''''''

    UP_DOWN_ARROW_CALLOUT : AutoShapeType
    ''''''

    QUAD_ARROW_CALLOUT : AutoShapeType
    ''''''

    BEVEL : AutoShapeType
    ''''''

    LEFT_BRACKET : AutoShapeType
    ''''''

    RIGHT_BRACKET : AutoShapeType
    ''''''

    LEFT_BRACE : AutoShapeType
    ''''''

    RIGHT_BRACE : AutoShapeType
    ''''''

    LEFT_UP_ARROW : AutoShapeType
    ''''''

    BENT_UP_ARROW : AutoShapeType
    ''''''

    BENT_ARROW : AutoShapeType
    ''''''

    STAR_24 : AutoShapeType
    ''''''

    STRIPED_RIGHT_ARROW : AutoShapeType
    ''''''

    NOTCHED_RIGHT_ARROW : AutoShapeType
    ''''''

    BLOCK_ARC : AutoShapeType
    ''''''

    SMILEY_FACE : AutoShapeType
    ''''''

    VERTICAL_SCROLL : AutoShapeType
    ''''''

    HORIZONTAL_SCROLL : AutoShapeType
    ''''''

    CIRCULAR_ARROW : AutoShapeType
    ''''''

    NOTCHED_CIRCULAR_ARROW : AutoShapeType
    '''A value that SHOULD NOT be used.'''

    U_TURN_ARROW : AutoShapeType
    ''''''

    CURVED_RIGHT_ARROW : AutoShapeType
    ''''''

    CURVED_LEFT_ARROW : AutoShapeType
    ''''''

    CURVED_UP_ARROW : AutoShapeType
    ''''''

    CURVED_DOWN_ARROW : AutoShapeType
    ''''''

    CLOUD_CALLOUT : AutoShapeType
    ''''''

    CURVED_DOWN_RIBBON : AutoShapeType
    ''''''

    CURVED_UP_RIBBON : AutoShapeType
    ''''''

    FLOW_CHART_PROCESS : AutoShapeType
    ''''''

    FLOW_CHART_DECISION : AutoShapeType
    ''''''

    FLOW_CHART_DATA : AutoShapeType
    ''''''

    FLOW_CHART_PREDEFINED_PROCESS : AutoShapeType
    ''''''

    FLOW_CHART_INTERNAL_STORAGE : AutoShapeType
    ''''''

    FLOW_CHART_DOCUMENT : AutoShapeType
    ''''''

    FLOW_CHART_MULTIDOCUMENT : AutoShapeType
    ''''''

    FLOW_CHART_TERMINATOR : AutoShapeType
    ''''''

    FLOW_CHART_PREPARATION : AutoShapeType
    ''''''

    FLOW_CHART_MANUAL_INPUT : AutoShapeType
    ''''''

    FLOW_CHART_MANUAL_OPERATION : AutoShapeType
    ''''''

    FLOW_CHART_CONNECTOR : AutoShapeType
    ''''''

    FLOW_CHART_CARD : AutoShapeType
    ''''''

    FLOW_CHART_PUNCHED_TAPE : AutoShapeType
    ''''''

    FLOW_CHART_SUMMING_JUNCTION : AutoShapeType
    ''''''

    FLOW_CHART_OR : AutoShapeType
    ''''''

    FLOW_CHART_COLLATE : AutoShapeType
    ''''''

    FLOW_CHART_SORT : AutoShapeType
    ''''''

    FLOW_CHART_EXTRACT : AutoShapeType
    ''''''

    FLOW_CHART_MERGE : AutoShapeType
    ''''''

    FLOW_CHART_OFFLINE_STORAGE : AutoShapeType
    ''''''

    FLOW_CHART_STORED_DATA : AutoShapeType
    ''''''

    FLOW_CHART_SEQUENTIAL_ACCESS_STORAGE : AutoShapeType
    ''''''

    FLOW_CHART_MAGNETIC_DISK : AutoShapeType
    ''''''

    FLOW_CHART_DIRECT_ACCESS_STORAGE : AutoShapeType
    ''''''

    FLOW_CHART_DISPLAY : AutoShapeType
    ''''''

    FLOW_CHART_DELAY : AutoShapeType
    ''''''

    TEXT_PLAIN_TEXT : AutoShapeType
    '''A plain text shape.'''

    TEXT_STOP : AutoShapeType
    '''An octagonal text shape.'''

    TEXT_TRIANGLE : AutoShapeType
    '''A triangular text shape pointing upwards.'''

    TEXT_TRIANGLE_INVERTED : AutoShapeType
    '''A triangular text shape pointing downwards.'''

    TEXT_CHEVRON : AutoShapeType
    '''A chevron text shape pointing upwards.'''

    TEXT_CHEVRON_INVERTED : AutoShapeType
    '''A chevron text shape pointing downwards.'''

    TEXT_RING_INSIDE : AutoShapeType
    '''A circular text shape, as if reading an inscription on the inside of a ring.'''

    TEXT_RING_OUTSIDE : AutoShapeType
    '''A circular text shape, as if reading an inscription on the outside of a ring.'''

    TEXT_ARCH_UP_CURVE : AutoShapeType
    '''An upward arching curved text shape.'''

    TEXT_ARCH_DOWN_CURVE : AutoShapeType
    '''A downward arching curved text shape.'''

    TEXT_CIRCLE_CURVE : AutoShapeType
    '''A circular text shape.'''

    TEXT_BUTTON_CURVE : AutoShapeType
    '''A text shape that resembles a button.'''

    TEXT_ARCH_UP_POUR : AutoShapeType
    '''An upward arching text shape.'''

    TEXT_ARCH_DOWN_POUR : AutoShapeType
    '''A downward arching text shape.'''

    TEXT_CIRCLE_POUR : AutoShapeType
    '''A circular text shape.'''

    TEXT_BUTTON_POUR : AutoShapeType
    '''A text shape that resembles a button.'''

    TEXT_CURVE_UP : AutoShapeType
    '''An upward curving text shape.'''

    TEXT_CURVE_DOWN : AutoShapeType
    '''A downward curving text shape.'''

    TEXT_CASCADE_UP : AutoShapeType
    '''A cascading text shape pointed upwards.'''

    TEXT_CASCADE_DOWN : AutoShapeType
    '''A cascading text shape pointed downwards.'''

    TEXT_WAVE_1 : AutoShapeType
    '''A wavy text shape.'''

    TEXT_WAVE_2 : AutoShapeType
    '''A wavy text shape.'''

    TEXT_DOUBLE_WAVE_1 : AutoShapeType
    '''A wavy text shape.'''

    TEXT_DOUBLE_WAVE_2 : AutoShapeType
    '''A wavy text shape.'''

    TEXT_INFLATE : AutoShapeType
    '''A text shape that expands vertically in the middle.'''

    TEXT_DEFLATE : AutoShapeType
    '''A text shape that shrinks vertically in the middle.'''

    TEXT_INFLATE_BOTTOM : AutoShapeType
    '''A text shape that expands downward in the middle.'''

    TEXT_DEFLATE_BOTTOM : AutoShapeType
    '''A text shape that shrinks upwards in the middle.'''

    TEXT_INFLATE_TOP : AutoShapeType
    '''A text shape that expands upward in the middle.'''

    TEXT_DEFLATE_TOP : AutoShapeType
    '''A text shape that shrinks downward in the middle.'''

    TEXT_DEFLATE_INFLATE : AutoShapeType
    '''A text shape where lower lines expand upward. Upper lines shrink to compensate.'''

    TEXT_DEFLATE_INFLATE_DEFLATE : AutoShapeType
    '''A text shape where lines in the center expand vertically. Upper and lower lines shrink to compensate.'''

    TEXT_FADE_RIGHT : AutoShapeType
    '''A text shape that shrinks vertically on the right side.'''

    TEXT_FADE_LEFT : AutoShapeType
    '''A text shape that shrinks vertically on the left side.'''

    TEXT_FADE_UP : AutoShapeType
    '''A text shape that shrinks horizontally on top.'''

    TEXT_FADE_DOWN : AutoShapeType
    '''A text shape that shrinks horizontally on bottom.'''

    TEXT_SLANT_UP : AutoShapeType
    '''An upward slanted text shape.'''

    TEXT_SLANT_DOWN : AutoShapeType
    '''A downward slanted text shape.'''

    TEXT_CAN_UP : AutoShapeType
    '''A text shape that is curved upwards as if being read on the side of a can.'''

    TEXT_CAN_DOWN : AutoShapeType
    '''A text shape that is curved downwards as if being read on the side of a can.'''

    FLOW_CHART_ALTERNATE_PROCESS : AutoShapeType
    ''''''

    FLOW_CHART_OFFPAGE_CONNECTOR : AutoShapeType
    ''''''

    LINE_CALLOUT_NO_BORDER_1 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_ACCENT_BAR_1 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_BORDER_1 : AutoShapeType
    ''''''

    LINE_CALLOUT_WITH_BORDER_AND_ACCENT_BAR_1 : AutoShapeType
    ''''''

    LEFT_RIGHT_UP_ARROW : AutoShapeType
    ''''''

    SUN : AutoShapeType
    ''''''

    MOON : AutoShapeType
    ''''''

    DOUBLE_BRACKET : AutoShapeType
    '''A shape enclosed in brackets.'''

    DOUBLE_BRACE : AutoShapeType
    '''A shape enclosed in braces.'''

    STAR_4 : AutoShapeType
    ''''''

    DOUBLE_WAVE : AutoShapeType
    ''''''

    BLANK_ACTION_BUTTON : AutoShapeType
    ''''''

    HOME_ACTION_BUTTON : AutoShapeType
    ''''''

    HELP_ACTION_BUTTON : AutoShapeType
    ''''''

    INFORMATION_ACTION_BUTTON : AutoShapeType
    ''''''

    FORWARD_NEXT_ACTION_BUTTON : AutoShapeType
    ''''''

    BACK_PREVIOUS_ACTION_BUTTON : AutoShapeType
    ''''''

    END_ACTION_BUTTON : AutoShapeType
    ''''''

    BEGINNING_ACTION_BUTTON : AutoShapeType
    ''''''

    RETURN_ACTION_BUTTON : AutoShapeType
    ''''''

    DOCUMENT_ACTION_BUTTON : AutoShapeType
    ''''''

    SOUND_ACTION_BUTTON : AutoShapeType
    ''''''

    MOVIE_ACTION_BUTTON : AutoShapeType
    ''''''

    HOST_CONTROL : AutoShapeType
    '''This value SHOULD NOT be used.'''

    TEXT_BOX : AutoShapeType
    ''''''

    HEPTAGON : AutoShapeType
    ''''''

    DECAGON : AutoShapeType
    ''''''

    DODECAGON : AutoShapeType
    ''''''

    STAR_6 : AutoShapeType
    ''''''

    STAR_7 : AutoShapeType
    ''''''

    STAR_10 : AutoShapeType
    ''''''

    STAR_12 : AutoShapeType
    ''''''

    ROUND_SINGLE_CORNER_RECTANGLE : AutoShapeType
    ''''''

    ROUND_SAME_SIDE_CORNER_RECTANGLE : AutoShapeType
    ''''''

    ROUND_DIAGONAL_CORNER_RECTANGLE : AutoShapeType
    ''''''

    SNIP_ROUND_SINGLE_CORNER_RECTANGLE : AutoShapeType
    ''''''

    SNIP_SINGLE_CORNER_RECTANGLE : AutoShapeType
    ''''''

    SNIP_SAME_SIDE_CORNER_RECTANGLE : AutoShapeType
    ''''''

    SNIP_DIAGONAL_CORNER_RECTANGLE : AutoShapeType
    ''''''

    TEARDROP : AutoShapeType
    ''''''

    PIE : AutoShapeType
    ''''''

    HALF_FRAME : AutoShapeType
    ''''''

    L_SHAPE : AutoShapeType
    ''''''

    DIAGONAL_STRIPE : AutoShapeType
    ''''''

    CHORD : AutoShapeType
    ''''''

    CLOUD : AutoShapeType
    ''''''

    MATH_PLUS : AutoShapeType
    ''''''

    MATH_MINUS : AutoShapeType
    ''''''

    MATH_MULTIPLY : AutoShapeType
    ''''''

    MATH_DIVIDE : AutoShapeType
    ''''''

    MATH_EQUAL : AutoShapeType
    ''''''

    MATH_NOT_EQUAL : AutoShapeType
    ''''''

    LINE_INV : AutoShapeType
    ''''''

    NON_ISOSCELES_TRAPEZOID : AutoShapeType
    ''''''

    PIE_WEDGE : AutoShapeType
    ''''''

    LEFT_CIRCULAR_ARROW : AutoShapeType
    ''''''

    LEFT_RIGHT_CIRCULAR_ARROW : AutoShapeType
    ''''''

    SWOOSH_ARROW : AutoShapeType
    ''''''

    LEFT_RIGHT_RIBBON : AutoShapeType
    ''''''

    TEXT_NO_SHAPE : AutoShapeType
    ''''''

    GEAR_6 : AutoShapeType
    ''''''

    GEAR_9 : AutoShapeType
    ''''''

    FUNNEL : AutoShapeType
    ''''''

    CORNER_TABS : AutoShapeType
    ''''''

    SQUARE_TABS : AutoShapeType
    ''''''

    PLAQUE_TABS : AutoShapeType
    ''''''

    CHART_X : AutoShapeType
    ''''''

    CHART_STAR : AutoShapeType
    ''''''

    CHART_PLUS : AutoShapeType
    ''''''

    FRAME : AutoShapeType
    ''''''

    MODEL_3_D : AutoShapeType
    ''''''

    ROUND_CALLOUT : AutoShapeType
    '''There is no such type in Excel'''

    TEXT_ARCH_LEFT_POUR : AutoShapeType
    '''There is no such type in Excel'''

    TEXT_ARCH_RIGHT_POUR : AutoShapeType
    '''There is no such type in Excel'''

    TEXT_ARCH_LEFT_CURVE : AutoShapeType
    '''There is no such type in Excel'''

    TEXT_ARCH_RIGHT_CURVE : AutoShapeType
    '''There is no such type in Excel'''

    UNKNOWN : AutoShapeType
    ''''''


class Axis:
    '''Encapsulates the object that represents an axis of chart.
    From the following codes , you can learn how to set unit, maximum and minimum value  of Axis.'''

    def getDisplayUnit(self) -> int:
        '''Represents the unit label for the specified axis.
        See :class:`DisplayUnitType`'''
        raise NotImplementedError()

    def setMinorUnitScale(self, value : int) -> None:
        '''Represents the major unit scale for the category axis.
        See :class:`TimeUnit`
        :param value: '''
        raise NotImplementedError()

    def isAutomaticMajorUnit(self) -> bool:
        '''Indicates whether the major unit of the axis is automatically assigned.'''
        raise NotImplementedError()

    def setMajorUnit(self, value : int) -> None:
        '''Represents the major units for the axis.
        :param value: '''
        raise NotImplementedError()

    def isLogarithmic(self) -> bool:
        '''Represents if the value axis scale type is logarithmic or not.'''
        raise NotImplementedError()

    def isAutomaticMinorUnit(self) -> bool:
        '''Indicates whether the minor unit of the axis is automatically assigned.'''
        raise NotImplementedError()

    def setAutomaticMajorUnit(self, value : bool) -> None:
        '''Indicates whether the major unit of the axis is automatically assigned.
        :param value: '''
        raise NotImplementedError()

    def setMinorUnit(self, value : int) -> None:
        '''Represents the minor units for the axis.
        :param value: '''
        raise NotImplementedError()

    def getMinorTickMark(self) -> int:
        '''Represents the type of minor tick mark for the specified axis.
        See :class:`TickMarkType`'''
        raise NotImplementedError()

    def setLogBase(self, value : int) -> None:
        '''Represents the logarithmic base. Default value is 10.Only applies for Excel2007.
        :param value: '''
        raise NotImplementedError()

    def setMinorTickMark(self, value : int) -> None:
        '''Represents the type of minor tick mark for the specified axis.
        See :class:`TickMarkType`
        :param value: '''
        raise NotImplementedError()

    def setAutomaticMinorUnit(self, value : bool) -> None:
        '''Indicates whether the minor unit of the axis is automatically assigned.
        :param value: '''
        raise NotImplementedError()

    def getCrossAt(self) -> int:
        '''Represents the point on the value axis where the category axis crosses it.'''
        raise NotImplementedError()

    def getTickLabels(self) -> TickLabels:
        '''Returns a :meth:`Axis.getTickLabels()` object that represents the tick-mark labels for the specified axis.'''
        raise NotImplementedError()

    def getAxisTexts(self) -> list[str]:
        '''Gets the labels of the axis after call Chart.Calculate() method.'''
        raise NotImplementedError()

    def getMaxValue(self) -> Object:
        '''Represents the maximum value on the value axis.'''
        raise NotImplementedError()

    def isAutomaticMinValue(self) -> bool:
        '''Indicates whether the min value is automatically assigned.'''
        raise NotImplementedError()

    def isDisplayUnitLabelShown(self) -> bool:
        '''Represents if the display unit label is shown on the specified axis.'''
        raise NotImplementedError()

    def getMinValue(self) -> Object:
        '''Represents the minimum value on the value axis.'''
        raise NotImplementedError()

    def setBaseUnitAuto(self, value : bool) -> None:
        '''Represents whether the base unit is automatic.
        :param value: '''
        raise NotImplementedError()

    def isAutoTickLabelSpacing(self) -> bool:
        '''Indicates whether the spacing of tick label is automatic'''
        raise NotImplementedError()

    def getMajorUnit(self) -> int:
        '''Represents the major units for the axis.'''
        raise NotImplementedError()

    def isAutomaticMaxValue(self) -> bool:
        '''Indicates whether the max value is automatically assigned.'''
        raise NotImplementedError()

    def setAutomaticMaxValue(self, value : bool) -> None:
        '''Indicates whether the max value is automatically assigned.
        :param value: '''
        raise NotImplementedError()

    def getMinorUnit(self) -> int:
        '''Represents the minor units for the axis.'''
        raise NotImplementedError()

    def setVisible(self, value : bool) -> None:
        '''Represents if the axis is visible.
        :param value: '''
        raise NotImplementedError()

    def setAutomaticMinValue(self, value : bool) -> None:
        '''Indicates whether the min value is automatically assigned.
        :param value: '''
        raise NotImplementedError()

    def setTickLabelSpacing(self, value : int) -> None:
        '''Represents the number of categories or series between tick-mark labels. Applies only to category and series axes.
        :param value: '''
        raise NotImplementedError()

    def setLogarithmic(self, value : bool) -> None:
        '''Represents if the value axis scale type is logarithmic or not.
        :param value: '''
        raise NotImplementedError()

    def hasMultiLevelLabels(self) -> bool:
        '''Indicates whether the labels shall be shown as multi level.'''
        raise NotImplementedError()

    def getTickLabelSpacing(self) -> int:
        '''Represents the number of categories or series between tick-mark labels. Applies only to category and series axes.'''
        raise NotImplementedError()

    def getTitle(self) -> Title:
        '''Gets the axis' title.'''
        raise NotImplementedError()

    def getAxisLine(self) -> Line:
        '''Gets the appearance of an Axis.'''
        raise NotImplementedError()

    def isBaseUnitAuto(self) -> bool:
        '''Represents whether the base unit is automatic.'''
        raise NotImplementedError()

    def setCrossType(self, value : int) -> None:
        '''Represents the :meth:`Axis.getCrossType()` on the specified axis where the other axis crosses.
        See :meth:`Axis.getCrossType()`
        :param value: '''
        raise NotImplementedError()

    def setHasMultiLevelLabels(self, value : bool) -> None:
        '''Indicates whether the labels shall be shown as multi level.
        :param value: '''
        raise NotImplementedError()

    def setCrossAt(self, value : int) -> None:
        '''Represents the point on the value axis where the category axis crosses it.
        :param value: '''
        raise NotImplementedError()

    def isPlotOrderReversed(self) -> bool:
        '''Represents if Microsoft Excel plots data points from last to first.'''
        raise NotImplementedError()

    def getBins(self) -> AxisBins:
        '''Represents bins on a chart(Histogram/Pareto) axis'''
        raise NotImplementedError()

    def getAxisLabels(self) -> list:
        ''':deprecated: Use Axis.GetAxisTexts method, instead.'''
        raise NotImplementedError()

    def getAxisBetweenCategories(self) -> bool:
        '''Represents if the value axis crosses the category axis between categories.'''
        raise NotImplementedError()

    def getBaseUnitScale(self) -> int:
        '''Represents the base unit scale for the category axis.
        See :class:`TimeUnit`'''
        raise NotImplementedError()

    def setAutoTickLabelSpacing(self, value : bool) -> None:
        '''Indicates whether the spacing of tick label is automatic
        :param value: '''
        raise NotImplementedError()

    def setBaseUnitScale(self, value : int) -> None:
        '''Represents the base unit scale for the category axis.
        See :class:`TimeUnit`
        :param value: '''
        raise NotImplementedError()

    def getMajorTickMark(self) -> int:
        '''Represents the type of major tick mark for the specified axis.
        See :class:`TickMarkType`'''
        raise NotImplementedError()

    def setMajorTickMark(self, value : int) -> None:
        '''Represents the type of major tick mark for the specified axis.
        See :class:`TickMarkType`
        :param value: '''
        raise NotImplementedError()

    def getCrossType(self) -> int:
        '''Represents the :meth:`Axis.getCrossType()` on the specified axis where the other axis crosses.
        See :meth:`Axis.getCrossType()`'''
        raise NotImplementedError()

    def getMajorGridLines(self) -> Line:
        '''Represents major gridlines on a chart axis.'''
        raise NotImplementedError()

    def setPlotOrderReversed(self, value : bool) -> None:
        '''Represents if Microsoft Excel plots data points from last to first.
        :param value: '''
        raise NotImplementedError()

    def getCustomUnit(self) -> int:
        '''Specifies a custom value for the display unit.'''
        raise NotImplementedError()

    def setCustomUnit(self, value : int) -> None:
        '''Specifies a custom value for the display unit.
        :param value: '''
        raise NotImplementedError()

    def setTickMarkSpacing(self, value : int) -> None:
        '''Returns or sets the number of categories or series between tick marks. Applies only to category and series axes.
        :param value: '''
        raise NotImplementedError()

    def getCategoryType(self) -> int:
        '''Represents the category axis type.
        See :class:`CategoryType`'''
        raise NotImplementedError()

    def getMajorUnitScale(self) -> int:
        '''Represents the major unit scale for the category axis.
        See :class:`TimeUnit`'''
        raise NotImplementedError()

    def setCustUnit(self, value : int) -> None:
        ''':deprecated: Use Axis.CustomUnit property, instead.'''
        raise NotImplementedError()

    def setCategoryType(self, value : int) -> None:
        '''Represents the category axis type.
        See :class:`CategoryType`
        :param value: '''
        raise NotImplementedError()

    def setTickLabelPosition(self, value : int) -> None:
        '''Represents the position of tick-mark labels on the specified axis.
        See :class:`TickLabelPositionType`
        :param value: '''
        raise NotImplementedError()

    def setMajorUnitScale(self, value : int) -> None:
        '''Represents the major unit scale for the category axis.
        See :class:`TimeUnit`
        :param value: '''
        raise NotImplementedError()

    def getArea(self) -> Area:
        '''Gets the :class:`Area`.'''
        raise NotImplementedError()

    def getLogBase(self) -> int:
        '''Represents the logarithmic base. Default value is 10.Only applies for Excel2007.'''
        raise NotImplementedError()

    def getDisplayUnitLabel(self) -> DisplayUnitLabel:
        '''Represents a unit label on an axis in the specified chart.
        Unit labels are useful for charting large values?for example, in the millions or billions.'''
        raise NotImplementedError()

    def getTickLabelPosition(self) -> int:
        '''Represents the position of tick-mark labels on the specified axis.
        See :class:`TickLabelPositionType`'''
        raise NotImplementedError()

    def getTickMarkSpacing(self) -> int:
        '''Returns or sets the number of categories or series between tick marks. Applies only to category and series axes.'''
        raise NotImplementedError()

    def setMaxValue(self, value : Object) -> None:
        '''Represents the maximum value on the value axis.
        :param value: '''
        raise NotImplementedError()

    def setDisplayUnit(self, value : int) -> None:
        '''Represents the unit label for the specified axis.
        See :class:`DisplayUnitType`
        :param value: '''
        raise NotImplementedError()

    def getMinorGridLines(self) -> Line:
        '''Represents minor gridlines on a chart axis.'''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Represents if the axis is visible.'''
        raise NotImplementedError()

    def setAxisBetweenCategories(self, value : bool) -> None:
        '''Represents if the value axis crosses the category axis between categories.
        :param value: '''
        raise NotImplementedError()

    def setDisplayUnitLabelShown(self, value : bool) -> None:
        '''Represents if the display unit label is shown on the specified axis.
        :param value: '''
        raise NotImplementedError()

    def setMinValue(self, value : Object) -> None:
        '''Represents the minimum value on the value axis.
        :param value: '''
        raise NotImplementedError()

    def getMinorUnitScale(self) -> int:
        '''Represents the major unit scale for the category axis.
        See :class:`TimeUnit`'''
        raise NotImplementedError()

    def getCustUnit(self) -> int:
        ''':deprecated: Use Axis.CustomUnit property, instead.'''
        raise NotImplementedError()


class AxisBins:
    '''Represents axis bins'''

    def setCount(self, value : int) -> None:
        '''Sets the count of axis bins
        :param value: '''
        raise NotImplementedError()

    def isByCategory(self) -> bool:
        '''Indicates whether grouping data by category'''
        raise NotImplementedError()

    def getCount(self) -> int:
        '''Gets the count of axis bins'''
        raise NotImplementedError()

    def setByCategory(self, value : bool) -> None:
        '''Indicates whether grouping data by category
        :param value: '''
        raise NotImplementedError()

    def resetUnderflow(self) -> None:
        ''':deprecated: This is an internal method.'''
        raise NotImplementedError()

    def resetOverflow(self) -> None:
        ''':deprecated: This is an internal method.'''
        raise NotImplementedError()

    def setUnderflow(self, value : int) -> None:
        '''Sets the underflow of axis bins
        :param value: '''
        raise NotImplementedError()

    def isAutomatic(self) -> bool:
        '''Indicates whether the axis bins are automatic.'''
        raise NotImplementedError()

    def setWidth(self, value : int) -> None:
        '''Sets the width of axis bin
        :param value: '''
        raise NotImplementedError()

    def setOverflow(self, value : int) -> None:
        '''Sets the overflow of axis bins
        :param value: '''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Gets the width of axis bin'''
        raise NotImplementedError()

    def setAutomatic(self, value : bool) -> None:
        '''Indicates whether the axis bins are automatic.
        :param value: '''
        raise NotImplementedError()

    def getOverflow(self) -> int:
        '''Gets the overflow of axis bins'''
        raise NotImplementedError()

    def getUnderflow(self) -> int:
        '''Gets the underflow of axis bins'''
        raise NotImplementedError()


class AxisType:
    '''Represents the axis type.'''

    CATEGORY : AxisType
    '''Category axis'''

    VALUE : AxisType
    '''Value axis'''

    SERIES : AxisType
    '''Series axis'''


class BackgroundMode:
    '''Represents the display mode of the background.'''

    AUTOMATIC : BackgroundMode
    '''Automatic'''

    OPAQUE : BackgroundMode
    '''Opaque'''

    TRANSPARENT : BackgroundMode
    '''Transparent'''


class BackgroundType:
    '''Enumerates cell background pattern types.'''

    DIAGONAL_CROSSHATCH : BackgroundType
    '''Represents diagonal crosshatch pattern.'''

    DIAGONAL_STRIPE : BackgroundType
    '''Represents diagonal stripe pattern.'''

    GRAY_6 : BackgroundType
    '''Represents 6.25% gray pattern'''

    GRAY_12 : BackgroundType
    '''Represents 12.5% gray pattern'''

    GRAY_25 : BackgroundType
    '''Represents 25% gray pattern.'''

    GRAY_50 : BackgroundType
    '''Represents 50% gray pattern.'''

    GRAY_75 : BackgroundType
    '''Represents 75% gray pattern.'''

    HORIZONTAL_STRIPE : BackgroundType
    '''Represents horizontal stripe pattern.'''

    NONE : BackgroundType
    '''Represents no background.'''

    REVERSE_DIAGONAL_STRIPE : BackgroundType
    '''Represents reverse diagonal stripe pattern.'''

    SOLID : BackgroundType
    '''Represents solid pattern.'''

    THICK_DIAGONAL_CROSSHATCH : BackgroundType
    '''Represents thick diagonal crosshatch pattern.'''

    THIN_DIAGONAL_CROSSHATCH : BackgroundType
    '''Represents thin diagonal crosshatch pattern.'''

    THIN_DIAGONAL_STRIPE : BackgroundType
    '''Represents thin diagonal stripe pattern.'''

    THIN_HORIZONTAL_CROSSHATCH : BackgroundType
    '''Represents thin horizontal crosshatch pattern.'''

    THIN_HORIZONTAL_STRIPE : BackgroundType
    '''Represents thin horizontal stripe pattern.'''

    THIN_REVERSE_DIAGONAL_STRIPE : BackgroundType
    '''Represents thin reverse diagonal stripe pattern.'''

    THIN_VERTICAL_STRIPE : BackgroundType
    '''Represents thin vertical stripe pattern.'''

    VERTICAL_STRIPE : BackgroundType
    '''Represents vertical stripe pattern.'''


class Bar3DShapeType:
    '''Represents the shape used with the 3-D bar or column chart.'''

    BOX : Bar3DShapeType
    '''Box'''

    PYRAMID_TO_POINT : Bar3DShapeType
    '''PyramidToPoint'''

    PYRAMID_TO_MAX : Bar3DShapeType
    '''PyramidToMax'''

    CYLINDER : Bar3DShapeType
    '''Cylinder'''

    CONE_TO_POINT : Bar3DShapeType
    '''ConeToPoint'''

    CONE_TO_MAX : Bar3DShapeType
    '''ConeToMax'''


class BarEquationNode:
    '''This class specifies the bar equation, consisting of a base argument and an overbar or underbar.'''

    def getBarPosition(self) -> int:
        '''This attribute specifies the position of the bar in the bar object
        See :class:`EquationCharacterPositionType`'''
        raise NotImplementedError()

    def setBarPosition(self, value : int) -> None:
        '''This attribute specifies the position of the bar in the bar object
        See :class:`EquationCharacterPositionType`
        :param value: '''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class BaseShapeGuide:
    '''Represents the shape guide.'''


class Bevel:
    '''Represents a bevel of a shape'''

    def getWidth(self) -> int:
        '''Gets the width of the bevel, or how far into the shape it is applied.
        In unit of Points.'''
        raise NotImplementedError()

    def setHeight(self, value : int) -> None:
        '''Sets the height of the bevel, or how far above the shape it is applied.
        In unit of Points.
        :param value: '''
        raise NotImplementedError()

    def setWidth(self, value : int) -> None:
        '''Sets the width of the bevel, or how far into the shape it is applied.
        In unit of Points.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the preset bevel type.
        See :class:`BevelPresetType`'''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Gets the height of the bevel, or how far above the shape it is applied.
        In unit of Points.'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets the preset bevel type.
        See :class:`BevelPresetType`
        :param value: '''
        raise NotImplementedError()


class BevelPresetType:
    '''Represents a preset for a type of bevel which can be applied to a shape in 3D.'''

    NONE : BevelPresetType
    '''No bevel'''

    ANGLE : BevelPresetType
    '''Angle'''

    ART_DECO : BevelPresetType
    '''Art deco'''

    CIRCLE : BevelPresetType
    '''Circle'''

    CONVEX : BevelPresetType
    '''Convex'''

    COOL_SLANT : BevelPresetType
    '''Cool slant'''

    CROSS : BevelPresetType
    '''Cross'''

    DIVOT : BevelPresetType
    '''Divot'''

    HARD_EDGE : BevelPresetType
    '''Hard edge'''

    RELAXED_INSET : BevelPresetType
    '''Relaxed inset'''

    RIBLET : BevelPresetType
    '''Riblet'''

    SLOPE : BevelPresetType
    '''Slope'''

    SOFT_ROUND : BevelPresetType
    '''Soft round'''


class BevelType:
    '''Represents a preset for a type of bevel which can be applied to a shape in 3D.'''

    NONE : BevelType
    '''No bevel'''

    ANGLE : BevelType
    '''Angle'''

    ART_DECO : BevelType
    '''Art deco'''

    CIRCLE : BevelType
    '''Circle'''

    CONVEX : BevelType
    '''Convex'''

    COOL_SLANT : BevelType
    '''Cool slant'''

    CROSS : BevelType
    '''Cross'''

    DIVOT : BevelType
    '''Divot'''

    HARD_EDGE : BevelType
    '''Hard edge'''

    RELAXED_INSET : BevelType
    '''Relaxed inset'''

    RIBLET : BevelType
    '''Riblet'''

    SLOPE : BevelType
    '''Slope'''

    SOFT_ROUND : BevelType
    '''Soft round'''


class Border:
    '''Encapsulates the object that represents the cell border.'''

    def getThemeColor(self) -> ThemeColor:
        '''Gets the theme color of the border.'''
        raise NotImplementedError()

    def setLineStyle(self, value : int) -> None:
        '''Sets the cell border type.
        See :class:`CellBorderType`
        :param value: '''
        raise NotImplementedError()

    def getArgbColor(self) -> int:
        '''Gets the color with a 32-bit ARGB value.'''
        raise NotImplementedError()

    def setThemeColor(self, value : ThemeColor) -> None:
        '''Sets the theme color of the border.
        :param value: '''
        raise NotImplementedError()

    def setColor(self, value : Color) -> None:
        '''Sets the :class:`Color` of the border.
        :param value: '''
        raise NotImplementedError()

    def getLineStyle(self) -> int:
        '''Gets the cell border type.
        See :class:`CellBorderType`'''
        raise NotImplementedError()

    def setArgbColor(self, value : int) -> None:
        '''Sets the color with a 32-bit ARGB value.
        :param value: '''
        raise NotImplementedError()

    def getColor(self) -> Color:
        '''Gets the :class:`Color` of the border.'''
        raise NotImplementedError()


class BorderBoxEquationNode:
    '''This class specifies the Border Box function, consisting of a border drawn around an equation.'''

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class BorderCollection:
    '''Encapsulates a collection of :class:`Border` objects.'''

    def setDiagonalStyle(self, value : int) -> None:
        '''Sets the style of Diagonal lines.
        See :class:`CellBorderType`
        :param value: '''
        raise NotImplementedError()

    def getDiagonalColor(self) -> Color:
        '''Gets the :class:`Color` of Diagonal lines.'''
        raise NotImplementedError()

    def setColor(self, color : Color) -> None:
        '''Sets the :class:`Color` of all borders in the collection.
        :param color: Borders' :class:`Color`.'''
        raise NotImplementedError()

    def getByBorderType(self, borderType : int) -> Border:
        '''Gets the :class:`Border` element at the specified index.
        :param borderType: :class:`BorderType`. The border to be retrieved.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    def getDiagonalStyle(self) -> int:
        '''Gets the style of Diagonal lines.
        See :class:`CellBorderType`'''
        raise NotImplementedError()

    def setStyle(self, style : int) -> None:
        '''Sets the style of all borders of the collection.
        :param style: :class:`CellBorderType`. Borders' style'''
        raise NotImplementedError()

    def setDiagonalColor(self, value : Color) -> None:
        '''Sets the :class:`Color` of Diagonal lines.
        :param value: '''
        raise NotImplementedError()


class BorderType:
    '''Enumerates the border line and diagonal line types.'''

    BOTTOM_BORDER : BorderType
    '''Represents bottom border line.'''

    DIAGONAL_DOWN : BorderType
    '''Represents the diagonal line from top left to right bottom.'''

    DIAGONAL_UP : BorderType
    '''Represents the diagonal line from bottom left to right top.'''

    LEFT_BORDER : BorderType
    '''Represents left border line.'''

    RIGHT_BORDER : BorderType
    '''Represents right border line exists.'''

    TOP_BORDER : BorderType
    '''Represents top border line.'''

    HORIZONTAL : BorderType
    '''Only for dynamic style,such as conditional formatting.'''

    VERTICAL : BorderType
    '''Only for dynamic style,such as conditional formatting.'''


class BoxEquationNode:
    '''This class specifies the box function, which is used to group components of an equation.'''

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class BubbleSizeRepresents:
    '''Represents what the bubble size represents on a bubble chart.'''

    SIZE_IS_AREA : BubbleSizeRepresents
    '''Represents the value of :meth:`Series.getBubbleSizes()` is area of the bubble.'''

    SIZE_IS_WIDTH : BubbleSizeRepresents
    '''Represents the value of :meth:`Series.getBubbleSizes()` is width of the bubble.'''


class BuiltInDocumentPropertyCollection:
    '''A collection of built-in document properties.'''

    def getCategory(self) -> str:
        '''Gets the category of the document.'''
        raise NotImplementedError()

    def getScaleCrop(self) -> bool:
        '''Indicates the display mode of the document thumbnail.'''
        raise NotImplementedError()

    def setSubject(self, value : str) -> None:
        '''Sets the subject of the document.
        :param value: '''
        raise NotImplementedError()

    def getParagraphs(self) -> int:
        ''':deprecated: This property is written for Word and PowerPoint. Excel will omit this property'''
        raise NotImplementedError()

    def getCreatedUniversalTime(self) -> DateTime:
        '''Gets the Universal time of the document creation.'''
        raise NotImplementedError()

    def getLinksUpToDate(self) -> bool:
        '''Indicates whether hyperlinks in a document are up-to-date.'''
        raise NotImplementedError()

    def setBytes(self, value : int) -> None:
        ''':deprecated: This property is written for Word and PowerPoint. Excel will omit this property'''
        raise NotImplementedError()

    def setCreatedUniversalTime(self, value : DateTime) -> None:
        '''Sets the Universal time of the document creation.
        :param value: '''
        raise NotImplementedError()

    def getLastSavedUniversalTime(self) -> DateTime:
        '''Gets the universal time of the last save.'''
        raise NotImplementedError()

    def setKeywords(self, value : str) -> None:
        '''Sets the document keywords.
        :param value: '''
        raise NotImplementedError()

    def getLastPrintedUniversalTime(self) -> DateTime:
        '''Gets the Universal time when the document was last printed.'''
        raise NotImplementedError()

    def setCompany(self, value : str) -> None:
        '''Sets the company property.
        :param value: '''
        raise NotImplementedError()

    def getBytes(self) -> int:
        ''':deprecated: This property is written for Word and PowerPoint. Excel will omit this property'''
        raise NotImplementedError()

    def setComments(self, value : str) -> None:
        '''Sets the document comments.
        :param value: '''
        raise NotImplementedError()

    def setTemplate(self, value : str) -> None:
        '''Sets the informational name of the document template.
        :param value: '''
        raise NotImplementedError()

    def setCharacters(self, value : int) -> None:
        ''':deprecated: This property is written for Word and PowerPoint. Excel will omit this property'''
        raise NotImplementedError()

    def getContentStatus(self) -> str:
        '''Gets the content status of the document.'''
        raise NotImplementedError()

    def setCategory(self, value : str) -> None:
        '''Sets the category of the document.
        :param value: '''
        raise NotImplementedError()

    def getLanguage(self) -> str:
        '''Gets the document's language.'''
        raise NotImplementedError()

    def getRevisionNumber(self) -> str:
        '''Gets the document revision number.'''
        raise NotImplementedError()

    def getVersion(self) -> str:
        '''Represents the version number of the application that created the document.'''
        raise NotImplementedError()

    def setNameOfApplication(self, value : str) -> None:
        '''Sets the name of the application.
        :param value: '''
        raise NotImplementedError()

    def getManager(self) -> str:
        '''Gets the manager property.'''
        raise NotImplementedError()

    def setLastSavedTime(self, value : DateTime) -> None:
        '''Sets the time of the last save in local timezone.
        :param value: '''
        raise NotImplementedError()

    def getCharactersWithSpaces(self) -> int:
        ''':deprecated: This property is written for Word and PowerPoint. Excel will omit this property'''
        raise NotImplementedError()

    def setParagraphs(self, value : int) -> None:
        ''':deprecated: This property is written for Word and PowerPoint. Excel will omit this property'''
        raise NotImplementedError()

    def setCreatedTime(self, value : DateTime) -> None:
        '''Sets date of the document creation in local timezone.
        :param value: '''
        raise NotImplementedError()

    def setHyperlinkBase(self, value : str) -> None:
        '''Sets the hyperlinkbase property.
        :param value: '''
        raise NotImplementedError()

    def setScaleCrop(self, value : bool) -> None:
        '''Indicates the display mode of the document thumbnail.
        :param value: '''
        raise NotImplementedError()

    def setTitle(self, value : str) -> None:
        '''Sets the title of the document.
        :param value: '''
        raise NotImplementedError()

    def getDocumentVersion(self) -> str:
        '''Represents the version of the file.'''
        raise NotImplementedError()

    def setLines(self, value : int) -> None:
        ''':deprecated: This property is written for Word and PowerPoint. Excel will omit this property'''
        raise NotImplementedError()

    def setLanguage(self, value : str) -> None:
        '''Sets the document's language.
        :param value: '''
        raise NotImplementedError()

    def setCharactersWithSpaces(self, value : int) -> None:
        ''':deprecated: This property is written for Word and PowerPoint. Excel will omit this property'''
        raise NotImplementedError()

    def getTitle(self) -> str:
        '''Gets the title of the document.'''
        raise NotImplementedError()

    def getSubject(self) -> str:
        '''Gets the subject of the document.'''
        raise NotImplementedError()

    def setContentType(self, value : str) -> None:
        '''Sets the content type of the document.
        :param value: '''
        raise NotImplementedError()

    def getLines(self) -> int:
        ''':deprecated: This property is written for Word and PowerPoint. Excel will omit this property'''
        raise NotImplementedError()

    def setLastPrinted(self, value : DateTime) -> None:
        '''Sets the date when the document was last printed in local timezone.
        :param value: '''
        raise NotImplementedError()

    def setLastPrintedUniversalTime(self, value : DateTime) -> None:
        '''Sets the Universal time when the document was last printed.
        :param value: '''
        raise NotImplementedError()

    def setLastSavedBy(self, value : str) -> None:
        '''Sets the name of the last author.
        :param value: '''
        raise NotImplementedError()

    def setLinksUpToDate(self, value : bool) -> None:
        '''Indicates whether hyperlinks in a document are up-to-date.
        :param value: '''
        raise NotImplementedError()

    def setTotalEditingTime(self, value : int) -> None:
        '''Sets the total editing time in minutes.
        :param value: '''
        raise NotImplementedError()

    def getCompany(self) -> str:
        '''Gets the company property.'''
        raise NotImplementedError()

    def getNameOfApplication(self) -> str:
        '''Gets the name of the application.'''
        raise NotImplementedError()

    def getCreatedTime(self) -> DateTime:
        '''Gets date of the document creation in local timezone.'''
        raise NotImplementedError()

    def setRevisionNumber(self, value : str) -> None:
        '''Sets the document revision number.
        :param value: '''
        raise NotImplementedError()

    def setDocumentVersion(self, value : str) -> None:
        '''Represents the version of the file.
        :param value: '''
        raise NotImplementedError()

    def getTotalEditingTime(self) -> int:
        '''Gets the total editing time in minutes.'''
        raise NotImplementedError()

    def getAuthor(self) -> str:
        '''Gets the name of the document's author.'''
        raise NotImplementedError()

    def setVersion(self, value : str) -> None:
        '''Represents the version number of the application that created the document.
        :param value: '''
        raise NotImplementedError()

    def setContentStatus(self, value : str) -> None:
        '''Sets the content status of the document.
        :param value: '''
        raise NotImplementedError()

    def getContentType(self) -> str:
        '''Gets the content type of the document.'''
        raise NotImplementedError()

    def setWords(self, value : int) -> None:
        '''Represents an estimate of the number of words in the document.
        :param value: '''
        raise NotImplementedError()

    def getLastPrinted(self) -> DateTime:
        '''Gets the date when the document was last printed in local timezone.'''
        raise NotImplementedError()

    def getCharacters(self) -> int:
        ''':deprecated: This property is written for Word and PowerPoint. Excel will omit this property'''
        raise NotImplementedError()

    def setManager(self, value : str) -> None:
        '''Sets the manager property.
        :param value: '''
        raise NotImplementedError()

    def setLastSavedUniversalTime(self, value : DateTime) -> None:
        '''Sets the universal time of the last save.
        :param value: '''
        raise NotImplementedError()

    def getLastSavedBy(self) -> str:
        '''Gets the name of the last author.'''
        raise NotImplementedError()

    def getWords(self) -> int:
        '''Represents an estimate of the number of words in the document.'''
        raise NotImplementedError()

    def setAuthor(self, value : str) -> None:
        '''Sets the name of the document's author.
        :param value: '''
        raise NotImplementedError()

    def getLastSavedTime(self) -> DateTime:
        '''Gets the time of the last save in local timezone.'''
        raise NotImplementedError()

    def get(self, name : str) -> DocumentProperty:
        '''Returns a :class:`DocumentProperty` object by the name of the property.
        :param name: The case-insensitive name of the property to retrieve.'''
        raise NotImplementedError()

    def getKeywords(self) -> str:
        '''Gets the document keywords.'''
        raise NotImplementedError()

    def setPages(self, value : int) -> None:
        '''Represents an estimate of the number of pages in the document.
        :param value: '''
        raise NotImplementedError()

    def getHyperlinkBase(self) -> str:
        '''Gets the hyperlinkbase property.'''
        raise NotImplementedError()

    def getComments(self) -> str:
        '''Gets the document comments.'''
        raise NotImplementedError()

    def getTemplate(self) -> str:
        '''Gets the informational name of the document template.'''
        raise NotImplementedError()

    def getPages(self) -> int:
        '''Represents an estimate of the number of pages in the document.'''
        raise NotImplementedError()


class BuiltinStyleType:
    '''Represents all built-in style types.'''

    TWENTY_PERCENT_ACCENT_1 : BuiltinStyleType
    ''''''

    TWENTY_PERCENT_ACCENT_2 : BuiltinStyleType
    ''''''

    TWENTY_PERCENT_ACCENT_3 : BuiltinStyleType
    ''''''

    TWENTY_PERCENT_ACCENT_4 : BuiltinStyleType
    ''''''

    TWENTY_PERCENT_ACCENT_5 : BuiltinStyleType
    ''''''

    TWENTY_PERCENT_ACCENT_6 : BuiltinStyleType
    ''''''

    FORTY_PERCENT_ACCENT_1 : BuiltinStyleType
    ''''''

    FORTY_PERCENT_ACCENT_2 : BuiltinStyleType
    ''''''

    FORTY_PERCENT_ACCENT_3 : BuiltinStyleType
    ''''''

    FORTY_PERCENT_ACCENT_4 : BuiltinStyleType
    ''''''

    FORTY_PERCENT_ACCENT_5 : BuiltinStyleType
    ''''''

    FORTY_PERCENT_ACCENT_6 : BuiltinStyleType
    ''''''

    SIXTY_PERCENT_ACCENT_1 : BuiltinStyleType
    ''''''

    SIXTY_PERCENT_ACCENT_2 : BuiltinStyleType
    ''''''

    SIXTY_PERCENT_ACCENT_3 : BuiltinStyleType
    ''''''

    SIXTY_PERCENT_ACCENT_4 : BuiltinStyleType
    ''''''

    SIXTY_PERCENT_ACCENT_5 : BuiltinStyleType
    ''''''

    SIXTY_PERCENT_ACCENT_6 : BuiltinStyleType
    ''''''

    ACCENT_1 : BuiltinStyleType
    ''''''

    ACCENT_2 : BuiltinStyleType
    ''''''

    ACCENT_3 : BuiltinStyleType
    ''''''

    ACCENT_4 : BuiltinStyleType
    ''''''

    ACCENT_5 : BuiltinStyleType
    ''''''

    ACCENT_6 : BuiltinStyleType
    ''''''

    BAD : BuiltinStyleType
    ''''''

    CALCULATION : BuiltinStyleType
    ''''''

    CHECK_CELL : BuiltinStyleType
    ''''''

    COMMA : BuiltinStyleType
    ''''''

    COMMA_1 : BuiltinStyleType
    ''''''

    CURRENCY : BuiltinStyleType
    ''''''

    CURRENCY_1 : BuiltinStyleType
    ''''''

    EXPLANATORY_TEXT : BuiltinStyleType
    ''''''

    GOOD : BuiltinStyleType
    ''''''

    HEADER_1 : BuiltinStyleType
    ''''''

    HEADER_2 : BuiltinStyleType
    ''''''

    HEADER_3 : BuiltinStyleType
    ''''''

    HEADER_4 : BuiltinStyleType
    ''''''

    HYPERLINK : BuiltinStyleType
    ''''''

    FOLLOWED_HYPERLINK : BuiltinStyleType
    ''''''

    INPUT : BuiltinStyleType
    ''''''

    LINKED_CELL : BuiltinStyleType
    ''''''

    NEUTRAL : BuiltinStyleType
    ''''''

    NORMAL : BuiltinStyleType
    ''''''

    NOTE : BuiltinStyleType
    ''''''

    OUTPUT : BuiltinStyleType
    ''''''

    PERCENT : BuiltinStyleType
    ''''''

    TITLE : BuiltinStyleType
    ''''''

    TOTAL : BuiltinStyleType
    ''''''

    WARNING_TEXT : BuiltinStyleType
    ''''''

    ROW_LEVEL : BuiltinStyleType
    ''''''

    COLUMN_LEVEL : BuiltinStyleType
    ''''''


class Bullet:
    '''Represents the bullet points should be applied to a paragraph.'''

    def getFontName(self) -> str:
        '''Gets the name of the font.'''
        raise NotImplementedError()

    def setFontName(self, value : str) -> None:
        '''Sets the name of the font.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of bullet.
        See :class:`BulletType`'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets the type of bullet.
        See :class:`BulletType`
        :param value: '''
        raise NotImplementedError()

    def getBulletValue(self) -> BulletValue:
        '''Gets the value of bullet.'''
        raise NotImplementedError()


class BulletType:
    '''Represents the type of the bullet.'''

    NONE : BulletType
    '''No bullet.'''

    CHARACTER : BulletType
    '''Character bullet.'''

    PICTURE : BulletType
    '''Image bullet.'''

    AUTO_NUMBERED : BulletType
    '''Automatic numbered bullet.'''


class BulletValue:
    '''Represents the value of the bullet.'''

    def getType(self) -> int:
        '''Gets the type of the bullet's value.
        See :class:`BulletType`'''
        raise NotImplementedError()


class Button:
    '''Represents the Forms control: Button'''


class CalcModeType:
    '''Represents the mode type of calculating formulas.'''

    AUTOMATIC : CalcModeType
    ''''''

    AUTOMATIC_EXCEPT_TABLE : CalcModeType
    ''''''

    MANUAL : CalcModeType
    ''''''


class CalculationCell:
    '''Represents the calculation relevant data about one cell which is being calculated.'''

    def getCellColumn(self) -> int:
        '''Gets the column index of the cell.'''
        raise NotImplementedError()

    def setCalculatedValue(self, v : Object) -> None:
        '''Sets the calculated value for the cell.
        :param v: '''
        raise NotImplementedError()

    def getCell(self) -> Cell:
        '''Gets the Cell object which is being calculated.'''
        raise NotImplementedError()

    def getWorkbook(self) -> Workbook:
        '''Gets the Workbook object.'''
        raise NotImplementedError()

    def getCellRow(self) -> int:
        '''Gets the row index of the cell.'''
        raise NotImplementedError()

    def getWorksheet(self) -> Worksheet:
        '''Gets the Worksheet object where the cell is in.'''
        raise NotImplementedError()


class CalculationData:
    '''Represents the required data when calculating one function, such as function name, parameters, ...etc.'''

    def getWorkbook(self) -> Workbook:
        '''Gets the Workbook object where the function is in.'''
        raise NotImplementedError()

    def getFunctionName(self) -> str:
        '''Gets the function name to be calculated.'''
        raise NotImplementedError()

    def setCalculatedValue(self, value : Object) -> None:
        '''Sets the calculated value for this function.
        :param value: '''
        raise NotImplementedError()

    def getWorksheet(self) -> Worksheet:
        '''Gets the Worksheet object where the function is in.'''
        raise NotImplementedError()

    def getParamValueInArrayMode(self, index : int, maxRowCount : int, maxColumnCount : int) -> list[list[Object]]:
        '''Gets the value(s) of the parameter at given index.
        If the parameter is some kind of expression that needs to be calculated,
        then it will be calculated in array mode.
        :param index: The index of the parameter(0 based)
        :param maxRowCount: The row count limit for the returned array.
        :param maxColumnCount: The column count limit for the returned array.
        :returns: An array which contains all items represented by the specified parameter.'''
        raise NotImplementedError()

    def getParamCount(self) -> int:
        '''Gets the count of parameters'''
        raise NotImplementedError()

    def getCalculatedValue(self) -> Object:
        '''Gets the calculated value for this function.'''
        raise NotImplementedError()

    def getCellColumn(self) -> int:
        '''Gets the column index of the cell where the function is in.'''
        raise NotImplementedError()

    def getParamValue(self, index : int) -> Object:
        '''Gets the represented value object of the parameter at given index.
        :param index: The index of the parameter(0 based)
        :returns: The calculated value of the parameter.'''
        raise NotImplementedError()

    def getParamText(self, index : int) -> str:
        '''Gets the literal text of the parameter at given index.
        :param index: index of the parameter(0 based)
        :returns: literal text of the parameter'''
        raise NotImplementedError()

    def getCell(self) -> Cell:
        '''Gets the Cell object where the function is in.'''
        raise NotImplementedError()

    def getCellRow(self) -> int:
        '''Gets the row index of the cell where the function is in.'''
        raise NotImplementedError()


class CalculationOptions:
    '''Represents options for calculation.'''

    def getCustomEngine(self) -> AbstractCalculationEngine:
        '''The custom formula calculation engine to extend the default calculation engine of Aspose.Cells.'''
        raise NotImplementedError()

    def setCalculationMonitor(self, value : AbstractCalculationMonitor) -> None:
        '''The monitor for user to track the progress of formula calculation.
        :param value: '''
        raise NotImplementedError()

    def getCharacterEncoding(self) -> Encoding:
        '''Specifies the encoding used for encoding/decoding characters when calculating formulas.
        For functions such as CHAR, CODE, the calculated result depends on the region settings and default charset of the environment.
        With this property user can specify the proper encoding used for those function to get the expected result.'''
        raise NotImplementedError()

    def setIgnoreError(self, value : bool) -> None:
        '''Indicates whether errors encountered while calculating formulas should be ignored.
        The error may be unsupported function, external links, etc.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def getPrecisionStrategy(self) -> int:
        '''Specifies the strategy for processing precision of calculation.
        See :class:`CalculationPrecisionStrategy`'''
        raise NotImplementedError()

    def setRecursive(self, value : bool) -> None:
        '''Indicates whether calculate the dependent cells recursively when calculating one cell and it depends on other cells.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def setCustomEngine(self, value : AbstractCalculationEngine) -> None:
        '''The custom formula calculation engine to extend the default calculation engine of Aspose.Cells.
        :param value: '''
        raise NotImplementedError()

    def setCharacterEncoding(self, value : Encoding) -> None:
        '''Specifies the encoding used for encoding/decoding characters when calculating formulas.
        For functions such as CHAR, CODE, the calculated result depends on the region settings and default charset of the environment.
        With this property user can specify the proper encoding used for those function to get the expected result.
        :param value: '''
        raise NotImplementedError()

    def setPrecisionStrategy(self, value : int) -> None:
        '''Specifies the strategy for processing precision of calculation.
        See :class:`CalculationPrecisionStrategy`
        :param value: '''
        raise NotImplementedError()

    def getCalculationMonitor(self) -> AbstractCalculationMonitor:
        '''The monitor for user to track the progress of formula calculation.'''
        raise NotImplementedError()

    def setCalcStackSize(self, value : int) -> None:
        '''The stack size for calculating cells recursively. Default value is 200.
        :param value: '''
        raise NotImplementedError()

    def setLinkedDataSources(self, value : list[Workbook]) -> None:
        '''Specifies the data sources for external links used in formulas.
        :param value: '''
        raise NotImplementedError()

    def getRecursive(self) -> bool:
        '''Indicates whether calculate the dependent cells recursively when calculating one cell and it depends on other cells.
        The default value is true.'''
        raise NotImplementedError()

    def getIgnoreError(self) -> bool:
        '''Indicates whether errors encountered while calculating formulas should be ignored.
        The error may be unsupported function, external links, etc.
        The default value is true.'''
        raise NotImplementedError()

    def getCalcStackSize(self) -> int:
        '''The stack size for calculating cells recursively. Default value is 200.'''
        raise NotImplementedError()

    def getLinkedDataSources(self) -> list[Workbook]:
        '''Specifies the data sources for external links used in formulas.'''
        raise NotImplementedError()


class CalculationPrecisionStrategy:
    '''Enumerates strategies for handling calculation precision.
    Because of the precision issue of IEEE 754 Floating-Point Arithmetic, some "seemingly simple" formulas may not be calculated as the expected result.
    Such as formula "=-0.45+0.43+0.02", when calculating operands by '+' operator directly, the result is not zero. For such kind of precision issue,
    some special strategies may give the expected result.'''

    NONE : CalculationPrecisionStrategy
    '''No strategy applied on calculation.
    When calculating just use the original double value as operand and return the result directly.
    Most efficient for performance and applicable for most cases.'''

    ROUND : CalculationPrecisionStrategy
    '''Rounds the calculation result according with significant digits.'''

    DECIMAL : CalculationPrecisionStrategy
    '''Uses decimal as operands when possible.
    Most inefficient for performance.'''


class CategoryType:
    '''Represents the category axis type.'''

    AUTOMATIC_SCALE : CategoryType
    '''AutomaticScale'''

    CATEGORY_SCALE : CategoryType
    '''CategoryScale'''

    TIME_SCALE : CategoryType
    '''TimeScale'''


class Cell:
    '''Encapsulates the object that represents a single Workbook cell.'''

    def getWidthOfValue(self) -> int:
        '''Gets the width of the value in unit of pixels.'''
        raise NotImplementedError()

    def hashCode(self) -> int:
        '''Serves as a hash function for a particular type.'''
        raise NotImplementedError()

    def isStyleSet(self) -> bool:
        '''Indicates if the cell's style is set. If return false, it means this cell has a default cell format.'''
        raise NotImplementedError()

    def getComment(self) -> Comment:
        '''Gets the comment of this cell.'''
        raise NotImplementedError()

    @overload
    def getHtmlString(self) -> str:
        '''Gets the html string which contains data and some formats in this cell.'''
        raise NotImplementedError()

    @overload
    def getHtmlString(self, html5 : bool) -> str:
        '''Gets the html string which contains data and some formats in this cell.
        :param html5: Indicates whether the value is compatible for html5'''
        raise NotImplementedError()

    @overload
    def setArrayFormula(self, arrayFormula : str, rowNumber : int, columnNumber : int, isR1C1 : bool, isLocal : bool) -> None:
        ''':deprecated: Use FormulaParseOptions for more options instead.'''
        raise NotImplementedError()

    @overload
    def setArrayFormula(self, arrayFormula : str, rowNumber : int, columnNumber : int) -> None:
        '''Sets an array formula(legacy array formula entered via CTRL+SHIFT+ENTER in ms excel) to a range of cells.
        :param arrayFormula: Array formula.
        :param rowNumber: Number of rows to populate result of the array formula.
        :param columnNumber: Number of columns to populate result of the array formula.'''
        raise NotImplementedError()

    @overload
    def setArrayFormula(self, arrayFormula : str, rowNumber : int, columnNumber : int, options : FormulaParseOptions) -> None:
        '''Sets an array formula to a range of cells.
        :param arrayFormula: Array formula.
        :param rowNumber: Number of rows to populate result of the array formula.
        :param columnNumber: Number of columns to populate result of the array formula.
        :param options: Options for parsing the formula.'''
        raise NotImplementedError()

    @overload
    def setArrayFormula(self, arrayFormula : str, rowNumber : int, columnNumber : int, options : FormulaParseOptions, values : list[list[Object]]) -> None:
        '''Sets an array formula to a range of cells.
        :param arrayFormula: Array formula.
        :param rowNumber: Number of rows to populate result of the array formula.
        :param columnNumber: Number of columns to populate result of the array formula.
        :param options: Options for parsing the formula.
        :param values: values for those cells with given array formula'''
        raise NotImplementedError()

    def isErrorValue(self) -> bool:
        '''Checks if the value of this cell is an error.'''
        raise NotImplementedError()

    def getConditionalFormattingResult(self) -> ConditionalFormattingResult:
        '''Get the result of the conditional formatting.'''
        raise NotImplementedError()

    def getColumn(self) -> int:
        '''Gets column number (zero based) of the cell.'''
        raise NotImplementedError()

    def getBoolValue(self) -> bool:
        '''Gets the boolean value contained in the cell.'''
        raise NotImplementedError()

    def getStringValueWithoutFormat(self) -> str:
        ''':deprecated: Use GetStringValue(CellValueFormatStrategy) with CellValueFormatStrategy.None instead.'''
        raise NotImplementedError()

    def getValidationValue(self) -> bool:
        '''Gets the value of validation which applied to this cell.'''
        raise NotImplementedError()

    def isNumericValue(self) -> bool:
        '''Indicates whether the value of this cell is numeric(int, double and datetime)'''
        raise NotImplementedError()

    @overload
    def setSharedFormula(self, sharedFormula : str, rowNumber : int, columnNumber : int, isR1C1 : bool, isLocal : bool) -> None:
        ''':deprecated: Use FormulaParseOptions for more options instead.'''
        raise NotImplementedError()

    @overload
    def setSharedFormula(self, sharedFormula : str, rowNumber : int, columnNumber : int) -> None:
        '''Sets shared formulas to a range of cells.
        :param sharedFormula: Shared formula.
        :param rowNumber: Number of rows to populate the formula.
        :param columnNumber: Number of columns to populate the formula.'''
        raise NotImplementedError()

    @overload
    def setSharedFormula(self, sharedFormula : str, rowNumber : int, columnNumber : int, options : FormulaParseOptions) -> None:
        '''Sets shared formulas to a range of cells.
        :param sharedFormula: Shared formula.
        :param rowNumber: Number of rows to populate the formula.
        :param columnNumber: Number of columns to populate the formula.
        :param options: Options for parsing the formula.'''
        raise NotImplementedError()

    @overload
    def setSharedFormula(self, sharedFormula : str, rowNumber : int, columnNumber : int, options : FormulaParseOptions, values : list[list[Object]]) -> None:
        '''Sets shared formulas to a range of cells.
        :param sharedFormula: Shared formula.
        :param rowNumber: Number of rows to populate the formula.
        :param columnNumber: Number of columns to populate the formula.
        :param options: Options for parsing the formula.
        :param values: values for those cells with given shared formula'''
        raise NotImplementedError()

    def setCheckBoxStyle(self, value : bool) -> None:
        '''Indicates whether setting this cell as a check box.
        :param value: '''
        raise NotImplementedError()

    def setValue(self, value : Object) -> None:
        '''Sets the value contained in this cell.
        :param value: '''
        raise NotImplementedError()

    def getFloatValue(self) -> float:
        '''Gets the float value contained in the cell.'''
        raise NotImplementedError()

    def calculate(self, options : CalculationOptions) -> None:
        '''Calculates the formula of the cell.
        :param options: Options for calculation'''
        raise NotImplementedError()

    def getDependents(self, isAll : bool) -> list[Cell]:
        '''Get all cells whose formula references to this cell directly.
        :param isAll: Indicates whether check formulas in other worksheets'''
        raise NotImplementedError()

    def getDisplayStringValue(self) -> str:
        '''Gets the formatted string value of this cell by cell's display style.'''
        raise NotImplementedError()

    def setR1C1Formula(self, value : str) -> None:
        '''Sets a R1C1 formula of the :class:`Cell`.
        :param value: '''
        raise NotImplementedError()

    @overload
    def getDisplayStyle(self) -> Style:
        '''Gets the display style of the cell.
        If this cell is also affected by other settings such as conditional formatting, list objects, etc.,
        then the display style may be different from cell.GetStyle().'''
        raise NotImplementedError()

    @overload
    def getDisplayStyle(self, includeMergedBorders : bool) -> Style:
        '''Gets the display style of the cell.
        If the cell is conditional formatted, the display style is not same as the cell.GetStyle().
        :param includeMergedBorders: Indicates whether checking borders of the merged cells.'''
        raise NotImplementedError()

    def isArrayFormula(self) -> bool:
        '''Indicates whether the cell formula is an array formula.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents cell value type.
        See :class:`CellValueType`'''
        raise NotImplementedError()

    def hasCustomStyle(self) -> bool:
        '''Indicates whether this cell has custom style settings(different from the default one inherited
        from corresponding row, column, or workbook).'''
        raise NotImplementedError()

    def characters(self, startIndex : int, length : int) -> FontSetting:
        '''Returns a Characters object that represents a range of characters within the cell text.
        :param startIndex: The index of the start of the character.
        :param length: The number of characters.
        :returns: Characters object.'''
        raise NotImplementedError()

    def getRichValue(self) -> CellRichValue:
        '''Gets rich value of the cell.'''
        raise NotImplementedError()

    @overload
    def setTableFormula(self, rowNumber : int, columnNumber : int, rowInputCell : str, columnInputCell : str, values : list[list[Object]]) -> None:
        '''Create two-variable data table for given range starting from this cell.
        :param rowNumber: Number of rows to populate the formula.
        :param columnNumber: Number of columns to populate the formula.
        :param rowInputCell: the row input cell
        :param columnInputCell: the column input cell
        :param values: values for cells in table formula range'''
        raise NotImplementedError()

    @overload
    def setTableFormula(self, rowNumber : int, columnNumber : int, inputCell : str, isRowInput : bool, values : list[list[Object]]) -> None:
        '''Create one-variable data table for given range starting from this cell.
        :param rowNumber: Number of rows to populate the formula.
        :param columnNumber: Number of columns to populate the formula.
        :param inputCell: the input cell
        :param isRowInput: Indicates whether the input cell is a row input cell(true) or a column input cell(false).
        :param values: values for cells in table formula range'''
        raise NotImplementedError()

    @overload
    def setTableFormula(self, rowNumber : int, columnNumber : int, rowIndexOfRowInputCell : int, columnIndexOfRowInputCell : int, rowIndexOfColumnInputCell : int, columnIndexOfColumnInputCell : int, values : list[list[Object]]) -> None:
        '''Create two-variable data table for given range starting from this cell.
        :param rowNumber: Number of rows to populate the formula.
        :param columnNumber: Number of columns to populate the formula.
        :param rowIndexOfRowInputCell: row index of the row input cell
        :param columnIndexOfRowInputCell: column index of the row input cell
        :param rowIndexOfColumnInputCell: row index of the column input cell
        :param columnIndexOfColumnInputCell: column index of the column input cell
        :param values: values for cells in table formula range'''
        raise NotImplementedError()

    @overload
    def setTableFormula(self, rowNumber : int, columnNumber : int, rowIndexOfInputCell : int, columnIndexOfInputCell : int, isRowInput : bool, values : list[list[Object]]) -> None:
        '''Create one-variable data table for given range starting from this cell.
        :param rowNumber: Number of rows to populate the formula.
        :param columnNumber: Number of columns to populate the formula.
        :param rowIndexOfInputCell: row index of the input cell
        :param columnIndexOfInputCell: column index of the input cell
        :param isRowInput: Indicates whether the input cell is a row input cell(true) or a column input cell(false).
        :param values: values for cells in table formula range'''
        raise NotImplementedError()

    def copy(self, cell : Cell) -> None:
        '''Copies data from a source cell.
        :param cell: Source :class:`Cell` object.'''
        raise NotImplementedError()

    @overload
    def setStyle(self, style : Style) -> None:
        '''Sets the cell style.
        :param style: The cell style.'''
        raise NotImplementedError()

    @overload
    def setStyle(self, style : Style, explicitFlag : bool) -> None:
        '''Apply the changed property of style to the cell.
        :param style: The cell style.
        :param explicitFlag: True, only overwriting formatting which is explicitly set.'''
        raise NotImplementedError()

    @overload
    def setStyle(self, style : Style, flag : StyleFlag) -> None:
        '''Apply the cell style based on flags.
        :param style: The cell style.
        :param flag: The style flag.'''
        raise NotImplementedError()

    @overload
    def getLeafs(self) -> Iterator:
        ''':deprecated: Use GetDependentsInCalculation(bool) instead.'''
        raise NotImplementedError()

    @overload
    def getLeafs(self, recursive : bool) -> Iterator:
        ''':deprecated: Use GetDependentsInCalculation(bool) instead.'''
        raise NotImplementedError()

    def getFormulaLocal(self) -> str:
        '''Get the locale formatted formula of the cell.'''
        raise NotImplementedError()

    def removeArrayFormula(self, leaveNormalFormula : bool) -> None:
        '''Remove array formula.
        :param leaveNormalFormula: True represents converting the array formula to normal formula.'''
        raise NotImplementedError()

    def getR1C1Formula(self) -> str:
        '''Gets a R1C1 formula of the :class:`Cell`.'''
        raise NotImplementedError()

    @overload
    def equals(self, obj : Object) -> bool:
        '''Checks whether this object refers to the same cell with another.
        :param obj: another object
        :returns: true if two objects refers to the same cell.'''
        raise NotImplementedError()

    @overload
    def equals(self, cell : Cell) -> bool:
        '''Checks whether this object refers to the same cell with another cell object.
        :param cell: another cell object
        :returns: true if two cell objects refers to the same cell.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the cell.'''
        raise NotImplementedError()

    def isMerged(self) -> bool:
        '''Checks if a cell is part of a merged range or not.'''
        raise NotImplementedError()

    def isFormula(self) -> bool:
        '''Represents if the specified cell contains formula.'''
        raise NotImplementedError()

    def getDoubleValue(self) -> int:
        '''Gets the double value contained in the cell.'''
        raise NotImplementedError()

    def getIntValue(self) -> int:
        '''Gets the integer value contained in the cell.'''
        raise NotImplementedError()

    def isTableFormula(self) -> bool:
        '''Indicates whether this cell is part of table formula.'''
        raise NotImplementedError()

    def setFormulaLocal(self, value : str) -> None:
        '''Get the locale formatted formula of the cell.
        :param value: '''
        raise NotImplementedError()

    @overload
    def getFormula(self) -> str:
        '''Gets a formula of the :class:`Cell`.'''
        raise NotImplementedError()

    @overload
    def getFormula(self, isR1C1 : bool, isLocal : bool) -> str:
        '''Get the formula of this cell.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :returns: the formula of this cell.'''
        raise NotImplementedError()

    def isCheckBoxStyle(self) -> bool:
        '''Indicates whether setting this cell as a check box.'''
        raise NotImplementedError()

    def getArrayRange(self) -> CellArea:
        '''Gets the array range if the cell's formula is an array formula.'''
        raise NotImplementedError()

    def replace(self, placeHolder : str, newValue : str, options : ReplaceOptions) -> None:
        '''Replace text of the cell with options.
        :param placeHolder: Cell placeholder
        :param newValue: String value to replace
        :param options: The replace options'''
        raise NotImplementedError()

    def getPrecedents(self) -> ReferredAreaCollection:
        '''Gets all references appearing in this cell's formula.'''
        raise NotImplementedError()

    def getEmbeddedImage(self) -> list[int]:
        '''Gets the embeddedn image in the cell.'''
        raise NotImplementedError()

    def getMergedRange(self) -> Range:
        '''Returns a :class:`Range` object which represents a merged range.'''
        raise NotImplementedError()

    def setEmbeddedImage(self, value : list[int]) -> None:
        '''Sets the embeddedn image in the cell.
        :param value: '''
        raise NotImplementedError()

    def getDateTimeValue(self) -> DateTime:
        '''Gets the DateTime value contained in the cell.'''
        raise NotImplementedError()

    def getPrecedentsInCalculation(self) -> Iterator:
        '''Gets all precedents(reference to cells in current workbook) used by this cell's formula while calculating it.'''
        raise NotImplementedError()

    def isSharedFormula(self) -> bool:
        '''Indicates whether the cell formula is part of shared formula.'''
        raise NotImplementedError()

    def getNumberCategoryType(self) -> int:
        '''Represents the category type of this cell's number formatting.
        See :class:`NumberCategoryType`'''
        raise NotImplementedError()

    def insertText(self, index : int, text : str) -> None:
        '''Insert some characters to the cell.
        If the cell is rich formatted, this method could keep the original formatting.
        :param index: The index.
        :param text: Inserted text.'''
        raise NotImplementedError()

    def isInTable(self) -> bool:
        ''':deprecated: Use IsTableFormula instead.'''
        raise NotImplementedError()

    def getValue(self) -> Object:
        '''Gets the value contained in this cell.'''
        raise NotImplementedError()

    def getDependentsInCalculation(self, recursive : bool) -> Iterator:
        '''Gets all cells whose calculated result depends on this cell.
        :param recursive: Whether returns those dependents which do not reference to this cell directly
        :returns: Enumerator to enumerate all dependents(Cell objects)'''
        raise NotImplementedError()

    def isArrayHeader(self) -> bool:
        '''Indicates the cell's formula is an array formula
        and it is the first cell of the array.'''
        raise NotImplementedError()

    def getWorksheet(self) -> Worksheet:
        '''Gets the parent worksheet.'''
        raise NotImplementedError()

    def getValidation(self) -> Validation:
        '''Gets the validation applied to this cell.'''
        raise NotImplementedError()

    def toString(self) -> str:
        '''Returns a string represents the current Cell object.'''
        raise NotImplementedError()

    @overload
    def getStyle(self) -> Style:
        '''Gets the cell style.'''
        raise NotImplementedError()

    @overload
    def getStyle(self, checkBorders : bool) -> Style:
        '''If checkBorders is true, check whether other cells' borders will effect the style of this cell.
        :param checkBorders: Check other cells' borders
        :returns: Style object.'''
        raise NotImplementedError()

    @overload
    def setFormula(self, value : str) -> None:
        '''Sets a formula of the :class:`Cell`.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setFormula(self, formula : str, value : Object) -> None:
        '''Set the formula and the value(calculated result) of the formula.
        :param formula: The formula.
        :param value: The value(calculated result) of the formula.'''
        raise NotImplementedError()

    @overload
    def setFormula(self, formula : str, options : FormulaParseOptions) -> None:
        '''Set the formula and the value(calculated result) of the formula.
        :param formula: The formula.
        :param options: Options for parsing the formula.'''
        raise NotImplementedError()

    @overload
    def setFormula(self, formula : str, isR1C1 : bool, isLocal : bool, value : Object) -> None:
        ''':deprecated: Use FormulaParseOptions for more options instead.'''
        raise NotImplementedError()

    @overload
    def setFormula(self, formula : str, options : FormulaParseOptions, value : Object) -> None:
        '''Set the formula and the value(calculated result) of the formula.
        :param formula: The formula.
        :param options: Options for parsing the formula.
        :param value: The value(calculated result) of the formula.'''
        raise NotImplementedError()

    @overload
    def getStringValue(self, formatStrategy : int) -> str:
        '''Gets the string value by specific formatted strategy.
        :param formatStrategy: :class:`CellValueFormatStrategy`. The formatted strategy.'''
        raise NotImplementedError()

    @overload
    def getStringValue(self) -> str:
        '''Gets the string value contained in the cell. If the type of this cell is string, then return the string value itself.
        For other cell types, the formatted string value (formatted with the specified style of this cell) will be returned.
        The formatted cell value is same with what you can get from excel when copying a cell as text(such as
        copying cell to text editor or exporting to csv).'''
        raise NotImplementedError()

    def getTable(self) -> ListObject:
        '''Gets the table which contains this cell.'''
        raise NotImplementedError()

    @overload
    def setDynamicArrayFormula(self, arrayFormula : str, options : FormulaParseOptions, calculateValue : bool) -> CellArea:
        '''Sets dynamic array formula and make the formula spill into neighboring cells if possible.
        :param arrayFormula: the formula expression
        :param options: options to parse formula.
        :param calculateValue: whether calculate this dynamic array formula for those cells in the spilled range.
        :returns: the range that the formula should spill into.'''
        raise NotImplementedError()

    @overload
    def setDynamicArrayFormula(self, arrayFormula : str, options : FormulaParseOptions, values : list[list[Object]], calculateRange : bool, calculateValue : bool) -> CellArea:
        '''Sets dynamic array formula and make the formula spill into neighboring cells if possible.
        :param arrayFormula: the formula expression
        :param options: options to parse formula.
        :param values: values(calculated results) for those cells with given dynamic array formula
        :param calculateRange: 
        :param calculateValue: 
        :returns: the range that the formula should spill into.'''
        raise NotImplementedError()

    @overload
    def setDynamicArrayFormula(self, arrayFormula : str, options : FormulaParseOptions, values : list[list[Object]], calculateRange : bool, calculateValue : bool, copts : CalculationOptions) -> CellArea:
        '''Sets dynamic array formula and make the formula spill into neighboring cells if possible.
        :param arrayFormula: the formula expression
        :param options: options to parse formula.
        :param values: values(calculated results) for those cells with given dynamic array formula
        :param calculateRange: 
        :param calculateValue: 
        :param copts: The options for calculating formula.
        :returns: the range that the formula should spill into.'''
        raise NotImplementedError()

    def isRichText(self) -> bool:
        '''Indicates whether the string value of this cell is a rich formatted text.'''
        raise NotImplementedError()

    def containsExternalLink(self) -> bool:
        '''Indicates whether this cell contains an external link.
        Only applies when the cell is a formula cell.'''
        raise NotImplementedError()

    def isInArray(self) -> bool:
        ''':deprecated: Use IsArrayFormula instead.'''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets row number (zero based) of the cell.'''
        raise NotImplementedError()

    def getSharedStyleIndex(self) -> int:
        '''Gets cell's shared style index in the style pool.'''
        raise NotImplementedError()

    def isDynamicArrayFormula(self) -> bool:
        '''Indicates whether the cell's formula is dynamic array formula(true) or legacy array formula(false).'''
        raise NotImplementedError()

    @overload
    def getCharacters(self) -> list[FontSetting]:
        '''Returns all Characters objects
        that represents a range of characters within the cell text.'''
        raise NotImplementedError()

    @overload
    def getCharacters(self, flag : bool) -> list[FontSetting]:
        '''Returns all Characters objects
        that represents a range of characters within the cell text.
        :param flag: Indicates whether applying table style to the cell if the cell is in the table.
        :returns: All Characters objects'''
        raise NotImplementedError()

    def setCharacters(self, characters : list[FontSetting]) -> None:
        '''Sets rich text format of the cell.
        :param characters: All Characters objects.'''
        raise NotImplementedError()

    def toJson(self) -> str:
        '''Convert :class:`Cell` to JSON struct data.'''
        raise NotImplementedError()

    def getFormatConditions(self) -> list[FormatConditionCollection]:
        '''Gets format conditions which applies to this cell.'''
        raise NotImplementedError()

    def getHeightOfValue(self) -> int:
        '''Gets the height of the value in unit of pixels.'''
        raise NotImplementedError()

    def setHtmlString(self, value : str) -> None:
        '''Sets the html string which contains data and some formats in this cell.
        :param value: '''
        raise NotImplementedError()

    @overload
    def putValue(self, boolValue : bool) -> None:
        '''Puts a boolean value into the cell.
        :param boolValue: '''
        raise NotImplementedError()

    @overload
    def putValue(self, intValue : int) -> None:
        '''Puts an integer value into the cell.
        :param intValue: Input value'''
        raise NotImplementedError()

    @overload
    def putValue(self, doubleValue : int) -> None:
        '''Puts a double value into the cell.
        :param doubleValue: Input value'''
        raise NotImplementedError()

    @overload
    def putValue(self, stringValue : str, isConverted : bool, setStyle : bool) -> None:
        '''Puts a value into the cell, if appropriate the value will be converted to other data type and cell's number format will be reset.
        :param stringValue: Input value
        :param isConverted: True: converted to other data type if appropriate.
        :param setStyle: True: set the number format to cell's style when converting to other data type'''
        raise NotImplementedError()

    @overload
    def putValue(self, stringValue : str, isConverted : bool) -> None:
        '''Puts a string value into the cell and converts the value to other data type if appropriate.
        :param stringValue: Input value
        :param isConverted: True: converted to other data type if appropriate.'''
        raise NotImplementedError()

    @overload
    def putValue(self, stringValue : str) -> None:
        '''Puts a string value into the cell.
        :param stringValue: Input value'''
        raise NotImplementedError()

    @overload
    def putValue(self, dateTime : DateTime) -> None:
        '''Puts a DateTime value into the cell.
        :param dateTime: Input value'''
        raise NotImplementedError()

    @overload
    def putValue(self, objectValue : Object) -> None:
        '''Puts an object value into the cell.
        :param objectValue: input value'''
        raise NotImplementedError()


class CellArea:
    '''Represent an area of cells.'''

    StartRow : CellArea
    '''Gets or set the start row of this area.'''

    EndRow : CellArea
    '''Gets or set the end row of this area.'''

    StartColumn : CellArea
    '''Gets or set the start column of this area.'''

    EndColumn : CellArea
    '''Gets or set the end column of this area.'''

    @overload
    def createCellArea(self, startRow : int, startColumn : int, endRow : int, endColumn : int) -> CellArea:
        '''Creates a cell area.
        :param startRow: The start row.
        :param startColumn: The start column.
        :param endRow: The end row.
        :param endColumn: The end column.
        :returns: Return a :class:`CellArea`.'''
        raise NotImplementedError()

    @overload
    def createCellArea(self, startCellName : str, endCellName : str) -> CellArea:
        '''Creates a cell area.
        :param startCellName: The top-left cell of the range.
        :param endCellName: The bottom-right cell of the range.
        :returns: Return a :class:`CellArea`.'''
        raise NotImplementedError()

    def compareTo(self, obj : Object) -> int:
        '''Compare two CellArea objects according to their top-left corner.
        :param obj: 
        :returns: If two corners are in different rows, then compare their row index. Otherwise compare their column index. If two corners are same, then 0 will be returned.'''
        raise NotImplementedError()

    def toString(self) -> str:
        '''Returns a string represents the current cell area object.'''
        raise NotImplementedError()


class CellBorderType:
    '''Enumerates a cell's border type.'''

    DASH_DOT : CellBorderType
    '''Represents thin dash-dotted line.'''

    DASH_DOT_DOT : CellBorderType
    '''Represents thin dash-dot-dotted line.'''

    DASHED : CellBorderType
    '''Represents dashed line.'''

    DOTTED : CellBorderType
    '''Represents dotted line.'''

    DOUBLE : CellBorderType
    '''Represents double line.'''

    HAIR : CellBorderType
    '''Represents hair line.'''

    MEDIUM_DASH_DOT : CellBorderType
    '''Represents medium dash-dotted line.'''

    MEDIUM_DASH_DOT_DOT : CellBorderType
    '''Represents medium dash-dot-dotted line.'''

    MEDIUM_DASHED : CellBorderType
    '''Represents medium dashed line.'''

    NONE : CellBorderType
    '''Represents no line.'''

    MEDIUM : CellBorderType
    '''Represents medium line.'''

    SLANTED_DASH_DOT : CellBorderType
    '''Represents slanted medium dash-dotted line.'''

    THICK : CellBorderType
    '''Represents thick line.'''

    THIN : CellBorderType
    '''Represents thin line.'''


class CellRichValue:
    '''Represents rich value of the cell.'''

    def getImage(self) -> list[int]:
        '''Gets the image data of the cell.'''
        raise NotImplementedError()

    def getAltText(self) -> str:
        '''Gets the alt text associated with the image.'''
        raise NotImplementedError()

    def getErrorValue(self) -> int:
        '''Gets the error value type of the cell.
        See :class:`ErrorCellValueType`'''
        raise NotImplementedError()


class Cells:
    '''Encapsulates a collection of cell relevant objects, such as :class:`Cell`, :class:`Row`, ...etc.'''

    def setColumnWidthPixel(self, column : int, pixels : int) -> None:
        '''Sets column width in unit of pixels in normal view.
        :param column: Column index.
        :param pixels: Number of pixels.'''
        raise NotImplementedError()

    @overload
    def clearFormats(self, range : CellArea) -> None:
        '''Clears formatting of a range.
        :param range: Range to be cleared.'''
        raise NotImplementedError()

    @overload
    def clearFormats(self, startRow : int, startColumn : int, endRow : int, endColumn : int) -> None:
        '''Clears formatting of a range.
        :param startRow: Start row index.
        :param startColumn: Start column index.
        :param endRow: End row index.
        :param endColumn: End column index.'''
        raise NotImplementedError()

    def getViewColumnWidthPixel(self, column : int) -> int:
        '''Get the width in different view type.
        :param column: The column index.
        :returns: the column width in unit of pixels'''
        raise NotImplementedError()

    def unhideRows(self, row : int, totalRows : int, height : int) -> None:
        '''Unhides the hidden rows.
        :param row: The row index.
        :param totalRows: The row number.
        :param height: Row height. The row's height will be changed only when the row is hidden and given height value is positive.'''
        raise NotImplementedError()

    def getRanges(self) -> RangeCollection:
        '''Gets the collection of :class:`Range` objects created at run time.'''
        raise NotImplementedError()

    def getCount(self) -> int:
        '''Gets the total count of instantiated Cell objects.'''
        raise NotImplementedError()

    def unhideColumn(self, column : int, width : int) -> None:
        '''Unhides a column
        :param column: Column index.
        :param width: Column width.'''
        raise NotImplementedError()

    def setRowHeight(self, row : int, height : int) -> None:
        '''Sets the height of the specified row.
        :param row: Row index.
        :param height: Height of row.In unit of point It should be between 0 and 409.5.'''
        raise NotImplementedError()

    @overload
    def clearContents(self, range : CellArea) -> None:
        '''Clears contents of a range.
        :param range: Range to be cleared.'''
        raise NotImplementedError()

    @overload
    def clearContents(self, startRow : int, startColumn : int, endRow : int, endColumn : int) -> None:
        '''Clears contents of a range.
        :param startRow: Start row index.
        :param startColumn: Start column index.
        :param endRow: End row index.
        :param endColumn: End column index.'''
        raise NotImplementedError()

    def deleteRange(self, startRow : int, startColumn : int, endRow : int, endColumn : int, shiftType : int) -> None:
        '''Deletes a range of cells and shift cells according to the shift option.
        :param startRow: Start row index.
        :param startColumn: Start column index.
        :param endRow: End row index.
        :param endColumn: End column index.
        :param shiftType: :class:`ShiftType`. Shift cells option.'''
        raise NotImplementedError()

    def getMinDataRow(self) -> int:
        '''Minimum row index of cell which contains data.'''
        raise NotImplementedError()

    @overload
    def importCSV(self, fileName : str, splitter : str, convertNumericData : bool, firstRow : int, firstColumn : int) -> None:
        '''Import a CSV file to the cells.
        :param fileName: The CSV file name.
        :param splitter: The splitter
        :param convertNumericData: Whether the string in text file is converted to numeric data.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.'''
        raise NotImplementedError()

    @overload
    def importCSV(self, stream : InputStream, splitter : str, convertNumericData : bool, firstRow : int, firstColumn : int) -> None:
        '''Import a CSV file to the cells.
        :param stream: The CSV file stream.
        :param splitter: The splitter
        :param convertNumericData: Whether the string in text file is converted to numeric data.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.'''
        raise NotImplementedError()

    @overload
    def importCSV(self, fileName : str, options : TxtLoadOptions, firstRow : int, firstColumn : int) -> None:
        '''Import a CSV file to the cells.
        :param fileName: The CSV file name.
        :param options: The load options for reading text file
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.'''
        raise NotImplementedError()

    @overload
    def importCSV(self, stream : InputStream, options : TxtLoadOptions, firstRow : int, firstColumn : int) -> None:
        '''Import a CSV file to the cells.
        :param stream: The CSV file stream.
        :param options: The load options for reading text file
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.'''
        raise NotImplementedError()

    def exportArray(self, firstRow : int, firstColumn : int, totalRows : int, totalColumns : int) -> list[list[Object]]:
        '''Exports data in the :class:`Cells` collection to a two-dimension array object.
        :param firstRow: The row number of the first cell to export out.
        :param firstColumn: The column number of the first cell to export out.
        :param totalRows: Number of rows to be exported
        :param totalColumns: Number of columns to be exported
        :returns: Exported cell value array object.'''
        raise NotImplementedError()

    def getStandardHeightInch(self) -> int:
        '''Gets the default row height in this worksheet, in unit of inches.'''
        raise NotImplementedError()

    def showGroupDetail(self, isVertical : bool, index : int) -> None:
        '''Expands the grouped rows/columns.
        :param isVertical: True, expands the grouped rows.
        :param index: The row/column index'''
        raise NotImplementedError()

    @overload
    def get(self, row : int, column : int) -> Cell:
        '''Gets the :class:`Cell` element at the specified cell row index and column index.
        :param row: Row index.
        :param column: Column index.
        :returns: The :class:`Cell` object.'''
        raise NotImplementedError()

    @overload
    def get(self, cellName : str) -> Cell:
        '''Gets the :class:`Cell` element at the specified cell name.
        :param cellName: Cell name,including its column letter and row number, for example A5.
        :returns: A :class:`Cell` object'''
        raise NotImplementedError()

    def hideColumn(self, column : int) -> None:
        '''Hides a column.
        :param column: Column index.'''
        raise NotImplementedError()

    def getRowHeightInch(self, row : int) -> int:
        '''Gets the height of a specified row in unit of inches.
        :param row: Row index
        :returns: Height of row'''
        raise NotImplementedError()

    def getOdsCellFields(self) -> OdsCellFieldCollection:
        '''Gets the list of fields of ods.'''
        raise NotImplementedError()

    def getColumnWidthInch(self, column : int) -> int:
        ''':deprecated: Use Cells.GetColumnWidth(int ,bool , CellsUnitType ) method, instead.'''
        raise NotImplementedError()

    def getMaxGroupedRowOutlineLevel(self) -> int:
        '''Gets the max grouped row outline level (zero-based).'''
        raise NotImplementedError()

    def getGroupedRowOutlineLevel(self, rowIndex : int) -> int:
        '''Gets the outline level (zero-based) of the row.
        :param rowIndex: The row index.
        :returns: The outline level (zero-based) of the row.'''
        raise NotImplementedError()

    def setStandardWidthPixels(self, value : int) -> None:
        '''Sets the default column width in the worksheet, in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def isDefaultRowHidden(self) -> bool:
        '''Indicates whether the row is default hidden.'''
        raise NotImplementedError()

    def getRowEnumerator(self) -> Iterator:
        ''':deprecated: Use RowCollection.GetEnumerator() method, instead.'''
        raise NotImplementedError()

    def getDependentsInCalculation(self, row : int, column : int, recursive : bool) -> Iterator:
        '''Gets all cells whose calculated result depends on specific cell.
        :param row: Row index of the specific cell
        :param column: Column index of the specific cell.
        :param recursive: Whether returns those dependents which do not reference to the specific cell directly
        :returns: Enumerator to enumerate all dependents(Cell objects)'''
        raise NotImplementedError()

    def getMinColumn(self) -> int:
        '''Minimum column index of those cells that have been instantiated in the collection(does not include the column
        where style is defined for the whole column but no cell has been instantiated in it).'''
        raise NotImplementedError()

    def isDeletingRangeEnabled(self, startRow : int, startColumn : int, totalRows : int, totalColumns : int) -> bool:
        '''Check whether the range could be deleted.
        :param startRow: The start row index of the range.
        :param startColumn: The start column index of the range.
        :param totalRows: The number of the rows in the range.
        :param totalColumns: The number of the columns in the range.'''
        raise NotImplementedError()

    @overload
    def getColumnWidth(self, column : int, isOriginal : bool, unitType : int) -> int:
        '''Gets the column width.
        :param column: The column index.
        :param isOriginal: Indicates whether getting original width.
        :param unitType: :class:`CellsUnitType`.'''
        raise NotImplementedError()

    @overload
    def getColumnWidth(self, column : int) -> int:
        '''Gets the width(in unit of characters) of the specified column in normal view
        :param column: Column index
        :returns: Width of column. For spreadsheet, column width is measured as the number of characters of the maximum digit width of the numbers 0~9 as rendered in the normal style's font.'''
        raise NotImplementedError()

    @overload
    def ungroupRows(self, firstIndex : int, lastIndex : int, isAll : bool) -> None:
        '''Ungroups rows.
        :param firstIndex: The first row index to be ungrouped.
        :param lastIndex: The last row index to be ungrouped.
        :param isAll: True, removes all grouped info.Otherwise, remove the outer group info.'''
        raise NotImplementedError()

    @overload
    def ungroupRows(self, firstIndex : int, lastIndex : int) -> None:
        '''Ungroups rows.
        :param firstIndex: The first row index to be ungrouped.
        :param lastIndex: The last row index to be ungrouped.'''
        raise NotImplementedError()

    def getStandardHeightPixels(self) -> int:
        '''Gets the default row height in this worksheet, in unit of pixels.'''
        raise NotImplementedError()

    def getStandardWidthInch(self) -> int:
        '''Gets the default column width in the worksheet, in unit of inches.'''
        raise NotImplementedError()

    @overload
    def groupRows(self, firstIndex : int, lastIndex : int, isHidden : bool) -> None:
        '''Groups rows.
        :param firstIndex: The first row index to be grouped.
        :param lastIndex: The last row index to be grouped.
        :param isHidden: Specifies if the grouped rows are hidden.'''
        raise NotImplementedError()

    @overload
    def groupRows(self, firstIndex : int, lastIndex : int) -> None:
        '''Groups rows.
        :param firstIndex: The first row index to be grouped.
        :param lastIndex: The last row index to be grouped.'''
        raise NotImplementedError()

    def getViewRowHeightInch(self, row : int) -> int:
        '''Gets the height of a specified row in unit of inches.
        :param row: Row index
        :returns: Height of row'''
        raise NotImplementedError()

    @overload
    def endCellInColumn(self, columnIndex : int) -> Cell:
        '''Gets the last cell in this column.
        :param columnIndex: Column index.
        :returns: Cell object.'''
        raise NotImplementedError()

    @overload
    def endCellInColumn(self, startRow : int, endRow : int, startColumn : int, endColumn : int) -> Cell:
        '''Gets the last cell with maximum column index in this range.
        :param startRow: Start row index.
        :param endRow: End row index.
        :param startColumn: Start column index.
        :param endColumn: End column index.
        :returns: Cell object.'''
        raise NotImplementedError()

    def setRowHeightInch(self, row : int, inches : int) -> None:
        '''Sets row height in unit of inches.
        :param row: Row index.
        :param inches: Number of inches. It should be between 0 and 409.5/72.'''
        raise NotImplementedError()

    def isRowHidden(self, rowIndex : int) -> bool:
        '''Checks whether a row at given index is hidden.
        :param rowIndex: row index
        :returns: true if the row is hidden'''
        raise NotImplementedError()

    def setStandardHeightInch(self, value : int) -> None:
        '''Sets the default row height in this worksheet, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def textToColumns(self, row : int, column : int, totalRows : int, options : TxtLoadOptions) -> int:
        '''Splits content in specified column into multiple columns..
        :param row: The row index.
        :param column: The column index.
        :param totalRows: The number of rows.
        :param options: The split options.
        :returns: Total column count of the split values.'''
        raise NotImplementedError()

    def getStandardWidth(self) -> int:
        '''Gets the default column width in the worksheet, in unit of characters.'''
        raise NotImplementedError()

    @overload
    def importResultSet(self, rs : ResultSet, startCell : str, options : ImportTableOptions) -> int:
        '''Imports data in a ResultSet object to the worksheet.
        :param rs: the ResultSet object to import from.
        :param startCell: name of start cell to insert the resultset, such as "A1".
        :param options: The import options
        :returns: how many rows actually imported.'''
        raise NotImplementedError()

    @overload
    def importResultSet(self, rs : ResultSet, rowIndex : int, columnIndex : int, options : ImportTableOptions) -> int:
        '''Imports data in a ResultSet object to the worksheet.
        :param rs: the ResultSet object to import from.
        :param rowIndex: start row index in the worksheet.
        :param columnIndex: start column index in the worksheet.
        :param options: The import options
        :returns: how many rows actually imported.'''
        raise NotImplementedError()

    @overload
    def importResultSet(self, rs : ResultSet, rowIndex : int, columnIndex : int, rowNum : int, columnNum : int, isFieldNameShown : bool) -> int:
        '''Imports data in a ResultSet object to the worksheet.
        :param rs: the ResultSet object to import from.
        :param rowIndex: start row index in the worksheet.
        :param columnIndex: start column index in the worksheet.
        :param rowNum: number of rows to import. -1 to import all records in given resultset.
        :param columnNum: number of columns to import. -1 to import all columns in given resultset.
        :param isFieldNameShown: Indicates whether the field name of the resultset will be imported to the first row.
        :returns: how many rows actually imported.'''
        raise NotImplementedError()

    @overload
    def importResultSet(self, rs : ResultSet, startCell : str, rowNum : int, columnNum : int, isFieldNameShown : bool) -> int:
        '''Imports data in a ResultSet object to the worksheet.
        :param rs: the ResultSet object to import from.
        :param startCell: name of start cell to insert the resultset, such as "A1".
        :param rowNum: number of rows to import. -1 to import all records in given resultset.
        :param columnNum: number of columns to import. -1 to import all columns in given resultset.
        :param isFieldNameShown: Indicates whether the field name of the resultset will be imported to the first row.
        :returns: how many rows actually imported.'''
        raise NotImplementedError()

    @overload
    def importResultSet(self, rs : ResultSet, rowIndex : int, columnIndex : int, isFieldNameShown : bool) -> int:
        '''Imports data in a ResultSet object to the worksheet.
        :param rs: the ResultSet object to import from.
        :param rowIndex: start row index in the worksheet.
        :param columnIndex: start column index in the worksheet.
        :param isFieldNameShown: Indicates whether the field name of the resultset will be imported to the first row.
        :returns: how many rows actually imported.'''
        raise NotImplementedError()

    @overload
    def importResultSet(self, rs : ResultSet, startCell : str, isFieldNameShown : bool) -> int:
        '''Imports data in a ResultSet object to the worksheet.
        :param rs: the ResultSet object to import from.
        :param startCell: name of start cell to insert the resultset, such as "A1".
        :param isFieldNameShown: Indicates whether the field name of the resultset will be imported to the first row.
        :returns: how many rows actually imported.'''
        raise NotImplementedError()

    @overload
    def importResultSet(self, rs : ResultSet, rowIndex : int, columnIndex : int, rowNum : int, columnNum : int, isFieldNameShown : bool, customDateFormatString : str, convertStringToNumber : bool) -> int:
        '''Imports data in a ResultSet object to the worksheet.
        :param rs: the ResultSet object to import from.
        :param rowIndex: start row index in the worksheet.
        :param columnIndex: start column index in the worksheet.
        :param rowNum: number of rows to import. -1 to import all records in given resultset.
        :param columnNum: number of columns to import. -1 to import all columns in given resultset.
        :param isFieldNameShown: Indicates whether the field name of the resultset will be imported to the first row.
        :param customDateFormatString: Date format string for cells which contain date value.
        :param convertStringToNumber: Indicates if this method will try to convert string to number.
        :returns: how many rows actually imported.'''
        raise NotImplementedError()

    @overload
    def importResultSet(self, rs : ResultSet, rowIndex : int, columnIndex : int, isFieldNameShown : bool, customDateFormatString : str, convertStringToNumber : bool) -> int:
        '''Imports data in a ResultSet object to the worksheet.
        :param rs: the ResultSet object to import from.
        :param rowIndex: start row index in the worksheet.
        :param columnIndex: start column index in the worksheet.
        :param isFieldNameShown: Indicates whether the field name of the resultset will be imported to the first row.
        :param customDateFormatString: Date format string for cells which contain date value.
        :param convertStringToNumber: Indicates if this method will try to convert string to number.
        :returns: how many rows actually imported.'''
        raise NotImplementedError()

    def unMerge(self, firstRow : int, firstColumn : int, totalRows : int, totalColumns : int) -> None:
        '''Unmerges a specified range of merged cells.
        :param firstRow: First row of this range(zero based)
        :param firstColumn: First column of this range(zero based)
        :param totalRows: Number of rows(one based)
        :param totalColumns: Number of columns(one based)'''
        raise NotImplementedError()

    def getMinDataColumn(self) -> int:
        '''Minimum column index of cell which contains data.'''
        raise NotImplementedError()

    @overload
    def importCustomObjects(self, list : Collection, propertyNames : list[str], isPropertyNameShown : bool, firstRow : int, firstColumn : int, rowNumber : int, insertRows : bool, dateFormatString : str, convertStringToNumber : bool) -> int:
        '''Imports custom objects.
        :param list: The custom object
        :param propertyNames: The property names.If it is null,we will import all properties of the object.
        :param isPropertyNameShown: 
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param rowNumber: Number of rows to be imported.
        :param insertRows: Indicates whether extra rows are added to fit data.
        :param dateFormatString: Date format string for cells.
        :param convertStringToNumber: Indicates if this method will try to convert string to number.
        :returns: Total number of rows imported.'''
        raise NotImplementedError()

    @overload
    def importCustomObjects(self, list : Collection, firstRow : int, firstColumn : int, options : ImportTableOptions) -> int:
        '''Imports custom objects.
        :param list: The custom object
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param options: The import options.
        :returns: Total number of rows imported.'''
        raise NotImplementedError()

    @overload
    def getRowHeight(self, row : int, isOriginal : bool, unitType : int) -> int:
        '''Gets row's height.
        :param row: The row index.
        :param isOriginal: Whether returns the original row height or 0 for hidden row.
        :param unitType: :class:`CellsUnitType`. Unit type of the returned height value
        :returns: Row's height'''
        raise NotImplementedError()

    @overload
    def getRowHeight(self, row : int) -> int:
        '''Gets the height of a specified row, in unit of points.
        :param row: Row index
        :returns: Height of row'''
        raise NotImplementedError()

    @overload
    def deleteBlankRows(self) -> None:
        '''Delete all blank rows which do not contain any data or other object.'''
        raise NotImplementedError()

    @overload
    def deleteBlankRows(self, options : DeleteOptions) -> None:
        '''Delete all blank rows which do not contain any data or some special objects such as visible comment, pivot table.
        :param options: The options of deleting range.'''
        raise NotImplementedError()

    @overload
    def importArray(self, stringArray : list[list[str]], firstRow : int, firstColumn : int) -> None:
        '''Imports a two-dimension array of string into a worksheet.
        :param stringArray: Two-dimension string array.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.'''
        raise NotImplementedError()

    @overload
    def importArray(self, stringArray : list[str], firstRow : int, firstColumn : int, isVertical : bool) -> None:
        '''Imports an array of string into a worksheet.
        :param stringArray: String array.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param isVertical: Specifies to import data vertically or horizontally.'''
        raise NotImplementedError()

    @overload
    def importArray(self, intArray : list[list[int]], firstRow : int, firstColumn : int) -> None:
        '''Imports a two-dimension array of integer into a worksheet.
        :param intArray: Two-dimension integer array.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.'''
        raise NotImplementedError()

    @overload
    def importArray(self, intArray : list[int], firstRow : int, firstColumn : int, isVertical : bool) -> None:
        '''Imports an array of integer into a worksheet.
        :param intArray: Integer array.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param isVertical: Specifies to import data vertically or horizontally.'''
        raise NotImplementedError()

    @overload
    def importArray(self, doubleArray : list[list[int]], firstRow : int, firstColumn : int) -> None:
        '''Imports a two-dimension array of double into a worksheet.
        :param doubleArray: Two-dimension double array.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.'''
        raise NotImplementedError()

    @overload
    def importArray(self, doubleArray : list[int], firstRow : int, firstColumn : int, isVertical : bool) -> None:
        '''Imports an array of double into a worksheet.
        :param doubleArray: Double array.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param isVertical: Specifies to import data vertically or horizontally.'''
        raise NotImplementedError()

    @overload
    def subtotal(self, ca : CellArea, groupBy : int, function : int, totalList : list[int]) -> None:
        '''Creates subtotals for the range.
        :param ca: The range
        :param groupBy: The field to group by, as a zero-based integer offset
        :param function: :class:`ConsolidationFunction`. The subtotal function.
        :param totalList: An array of zero-based field offsets, indicating the fields to which the subtotals are added.'''
        raise NotImplementedError()

    @overload
    def subtotal(self, ca : CellArea, groupBy : int, function : int, totalList : list[int], replace : bool, pageBreaks : bool, summaryBelowData : bool) -> None:
        '''Creates subtotals for the range.
        :param ca: The range
        :param groupBy: The field to group by, as a zero-based integer offset
        :param function: :class:`ConsolidationFunction`. The subtotal function.
        :param totalList: An array of zero-based field offsets, indicating the fields to which the subtotals are added.
        :param replace: Indicates whether replace the current subtotals
        :param pageBreaks: Indicates whether add page break between groups
        :param summaryBelowData: Indicates whether add summary below data.'''
        raise NotImplementedError()

    @overload
    def deleteColumns(self, columnIndex : int, totalColumns : int, updateReference : bool) -> None:
        '''Deletes several columns.
        :param columnIndex: Index of the first column to be deleted.
        :param totalColumns: Count of columns to be deleted.
        :param updateReference: Indicates whether update references in other worksheets.'''
        raise NotImplementedError()

    @overload
    def deleteColumns(self, columnIndex : int, totalColumns : int, options : DeleteOptions) -> None:
        '''Deletes several columns.
        :param columnIndex: Index of the first column to be deleted.
        :param totalColumns: Count of columns to be deleted.
        :param options: Options for the deleting operation'''
        raise NotImplementedError()

    def hideGroupDetail(self, isVertical : bool, index : int) -> None:
        '''Collapses the grouped rows/columns.
        :param isVertical: True, collapse the grouped rows.
        :param index: The row/column index'''
        raise NotImplementedError()

    def getMultiThreadReading(self) -> bool:
        '''Gets whether the cells data model should support Multi-Thread reading.
        Default value of this property is false.'''
        raise NotImplementedError()

    @overload
    def endCellInRow(self, rowIndex : int) -> Cell:
        '''Gets the last cell in this row.
        :param rowIndex: Row index.
        :returns: Cell object.'''
        raise NotImplementedError()

    @overload
    def endCellInRow(self, startRow : int, endRow : int, startColumn : int, endColumn : int) -> Cell:
        '''Gets the last cell with maximum row index in this range.
        :param startRow: Start row index.
        :param endRow: End row index.
        :param startColumn: Start column index.
        :param endColumn: End column index.
        :returns: Cell object.'''
        raise NotImplementedError()

    def getMinRow(self) -> int:
        '''Minimum row index of cell which contains data or style.'''
        raise NotImplementedError()

    def setStyle(self, value : Style) -> None:
        '''Sets the default style of the worksheet.
        :param value: '''
        raise NotImplementedError()

    def hideRow(self, row : int) -> None:
        '''Hides a row.
        :param row: Row index.'''
        raise NotImplementedError()

    def getColumns(self) -> ColumnCollection:
        '''Gets the collection of :class:`Column` objects that represents the individual columns in this worksheet.'''
        raise NotImplementedError()

    def setColumnWidth(self, column : int, width : int) -> None:
        '''Sets the width of the specified column in normal view.
        :param column: Column index.
        :param width: Width of column.Column width must be between 0 and 255.'''
        raise NotImplementedError()

    def getRows(self) -> RowCollection:
        '''Gets the collection of :class:`Row` objects that represents the individual rows in this worksheet.'''
        raise NotImplementedError()

    def getRowOriginalHeightPoint(self, row : int) -> int:
        ''':deprecated: Use Cells.GetRowHeight(int,bool,CellsUnitType) method, instead.'''
        raise NotImplementedError()

    @overload
    def copyRows(self, sourceCells : Cells, sourceRowIndex : int, destinationRowIndex : int, rowNumber : int) -> None:
        '''Copies data and formats of some whole rows.
        :param sourceCells: Source Cells object contains data and formats to copy.
        :param sourceRowIndex: Source row index.
        :param destinationRowIndex: Destination row index.
        :param rowNumber: The copied row number.'''
        raise NotImplementedError()

    @overload
    def copyRows(self, sourceCells0 : Cells, sourceRowIndex : int, destinationRowIndex : int, rowNumber : int, copyOptions : CopyOptions) -> None:
        '''Copies data and formats of some whole rows.
        :param sourceCells0: Source Cells object contains data and formats to copy.
        :param sourceRowIndex: Source row index.
        :param destinationRowIndex: Destination row index.
        :param rowNumber: The copied row number.
        :param copyOptions: The copy options.'''
        raise NotImplementedError()

    @overload
    def copyRows(self, sourceCells0 : Cells, sourceRowIndex : int, destinationRowIndex : int, rowNumber : int, copyOptions : CopyOptions, pasteOptions : PasteOptions) -> None:
        '''Copies data and formats of some whole rows.
        :param sourceCells0: Source Cells object contains data and formats to copy.
        :param sourceRowIndex: Source row index.
        :param destinationRowIndex: Destination row index.
        :param rowNumber: The copied row number.
        :param copyOptions: The copy options.
        :param pasteOptions: the options of pasting.'''
        raise NotImplementedError()

    def getMemorySetting(self) -> int:
        '''Gets the memory usage option for this cells.
        See :class:`MemorySetting`'''
        raise NotImplementedError()

    def getGroupedColumnOutlineLevel(self, columnIndex : int) -> int:
        '''Gets the outline level (zero-based) of the column.
        :param columnIndex: The column index
        :returns: The outline level of the column'''
        raise NotImplementedError()

    def isBlankColumn(self, columnIndex : int) -> bool:
        '''Checks whether given column is blank(does not contain any data).
        :param columnIndex: the column index
        :returns: true if given column does not contain any data'''
        raise NotImplementedError()

    def getPreserveString(self) -> bool:
        '''Gets a value indicating whether all worksheet values are preserved as strings.
        Default is false.'''
        raise NotImplementedError()

    def getMaxDisplayRange(self) -> Range:
        '''Gets the max range which includes data, merged cells and shapes.'''
        raise NotImplementedError()

    def getRowHeightPixel(self, row : int) -> int:
        '''Gets the height of a specified row in unit of pixel.
        :param row: Row index
        :returns: Height of row'''
        raise NotImplementedError()

    def setStandardWidth(self, value : int) -> None:
        '''Sets the default column width in the worksheet, in unit of characters.
        :param value: '''
        raise NotImplementedError()

    def clearMergedCells(self) -> None:
        '''Clears all merged ranges.'''
        raise NotImplementedError()

    def getMaxDataRow(self) -> int:
        '''Maximum row index of cell which contains data.'''
        raise NotImplementedError()

    def getLastCell(self) -> Cell:
        '''Gets the last cell in this worksheet.'''
        raise NotImplementedError()

    @overload
    def deleteColumn(self, columnIndex : int, updateReference : bool) -> None:
        '''Deletes a column.
        :param columnIndex: Index of the column to be deleted.
        :param updateReference: Indicates whether update references in other worksheets.'''
        raise NotImplementedError()

    @overload
    def deleteColumn(self, columnIndex : int) -> None:
        '''Deletes a column.
        :param columnIndex: Index of the column to be deleted.'''
        raise NotImplementedError()

    def getStandardHeight(self) -> int:
        '''Gets the default row height in this worksheet, in unit of points.'''
        raise NotImplementedError()

    def isDefaultRowHeightMatched(self) -> bool:
        '''Indicates that row height and default font height matches'''
        raise NotImplementedError()

    def setColumnWidthInch(self, column : int, inches : int) -> None:
        '''Sets column width in unit of inches  in normal view.
        :param column: Column index.
        :param inches: Number of inches.'''
        raise NotImplementedError()

    def exportTypeArray(self, firstRow : int, firstColumn : int, totalRows : int, totalColumns : int) -> list[list[int]]:
        '''Exports cell value type in the :class:`Cells` collection to a two-dimension array object.
        :param firstRow: The row number of the first cell to export out.
        :param firstColumn: The column number of the first cell to export out.
        :param totalRows: Number of rows to be exported.
        :param totalColumns: Number of columns to be exported.
        :returns: :class:`CellValueType`. Exported array object representing cell value types.'''
        raise NotImplementedError()

    def getMaxColumn(self) -> int:
        '''Maximum column index of those cells that have been instantiated in the collection(does not include the column
        where style is defined for the whole column but no cell has been instantiated in it).'''
        raise NotImplementedError()

    @overload
    def find(self, what : Object, previousCell : Cell) -> Cell:
        '''Finds the cell containing with the input object.
        :param what: The object to search for.
        :param previousCell: Previous cell with the same object.
        :returns: Cell object.'''
        raise NotImplementedError()

    @overload
    def find(self, what : Object, previousCell : Cell, findOptions : FindOptions) -> Cell:
        '''Finds the cell containing with the input object.
        :param what: The object to search for.
        :param previousCell: Previous cell with the same object.
        :param findOptions: Find options
        :returns: Cell object.'''
        raise NotImplementedError()

    def getViewRowHeight(self, row : int) -> int:
        '''Gets the height of a specified row.
        :param row: Row index.
        :returns: Height of row.'''
        raise NotImplementedError()

    def retrieveSubtotalSetting(self, ca : CellArea) -> SubtotalSetting:
        '''Retrieves subtotals setting of the range.
        :param ca: The range'''
        raise NotImplementedError()

    def hideRows(self, row : int, totalRows : int) -> None:
        '''Hides multiple rows.
        :param row: The row index.
        :param totalRows: The row number.'''
        raise NotImplementedError()

    @overload
    def merge(self, firstRow : int, firstColumn : int, totalRows : int, totalColumns : int) -> None:
        '''Merges a specified range of cells into a single cell.
        :param firstRow: First row of this range(zero based)
        :param firstColumn: First column of this range(zero based)
        :param totalRows: Number of rows(one based)
        :param totalColumns: Number of columns(one based)'''
        raise NotImplementedError()

    @overload
    def merge(self, firstRow : int, firstColumn : int, totalRows : int, totalColumns : int, mergeConflict : bool) -> None:
        '''Merges a specified range of cells into a single cell.
        :param firstRow: First row of this range(zero based)
        :param firstColumn: First column of this range(zero based)
        :param totalRows: Number of rows(one based)
        :param totalColumns: Number of columns(one based)
        :param mergeConflict: Merge conflict merged ranges.'''
        raise NotImplementedError()

    @overload
    def merge(self, firstRow : int, firstColumn : int, totalRows : int, totalColumns : int, checkConflict : bool, mergeConflict : bool) -> None:
        '''Merges a specified range of cells into a single cell.
        :param firstRow: First row of this range(zero based)
        :param firstColumn: First column of this range(zero based)
        :param totalRows: Number of rows(one based)
        :param totalColumns: Number of columns(one based)
        :param checkConflict: Indicates whether check the merged cells intersects other merged cells
        :param mergeConflict: Merge conflict merged ranges.'''
        raise NotImplementedError()

    def setMemorySetting(self, value : int) -> None:
        '''Sets the memory usage option for this cells.
        See :class:`MemorySetting`
        :param value: '''
        raise NotImplementedError()

    def getMergedAreas(self) -> list[CellArea]:
        '''Gets all merged cells.'''
        raise NotImplementedError()

    def setMultiThreadReading(self, value : bool) -> None:
        '''Sets whether the cells data model should support Multi-Thread reading.
        Default value of this property is false.
        :param value: '''
        raise NotImplementedError()

    def iterator(self) -> Iterator:
        '''Gets the cells enumerator.'''
        raise NotImplementedError()

    @overload
    def insertRange(self, area : CellArea, shiftNumber : int, shiftType : int, updateReference : bool) -> None:
        '''Inserts a range of cells and shift cells according to the shift option.
        :param area: Shift area.
        :param shiftNumber: Number of rows or columns to be inserted.
        :param shiftType: :class:`ShiftType`. Shift cells option.
        :param updateReference: Indicates whether update references in other worksheets.'''
        raise NotImplementedError()

    @overload
    def insertRange(self, area : CellArea, shiftType : int) -> None:
        '''Inserts a range of cells and shift cells according to the shift option.
        :param area: Shift area.
        :param shiftType: :class:`ShiftType`. Shift cells option.'''
        raise NotImplementedError()

    @overload
    def insertRange(self, area : CellArea, shiftNumber : int, shiftType : int) -> None:
        '''Inserts a range of cells and shift cells according to the shift option.
        :param area: Shift area.
        :param shiftNumber: Number of rows or columns to be inserted.
        :param shiftType: :class:`ShiftType`. Shift cells option.'''
        raise NotImplementedError()

    def importData(self, table : ICellsDataTable, firstRow : int, firstColumn : int, options : ImportTableOptions) -> int:
        '''Import data from custom data table.
        :param table: The custom data table.
        :param firstRow: First row index.
        :param firstColumn: First column index.
        :param options: The import options'''
        raise NotImplementedError()

    def unhideRow(self, row : int, height : int) -> None:
        '''Unhides a row.
        :param row: Row index.
        :param height: Row height. The row's height will be changed only when the row is hidden and given height value is positive.'''
        raise NotImplementedError()

    def setStandardHeight(self, value : int) -> None:
        '''Sets the default row height in this worksheet, in unit of points.
        :param value: '''
        raise NotImplementedError()

    def getStandardWidthPixels(self) -> int:
        '''Gets the default column width in the worksheet, in unit of pixels.'''
        raise NotImplementedError()

    def linkToXmlMap(self, mapName : str, row : int, column : int, path : str) -> None:
        '''Link to a xml map.
        :param mapName: name of xml map
        :param row: row of the destination cell
        :param column: column of the destination cell
        :param path: path of xml element in xml map'''
        raise NotImplementedError()

    @overload
    def insertRows(self, rowIndex : int, totalRows : int, updateReference : bool) -> None:
        '''Inserts multiple rows into the worksheet.
        :param rowIndex: Row index.
        :param totalRows: Number of rows to be inserted.
        :param updateReference: Indicates if references in other worksheets will be updated.'''
        raise NotImplementedError()

    @overload
    def insertRows(self, rowIndex : int, totalRows : int, options : InsertOptions) -> None:
        '''Inserts multiple rows into the worksheet.
        :param rowIndex: Row index.
        :param totalRows: Number of rows to be inserted.
        :param options: Options for inserting operation.'''
        raise NotImplementedError()

    @overload
    def insertRows(self, rowIndex : int, totalRows : int) -> None:
        '''Inserts multiple rows into the worksheet.
        :param rowIndex: Row index.
        :param totalRows: Number of rows to be inserted.'''
        raise NotImplementedError()

    def setPreserveString(self, value : bool) -> None:
        '''Sets a value indicating whether all worksheet values are preserved as strings.
        Default is false.
        :param value: '''
        raise NotImplementedError()

    def moveRange(self, sourceArea : CellArea, destRow : int, destColumn : int) -> None:
        '''Moves the range.
        :param sourceArea: The range which should be moved.
        :param destRow: The dest row.
        :param destColumn: The dest column.'''
        raise NotImplementedError()

    def setStandardWidthInch(self, value : int) -> None:
        '''Sets the default column width in the worksheet, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    @overload
    def importTwoDimensionArray(self, objArray : list[list[Object]], firstRow : int, firstColumn : int) -> None:
        '''Imports a two-dimension array of data into a worksheet.
        :param objArray: Two-dimension data array.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.'''
        raise NotImplementedError()

    @overload
    def importTwoDimensionArray(self, objArray : list[list[Object]], firstRow : int, firstColumn : int, convertStringToNumber : bool) -> None:
        '''Imports a two-dimension array of data into a worksheet.
        :param objArray: Two-dimension data array.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param convertStringToNumber: Indicates if this method will try to convert string to number.'''
        raise NotImplementedError()

    @overload
    def importTwoDimensionArray(self, objArray : list[list[Object]], styles : list[list[Object]], firstRow : int, firstColumn : int, convertStringToNumber : bool) -> None:
        '''Imports a two-dimension array of data into a worksheet.
        :param objArray: Two-dimension data array.
        :param styles: Two-dimension data style.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param convertStringToNumber: Indicates if this method will try to convert string to number.'''
        raise NotImplementedError()

    @overload
    def importTwoDimensionArray(self, objArray : list[list[Object]], styles : list[list[Object]], firstRow : int, firstColumn : int, opts : TxtLoadOptions) -> None:
        '''Imports a two-dimension array of data into a worksheet.
        :param objArray: Two-dimension data array.
        :param styles: Two-dimension data style.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param opts: Options for converting string values'''
        raise NotImplementedError()

    def dispose(self) -> None:
        '''Performs application-defined tasks associated with freeing, releasing, or
        resetting unmanaged resources.'''
        raise NotImplementedError()

    def setRowHeightPixel(self, row : int, pixels : int) -> None:
        '''Sets row height in unit of pixels.
        :param row: Row index.
        :param pixels: Number of pixels.'''
        raise NotImplementedError()

    def insertCutCells(self, cutRange : Range, row : int, column : int, shiftType : int) -> None:
        '''Insert cut range.
        :param cutRange: The cut range.
        :param row: The row.
        :param column: The column.
        :param shiftType: :class:`ShiftType`. The shift type .'''
        raise NotImplementedError()

    def ungroupColumns(self, firstIndex : int, lastIndex : int) -> None:
        '''Ungroups columns.
        :param firstIndex: The first column index to be ungrouped.
        :param lastIndex: The last column index to be ungrouped.'''
        raise NotImplementedError()

    def applyStyle(self, style : Style, flag : StyleFlag) -> None:
        '''Applies formats for a whole worksheet.
        :param style: The style object which will be applied.
        :param flag: Flags which indicates applied formatting properties.'''
        raise NotImplementedError()

    def removeFormulas(self) -> None:
        '''Removes all formula and replaces with the value of the formula.'''
        raise NotImplementedError()

    def copyColumn(self, sourceCells : Cells, sourceColumnIndex : int, destinationColumnIndex : int) -> None:
        '''Copies data and formats of a whole column.
        :param sourceCells: Source Cells object contains data and formats to copy.
        :param sourceColumnIndex: Source column index.
        :param destinationColumnIndex: Destination column index.'''
        raise NotImplementedError()

    def checkCell(self, row : int, column : int) -> Cell:
        '''Gets the :class:`Cell` element or null at the specified cell row index and column index.
        :param row: Row index
        :param column: Column index
        :returns: Return Cell object if a Cell object exists. Return null if the cell does not exist.'''
        raise NotImplementedError()

    def getLastDataRow(self, column : int) -> int:
        '''Gets the last row index of cell which contains data in the specified column.
        :param column: Column index.
        :returns: last row index.'''
        raise NotImplementedError()

    def applyRowStyle(self, row : int, style : Style, flag : StyleFlag) -> None:
        '''Applies formats for a whole row.
        :param row: The row index.
        :param style: The style object which will be applied.
        :param flag: Flags which indicates applied formatting properties.'''
        raise NotImplementedError()

    def getMergedCells(self) -> list:
        ''':deprecated: Use Cells.GetMergedAreas() instead.'''
        raise NotImplementedError()

    def setViewColumnWidthPixel(self, column : int, pixels : int) -> None:
        '''Sets the width of the column in different view.
        :param column: The column index.
        :param pixels: The width in unit of pixels.'''
        raise NotImplementedError()

    def getCellsWithPlaceInCellPicture(self) -> Iterator:
        '''Gets all cells that contain embedded picture.'''
        raise NotImplementedError()

    def hideColumns(self, column : int, totalColumns : int) -> None:
        '''Hide multiple columns.
        :param column: Column index.
        :param totalColumns: Column number.'''
        raise NotImplementedError()

    def insertRow(self, rowIndex : int) -> None:
        '''Inserts a new row into the worksheet.
        :param rowIndex: Row index.'''
        raise NotImplementedError()

    def isColumnHidden(self, columnIndex : int) -> bool:
        '''Checks whether a column at given index is hidden.
        :param columnIndex: column index
        :returns: true if the column is hidden.'''
        raise NotImplementedError()

    def checkRow(self, row : int) -> Row:
        '''Gets the :class:`Row` element or null at the specified cell row index.
        :param row: Row index
        :returns: Returns :class:`Row` object If the row object does exist, otherwise returns null.'''
        raise NotImplementedError()

    @overload
    def deleteRow(self, rowIndex : int) -> None:
        '''Deletes a row.
        :param rowIndex: Index of the row to be deleted.'''
        raise NotImplementedError()

    @overload
    def deleteRow(self, rowIndex : int, updateReference : bool) -> None:
        '''Deletes a row.
        :param rowIndex: Index of the row to be deleted.
        :param updateReference: Indicates whether update references in other worksheets.'''
        raise NotImplementedError()

    def getCountLarge(self) -> int:
        '''Gets the total count of instantiated Cell objects.'''
        raise NotImplementedError()

    def getStyle(self) -> Style:
        '''Gets the default style of the worksheet.'''
        raise NotImplementedError()

    def setDefaultRowHeightMatched(self, value : bool) -> None:
        '''Indicates that row height and default font height matches
        :param value: '''
        raise NotImplementedError()

    def getMaxRow(self) -> int:
        '''Maximum row index of cell which contains data or style.'''
        raise NotImplementedError()

    @overload
    def deleteBlankColumns(self) -> None:
        '''Delete all blank columns which do not contain any data.'''
        raise NotImplementedError()

    @overload
    def deleteBlankColumns(self, options : DeleteOptions) -> None:
        '''Delete all blank columns which do not contain any data.
        :param options: The options of deleting range.'''
        raise NotImplementedError()

    @overload
    def createRange(self, upperLeftCell : str, lowerRightCell : str) -> Range:
        '''Creates a :class:`Range` object from a range of cells.
        :param upperLeftCell: Upper left cell name.
        :param lowerRightCell: Lower right cell name.
        :returns: A :class:`Range` object'''
        raise NotImplementedError()

    @overload
    def createRange(self, firstRow : int, firstColumn : int, totalRows : int, totalColumns : int) -> Range:
        '''Creates a :class:`Range` object from a range of cells.
        :param firstRow: First row of this range
        :param firstColumn: First column of this range
        :param totalRows: Number of rows
        :param totalColumns: Number of columns
        :returns: A :class:`Range` object'''
        raise NotImplementedError()

    @overload
    def createRange(self, address : str) -> Range:
        '''Creates a :class:`Range` object from an address of the range.
        :param address: The address of the range.
        :returns: A :class:`Range` object'''
        raise NotImplementedError()

    @overload
    def createRange(self, firstIndex : int, number : int, isVertical : bool) -> Range:
        '''Creates a :class:`Range` object from rows of cells or columns of cells.
        :param firstIndex: First row index or first column index, zero based.
        :param number: Total number of rows or columns, one based.
        :param isVertical: True - Range created from columns of cells. False - Range created from rows of cells.
        :returns: A :class:`Range` object.'''
        raise NotImplementedError()

    def applyColumnStyle(self, column : int, style : Style, flag : StyleFlag) -> None:
        '''Applies formats for a whole column.
        :param column: The column index.
        :param style: The style object which will be applied.
        :param flag: Flags which indicates applied formatting properties.'''
        raise NotImplementedError()

    def convertStringToNumericValue(self) -> None:
        '''Converts all string data in the worksheet to numeric value if possible.'''
        raise NotImplementedError()

    @overload
    def groupColumns(self, firstIndex : int, lastIndex : int) -> None:
        '''Groups columns.
        :param firstIndex: The first column index to be grouped.
        :param lastIndex: The last column index to be grouped.'''
        raise NotImplementedError()

    @overload
    def groupColumns(self, firstIndex : int, lastIndex : int, isHidden : bool) -> None:
        '''Groups columns.
        :param firstIndex: The first column index to be grouped.
        :param lastIndex: The last column index to be grouped.
        :param isHidden: Specifies if the grouped columns are hidden.'''
        raise NotImplementedError()

    def getColumnOriginalWidthPoint(self, column : int) -> int:
        ''':deprecated: Use Cells.GetColumnWidth(int ,bool , CellsUnitType ) method, instead.'''
        raise NotImplementedError()

    @overload
    def deleteRows(self, rowIndex : int, totalRows : int) -> bool:
        '''Deletes multiple rows.
        :param rowIndex: The first row index to be deleted.
        :param totalRows: Count of rows to be deleted.'''
        raise NotImplementedError()

    @overload
    def deleteRows(self, rowIndex : int, totalRows : int, updateReference : bool) -> bool:
        '''Deletes multiple rows in the worksheet.
        :param rowIndex: Index of the first row to be deleted.
        :param totalRows: Count of rows to be deleted.
        :param updateReference: Indicates whether update references in other worksheets.'''
        raise NotImplementedError()

    @overload
    def deleteRows(self, rowIndex : int, totalRows : int, options : DeleteOptions) -> bool:
        '''Deletes multiple rows in the worksheet.
        :param rowIndex: Index of the first row to be deleted.
        :param totalRows: Count of rows to be deleted.
        :param options: Options for the deleting operation'''
        raise NotImplementedError()

    @overload
    def importObjectArray(self, objArray : list[Object], firstRow : int, firstColumn : int, isVertical : bool) -> None:
        '''Imports an array of data into a worksheet.
        :param objArray: Data array.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param isVertical: Specifies to import data vertically or horizontally.'''
        raise NotImplementedError()

    @overload
    def importObjectArray(self, objArray : list[Object], firstRow : int, firstColumn : int, isVertical : bool, skip : int) -> None:
        '''Imports an array of data into a worksheet.
        :param objArray: Data array.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param isVertical: Specifies to import data vertically or horizontally.
        :param skip: Skipped number of rows or columns.'''
        raise NotImplementedError()

    @overload
    def insertColumns(self, columnIndex : int, totalColumns : int) -> None:
        '''Inserts some columns into the worksheet.
        :param columnIndex: Column index.
        :param totalColumns: The number of columns.'''
        raise NotImplementedError()

    @overload
    def insertColumns(self, columnIndex : int, totalColumns : int, updateReference : bool) -> None:
        '''Inserts some columns into the worksheet.
        :param columnIndex: Column index.
        :param totalColumns: The number of columns.
        :param updateReference: Indicates if references in other worksheets will be updated.'''
        raise NotImplementedError()

    @overload
    def insertColumns(self, columnIndex : int, totalColumns : int, options : InsertOptions) -> None:
        '''Inserts some columns into the worksheet.
        :param columnIndex: Column index.
        :param totalColumns: The number of columns.
        :param options: The options for inserting operation.'''
        raise NotImplementedError()

    @overload
    def copyColumns(self, sourceCells0 : Cells, sourceColumnIndex : int, destinationColumnIndex : int, columnNumber : int, pasteOptions : PasteOptions) -> None:
        '''Copies data and formats of a whole column.
        :param sourceCells0: Source Cells object contains data and formats to copy.
        :param sourceColumnIndex: Source column index.
        :param destinationColumnIndex: Destination column index.
        :param columnNumber: The copied column number.
        :param pasteOptions: the options of pasting.'''
        raise NotImplementedError()

    @overload
    def copyColumns(self, sourceCells0 : Cells, sourceColumnIndex : int, destinationColumnIndex : int, columnNumber : int) -> None:
        '''Copies data and formats of a whole column.
        :param sourceCells0: Source Cells object contains data and formats to copy.
        :param sourceColumnIndex: Source column index.
        :param destinationColumnIndex: Destination column index.
        :param columnNumber: The copied column number.'''
        raise NotImplementedError()

    @overload
    def copyColumns(self, sourceCells : Cells, sourceColumnIndex : int, sourceTotalColumns : int, destinationColumnIndex : int, destinationTotalColumns : int) -> None:
        '''Copies data and formats of the whole columns.
        :param sourceCells: Source Cells object contains data and formats to copy.
        :param sourceColumnIndex: Source column index.
        :param sourceTotalColumns: The number of the source columns.
        :param destinationColumnIndex: Destination column index.
        :param destinationTotalColumns: The number of the destination columns.'''
        raise NotImplementedError()

    @overload
    def removeDuplicates(self) -> None:
        '''Removes duplicate rows in the sheet.'''
        raise NotImplementedError()

    @overload
    def removeDuplicates(self, startRow : int, startColumn : int, endRow : int, endColumn : int) -> None:
        '''Removes duplicate values in the range.
        :param startRow: The start row.
        :param startColumn: The start column
        :param endRow: The end row index.
        :param endColumn: The end column index.'''
        raise NotImplementedError()

    @overload
    def removeDuplicates(self, startRow : int, startColumn : int, endRow : int, endColumn : int, hasHeaders : bool, columnOffsets : list[int]) -> None:
        '''Removes duplicate data of the range.
        :param startRow: The start row.
        :param startColumn: The start column
        :param endRow: The end row index.
        :param endColumn: The end column index.
        :param hasHeaders: Indicates whether the range contains headers.
        :param columnOffsets: The column offsets.'''
        raise NotImplementedError()

    def getDependents(self, isAll : bool, row : int, column : int) -> list[Cell]:
        '''Get all cells which refer to the specific cell.
        :param isAll: Indicates whether check other worksheets
        :param row: The row index.
        :param column: The column index.'''
        raise NotImplementedError()

    def getMaxGroupedColumnOutlineLevel(self) -> int:
        '''Gets the max grouped column outline level (zero-based).'''
        raise NotImplementedError()

    def importFormulaArray(self, stringArray : list[str], firstRow : int, firstColumn : int, isVertical : bool) -> None:
        '''Imports an array of formula into a worksheet.
        :param stringArray: Formula array.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param isVertical: Specifies to import data vertically or horizontally.'''
        raise NotImplementedError()

    @overload
    def insertColumn(self, columnIndex : int, updateReference : bool) -> None:
        '''Inserts a new column into the worksheet.
        :param columnIndex: Column index.
        :param updateReference: Indicates if references in other worksheets will be updated.'''
        raise NotImplementedError()

    @overload
    def insertColumn(self, columnIndex : int) -> None:
        '''Inserts a new column into the worksheet.
        :param columnIndex: Column index.'''
        raise NotImplementedError()

    def importArrayList(self, arrayList : list, firstRow : int, firstColumn : int, isVertical : bool) -> None:
        '''Imports an arraylist of data into a worksheet.
        :param arrayList: Data arraylist.
        :param firstRow: The row number of the first cell to import in.
        :param firstColumn: The column number of the first cell to import in.
        :param isVertical: Specifies to import data vertically or horizontally.'''
        raise NotImplementedError()

    @overload
    def clearRange(self, range : CellArea) -> None:
        '''Clears contents and formatting of a range.
        :param range: Range to be cleared.'''
        raise NotImplementedError()

    @overload
    def clearRange(self, startRow : int, startColumn : int, endRow : int, endColumn : int) -> None:
        '''Clears contents and formatting of a range.
        :param startRow: Start row index.
        :param startColumn: Start column index.
        :param endRow: End row index.
        :param endColumn: End column index.'''
        raise NotImplementedError()

    def setStandardHeightPixels(self, value : int) -> None:
        '''Sets the default row height in this worksheet, in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def getMaxDataColumn(self) -> int:
        '''Maximum column index of cell which contains data.'''
        raise NotImplementedError()

    def setDefaultRowHidden(self, value : bool) -> None:
        '''Indicates whether the row is default hidden.
        :param value: '''
        raise NotImplementedError()

    def clear(self) -> None:
        '''Clears all data of the worksheet.'''
        raise NotImplementedError()

    def checkColumn(self, columnIndex : int) -> Column:
        '''Gets the :class:`Column` element or null at the specified column index.
        :param columnIndex: The column index.
        :returns: The Column object.'''
        raise NotImplementedError()

    def unhideColumns(self, column : int, totalColumns : int, width : int) -> None:
        '''Unhide multiple columns.
        :param column: Column index.
        :param totalColumns: Column number
        :param width: Column width.'''
        raise NotImplementedError()

    def getCellStyle(self, row : int, column : int) -> Style:
        '''Get the style of given cell.
        :param row: row index
        :param column: column
        :returns: the style of given cell.'''
        raise NotImplementedError()

    @overload
    def getColumnWidthPixel(self, column : int) -> int:
        '''Gets the width of the specified column in normal view, in units of pixel.
        :param column: Column index
        :returns: Width of column in normal view.'''
        raise NotImplementedError()

    @overload
    def getColumnWidthPixel(self, column : int, original : bool) -> int:
        ''':deprecated: Use Cells.GetColumnWidth(int ,bool , CellsUnitType ) method, instead.'''
        raise NotImplementedError()

    def copyRow(self, sourceCells : Cells, sourceRowIndex : int, destinationRowIndex : int) -> None:
        '''Copies data and formats of a whole row.
        :param sourceCells: Source Cells object contains data and formats to copy.
        :param sourceRowIndex: Source row index.
        :param destinationRowIndex: Destination row index.'''
        raise NotImplementedError()

    def getFirstCell(self) -> Cell:
        '''Gets the first cell in this worksheet.'''
        raise NotImplementedError()

    def addRange(self, rangeObject : Range) -> None:
        '''Adds a range object reference to cells
        :param rangeObject: The range object will be contained in the cells'''
        raise NotImplementedError()


class CellsColor:
    '''Represents all types of color.'''

    def setTransparency(self, value : int) -> None:
        '''Sets transparency as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def getColorIndex(self) -> int:
        '''Gets the color index in the color palette. Only applies of indexed color.'''
        raise NotImplementedError()

    def getThemeColor(self) -> ThemeColor:
        '''Gets the theme color. Only applies for theme color type.'''
        raise NotImplementedError()

    def getArgb(self) -> int:
        '''Gets the color from a 32-bit ARGB value.'''
        raise NotImplementedError()

    def isShapeColor(self) -> bool:
        '''Gets the color which should apply to cell or shape.'''
        raise NotImplementedError()

    def setTintOfShapeColor(self, tint : int) -> None:
        '''Set the tint of the shape color
        :param tint: '''
        raise NotImplementedError()

    def setShapeColor(self, value : bool) -> None:
        '''Sets the color which should apply to cell or shape.
        :param value: '''
        raise NotImplementedError()

    def setColorIndex(self, value : int) -> None:
        '''Sets the color index in the color palette. Only applies of indexed color.
        :param value: '''
        raise NotImplementedError()

    def setThemeColor(self, value : ThemeColor) -> None:
        '''Gets the theme color. Only applies for theme color type.
        :param value: '''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Gets transparency as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''The color type.
        See :class:`ColorType`'''
        raise NotImplementedError()

    def setColor(self, value : Color) -> None:
        '''Sets the RGB color.
        :param value: '''
        raise NotImplementedError()

    def setArgb(self, value : int) -> None:
        '''Sets the color from a 32-bit ARGB value.
        :param value: '''
        raise NotImplementedError()

    def getColor(self) -> Color:
        '''Gets the RGB color.'''
        raise NotImplementedError()


class CellsDataTableFactory:
    '''Utility to build ICellsDataTable from custom objects for user's convenience.'''

    @overload
    def getInstance(self, vals : list[int], columnNames : list[str]) -> ICellsDataTable:
        '''Creates ICellsDataTable from given sequence of int values.
        :param vals: int values to build table
        :param columnNames: Column names of the table.
        :returns: Instance of ICellsDataTable'''
        raise NotImplementedError()

    @overload
    def getInstance(self, vals : list[int], vertial : bool) -> ICellsDataTable:
        '''Creates ICellsDataTable from given sequence of int values.
        :param vals: int values to build table
        :param vertial: whether build table by the int values vertiacally(true) or horizontally(false)
        :returns: Instance of ICellsDataTable'''
        raise NotImplementedError()

    @overload
    def getInstance(self, vals : list[int], columnNames : list[str]) -> ICellsDataTable:
        '''Creates ICellsDataTable from given sequence of double values.
        :param vals: double values to build table
        :param columnNames: Column names of the table.
        :returns: Instance of ICellsDataTable'''
        raise NotImplementedError()

    @overload
    def getInstance(self, vals : list[int], vertial : bool) -> ICellsDataTable:
        '''Creates ICellsDataTable from given sequence of double values.
        :param vals: double values to build table
        :param vertial: whether build table by the double values vertiacally(true) or horizontally(false)
        :returns: Instance of ICellsDataTable'''
        raise NotImplementedError()

    @overload
    def getInstance(self, vals : list[Object], columnNames : list[str]) -> ICellsDataTable:
        '''Creates ICellsDataTable from given sequence of objects.
        :param vals: objects to build table
        :param columnNames: Column names of the table.
        :returns: Instance of ICellsDataTable'''
        raise NotImplementedError()

    @overload
    def getInstance(self, vals : list[Object], vertial : bool) -> ICellsDataTable:
        '''Creates ICellsDataTable from given sequence of objects.
        :param vals: objects to build table
        :param vertial: whether build table by the objects vertiacally(true) or horizontally(false)
        :returns: Instance of ICellsDataTable'''
        raise NotImplementedError()

    @overload
    def getInstance(self, vals : list[list[int]]) -> ICellsDataTable:
        '''Creates ICellsDataTable from given 2D array.
        :param vals: int values to build table
        :returns: Instance of ICellsDataTable'''
        raise NotImplementedError()

    @overload
    def getInstance(self, vals : list[list[int]]) -> ICellsDataTable:
        '''Creates ICellsDataTable from given 2D array.
        :param vals: double values to build table
        :returns: Instance of ICellsDataTable'''
        raise NotImplementedError()

    @overload
    def getInstance(self, vals : list[list[Object]]) -> ICellsDataTable:
        '''Creates ICellsDataTable from given 2D array.
        :param vals: objects to build table
        :returns: Instance of ICellsDataTable'''
        raise NotImplementedError()

    @overload
    def getInstance(self, collection : Collection) -> ICellsDataTable:
        '''Creates ICellsDataTable from given collection.
        :param collection: the collection to build table
        :returns: Instance of ICellsDataTable'''
        raise NotImplementedError()


class CellsDrawing:
    '''Represents the auto shape and drawing object.'''


class CellsException:
    '''The exception that is thrown when Aspose.Cells specified error occurs.'''

    def getCode(self) -> int:
        '''Represents custom exception code.
        See :class:`ExceptionType`'''
        raise NotImplementedError()


class CellsFactory:
    '''Utility for instantiating classes of Cells model.'''

    def createStyle(self) -> Style:
        '''Creates a new style.'''
        raise NotImplementedError()


class CellsHelper:
    '''Provides helper functions.'''

    def setDPI(self, value : int) -> None:
        '''Gets the DPI of the machine.
        :param value: '''
        raise NotImplementedError()

    def convertA1FormulaToR1C1(self, formula : str, row : int, column : int) -> str:
        ''':deprecated: Use Worksheet.ConvertFormulaReferenceStyle() method instead.'''
        raise NotImplementedError()

    def getStartupPath(self) -> str:
        '''Gets the startup path, which is referred to by some external formula references.'''
        raise NotImplementedError()

    def setAltStartPath(self, value : str) -> None:
        '''Sets the alternate startup path, which is referred to by some external formula references.
        :param value: '''
        raise NotImplementedError()

    def getLibraryPath(self) -> str:
        '''Gets the library path which is referred to by some external formula references.'''
        raise NotImplementedError()

    def setSignificantDigits(self, value : int) -> None:
        '''Sets the number of significant digits.
        The default value is 17.
        :param value: '''
        raise NotImplementedError()

    def columnIndexToName(self, column : int) -> str:
        '''Gets column name according to column index.
        :param column: Column index.
        :returns: Name of column.'''
        raise NotImplementedError()

    def columnNameToIndex(self, columnName : str) -> int:
        '''Gets column index according to column name.
        :param columnName: Column name.
        :returns: Column index.'''
        raise NotImplementedError()

    def getUsedColors(self, workbook : Workbook) -> list[Color]:
        '''Gets all used colors in the workbook.
        :param workbook: The workbook object.
        :returns: The used colors.'''
        raise NotImplementedError()

    def rowIndexToName(self, row : int) -> str:
        '''Gets row name according to row index.
        :param row: Row index.
        :returns: Name of row.'''
        raise NotImplementedError()

    @overload
    def createSafeSheetName(self, nameProposal : str) -> str:
        '''Checks given sheet name and create a valid one when needed.
        If given sheet name conforms to the rules of excel sheet name, then return it.
        Otherwise string will be truncated if length exceeds the limit
        and invalid characters will be replaced with ' ', then return the rebuilt string value.
        :param nameProposal: sheet name to be used'''
        raise NotImplementedError()

    @overload
    def createSafeSheetName(self, nameProposal : str, replaceChar : str) -> str:
        '''Checks given sheet name and create a valid one when needed.
        If given sheet name conforms to the rules of excel sheet name, then return it.
        Otherwise string will be truncated if length exceeds the limit
        and invalid characters will be replaced with given character, then return the rebuilt string value.
        :param nameProposal: sheet name to be used
        :param replaceChar: character which will be used to replace invalid characters in given sheet name'''
        raise NotImplementedError()

    def getAltStartPath(self) -> str:
        '''Gets the alternate startup path, which is referred to by some external formula references.'''
        raise NotImplementedError()

    def rowNameToIndex(self, rowName : str) -> int:
        '''Gets row index according to row name.
        :param rowName: Row name.
        :returns: Row index.'''
        raise NotImplementedError()

    def getTextWidth(self, text : str, font : Font, scaling : int) -> int:
        '''Get width of text in unit of points.
        :param text: The text.
        :param font: The font of the text.
        :param scaling: The scaling of text.'''
        raise NotImplementedError()

    def getVersion(self) -> str:
        '''Get the release version.'''
        raise NotImplementedError()

    def isCloudPlatform(self) -> bool:
        '''Please set this property True when running on a cloud platform, such as: Azure, AWSLambda, etc,'''
        raise NotImplementedError()

    def getDPI(self) -> int:
        '''Gets the DPI of the machine.'''
        raise NotImplementedError()

    def getDoubleFromDateTime(self, dateTime : DateTime, date1904 : bool) -> int:
        '''Convert the date time to double value.
        :param dateTime: The date time.
        :param date1904: Date 1904 system.'''
        raise NotImplementedError()

    def getDateTimeFromDouble(self, doubleValue : int, date1904 : bool) -> DateTime:
        '''Convert the double value to the date time value.
        :param doubleValue: The double value.
        :param date1904: Date 1904 system.'''
        raise NotImplementedError()

    def setStartupPath(self, value : str) -> None:
        '''Sets the startup path, which is referred to by some external formula references.
        :param value: '''
        raise NotImplementedError()

    def setLibraryPath(self, value : str) -> None:
        '''Sets the library path which is referred to by some external formula references.
        :param value: '''
        raise NotImplementedError()

    def addAddInFunction(self, function : str, minCountOfParameters : int, maxCountOfParameters : int, paramersType : list[int], functionValueType : int) -> None:
        ''':deprecated: Use WorksheetCollection.RegisterAddInFunction() methods instead.'''
        raise NotImplementedError()

    def getCustomImplementationFactory(self) -> CustomImplementationFactory:
        '''Gets the factory for creating instances with special implementation.'''
        raise NotImplementedError()

    def cellIndexToName(self, row : int, column : int) -> str:
        '''Gets cell name according to its row and column indexes.
        :param row: Row index.
        :param column: Column index.
        :returns: Name of cell.'''
        raise NotImplementedError()

    def cellNameToIndex(self, cellName : str) -> list[int]:
        '''Gets the cell row and column indexes according to its name.
        :param cellName: Name of cell
        :returns: [0] is the row index and [1] is the column index.'''
        raise NotImplementedError()

    def mergeFiles(self, files : list[str], cachedFile : str, destFile : str) -> None:
        '''Merges some large xls files to a xls file.
        :param files: The files.
        :param cachedFile: The cached file.
        :param destFile: The dest file.'''
        raise NotImplementedError()

    def setCustomImplementationFactory(self, value : CustomImplementationFactory) -> None:
        '''Sets the factory for creating instances with special implementation.
        :param value: '''
        raise NotImplementedError()

    def getSignificantDigits(self) -> int:
        '''Gets the number of significant digits.
        The default value is 17.'''
        raise NotImplementedError()

    def needQuoteInFormula(self, sheetName : str) -> bool:
        '''Indicates whether the name of the sheet should be enclosed in single quotes
        :param sheetName: The name of the sheet'''
        raise NotImplementedError()

    def setCloudPlatform(self, value : bool) -> None:
        '''Please set this property True when running on a cloud platform, such as: Azure, AWSLambda, etc,
        :param value: '''
        raise NotImplementedError()

    def convertR1C1FormulaToA1(self, r1c1Formula : str, row : int, column : int) -> str:
        ''':deprecated: Use Worksheet.ConvertFormulaReferenceStyle() method instead.'''
        raise NotImplementedError()


class CellsUnitType:
    '''Specifies the unit of measurement.'''

    PIXEL : CellsUnitType
    '''Measurement is in pixels.'''

    POINT : CellsUnitType
    '''Measurement is in points. A point represents 1/72 of an inch.'''

    INCH : CellsUnitType
    '''Measurement is in inches.'''

    CM : CellsUnitType
    '''Measurement is in centimeters.'''

    CHARACTER : CellsUnitType
    '''In unit of characters.'''


class CellValue:
    '''Represents the cell value and corresponding type.'''

    def getValue(self) -> Object:
        '''Gets the cell value.'''
        raise NotImplementedError()

    def setValue(self, value : Object) -> None:
        '''Sets the cell value.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of cell value.
        See :class:`CellValueType`'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets the type of cell value.
        See :class:`CellValueType`
        :param value: '''
        raise NotImplementedError()


class CellValueFormatStrategy:
    '''Specifies how to apply style for the value of the cell.'''

    NONE : CellValueFormatStrategy
    '''Not formatted.'''

    CELL_STYLE : CellValueFormatStrategy
    '''Only formatted with the cell's original style.'''

    DISPLAY_STYLE : CellValueFormatStrategy
    '''Formatted with the cell's displayed style.'''

    DISPLAY_STRING : CellValueFormatStrategy
    '''Gets the displayed string shown in ms excel.
    The main difference from :attr:`CellValueFormatStrategy.DISPLAY_STYLE` is this option also considers the effect of column width.
    If the column width is too small to show the formatted string completely,
    "#" may be shown, just like what ms excel does.'''


class CellValueType:
    '''Specifies a cell value type.'''

    IS_UNKNOWN : CellValueType
    '''Cell value type is unknown.'''

    IS_NULL : CellValueType
    '''Blank cell. Corresponding value should be null.'''

    IS_NUMERIC : CellValueType
    '''Cell value is numeric. Corresponding value must be int or double.'''

    IS_DATE_TIME : CellValueType
    '''Cell value is datetime. Corresponding value must be DateTime.'''

    IS_STRING : CellValueType
    '''Cell value is string. Corresponding value must be string.'''

    IS_BOOL : CellValueType
    '''Cell value is boolean. Corresponding value must be bool.'''

    IS_ERROR : CellValueType
    '''Cell contains error value. Corresponding value must be error string.'''


class CellWatch:
    '''Represents Cell Watch Item in the 'watch window'.'''

    def setCellName(self, value : str) -> None:
        '''Sets the name of the cell.
        :param value: '''
        raise NotImplementedError()

    def getColumn(self) -> int:
        '''Gets the column of the cell.'''
        raise NotImplementedError()

    def getCellName(self) -> str:
        '''Gets the name of the cell.'''
        raise NotImplementedError()

    def setColumn(self, value : int) -> None:
        '''Sets the column of the cell.
        :param value: '''
        raise NotImplementedError()

    def setRow(self, value : int) -> None:
        '''Sets the row of the cell.
        :param value: '''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets the row of the cell.'''
        raise NotImplementedError()


class CellWatchCollection:
    '''Represents the collection of cells on this worksheet being watched in the 'watch window'.'''

    @overload
    def get(self, index : int) -> CellWatch:
        '''Gets and sets :class:`CellWatch` by index.
        :param index: The index.'''
        raise NotImplementedError()

    @overload
    def get(self, cellName : str) -> CellWatch:
        '''Gets and sets :class:`CellWatch` by the name of the cell.
        :param cellName: The name of the cell.'''
        raise NotImplementedError()

    @overload
    def add(self, row : int, column : int) -> int:
        '''Adds :class:`CellWatch` with row and column.
        :param row: The row index.
        :param column: The column index.
        :returns: Returns the position of this item in the collection.'''
        raise NotImplementedError()

    @overload
    def add(self, cellName : str) -> int:
        '''Adds :class:`CellWatch` with the name the of cell.
        :param cellName: The name of the cell.'''
        raise NotImplementedError()


class CharacterBulletValue:
    '''Represents the character bullet.'''

    def getCharacter(self) -> str:
        '''Gets character of the bullet.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the bullet.
        See :class:`BulletType`'''
        raise NotImplementedError()

    def setCharacter(self, value : str) -> None:
        '''Sets character of the bullet.
        :param value: '''
        raise NotImplementedError()


class Chart:
    '''Encapsulates the object that represents a single Excel chart.
    The following codes show how to create a chart with .Net codes.'''

    def setRectangularCornered(self, value : bool) -> None:
        '''Sets a value indicating whether the chart area is rectangular cornered.
        Default is true.
        :param value: '''
        raise NotImplementedError()

    def setFirstSliceAngle(self, value : int) -> None:
        '''Sets the angle of the first pie-chart or doughnut-chart slice, in degrees (clockwise from vertical).
        Applies only to pie, 3-D pie, and doughnut charts, 0 to 360.
        :param value: '''
        raise NotImplementedError()

    def getChartDataRange(self) -> str:
        '''Gets the data source range of the chart.'''
        raise NotImplementedError()

    def setHidePivotFieldButtons(self, value : bool) -> None:
        '''Indicates whether hide the pivot chart field buttons only when the chart is PivotChart.
        :param value: '''
        raise NotImplementedError()

    def getShapes(self) -> ShapeCollection:
        '''Returns all drawing shapes in this chart.'''
        raise NotImplementedError()

    def setDepthPercent(self, value : int) -> None:
        '''Represents the depth of a 3-D chart as a percentage of the chart width (between 20 and 2000 percent).
        :param value: '''
        raise NotImplementedError()

    def getChartShape(self) -> ChartShape:
        ''':deprecated: Use Aspose.Cells.Charts.Chart.ChartObject property instead.'''
        raise NotImplementedError()

    def getSideWall(self) -> Walls:
        '''Returns a :meth:`Chart.getWalls()` object that represents the side wall of a 3-D chart.'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets a chart's type.
        See :class:`ChartType`
        :param value: '''
        raise NotImplementedError()

    def getFilteredNSeries(self) -> SeriesCollection:
        '''Gets a :class:`SeriesCollection` collection representing the data series that are filtered in the chart.'''
        raise NotImplementedError()

    def getPlacement(self) -> int:
        '''Represents the way the chart is attached to the cells below it.
        See :class:`PlacementType`'''
        raise NotImplementedError()

    def getPlotArea(self) -> PlotArea:
        '''Gets the chart's plot area which includes axis tick labels.'''
        raise NotImplementedError()

    def setChartDataRange(self, area : str, isVertical : bool) -> None:
        '''Specifies data range for a chart.
        :param area: Specifies values from which to plot the data series
        :param isVertical: Specifies whether to plot the series from a range of cell values by row or by column.'''
        raise NotImplementedError()

    def setDisplayNaAsBlank(self, value : bool) -> None:
        '''Indicates whether displaying #N/A as blank value.
        :param value: '''
        raise NotImplementedError()

    def setWallsAndGridlines2D(self, value : bool) -> None:
        '''True if gridlines are drawn two-dimensionally on a 3-D chart.
        :param value: '''
        raise NotImplementedError()

    def hasAxis(self, aixsType : int, isPrimary : bool) -> bool:
        '''Returns which axes exist on the chart.
        :param aixsType: 
        :param isPrimary: '''
        raise NotImplementedError()

    def isReferedByChart(self, rowIndex : int, columnIndex : int) -> bool:
        ''':deprecated: Use Chart.IsCellReferedByChart(int,int,int) method instead.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the chart.
        :param value: '''
        raise NotImplementedError()

    @overload
    def calculate(self) -> None:
        '''Calculates the custom position of plot area, axes if the position of them are auto assigned.'''
        raise NotImplementedError()

    @overload
    def calculate(self, calculateOptions : ChartCalculateOptions) -> None:
        '''Calculates the custom position of plot area, axes if the position of them are auto assigned, with Chart Calculate Options.
        :param calculateOptions: '''
        raise NotImplementedError()

    def getPivotOptions(self) -> PivotOptions:
        '''Specifies the pivot controls that appear on the chart'''
        raise NotImplementedError()

    def getDisplayNaAsBlank(self) -> bool:
        '''Indicates whether displaying #N/A as blank value.'''
        raise NotImplementedError()

    def getIs3D(self) -> bool:
        '''Indicates whether the chart is a 3d chart.'''
        raise NotImplementedError()

    def isRectangularCornered(self) -> bool:
        '''Gets a value indicating whether the chart area is rectangular cornered.
        Default is true.'''
        raise NotImplementedError()

    def getChartDataTable(self) -> ChartDataTable:
        '''Represents the chart data table.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets a chart's type.
        See :class:`ChartType`'''
        raise NotImplementedError()

    def setGapWidth(self, value : int) -> None:
        '''Returns or sets the space between bar or column clusters, as a percentage of the bar or column width.
        The value of this property must be between 0 and 500.
        :param value: '''
        raise NotImplementedError()

    def getFirstSliceAngle(self) -> int:
        '''Gets the angle of the first pie-chart or doughnut-chart slice, in degrees (clockwise from vertical).
        Applies only to pie, 3-D pie, and doughnut charts, 0 to 360.'''
        raise NotImplementedError()

    def getCategoryAxis(self) -> Axis:
        '''Gets the chart's X axis.'''
        raise NotImplementedError()

    def setStyle(self, value : int) -> None:
        '''Sets the builtin style.
        :param value: '''
        raise NotImplementedError()

    def setPlotVisibleCellsOnly(self, value : bool) -> None:
        '''Indicates whether plot visible cells only.
        :param value: '''
        raise NotImplementedError()

    def isChartDataChanged(self) -> bool:
        '''Detects if a chart's data source has changed.'''
        raise NotImplementedError()

    def setAutoScaling(self, value : bool) -> None:
        '''True if Microsoft Excel scales a 3-D chart so that it's closer in size to the equivalent 2-D chart.
        The RightAngleAxes property must be True.
        :param value: '''
        raise NotImplementedError()

    def switchRowColumn(self) -> bool:
        '''Switches row/column.'''
        raise NotImplementedError()

    def getSecondCategoryAxis(self) -> Axis:
        '''Gets the chart's second X axis.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the chart.'''
        raise NotImplementedError()

    def setGapDepth(self, value : int) -> None:
        '''Sets the distance between the data series in a 3-D chart, as a percentage of the marker width.
        The value of this property must be between 0 and 500.
        :param value: '''
        raise NotImplementedError()

    def changeTemplate(self, data : list[int]) -> None:
        '''Change chart type with preset template.
        :param data: The data of chart template file(.crtx).'''
        raise NotImplementedError()

    def getPlotVisibleCellsOnly(self) -> bool:
        '''Indicates whether plot visible cells only.'''
        raise NotImplementedError()

    def getTitle(self) -> Title:
        '''Gets the chart's title.'''
        raise NotImplementedError()

    @overload
    def toImage(self, imageFile : str) -> None:
        '''Creates the chart image and saves it to a file.
        The extension of the file name determines the format of the image.
        :param imageFile: The image file name with full path.'''
        raise NotImplementedError()

    @overload
    def toImage(self, imageFile : str, imageFormat : ImageFormat) -> None:
        ''':deprecated: Use Chart.ToImage(string, ImageType) method instead.'''
        raise NotImplementedError()

    @overload
    def toImage(self, imageFile : str, imageType : int) -> None:
        '''Creates the chart image and saves it to a file in the specified image type.
        :param imageFile: The image file name with full path.
        :param imageType: :meth:`ImageOrPrintOptions.getImageType()`. The image type in which to save the image.'''
        raise NotImplementedError()

    @overload
    def toImage(self, imageFile : str, jpegQuality : int) -> None:
        '''Creates the chart image and saves it to a file in the Jpeg format.
        :param imageFile: The image file name with full path.
        :param jpegQuality: Jpeg quality.'''
        raise NotImplementedError()

    @overload
    def toImage(self, imageFile : str, options : ImageOrPrintOptions) -> None:
        '''Creates the chart image and saves it to a file.
        The extension of the file name determines the format of the image.
        :param imageFile: The image file name with full path.
        :param options: Additional image creation options'''
        raise NotImplementedError()

    @overload
    def toImage(self, stream : OutputStream, options : ImageOrPrintOptions) -> None:
        '''Creates the chart image and saves it to a stream in the specified format.
        :param stream: The output stream.
        :param options: Additional image creation options'''
        raise NotImplementedError()

    def getBackWall(self) -> Walls:
        '''Returns a :meth:`Chart.getWalls()` object that represents the back wall of a 3-D chart.'''
        raise NotImplementedError()

    def getChartObject(self) -> ChartShape:
        '''Represents the chartShape;'''
        raise NotImplementedError()

    def setPerspective(self, value : int) -> None:
        '''Returns or sets the perspective for the 3-D chart view. Must be between 0 and 100.
        This property is ignored if the RightAngleAxes property is True.
        :param value: '''
        raise NotImplementedError()

    def getPlotEmptyCellsType(self) -> int:
        '''Gets how to plot the empty cells.
        See :class:`PlotEmptyCellsType`'''
        raise NotImplementedError()

    def getRightAngleAxes(self) -> bool:
        '''True if the chart axes are at right angles. Applies only for 3-D charts(except Column3D and 3-D Pie Charts).'''
        raise NotImplementedError()

    def getAutoScaling(self) -> bool:
        '''True if Microsoft Excel scales a 3-D chart so that it's closer in size to the equivalent 2-D chart.
        The RightAngleAxes property must be True.'''
        raise NotImplementedError()

    def getGapWidth(self) -> int:
        '''Returns or sets the space between bar or column clusters, as a percentage of the bar or column width.
        The value of this property must be between 0 and 500.'''
        raise NotImplementedError()

    def getRotationAngle(self) -> int:
        '''Represents the rotation of the 3-D chart view (the rotation of the plot area around the z-axis, in degrees).'''
        raise NotImplementedError()

    def setRotationAngle(self, value : int) -> None:
        '''Represents the rotation of the 3-D chart view (the rotation of the plot area around the z-axis, in degrees).
        :param value: '''
        raise NotImplementedError()

    def getHeightPercent(self) -> int:
        '''Returns or sets the height of a 3-D chart as a percentage of the chart width (between 5 and 500 percent).'''
        raise NotImplementedError()

    def setPrintSize(self, value : int) -> None:
        '''Sets the printed chart size.
        See :class:`PrintSizeType`
        :param value: '''
        raise NotImplementedError()

    def getWallsAndGridlines2D(self) -> bool:
        '''True if gridlines are drawn two-dimensionally on a 3-D chart.'''
        raise NotImplementedError()

    def setRightAngleAxes(self, value : bool) -> None:
        '''True if the chart axes are at right angles. Applies only for 3-D charts(except Column3D and 3-D Pie Charts).
        :param value: '''
        raise NotImplementedError()

    def setPlotVisibleCells(self, value : bool) -> None:
        ''':deprecated: Use PlotVisibleCellsOnly property instead.'''
        raise NotImplementedError()

    def getPerspective(self) -> int:
        '''Returns or sets the perspective for the 3-D chart view. Must be between 0 and 100.
        This property is ignored if the RightAngleAxes property is True.'''
        raise NotImplementedError()

    def setHeightPercent(self, value : int) -> None:
        '''Returns or sets the height of a 3-D chart as a percentage of the chart width (between 5 and 500 percent).
        :param value: '''
        raise NotImplementedError()

    def refreshPivotData(self) -> None:
        '''Refreshes chart's data from pivot table.'''
        raise NotImplementedError()

    def setPivotSource(self, value : str) -> None:
        '''The source is the data of the pivotTable.
        If PivotSource is not empty ,the chart is PivotChart.
        :param value: '''
        raise NotImplementedError()

    def getNSeries(self) -> SeriesCollection:
        '''Gets a :class:`SeriesCollection` collection representing the data series in the chart.'''
        raise NotImplementedError()

    def getPrintSize(self) -> int:
        '''Gets the printed chart size.
        See :class:`PrintSizeType`'''
        raise NotImplementedError()

    def getGapDepth(self) -> int:
        '''Gets the distance between the data series in a 3-D chart, as a percentage of the marker width.
        The value of this property must be between 0 and 500.'''
        raise NotImplementedError()

    def getSeriesAxis(self) -> Axis:
        '''Gets the chart's series axis.'''
        raise NotImplementedError()

    def getPlotVisibleCells(self) -> bool:
        ''':deprecated: Use PlotVisibleCellsOnly property instead.'''
        raise NotImplementedError()

    def getChartArea(self) -> ChartArea:
        '''Gets the chart area in the worksheet.'''
        raise NotImplementedError()

    def getWorksheet(self) -> Worksheet:
        '''Gets the worksheet which contains this chart.'''
        raise NotImplementedError()

    def getLegend(self) -> Legend:
        '''Gets the chart legend.'''
        raise NotImplementedError()

    def getValueAxis(self) -> Axis:
        '''Gets the chart's Y axis.'''
        raise NotImplementedError()

    def move(self, upperLeftRow : int, upperLeftColumn : int, lowerRightRow : int, lowerRightColumn : int) -> None:
        '''Moves the chart to a specified location.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param lowerRightRow: Lower right row index
        :param lowerRightColumn: Lower right column index'''
        raise NotImplementedError()

    def getPivotSource(self) -> str:
        '''The source is the data of the pivotTable.
        If PivotSource is not empty ,the chart is PivotChart.'''
        raise NotImplementedError()

    def getShowLegend(self) -> bool:
        '''Gets a value indicating whether the chart legend will be displayed. Default is true.'''
        raise NotImplementedError()

    def setShowLegend(self, value : bool) -> None:
        '''Sets a value indicating whether the chart legend will be displayed. Default is true.
        :param value: '''
        raise NotImplementedError()

    def getStyle(self) -> int:
        '''Gets the builtin style.'''
        raise NotImplementedError()

    def getHidePivotFieldButtons(self) -> bool:
        '''Indicates whether hide the pivot chart field buttons only when the chart is PivotChart.'''
        raise NotImplementedError()

    def getFloor(self) -> Floor:
        '''Returns a :meth:`Chart.getFloor()` object that represents the walls of a 3-D chart.'''
        raise NotImplementedError()

    def setElevation(self, value : int) -> None:
        '''Represents the elevation of the 3-D chart view, in degrees.
        :param value: '''
        raise NotImplementedError()

    def getPlotBy(self) -> int:
        '''Gets whether plot by row or column.
        See :class:`PlotDataByType`'''
        raise NotImplementedError()

    @overload
    def toPdf(self, fileName : str) -> None:
        '''Saves the chart to a pdf file.
        :param fileName: the pdf file name with full path'''
        raise NotImplementedError()

    @overload
    def toPdf(self, fileName : str, desiredPageWidth : float, desiredPageHeight : float, hAlignmentType : int, vAlignmentType : int) -> None:
        '''Saves the chart to a pdf file.
        :param fileName: the pdf file name with full path
        :param desiredPageWidth: The desired page width in inches.
        :param desiredPageHeight: The desired page height in inches.
        :param hAlignmentType: :class:`PageLayoutAlignmentType`. The chart horizontal alignment type in the output page.
        :param vAlignmentType: :class:`PageLayoutAlignmentType`. The chart vertical alignment type in the output page.'''
        raise NotImplementedError()

    @overload
    def toPdf(self, stream : OutputStream) -> None:
        '''Creates the chart pdf and saves it to a stream.
        :param stream: The output stream.'''
        raise NotImplementedError()

    @overload
    def toPdf(self, stream : OutputStream, desiredPageWidth : float, desiredPageHeight : float, hAlignmentType : int, vAlignmentType : int) -> None:
        '''Creates the chart pdf and saves it to a stream.
        :param stream: The output stream.
        :param desiredPageWidth: The desired page width in inches.
        :param desiredPageHeight: The desired page height in inches.
        :param hAlignmentType: :class:`PageLayoutAlignmentType`. The chart horizontal alignment type in the output page.
        :param vAlignmentType: :class:`PageLayoutAlignmentType`. The chart vertical alignment type in the output page.'''
        raise NotImplementedError()

    def getSecondValueAxis(self) -> Axis:
        '''Gets the chart's second Y axis.'''
        raise NotImplementedError()

    def getPageSetup(self) -> PageSetup:
        '''Represents the page setup description in this chart.'''
        raise NotImplementedError()

    def getActualChartSize(self) -> list[int]:
        ''':deprecated: Use Chart.getActualSize() method instead.'''
        raise NotImplementedError()

    def getSizeWithWindow(self) -> bool:
        '''True if Microsoft Excel resizes the chart to match the size of the chart sheet window.'''
        raise NotImplementedError()

    def getWalls(self) -> Walls:
        '''Returns a :meth:`Chart.getWalls()` object that represents the walls of a 3-D chart.'''
        raise NotImplementedError()

    def isCellReferedByChart(self, sheetIndex : int, rowIndex : int, columnIndex : int) -> bool:
        '''Returns whether the cell refered by the chart.
        :param sheetIndex: 
        :param rowIndex: The row index
        :param columnIndex: The column index'''
        raise NotImplementedError()

    def getSubTitle(self) -> Title:
        '''Gets the chart's sub-title.
        Only for ODS format file.'''
        raise NotImplementedError()

    def getLine(self) -> Line:
        '''Gets the line.'''
        raise NotImplementedError()

    def getElevation(self) -> int:
        '''Represents the elevation of the 3-D chart view, in degrees.'''
        raise NotImplementedError()

    def getDepthPercent(self) -> int:
        '''Represents the depth of a 3-D chart as a percentage of the chart width (between 20 and 2000 percent).'''
        raise NotImplementedError()

    def getActualSize(self) -> list[int]:
        '''Gets actual size of chart in unit of pixels.'''
        raise NotImplementedError()

    def setPlacement(self, value : int) -> None:
        '''Represents the way the chart is attached to the cells below it.
        See :class:`PlacementType`
        :param value: '''
        raise NotImplementedError()

    def getShowDataTable(self) -> bool:
        '''Gets a value indicating whether the chart displays a data table.'''
        raise NotImplementedError()

    def setPlotEmptyCellsType(self, value : int) -> None:
        '''Sets how to plot the empty cells.
        See :class:`PlotEmptyCellsType`
        :param value: '''
        raise NotImplementedError()

    def setSizeWithWindow(self, value : bool) -> None:
        '''True if Microsoft Excel resizes the chart to match the size of the chart sheet window.
        :param value: '''
        raise NotImplementedError()

    def setShowDataTable(self, value : bool) -> None:
        '''Sets a value indicating whether the chart displays a data table.
        :param value: '''
        raise NotImplementedError()


class ChartArea:
    '''Encapsulates the object that represents the chart area in the worksheet.'''

    def getFont(self) -> Font:
        '''Gets a :meth:`ChartArea.getFont()` object of the specified chartarea object.'''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Gets the vertical offset from its lower right corner row.'''
        raise NotImplementedError()

    def setWidth(self, value : int) -> None:
        '''Sets the horizontal offset from its lower right corner column.
        :param value: '''
        raise NotImplementedError()

    def setHeight(self, value : int) -> None:
        '''Sets the vertical offset from its lower right corner row.
        :param value: '''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Gets the horizontal offset from its lower right corner column.'''
        raise NotImplementedError()

    def setY(self, value : int) -> None:
        '''Gets or gets the vertical offset from its upper left corner row.
        :param value: '''
        raise NotImplementedError()

    def setX(self, value : int) -> None:
        '''Gets or gets the horizontal offset from its upper left corner column.
        :param value: '''
        raise NotImplementedError()

    def getY(self) -> int:
        '''Gets or gets the vertical offset from its upper left corner row.'''
        raise NotImplementedError()

    def getX(self) -> int:
        '''Gets or gets the horizontal offset from its upper left corner column.'''
        raise NotImplementedError()


class ChartCalculateOptions:
    '''Represents the options for calculating chart.'''

    def getUpdateAllPoints(self) -> bool:
        '''Whether update all data points when performing the chart calculation. Default: False.
        When you want to get the value for each data point in the chart specifically, set it to true.
        If this parameter is set to True, the new data points may be generated when chart is calculated. This could make the Excel file larger.'''
        raise NotImplementedError()

    def setUpdateAllPoints(self, value : bool) -> None:
        '''Whether update all data points when performing the chart calculation. Default: False.
        When you want to get the value for each data point in the chart specifically, set it to true.
        If this parameter is set to True, the new data points may be generated when chart is calculated. This could make the Excel file larger.
        :param value: '''
        raise NotImplementedError()


class ChartCollection:
    '''Encapsulates a collection of :class:`Chart` objects.'''

    def clear(self) -> None:
        '''Clear all charts.'''
        raise NotImplementedError()

    def remove(self, chart : Chart) -> None:
        '''Remove the specific chart.
        :param chart: '''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Remove a chart at the specific index.
        :param index: The chart index.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> Chart:
        '''Gets the :class:`Chart` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> Chart:
        '''Gets the chart by the name.
        :param name: The chart name.
        :returns: The chart.'''
        raise NotImplementedError()

    def addFloatingChart(self, type : int, left : int, top : int, width : int, height : int) -> int:
        '''Adds a chart to the collection.
        :param type: :class:`ChartType`. Chart type
        :param left: The x offset to corner
        :param top: The y offset to corner
        :param width: The chart width
        :param height: The chart height
        :returns: :class:`Chart` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, type : int, upperLeftRow : int, upperLeftColumn : int, lowerRightRow : int, lowerRightColumn : int) -> int:
        '''Adds a chart to the collection.
        :param type: :class:`ChartType`. Chart type
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param lowerRightRow: Lower right row index
        :param lowerRightColumn: Lower right column index
        :returns: :class:`Chart` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, type : int, dataRange : str, topRow : int, leftColumn : int, rightRow : int, bottomColumn : int) -> int:
        ''':deprecated: Use ChartCollection.Add(ChartType, string, bool ,int , int, int, int ) instead.'''
        raise NotImplementedError()

    @overload
    def add(self, data : list[int], dataRange : str, isVertical : bool, topRow : int, leftColumn : int, rightRow : int, bottomColumn : int) -> int:
        '''Adds a chart with preset template.
        :param data: The data of chart template file(.crtx).
        :param dataRange: Specifies the data range of the chart
        :param isVertical: Specifies whether to plot the series from a range of cell values by row or by column.
        :param topRow: Upper left row index.
        :param leftColumn: Upper left column index.
        :param rightRow: Lower right row index
        :param bottomColumn: Lower right column index
        :returns: :class:`Chart` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, type : int, dataRange : str, isVertical : bool, topRow : int, leftColumn : int, rightRow : int, bottomColumn : int) -> int:
        '''Adds a chart to the collection.
        :param type: :class:`ChartType`. Chart type
        :param dataRange: Specifies the data range of the chart
        :param isVertical: Specifies whether to plot the series from a range of cell values by row or by column.
        :param topRow: Upper left row index.
        :param leftColumn: Upper left column index.
        :param rightRow: Lower right row index
        :param bottomColumn: Lower right column index
        :returns: :class:`Chart` object index.'''
        raise NotImplementedError()


class ChartDataTable:
    '''Represents a chart data table.'''

    def getFont(self) -> Font:
        '''Gets a :meth:`ChartArea.getFont()` object which represents the font setting of the specified chart data table.'''
        raise NotImplementedError()

    def setShowLegendKey(self, value : bool) -> None:
        '''True if the data label legend key is visible.
        :param value: '''
        raise NotImplementedError()

    def hasOutlineBorder(self) -> bool:
        '''True if the chart data table has outline borders'''
        raise NotImplementedError()

    def getAutoScaleFont(self) -> bool:
        '''True if the text in the object changes font size when the object size changes.
        The default value is True.'''
        raise NotImplementedError()

    def getBackgroundMode(self) -> int:
        '''Gets the display mode of the background
        See :class:`BackgroundMode`'''
        raise NotImplementedError()

    def setHasOutlineBorder(self, value : bool) -> None:
        '''True if the chart data table has outline borders
        :param value: '''
        raise NotImplementedError()

    def setAutoScaleFont(self, value : bool) -> None:
        '''True if the text in the object changes font size when the object size changes.
        The default value is True.
        :param value: '''
        raise NotImplementedError()

    def hasBorderOutline(self) -> bool:
        ''':deprecated: Use ChartDataTable.HasOutlineBorder property, instead.'''
        raise NotImplementedError()

    def setHasHorizontalBorder(self, value : bool) -> None:
        '''True if the chart data table has horizontal cell borders
        :param value: '''
        raise NotImplementedError()

    def getBorder(self) -> Line:
        '''Returns a Border object that represents the border of the object'''
        raise NotImplementedError()

    def hasHorizontalBorder(self) -> bool:
        '''True if the chart data table has horizontal cell borders'''
        raise NotImplementedError()

    def setHasBorderOutline(self, value : bool) -> None:
        ''':deprecated: Use ChartDataTable.HasOutlineBorder property, instead.'''
        raise NotImplementedError()

    def setHasBorderHorizontal(self, value : bool) -> None:
        ''':deprecated: Use ChartDataTable.HasHorizontalBorder property, instead.'''
        raise NotImplementedError()

    def hasBorderHorizontal(self) -> bool:
        ''':deprecated: Use ChartDataTable.HasHorizontalBorder property, instead.'''
        raise NotImplementedError()

    def setHasBorderVertical(self, value : bool) -> None:
        ''':deprecated: Use ChartDataTable.HasVerticalBorder property, instead.'''
        raise NotImplementedError()

    def setBackgroundMode(self, value : int) -> None:
        '''Sets the display mode of the background
        See :class:`BackgroundMode`
        :param value: '''
        raise NotImplementedError()

    def hasBorderVertical(self) -> bool:
        ''':deprecated: Use ChartDataTable.HasVerticalBorder property, instead.'''
        raise NotImplementedError()

    def getShowLegendKey(self) -> bool:
        '''True if the data label legend key is visible.'''
        raise NotImplementedError()

    def setHasVerticalBorder(self, value : bool) -> None:
        '''True if the chart data table has vertical cell borders
        :param value: '''
        raise NotImplementedError()

    def hasVerticalBorder(self) -> bool:
        '''True if the chart data table has vertical cell borders'''
        raise NotImplementedError()


class ChartFrame:
    '''Encapsulates the object that represents the frame object in a chart.'''

    def setInnerMode(self, value : bool) -> None:
        '''Indicates whether the size of the plot area size includes the tick marks, and the axis labels.
        False specifies that the size shall determine the size of the plot area, the tick marks, and the axis labels.
        :param value: '''
        raise NotImplementedError()

    def getChart(self) -> Chart:
        '''Gets the chart to which this object belongs.'''
        raise NotImplementedError()

    def getBackground(self) -> int:
        ''':deprecated: Use ChartFrame.BackgroundMode property instead.'''
        raise NotImplementedError()

    def setWidth(self, value : int) -> None:
        '''Sets the width of frame in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def getTextOptions(self) -> TextOptions:
        '''Gets the options of the text.'''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Gets the width of frame in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def getFont(self) -> Font:
        '''Gets a :meth:`ChartArea.getFont()` object of the specified ChartFrame object.'''
        raise NotImplementedError()

    def isInnerMode(self) -> bool:
        '''Indicates whether the size of the plot area size includes the tick marks, and the axis labels.
        False specifies that the size shall determine the size of the plot area, the tick marks, and the axis labels.'''
        raise NotImplementedError()

    def setAutomaticSize(self, value : bool) -> None:
        '''Indicates whether the chart frame is automatic sized.
        :param value: '''
        raise NotImplementedError()

    def setBackground(self, value : int) -> None:
        ''':deprecated: Use ChartFrame.BackgroundMode property instead.'''
        raise NotImplementedError()

    def isAutomaticSize(self) -> bool:
        '''Indicates whether the chart frame is automatic sized.'''
        raise NotImplementedError()

    def getShadow(self) -> bool:
        '''True if the frame has a shadow.'''
        raise NotImplementedError()

    def getAutoScaleFont(self) -> bool:
        '''True if the text in the object changes font size when the object size changes. The default value is True.'''
        raise NotImplementedError()

    def setHeight(self, value : int) -> None:
        '''Sets the height of frame in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def getArea(self) -> Area:
        '''Gets the :class:`Area`.'''
        raise NotImplementedError()

    def getBackgroundMode(self) -> int:
        '''Gets the display mode of the background
        See :class:`BackgroundMode`'''
        raise NotImplementedError()

    def setAutoScaleFont(self, value : bool) -> None:
        '''True if the text in the object changes font size when the object size changes. The default value is True.
        :param value: '''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Gets the height of frame in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def getTextFont(self) -> Font:
        ''':deprecated: Use ChartFrame.Font property instead.'''
        raise NotImplementedError()

    def setY(self, value : int) -> None:
        '''Sets the y coordinate of the upper left corner in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def getDefaultWidth(self) -> int:
        '''Represents width of default position'''
        raise NotImplementedError()

    def setX(self, value : int) -> None:
        '''Sets the x coordinate of the upper left corner in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def getBorder(self) -> Line:
        '''Gets the :class:`Line`.'''
        raise NotImplementedError()

    def getDefaultHeight(self) -> int:
        '''Represents height of default position'''
        raise NotImplementedError()

    def isDefaultPosBeSet(self) -> bool:
        '''Indicates whether default position(DefaultX, DefaultY, DefaultWidth and DefaultHeight) are set.'''
        raise NotImplementedError()

    def getY(self) -> int:
        '''Gets the y coordinate of the upper left corner in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def getX(self) -> int:
        '''Gets the x coordinate of the upper left corner in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def setPositionAuto(self) -> None:
        '''Set position of the frame to automatic'''
        raise NotImplementedError()

    def setBackgroundMode(self, value : int) -> None:
        '''Sets the display mode of the background
        See :class:`BackgroundMode`
        :param value: '''
        raise NotImplementedError()

    def getShapeProperties(self) -> ShapePropertyCollection:
        '''Gets the :meth:`ChartFrame.getShapeProperties()` object.'''
        raise NotImplementedError()

    def getDefaultY(self) -> int:
        '''Represents y of default position'''
        raise NotImplementedError()

    def getDefaultX(self) -> int:
        '''Represents x of default position'''
        raise NotImplementedError()

    def setShadow(self, value : bool) -> None:
        '''True if the frame has a shadow.
        :param value: '''
        raise NotImplementedError()


class ChartGlobalizationSettings:
    '''Represents the globalization settings for chart.'''

    def getLegendDecreaseName(self) -> str:
        '''Gets the name of Decrease for Legend.'''
        raise NotImplementedError()

    def getAxisUnitName(self, type : int) -> str:
        '''Gets the Name of Axis Unit.
        :param type: '''
        raise NotImplementedError()

    def getAxisTitleName(self) -> str:
        '''Gets the name of Title for Axis.'''
        raise NotImplementedError()

    def getSeriesName(self) -> str:
        '''Gets the name of Series in the Chart.'''
        raise NotImplementedError()

    def getLegendIncreaseName(self) -> str:
        '''Gets the name of increase for Legend.'''
        raise NotImplementedError()

    def getOtherName(self) -> str:
        '''Gets the name of "Other" labels for Chart.'''
        raise NotImplementedError()

    def getLegendTotalName(self) -> str:
        '''Gets the name of Total for Legend.'''
        raise NotImplementedError()

    def getChartTitleName(self) -> str:
        '''Gets the name of Chart Title.'''
        raise NotImplementedError()


class ChartLineFormattingType:
    '''Represents line format type of chart line.'''

    AUTOMATIC : ChartLineFormattingType
    '''Represents automatic formatting type.'''

    SOLID : ChartLineFormattingType
    '''Represents solid formatting type.'''

    NONE : ChartLineFormattingType
    '''Represents none formatting type.'''

    GRADIENT : ChartLineFormattingType
    '''Gradient'''


class ChartMarkerType:
    '''Represents the marker style in a line chart, scatter chart, or radar chart.'''

    AUTOMATIC : ChartMarkerType
    '''Automatic markers.'''

    CIRCLE : ChartMarkerType
    '''Circular markers.'''

    DASH : ChartMarkerType
    '''Long bar markers'''

    DIAMOND : ChartMarkerType
    '''Diamond-shaped markers.'''

    DOT : ChartMarkerType
    '''Short bar markers.'''

    NONE : ChartMarkerType
    '''No markers.'''

    SQUARE_PLUS : ChartMarkerType
    '''Square markers with a plus sign.'''

    SQUARE : ChartMarkerType
    '''Square markers.'''

    SQUARE_STAR : ChartMarkerType
    '''Square markers with an asterisk.'''

    TRIANGLE : ChartMarkerType
    '''Triangular markers.'''

    SQUARE_X : ChartMarkerType
    '''Square markers with an X.'''

    PICTURE : ChartMarkerType
    '''Picture'''


class ChartPoint:
    '''Represents a single point in a series in a chart.'''

    def getShapeHeightPx(self) -> int:
        '''Gets the height in units of pixels after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getXValue(self) -> Object:
        '''Gets the X value of the chart point.'''
        raise NotImplementedError()

    def getInnerArcEndPointXPx(self) -> float:
        '''Gets the x coordinate of ending point for the pie section after calls Chart.Calculate() method.
        Applies to Doughnut chart.'''
        raise NotImplementedError()

    def getArcEndPointXPx(self) -> float:
        '''Gets the x coordinate of ending point for the pie section after calls Chart.Calculate() method.
        Applies to Pie and Doughnut  chart.'''
        raise NotImplementedError()

    def getShapeWidthPx(self) -> int:
        '''Gets the width in units of pixels after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getArea(self) -> Area:
        '''Gets the :class:`Area`.'''
        raise NotImplementedError()

    def getShapeHeight(self) -> int:
        '''Gets the height in units of 1/4000 of chart's height after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def setXValue(self, value : Object) -> None:
        '''Sets the X value of the chart point.
        :param value: '''
        raise NotImplementedError()

    def getBorderWidthPx(self) -> int:
        '''Gets the width of border in units of pixels after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getArcStartPointYPx(self) -> float:
        '''Gets the y coordinate of starting point for the pie section after calls Chart.Calculate() method.
        Applies to Pie and Doughnut  chart.'''
        raise NotImplementedError()

    def getShadow(self) -> bool:
        '''True if the chartpoint has a shadow.'''
        raise NotImplementedError()

    def setExplosion(self, value : int) -> None:
        '''The distance of an open pie slice from the center of the pie chart is expressed as a percentage of the pie diameter.
        :param value: '''
        raise NotImplementedError()

    def getRadiusPx(self) -> int:
        '''Gets the radius of bubble, pie or doughnut in units of pixels after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getInnerRadiusPx(self) -> int:
        ''':deprecated: Use ChartPoint.DoughnutInnerRadius property, instead.'''
        raise NotImplementedError()

    def getArcStartPointXPx(self) -> float:
        '''Gets the x coordinate of starting point for the pie section after calls Chart.Calculate() method.
        Applies to Pie and Doughnut  chart.'''
        raise NotImplementedError()

    def getShapeYPx(self) -> int:
        '''Gets the y coordinate of the upper left corner in units of pixels after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def setShadow(self, value : bool) -> None:
        '''True if the chartpoint has a shadow.
        :param value: '''
        raise NotImplementedError()

    def getBottomPointYPx(self, index : int) -> float:
        '''Gets y-coordinate of the bottom point of shape  after calls Chart.Calculate() method.
        Applies 3D charts: Column3D, Bar3D, Cone, Cylinder, Pyramid
        :param index: '''
        raise NotImplementedError()

    def getOnCategoryAxisPointYPx(self, index : int) -> float:
        '''Gets y-coordinate of the point on category axis after calls Chart.Calculate() method. Only applies to Area chart.
        :param index: '''
        raise NotImplementedError()

    def getShapeY(self) -> int:
        '''Gets the y coordinate of the upper left corner in units of 1/4000 of chart's height after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getShapeX(self) -> int:
        '''Gets the x coordinate of the upper left corner in units of 1/4000 of chart's width after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getTopPointYPx(self, index : int) -> float:
        '''Gets y-coordinate of the top point of shape after calls Chart.Calculate() method.
        Applies 3D charts: Column3D, Bar3D, Cone, Cylinder, Pyramid and Area3D
        :param index: '''
        raise NotImplementedError()

    def getShapeXPx(self) -> int:
        '''Gets the x coordinate of the upper left corner in units of pixels after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getBottomPointXPx(self, index : int) -> float:
        '''Gets x-coordinate of the bottom point of shape after calls Chart.Calculate() method.
        Applies 3D charts: Column3D, Bar3D, Cone, Cylinder, Pyramid
        :param index: '''
        raise NotImplementedError()

    def getOnCategoryAxisPointXPx(self, index : int) -> float:
        '''Gets x-coordinate of the point on category axis after calls Chart.Calculate() method. Only applies to Area chart.
        :param index: '''
        raise NotImplementedError()

    def getMarker(self) -> Marker:
        '''Gets the :meth:`Series.getMarker()`.'''
        raise NotImplementedError()

    def getYValue(self) -> Object:
        '''Gets the Y value of the chart point.'''
        raise NotImplementedError()

    def getTopPointXPx(self, index : int) -> float:
        '''Gets x-coordinate of the top point of shape after calls Chart.Calculate() method.
        Applies 3D charts: Column3D, Bar3D, Cone, Cylinder, Pyramid and Area3D
        :param index: '''
        raise NotImplementedError()

    def getBottomPointCount(self) -> int:
        '''Gets the number of bottom points  after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getShapeWidth(self) -> int:
        '''Gets the width in units of 1/4000 of chart's width after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def isInSecondaryPlot(self) -> bool:
        '''Gets a value indicates whether this data points is in the second pie or bar
        on a pie of pie or bar of pie chart'''
        raise NotImplementedError()

    def getShapeProperties(self) -> ShapePropertyCollection:
        '''Gets the :class:`ShapePropertyCollection` object that holds the visual shape properties of the ChartPoint.'''
        raise NotImplementedError()

    def getXValueType(self) -> int:
        '''Gets X value type of the chart point.
        See :class:`CellValueType`'''
        raise NotImplementedError()

    def setYValue(self, value : Object) -> None:
        '''Sets the Y value of the chart point.
        :param value: '''
        raise NotImplementedError()

    def getOnCategoryAxisPointCount(self) -> int:
        '''Gets the number of the points on category axis after calls Chart.Calculate() method. Only applies to area chart.'''
        raise NotImplementedError()

    def setInSecondaryPlot(self, value : bool) -> None:
        '''Sets a value indicates whether this data points is in the second pie or bar
        on a pie of pie or bar of pie chart
        :param value: '''
        raise NotImplementedError()

    def getInnerArcStartPointYPx(self) -> float:
        '''Gets the y coordinate of starting point for the pie section after calls Chart.Calculate() method.
        Applies to Doughnut chart.'''
        raise NotImplementedError()

    def getEndAngle(self) -> float:
        '''Gets the ending angle for the pie section, measured in degrees clockwise from the x-axis after calls Chart.Calculate() method.
        Applies to Pie chart.'''
        raise NotImplementedError()

    def getTopPointCount(self) -> int:
        '''Gets the number of top points after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getExplosion(self) -> int:
        '''The distance of an open pie slice from the center of the pie chart is expressed as a percentage of the pie diameter.'''
        raise NotImplementedError()

    def getDataLabels(self) -> DataLabels:
        '''Returns a :meth:`ChartPoint.getDataLabels()` object that represents the data label associated with this chart point.'''
        raise NotImplementedError()

    def getStartAngle(self) -> float:
        '''Gets the starting angle for the pie section, measured in degrees clockwise from the x-axis after calls Chart.Calculate() method.
        Applies to Pie chart.'''
        raise NotImplementedError()

    def getDoughnutInnerRadius(self) -> int:
        '''Gets the inner radius of doughnut slice in units of pixels after calls Chart.Calculate() method.
        Applies to Doughnut chart.'''
        raise NotImplementedError()

    def getBorder(self) -> Line:
        '''Gets the :class:`Line`.'''
        raise NotImplementedError()

    def getYValueType(self) -> int:
        '''Gets Y value type of the chart point.
        See :class:`CellValueType`'''
        raise NotImplementedError()

    def getInnerArcStartPointXPx(self) -> float:
        '''Gets the x coordinate of starting point for the pie section after calls Chart.Calculate() method.
        Applies to Doughnut chart.'''
        raise NotImplementedError()

    def getInnerArcEndPointYPx(self) -> float:
        '''Gets the y coordinate of ending point for the pie section after calls Chart.Calculate() method.
        Applies to Doughnut chart.'''
        raise NotImplementedError()

    def getArcEndPointYPx(self) -> float:
        '''Gets the y coordinate of ending point for the pie section after calls Chart.Calculate() method.
        Applies to Pie and Doughnut chart.'''
        raise NotImplementedError()


class ChartPointCollection:
    '''Represents a collection that contains all the points in one series.'''

    def clear(self) -> None:
        '''Remove all setting of the chart points.'''
        raise NotImplementedError()

    def getCount(self) -> int:
        '''Gets the count of the chart point.'''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Removes point at the index of the series..
        :param index: The index of the point.'''
        raise NotImplementedError()

    def get(self, index : int) -> ChartPoint:
        '''Gets the :class:`ChartPoint` element at the specified index in the series.
        :param index: The index of chart point in the series.
        :returns: The ChartPoint object.'''
        raise NotImplementedError()

    def iterator(self) -> Iterator:
        '''Returns an enumerator for the entire :class:`ChartPointCollection`.'''
        raise NotImplementedError()


class ChartShape:
    '''Represents the shape of the chart.
    Properties and methods for the ChartObject object control the appearance and size of the embedded chart on the worksheet.'''

    def getChart(self) -> Chart:
        '''Returns a Chart object that represents the chart contained in the object.'''
        raise NotImplementedError()


class ChartSplitType:
    '''Represents the way the two sections of either a pie of pie chart or a bar of pie chart are split.'''

    POSITION : ChartSplitType
    '''Represents the data points shall be split between the pie
    and the second chart by putting the last Split Position
    of the data points in the second chart'''

    VALUE : ChartSplitType
    '''Represents the data points shall be split between the pie
    and the second chart by putting the data points with
    value less than Split Position in the second chart.'''

    PERCENT_VALUE : ChartSplitType
    '''Represents the data points shall be split between the pie
    and the second chart by putting the points with
    percentage less than Split Position percent in the
    second chart.'''

    CUSTOM : ChartSplitType
    '''Represents the data points shall be split between the pie
    and the second chart according to the Custom Split
    values.'''

    AUTO : ChartSplitType
    '''Represents the data points shall be split using the default
    mechanism for this chart type.'''


class ChartTextDirectionType:
    '''Represents the text direction type of the chart.'''

    HORIZONTAL : ChartTextDirectionType
    '''Horizontal direction type.'''

    VERTICAL : ChartTextDirectionType
    '''Vertical direction type.'''

    ROTATE_90 : ChartTextDirectionType
    '''Rotate 90 angle.'''

    ROTATE_270 : ChartTextDirectionType
    '''Rotate 270 angle.'''

    STACKED : ChartTextDirectionType
    '''Stacked text.'''


class ChartTextFrame:
    '''Encapsulates the object that represents the frame object which contains text.'''

    def characters(self, startIndex : int, length : int) -> FontSetting:
        '''Returns a Characters object that represents a range of characters within the text.
        :param startIndex: The index of the start of the character.
        :param length: The number of characters.
        :returns: Characters object.'''
        raise NotImplementedError()

    def getText(self) -> str:
        '''Gets the text of a frame's title.'''
        raise NotImplementedError()

    def getReadingOrder(self) -> int:
        '''Represents text reading order.
        See :class:`TextDirectionType`'''
        raise NotImplementedError()

    def isAutoText(self) -> bool:
        '''Indicates the text is auto generated.'''
        raise NotImplementedError()

    def getLinkedSource(self) -> str:
        '''Gets a reference to the worksheet.'''
        raise NotImplementedError()

    def getTextDirection(self) -> int:
        ''':deprecated: Use ChartTextFrame.ReadingOrder property instead.'''
        raise NotImplementedError()

    def isTextWrapped(self) -> bool:
        '''Gets a value indicating whether the text is wrapped.'''
        raise NotImplementedError()

    def getTextVerticalAlignment(self) -> int:
        '''Gets the text vertical alignment of text.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def setLinkedSource(self, value : str) -> None:
        '''Sets a reference to the worksheet.
        :param value: '''
        raise NotImplementedError()

    def isAutomaticRotation(self) -> bool:
        '''Indicates whether the text of the chart is automatically rotated.'''
        raise NotImplementedError()

    def setResizeShapeToFitText(self, value : bool) -> None:
        '''Sets whether a shape should be auto-fit to fully contain the text described within it. Auto-fitting is
        when text within a shape is scaled in order to contain all the text inside.
        :param value: '''
        raise NotImplementedError()

    def setTextWrapped(self, value : bool) -> None:
        '''Sets a value indicating whether the text is wrapped.
        :param value: '''
        raise NotImplementedError()

    def setTextVerticalAlignment(self, value : int) -> None:
        '''Sets the text vertical alignment of text.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def isDeleted(self) -> bool:
        '''Indicates whether this data labels is deleted.'''
        raise NotImplementedError()

    def setTextDirection(self, value : int) -> None:
        ''':deprecated: Use ChartTextFrame.ReadingOrder property instead.'''
        raise NotImplementedError()

    def getDirectionType(self) -> int:
        '''Gets the direction of text.
        See :class:`ChartTextDirectionType`'''
        raise NotImplementedError()

    def setAutoText(self, value : bool) -> None:
        '''Indicates the text is auto generated.
        :param value: '''
        raise NotImplementedError()

    def isResizeShapeToFitText(self) -> bool:
        '''Gets whether a shape should be auto-fit to fully contain the text described within it. Auto-fitting is
        when text within a shape is scaled in order to contain all the text inside.'''
        raise NotImplementedError()

    def setDeleted(self, value : bool) -> None:
        '''Indicates whether this data labels is deleted.
        :param value: '''
        raise NotImplementedError()

    def setTextHorizontalAlignment(self, value : int) -> None:
        '''Sets the text horizontal alignment.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getRotationAngle(self) -> int:
        '''Represents text rotation angle.'''
        raise NotImplementedError()

    def setDirectionType(self, value : int) -> None:
        '''Sets the direction of text.
        See :class:`ChartTextDirectionType`
        :param value: '''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''Sets the text of a frame's title.
        :param value: '''
        raise NotImplementedError()

    def setReadingOrder(self, value : int) -> None:
        '''Represents text reading order.
        See :class:`TextDirectionType`
        :param value: '''
        raise NotImplementedError()

    def setRotationAngle(self, value : int) -> None:
        '''Represents text rotation angle.
        :param value: '''
        raise NotImplementedError()

    def getTextHorizontalAlignment(self) -> int:
        '''Gets the text horizontal alignment.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()


class ChartType:
    '''Enumerates all chart types used in Excel.'''

    AREA : ChartType
    '''Represents Area Chart.'''

    AREA_STACKED : ChartType
    '''Represents Stacked Area Chart.'''

    AREA_100_PERCENT_STACKED : ChartType
    '''Represents 100% Stacked Area Chart.'''

    AREA_3_D : ChartType
    '''Represents 3D Area Chart.'''

    AREA_3_D_STACKED : ChartType
    '''Represents 3D Stacked Area Chart.'''

    AREA_3_D_100_PERCENT_STACKED : ChartType
    '''Represents 3D 100% Stacked Area Chart.'''

    BAR : ChartType
    '''Represents Bar Chart: Clustered Bar Chart.'''

    BAR_STACKED : ChartType
    '''Represents Stacked Bar Chart.'''

    BAR_100_PERCENT_STACKED : ChartType
    '''Represents 100% Stacked Bar Chart.'''

    BAR_3_D_CLUSTERED : ChartType
    '''Represents 3D Clustered Bar Chart.'''

    BAR_3_D_STACKED : ChartType
    '''Represents 3D Stacked Bar Chart.'''

    BAR_3_D_100_PERCENT_STACKED : ChartType
    '''Represents 3D 100% Stacked Bar Chart.'''

    BUBBLE : ChartType
    '''Represents Bubble Chart.'''

    BUBBLE_3_D : ChartType
    '''Represents 3D Bubble Chart.'''

    COLUMN : ChartType
    '''Represents Column Chart: Clustered Column Chart.'''

    COLUMN_STACKED : ChartType
    '''Represents Stacked Column Chart.'''

    COLUMN_100_PERCENT_STACKED : ChartType
    '''Represents 100% Stacked Column Chart.'''

    COLUMN_3_D : ChartType
    '''Represents 3D Column Chart.'''

    COLUMN_3_D_CLUSTERED : ChartType
    '''Represents 3D Clustered Column Chart.'''

    COLUMN_3_D_STACKED : ChartType
    '''Represents 3D Stacked Column Chart.'''

    COLUMN_3_D_100_PERCENT_STACKED : ChartType
    '''Represents 3D 100% Stacked Column Chart.'''

    CONE : ChartType
    '''Represents Cone Chart.'''

    CONE_STACKED : ChartType
    '''Represents Stacked Cone Chart.'''

    CONE_100_PERCENT_STACKED : ChartType
    '''Represents 100% Stacked Cone Chart.'''

    CONICAL_BAR : ChartType
    '''Represents Conical Bar Chart.'''

    CONICAL_BAR_STACKED : ChartType
    '''Represents Stacked Conical Bar Chart.'''

    CONICAL_BAR_100_PERCENT_STACKED : ChartType
    '''Represents 100% Stacked Conical Bar Chart.'''

    CONICAL_COLUMN_3_D : ChartType
    '''Represents 3D Conical Column Chart.'''

    CYLINDER : ChartType
    '''Represents Cylinder Chart.'''

    CYLINDER_STACKED : ChartType
    '''Represents Stacked Cylinder Chart.'''

    CYLINDER_100_PERCENT_STACKED : ChartType
    '''Represents 100% Stacked Cylinder Chart.'''

    CYLINDRICAL_BAR : ChartType
    '''Represents Cylindrical Bar Chart.'''

    CYLINDRICAL_BAR_STACKED : ChartType
    '''Represents Stacked Cylindrical Bar Chart.'''

    CYLINDRICAL_BAR_100_PERCENT_STACKED : ChartType
    '''Represents 100% Stacked Cylindrical Bar Chart.'''

    CYLINDRICAL_COLUMN_3_D : ChartType
    '''Represents 3D Cylindrical Column Chart.'''

    DOUGHNUT : ChartType
    '''Represents Doughnut Chart.'''

    DOUGHNUT_EXPLODED : ChartType
    '''Represents Exploded Doughnut Chart.'''

    LINE : ChartType
    '''Represents Line Chart.'''

    LINE_STACKED : ChartType
    '''Represents Stacked Line Chart.'''

    LINE_100_PERCENT_STACKED : ChartType
    '''Represents 100% Stacked Line Chart.'''

    LINE_WITH_DATA_MARKERS : ChartType
    '''Represents Line Chart with data markers.'''

    LINE_STACKED_WITH_DATA_MARKERS : ChartType
    '''Represents Stacked Line Chart with data markers.'''

    LINE_100_PERCENT_STACKED_WITH_DATA_MARKERS : ChartType
    '''Represents 100% Stacked Line Chart with data markers.'''

    LINE_3_D : ChartType
    '''Represents 3D Line Chart.'''

    PIE : ChartType
    '''Represents Pie Chart.'''

    PIE_3_D : ChartType
    '''Represents 3D Pie Chart.'''

    PIE_PIE : ChartType
    '''Represents Pie of Pie Chart.'''

    PIE_EXPLODED : ChartType
    '''Represents Exploded Pie Chart.'''

    PIE_3_D_EXPLODED : ChartType
    '''Represents 3D Exploded Pie Chart.'''

    PIE_BAR : ChartType
    '''Represents Bar of Pie Chart.'''

    PYRAMID : ChartType
    '''Represents Pyramid Chart.'''

    PYRAMID_STACKED : ChartType
    '''Represents Stacked Pyramid Chart.'''

    PYRAMID_100_PERCENT_STACKED : ChartType
    '''Represents 100% Stacked Pyramid Chart.'''

    PYRAMID_BAR : ChartType
    '''Represents Pyramid Bar Chart.'''

    PYRAMID_BAR_STACKED : ChartType
    '''Represents Stacked Pyramid Bar Chart.'''

    PYRAMID_BAR_100_PERCENT_STACKED : ChartType
    '''Represents 100% Stacked Pyramid Bar Chart.'''

    PYRAMID_COLUMN_3_D : ChartType
    '''Represents 3D Pyramid Column Chart.'''

    RADAR : ChartType
    '''Represents Radar Chart.'''

    RADAR_WITH_DATA_MARKERS : ChartType
    '''Represents Radar Chart with data markers.'''

    RADAR_FILLED : ChartType
    '''Represents Filled Radar Chart.'''

    SCATTER : ChartType
    '''Represents Scatter Chart.'''

    SCATTER_CONNECTED_BY_CURVES_WITH_DATA_MARKER : ChartType
    '''Represents Scatter Chart connected by curves, with data markers.'''

    SCATTER_CONNECTED_BY_CURVES_WITHOUT_DATA_MARKER : ChartType
    '''Represents Scatter Chart connected by curves, without data markers.'''

    SCATTER_CONNECTED_BY_LINES_WITH_DATA_MARKER : ChartType
    '''Represents Scatter Chart connected by lines, with data markers.'''

    SCATTER_CONNECTED_BY_LINES_WITHOUT_DATA_MARKER : ChartType
    '''Represents Scatter Chart connected by lines, without data markers.'''

    STOCK_HIGH_LOW_CLOSE : ChartType
    '''Represents High-Low-Close Stock Chart.'''

    STOCK_OPEN_HIGH_LOW_CLOSE : ChartType
    '''Represents Open-High-Low-Close Stock Chart.'''

    STOCK_VOLUME_HIGH_LOW_CLOSE : ChartType
    '''Represents Volume-High-Low-Close Stock Chart.'''

    STOCK_VOLUME_OPEN_HIGH_LOW_CLOSE : ChartType
    '''Represents Volume-Open-High-Low-Close Stock Chart.'''

    SURFACE_3_D : ChartType
    '''Represents Surface Chart: 3D Surface Chart.'''

    SURFACE_WIREFRAME_3_D : ChartType
    '''Represents Wireframe 3D Surface Chart.'''

    SURFACE_CONTOUR : ChartType
    '''Represents Contour Chart.'''

    SURFACE_CONTOUR_WIREFRAME : ChartType
    '''Represents Wireframe Contour Chart.'''

    BOX_WHISKER : ChartType
    '''The series is laid out as box and whisker.'''

    FUNNEL : ChartType
    '''The series is laid out as a funnel.'''

    PARETO_LINE : ChartType
    '''The series is laid out as pareto lines.'''

    SUNBURST : ChartType
    '''The series is laid out as a sunburst.'''

    TREEMAP : ChartType
    '''The series is laid out as a treemap.'''

    WATERFALL : ChartType
    '''The series is laid out as a waterfall.'''

    HISTOGRAM : ChartType
    '''The series is laid out as a histogram.'''

    MAP : ChartType
    '''The series is laid out as a region map.'''

    RADIAL_HISTOGRAM : ChartType
    '''The series is laid out as a radial historgram. It is used only for rendering'''


class CheckBox:
    '''Represents a check box object in a worksheet.'''

    def setShadow(self, value : bool) -> None:
        '''Indicates whether the combobox has 3-D shading.
        :param value: '''
        raise NotImplementedError()

    def getCheckValue(self) -> int:
        ''':deprecated: Use CheckBox.CheckValueType property instead.'''
        raise NotImplementedError()

    def getValue(self) -> bool:
        '''Indicates if the checkbox is checked or not.'''
        raise NotImplementedError()

    def setCheckValue(self, value : int) -> None:
        ''':deprecated: Use CheckBox.CheckValueType property instead.'''
        raise NotImplementedError()

    def setCheckedValue(self, value : int) -> None:
        '''Sets checkbox' value.
        See :class:`CheckValueType`
        :param value: '''
        raise NotImplementedError()

    def getCheckedValue(self) -> int:
        '''Gets checkbox' value.
        See :class:`CheckValueType`'''
        raise NotImplementedError()

    def getShadow(self) -> bool:
        '''Indicates whether the combobox has 3-D shading.'''
        raise NotImplementedError()

    def setValue(self, value : bool) -> None:
        '''Indicates if the checkbox is checked or not.
        :param value: '''
        raise NotImplementedError()


class CheckBoxActiveXControl:
    '''Represents a CheckBox ActiveX control.'''

    def isWordWrapped(self) -> bool:
        '''Indicates whether the contents of the control automatically wrap at the end of a line.'''
        raise NotImplementedError()

    def getPicture(self) -> list[int]:
        '''Gets the data of the picture.'''
        raise NotImplementedError()

    def setPicturePosition(self, value : int) -> None:
        '''Sets the location of the control's picture relative to its caption.
        See :class:`ControlPicturePositionType`
        :param value: '''
        raise NotImplementedError()

    def getCaption(self) -> str:
        '''Gets the descriptive text that appears on a control.'''
        raise NotImplementedError()

    def setValue(self, value : int) -> None:
        '''Indicates if the control is checked or not.
        See :class:`CheckValueType`
        :param value: '''
        raise NotImplementedError()

    def setAlignment(self, value : int) -> None:
        '''Sets the position of the Caption relative to the control.
        See :class:`ControlCaptionAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getAccelerator(self) -> str:
        '''Gets the accelerator key for the control.'''
        raise NotImplementedError()

    def isTripleState(self) -> bool:
        '''Indicates how the specified control will display Null values.'''
        raise NotImplementedError()

    def getValue(self) -> int:
        '''Indicates if the control is checked or not.
        See :class:`CheckValueType`'''
        raise NotImplementedError()

    def getPicturePosition(self) -> int:
        '''Gets the location of the control's picture relative to its caption.
        See :class:`ControlPicturePositionType`'''
        raise NotImplementedError()

    def setSpecialEffect(self, value : int) -> None:
        '''Sets the special effect of the control.
        See :class:`ControlSpecialEffectType`
        :param value: '''
        raise NotImplementedError()

    def setGroupName(self, value : str) -> None:
        '''Sets the group's name.
        :param value: '''
        raise NotImplementedError()

    def setPicture(self, value : list[int]) -> None:
        '''Sets the data of the picture.
        :param value: '''
        raise NotImplementedError()

    def setCaption(self, value : str) -> None:
        '''Sets the descriptive text that appears on a control.
        :param value: '''
        raise NotImplementedError()

    def getSpecialEffect(self) -> int:
        '''Gets the special effect of the control.
        See :class:`ControlSpecialEffectType`'''
        raise NotImplementedError()

    def getAlignment(self) -> int:
        '''Gets the position of the Caption relative to the control.
        See :class:`ControlCaptionAlignmentType`'''
        raise NotImplementedError()

    def setAccelerator(self, value : str) -> None:
        '''Sets the accelerator key for the control.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()

    def setWordWrapped(self, value : bool) -> None:
        '''Indicates whether the contents of the control automatically wrap at the end of a line.
        :param value: '''
        raise NotImplementedError()

    def getGroupName(self) -> str:
        '''Gets the group's name.'''
        raise NotImplementedError()

    def setTripleState(self, value : bool) -> None:
        '''Indicates how the specified control will display Null values.
        :param value: '''
        raise NotImplementedError()


class CheckBoxCollection:
    '''Represents a collection of :class:`CheckBox` objects in a worksheet.'''

    def get(self, index : int) -> CheckBox:
        '''Gets the :class:`CheckBox` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    def add(self, upperLeftRow : int, upperLeftColumn : int, height : int, width : int) -> int:
        '''Adds a checkBox to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param height: Height of checkBox, in unit of pixel.
        :param width: Width of checkBox, in unit of pixel.
        :returns: :class:`CheckBox` object index.'''
        raise NotImplementedError()


class CheckValueType:
    '''Represents the check value type of the check box.'''

    UN_CHECKED : CheckValueType
    '''UnChecked'''

    CHECKED : CheckValueType
    '''Checked'''

    MIXED : CheckValueType
    '''Mixed'''


class CollectionBase:
    '''Provides the abstract base class for a strongly typed collection.'''

    def clear(self) -> None:
        '''Removes all objects from the CollectionBase instance.'''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Removes the item at the specified index.
        :param index: The zero-based index of the item to remove.'''
        raise NotImplementedError()

    def getCount(self) -> int:
        '''Gets the number of elements contained in the CollectionBase instance.'''
        raise NotImplementedError()

    def get(self, index : int) -> Object:
        '''Get an item at specified position.
        :param index: Specified position index.
        :returns: The item at specified position.'''
        raise NotImplementedError()

    def contains(self, o : Object) -> bool:
        '''Return whether instance contains this object
        :param o: test object
        :returns: Whether instance contains this object'''
        raise NotImplementedError()

    def indexOf(self, o : Object) -> int:
        '''Determines the index of a specific item in the CollectionBase instance.
        :param o: Determines the index of a specific item in the CollectionBase instance.
        :returns: The index of value if found in the list; otherwise, -1.'''
        raise NotImplementedError()

    def iterator(self) -> Iterator:
        '''Returns an enumerator that iterates through the CollectionBase instance.'''
        raise NotImplementedError()

    def add(self, o : Object) -> int:
        '''Adds an item to the CollectionBase instance.
        :param o: The Object to add to the CollectionBase instance.
        :returns: The position into which the new element was inserted.'''
        raise NotImplementedError()


class Color:
    '''Represents an ARGB (alpha, red, green, blue) color.'''

    def getRed(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getCornflowerBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def hashCode(self) -> int:
        '''Returns a hash code for this Color object.'''
        raise NotImplementedError()

    def getSteelBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightSteelBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getHotPink(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLemonChiffon(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getChartreuse(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def toArgb(self) -> int:
        '''Gets the 32-bit ARGB value of this Color object.'''
        raise NotImplementedError()

    def getSaddleBrown(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkCyan(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getWheat(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getOrangeRed(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getEmpty(self) -> Color:
        '''Get a system-defined empty color.'''
        raise NotImplementedError()

    def getDeepPink(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightCyan(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Tests whether the specified object is a Color object and is equivalent to this object.
        :param obj: The object to test.
        :returns: true if obj is a Color object and equivalent to this Color object; otherwise, false.'''
        raise NotImplementedError()

    def getMediumSlateBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getBurlyWood(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getPaleGoldenrod(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getForestGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDeepSkyBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getCrimson(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getGoldenrod(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getSlateGray(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getAliceBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightSlateGray(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMediumVioletRed(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getSeaShell(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getFloralWhite(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getSkyBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMediumAquamarine(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getSpringGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightGoldenrodYellow(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightYellow(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getIndianRed(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getThistle(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getGray(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getTomato(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getBlueViolet(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkOliveGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getCornsilk(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getSeaGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightSeaGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getOrchid(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getPaleTurquoise(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightSalmon(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getTan(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getR(self) -> int:
        '''Gets the red component value of this Color object.'''
        raise NotImplementedError()

    def getDarkOrange(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getBrown(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getGreenYellow(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getGainsboro(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkRed(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getG(self) -> int:
        '''Gets the green component value of this Color object.'''
        raise NotImplementedError()

    def getB(self) -> int:
        '''Gets the blue component value of this Color object.'''
        raise NotImplementedError()

    def getA(self) -> int:
        '''Gets the alpha component value of this Color object.'''
        raise NotImplementedError()

    def getDarkSalmon(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getBisque(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLavenderBlush(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getChocolate(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getPapayaWhip(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getTurquoise(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getFirebrick(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getPeru(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    @overload
    def fromArgb(self, argb : int) -> Color:
        '''Creates a Color object from a 32-bit ARGB value.
        :param argb: A value specifying the 32-bit ARGB value.
        :returns: The Color object that this method creates.'''
        raise NotImplementedError()

    @overload
    def fromArgb(self, red : int, green : int, blue : int) -> Color:
        '''Creates a Color object from the specified 8-bit color values
        (red, green, and blue). The alpha value is implicitly 255 (fully opaque).
        Although this method allows a 32-bit value to be passed for each color component,
        the value of each component is limited to 8 bits.
        :param red: The red component value for the new Color object. Valid values are 0 through 255.
        :param green: The green component value for the new Color object. Valid values are 0 through 255.
        :param blue: The blue component value for the new Color object. Valid values are 0 through 255.
        :returns: The Color object that this method creates.'''
        raise NotImplementedError()

    @overload
    def fromArgb(self, alpha : int, red : int, green : int, blue : int) -> Color:
        '''Creates a Color object from the four ARGB component (alpha,red, green, and blue) values. Although this method allows a 32-bit value
        to be passed for each component, the value of each component is limited to 8 bits.
        :param alpha: The alpha component. Valid values are 0 through 255.
        :param red: The red component. Valid values are 0 through 255.
        :param green: The green component. Valid values are 0 through 255.
        :param blue: The blue component. Valid values are 0 through 255.
        :returns: The Color object that this method creates.'''
        raise NotImplementedError()

    def getGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkGray(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMediumSeaGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getViolet(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getNavajoWhite(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getAquamarine(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightGray(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getOlive(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLinen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getPowderBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getBlanchedAlmond(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMagenta(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDodgerBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkGoldenrod(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getWhite(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkSlateGray(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getRosyBrown(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getSlateBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMintCream(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkSeaGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getOliveDrab(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getIvory(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getPaleVioletRed(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkKhaki(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMediumOrchid(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getTransparent(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMediumBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLawnGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getYellowGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getPurple(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getCoral(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkOrchid(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getPlum(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getHoneydew(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMediumSpringGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightCoral(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getAzure(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getTeal(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getNavy(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getIndigo(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkTurquoise(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getKhaki(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getRoyalBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getOldLace(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getSnow(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkMagenta(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMaroon(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getWhiteSmoke(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getPink(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkViolet(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getAntiqueWhite(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMoccasin(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def isEmpty(self) -> bool:
        '''Specifies whether this Color object is uninitialized.'''
        raise NotImplementedError()

    def getMistyRose(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getBlack(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMidnightBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getCyan(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLavender(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightSkyBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getSienna(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getCadetBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getPaleGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getBeige(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMediumTurquoise(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getGhostWhite(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getAqua(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getPeachPuff(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getFuchsia(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getYellow(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getGold(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getMediumPurple(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDarkSlateBlue(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getSandyBrown(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getOrange(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLimeGreen(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getSilver(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLime(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getDimGray(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getSalmon(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()

    def getLightPink(self) -> Color:
        '''Get a system-defined color.'''
        raise NotImplementedError()


class ColorDepth:
    '''Enumerates Bit Depth Type for tiff image.'''

    DEFAULT : ColorDepth
    '''Default value, not set value.'''

    FORMAT_1_BPP : ColorDepth
    '''1 bit per pixel'''

    FORMAT_4_BPP : ColorDepth
    '''4 bits per pixel'''

    FORMAT_8_BPP : ColorDepth
    '''8 bits per pixel'''

    FORMAT_24_BPP : ColorDepth
    '''24 bits per pixel'''

    FORMAT_32_BPP : ColorDepth
    '''32 bits per pixel'''


class ColorFilter:
    '''Represents filtering the range by color.'''

    def getFilterByFillColor(self) -> bool:
        '''Whether filter by the cell's fill color.'''
        raise NotImplementedError()

    def setFilterByFillColor(self, value : bool) -> None:
        '''Whether filter by the cell's fill color.
        :param value: '''
        raise NotImplementedError()

    def getColor(self, sheets : WorksheetCollection) -> Color:
        '''Gets the color of this filter.
        :param sheets: '''
        raise NotImplementedError()


class ColorHelper:
    '''Provides helper functions about color.'''

    def toOleColor(self, color : Color, workbook : Workbook) -> int:
        '''Convert color to OLE_COLOR
        :param color: The :class:`Color` object.
        :param workbook: 
        :returns: The value of OLE_COLOR'''
        raise NotImplementedError()

    def fromOleColor(self, oleColor : int) -> Color:
        '''Convert OLE_COLOR.
        :param oleColor: The value of OLE_COLOR.
        :returns: The :class:`Color` object.'''
        raise NotImplementedError()


class ColorScale:
    '''Describe the ColorScale conditional formatting rule.
    This conditional formatting rule creates a gradated color scale on the cells.'''

    def getMidCfvo(self) -> ConditionalFormattingValue:
        '''Gets this ColorScale's mid value object.
        Cannot set CFValueObject with type FormatConditionValueType.Max or FormatConditionValueType.Min to it.'''
        raise NotImplementedError()

    def getMinCfvo(self) -> ConditionalFormattingValue:
        '''Gets this ColorScale's min value object.
        Cannot set null or CFValueObject with type FormatConditionValueType.Max to it.'''
        raise NotImplementedError()

    def setMaxColor(self, value : Color) -> None:
        '''Sets the gradient color for the maximum value in the range.
        :param value: '''
        raise NotImplementedError()

    def getMaxColor(self) -> Color:
        '''Gets the gradient color for the maximum value in the range.'''
        raise NotImplementedError()

    def setMidColor(self, value : Color) -> None:
        '''Sets the gradient color for the middle value in the range.
        :param value: '''
        raise NotImplementedError()

    def setMinColor(self, value : Color) -> None:
        '''Sets the gradient color for the minimum value in the range.
        :param value: '''
        raise NotImplementedError()

    def getMidColor(self) -> Color:
        '''Gets the gradient color for the middle value in the range.'''
        raise NotImplementedError()

    def getMinColor(self) -> Color:
        '''Gets the gradient color for the minimum value in the range.'''
        raise NotImplementedError()

    def getIs3ColorScale(self) -> bool:
        '''Indicates whether conditional formatting is 3 color scale.'''
        raise NotImplementedError()

    def setIs3ColorScale(self, value : bool) -> None:
        '''Indicates whether conditional formatting is 3 color scale.
        :param value: '''
        raise NotImplementedError()

    def getMaxCfvo(self) -> ConditionalFormattingValue:
        '''Gets this ColorScale's max value object.
        Cannot set null or CFValueObject with type FormatConditionValueType.Min to it.'''
        raise NotImplementedError()


class ColorType:
    '''Represents all color type'''

    AUTOMATIC : ColorType
    '''Automatic color.'''

    AUTOMATIC_INDEX : ColorType
    '''It's automatic color,but the displayed color depends the setting of the OS System.'''

    RGB : ColorType
    '''The RGB color.'''

    INDEXED_COLOR : ColorType
    '''The color index in the color palette.'''

    THEME : ColorType
    '''The theme color.'''


class Column:
    '''Represents a single column in a worksheet.'''

    def getIndex(self) -> int:
        '''Gets the index of this column.'''
        raise NotImplementedError()

    def isHidden(self) -> bool:
        '''Indicates whether the column is hidden.'''
        raise NotImplementedError()

    def setGroupLevel(self, value : int) -> None:
        '''Gets the group level of the column.
        :param value: '''
        raise NotImplementedError()

    def setHidden(self, value : bool) -> None:
        '''Indicates whether the column is hidden.
        :param value: '''
        raise NotImplementedError()

    def isCollapsed(self) -> bool:
        '''whether the column is collapsed'''
        raise NotImplementedError()

    def setStyle(self, style : Style) -> None:
        '''Sets the style of this column.
        :param style: the style to be used as the default style for cells in this column.'''
        raise NotImplementedError()

    def setWidth(self, value : int) -> None:
        '''Sets the column width in unit of characters.
        :param value: '''
        raise NotImplementedError()

    def setCollapsed(self, value : bool) -> None:
        '''whether the column is collapsed
        :param value: '''
        raise NotImplementedError()

    def getStyle(self) -> Style:
        '''Gets the style of this column.'''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Gets the column width in unit of characters.'''
        raise NotImplementedError()

    def hasCustomStyle(self) -> bool:
        '''Indicates whether this column has custom style settings(different from the default one inherited from workbook).'''
        raise NotImplementedError()

    def applyStyle(self, style : Style, flag : StyleFlag) -> None:
        '''Applies formats for a whole column.
        :param style: The style object which will be applied.
        :param flag: Flags which indicates applied formatting properties.'''
        raise NotImplementedError()

    def getGroupLevel(self) -> int:
        '''Gets the group level of the column.'''
        raise NotImplementedError()


class ColumnCollection:
    '''Collection of the :class:`Column` objects that represent the individual column(setting)s in a worksheet.
    The Column object only represents the settings such as column width, styles, .etc. for the whole column,
    has nothing to do with the fact that there are non-empty cells(data) or not in corresponding column.
    And the "Count" of this collection only represents the count Column objects that have been instantiated in this collection,
    has nothing to do with the fact that there are non-empty cells(data) or not in the worksheet.'''

    def get(self, columnIndex : int) -> Column:
        '''Gets a :class:`Column` object by column index.
        The Column object of given column index will be instantiated if it does not exist before.
        :param columnIndex: '''
        raise NotImplementedError()

    def getByIndex(self, index : int) -> Column:
        ''':deprecated: Use Columns.GetColumnByIndex() method instead.'''
        raise NotImplementedError()

    def getColumnByIndex(self, index : int) -> Column:
        '''Gets the :class:`Column` object by the position in the list.
        :param index: The position in the list.
        :returns: Returns the column object.'''
        raise NotImplementedError()


class ComboBox:
    '''Represents the control form ComboBox.'''

    def setShadow(self, value : bool) -> None:
        '''Indicates whether the combobox has 3-D shading.
        :param value: '''
        raise NotImplementedError()

    def getSelectedValue(self) -> str:
        '''Gets the selected value of the combox box.'''
        raise NotImplementedError()

    def setSelectedIndex(self, value : int) -> None:
        '''Sets the index number of the currently selected item in a list box or combo box.
        Zero-based.
        :param value: '''
        raise NotImplementedError()

    def setDropDownLines(self, value : int) -> None:
        '''Sets the number of list lines displayed in the drop-down portion of a combo box.
        :param value: '''
        raise NotImplementedError()

    def getShadow(self) -> bool:
        '''Indicates whether the combobox has 3-D shading.'''
        raise NotImplementedError()

    def getSelectedIndex(self) -> int:
        '''Gets the index number of the currently selected item in a list box or combo box.
        Zero-based.'''
        raise NotImplementedError()

    def getDropDownLines(self) -> int:
        '''Gets the number of list lines displayed in the drop-down portion of a combo box.'''
        raise NotImplementedError()

    def getSelectedCell(self) -> Cell:
        '''Gets the selected cell in the input range of the combo box.'''
        raise NotImplementedError()


class ComboBoxActiveXControl:
    '''Represents a ComboBox ActiveX control.'''

    def getListStyle(self) -> int:
        '''Gets the visual appearance.
        See :class:`ControlListStyle`'''
        raise NotImplementedError()

    def setSpecialEffect(self, value : int) -> None:
        '''Sets the special effect of the control.
        See :class:`ControlSpecialEffectType`
        :param value: '''
        raise NotImplementedError()

    def isEditable(self) -> bool:
        '''Indicates whether the user can type into the control.'''
        raise NotImplementedError()

    def setTextColumn(self, value : int) -> None:
        '''Represents the column in a ComboBox or ListBox to display to the user.
        :param value: '''
        raise NotImplementedError()

    def setBorderStyle(self, value : int) -> None:
        '''Sets the type of border used by the control.
        See :class:`ControlBorderType`
        :param value: '''
        raise NotImplementedError()

    def setBorderOleColor(self, value : int) -> None:
        '''Sets the ole color of the background.
        :param value: '''
        raise NotImplementedError()

    def setAutoWordSelected(self, value : bool) -> None:
        '''Specifies the basic unit used to extend a selection.
        True specifies that the basic unit is a single character.
        false specifies that the basic unit is a whole word.
        :param value: '''
        raise NotImplementedError()

    def setShowColumnHeads(self, value : bool) -> None:
        '''Indicates whether column headings are displayed.
        :param value: '''
        raise NotImplementedError()

    def setListRows(self, value : int) -> None:
        '''Represents the maximum number of rows to display in the list.
        :param value: '''
        raise NotImplementedError()

    def setHideSelection(self, value : bool) -> None:
        '''Indicates whether selected text in the control appears highlighted when the control does not have focus.
        :param value: '''
        raise NotImplementedError()

    def getListWidth(self) -> int:
        '''Gets the width in unit of points.'''
        raise NotImplementedError()

    def getMaxLength(self) -> int:
        '''Gets the maximum number of characters'''
        raise NotImplementedError()

    def getBoundColumn(self) -> int:
        '''Represents how the Value property is determined for a ComboBox or ListBox
        when the MultiSelect properties value (fmMultiSelectSingle).'''
        raise NotImplementedError()

    def getColumnWidths(self) -> int:
        '''Gets the width of the column.'''
        raise NotImplementedError()

    def setColumnCount(self, value : int) -> None:
        '''Represents the number of columns to display in a ComboBox or ListBox.
        :param value: '''
        raise NotImplementedError()

    def getDropButtonStyle(self) -> int:
        '''Specifies the symbol displayed on the drop button
        See :class:`DropButtonStyle`'''
        raise NotImplementedError()

    def setMatchEntry(self, value : int) -> None:
        '''Indicates how a ListBox or ComboBox searches its list as the user types.
        See :class:`ControlMatchEntryType`
        :param value: '''
        raise NotImplementedError()

    def getBorderStyle(self) -> int:
        '''Gets the type of border used by the control.
        See :class:`ControlBorderType`'''
        raise NotImplementedError()

    def getSelectionMargin(self) -> bool:
        '''Indicates whether the user can select a line of text by clicking in the region to the left of the text.'''
        raise NotImplementedError()

    def setShowDropButtonTypeWhen(self, value : int) -> None:
        '''Specifies the symbol displayed on the drop button
        See :class:`ShowDropButtonType`
        :param value: '''
        raise NotImplementedError()

    def getSpecialEffect(self) -> int:
        '''Gets the special effect of the control.
        See :class:`ControlSpecialEffectType`'''
        raise NotImplementedError()

    def isDragBehaviorEnabled(self) -> bool:
        '''Indicates whether dragging and dropping is enabled for the control.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()

    def setListStyle(self, value : int) -> None:
        '''Sets the visual appearance.
        See :class:`ControlListStyle`
        :param value: '''
        raise NotImplementedError()

    def getColumnCount(self) -> int:
        '''Represents the number of columns to display in a ComboBox or ListBox.'''
        raise NotImplementedError()

    def setEnterFieldBehavior(self, value : bool) -> None:
        '''Specifies selection behavior when entering the control.
        True specifies that the selection remains unchanged from last time the control was active.
        False specifies that all the text in the control will be selected when entering the control.
        :param value: '''
        raise NotImplementedError()

    def setDragBehaviorEnabled(self, value : bool) -> None:
        '''Indicates whether dragging and dropping is enabled for the control.
        :param value: '''
        raise NotImplementedError()

    def setDropButtonStyle(self, value : int) -> None:
        '''Specifies the symbol displayed on the drop button
        See :class:`DropButtonStyle`
        :param value: '''
        raise NotImplementedError()

    def setColumnWidths(self, value : int) -> None:
        '''Sets the width of the column.
        :param value: '''
        raise NotImplementedError()

    def setValue(self, value : str) -> None:
        '''Sets the value of the control.
        :param value: '''
        raise NotImplementedError()

    def getBorderOleColor(self) -> int:
        '''Gets the ole color of the background.'''
        raise NotImplementedError()

    def setSelectionMargin(self, value : bool) -> None:
        '''Indicates whether the user can select a line of text by clicking in the region to the left of the text.
        :param value: '''
        raise NotImplementedError()

    def getHideSelection(self) -> bool:
        '''Indicates whether selected text in the control appears highlighted when the control does not have focus.'''
        raise NotImplementedError()

    def getTextColumn(self) -> int:
        '''Represents the column in a ComboBox or ListBox to display to the user.'''
        raise NotImplementedError()

    def setListWidth(self, value : int) -> None:
        '''Sets the width in unit of points.
        :param value: '''
        raise NotImplementedError()

    def getValue(self) -> str:
        '''Gets the value of the control.'''
        raise NotImplementedError()

    def setMaxLength(self, value : int) -> None:
        '''Sets the maximum number of characters
        :param value: '''
        raise NotImplementedError()

    def getShowDropButtonTypeWhen(self) -> int:
        '''Specifies the symbol displayed on the drop button
        See :class:`ShowDropButtonType`'''
        raise NotImplementedError()

    def isAutoWordSelected(self) -> bool:
        '''Specifies the basic unit used to extend a selection.
        True specifies that the basic unit is a single character.
        false specifies that the basic unit is a whole word.'''
        raise NotImplementedError()

    def setEditable(self, value : bool) -> None:
        '''Indicates whether the user can type into the control.
        :param value: '''
        raise NotImplementedError()

    def getEnterFieldBehavior(self) -> bool:
        '''Specifies selection behavior when entering the control.
        True specifies that the selection remains unchanged from last time the control was active.
        False specifies that all the text in the control will be selected when entering the control.'''
        raise NotImplementedError()

    def getMatchEntry(self) -> int:
        '''Indicates how a ListBox or ComboBox searches its list as the user types.
        See :class:`ControlMatchEntryType`'''
        raise NotImplementedError()

    def getShowColumnHeads(self) -> bool:
        '''Indicates whether column headings are displayed.'''
        raise NotImplementedError()

    def getListRows(self) -> int:
        '''Represents the maximum number of rows to display in the list.'''
        raise NotImplementedError()

    def setBoundColumn(self, value : int) -> None:
        '''Represents how the Value property is determined for a ComboBox or ListBox
        when the MultiSelect properties value (fmMultiSelectSingle).
        :param value: '''
        raise NotImplementedError()


class CommandButtonActiveXControl:
    '''Represents a command button.'''

    def setPicturePosition(self, value : int) -> None:
        '''Sets the location of the control's picture relative to its caption.
        See :class:`ControlPicturePositionType`
        :param value: '''
        raise NotImplementedError()

    def getAccelerator(self) -> str:
        '''Gets the accelerator key for the control.'''
        raise NotImplementedError()

    def getPicturePosition(self) -> int:
        '''Gets the location of the control's picture relative to its caption.
        See :class:`ControlPicturePositionType`'''
        raise NotImplementedError()

    def setPicture(self, value : list[int]) -> None:
        '''Sets the data of the picture.
        :param value: '''
        raise NotImplementedError()

    def getPicture(self) -> list[int]:
        '''Gets the data of the picture.'''
        raise NotImplementedError()

    def setCaption(self, value : str) -> None:
        '''Sets the descriptive text that appears on a control.
        :param value: '''
        raise NotImplementedError()

    def getTakeFocusOnClick(self) -> bool:
        '''Indicates whether the control takes the focus when clicked.'''
        raise NotImplementedError()

    def getCaption(self) -> str:
        '''Gets the descriptive text that appears on a control.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()

    def setAccelerator(self, value : str) -> None:
        '''Sets the accelerator key for the control.
        :param value: '''
        raise NotImplementedError()

    def setWordWrapped(self, value : bool) -> None:
        '''Indicates whether the contents of the control automatically wrap at the end of a line.
        :param value: '''
        raise NotImplementedError()

    def isWordWrapped(self) -> bool:
        '''Indicates whether the contents of the control automatically wrap at the end of a line.'''
        raise NotImplementedError()

    def setTakeFocusOnClick(self, value : bool) -> None:
        '''Indicates whether the control takes the focus when clicked.
        :param value: '''
        raise NotImplementedError()


class Comment:
    '''Encapsulates the object that represents a cell comment.'''

    def setHeightCM(self, value : int) -> None:
        '''Represents the height of the comment, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Represents if the comment is visible or not.'''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets the row index of the comment.'''
        raise NotImplementedError()

    def setTextOrientationType(self, value : int) -> None:
        '''Sets the text orientation type of the comment.
        See :class:`TextOrientationType`
        :param value: '''
        raise NotImplementedError()

    def characters(self, startIndex : int, length : int) -> FontSetting:
        '''Returns a Characters object that represents a range of characters within the comment text.
        :param startIndex: The index of the start of the character.
        :param length: The number of characters.
        :returns: Characters object.'''
        raise NotImplementedError()

    def getHtmlNote(self) -> str:
        '''Gets the html string which contains data and some formats in this comment.'''
        raise NotImplementedError()

    def getAutoSize(self) -> bool:
        '''Indicates if size of comment is adjusted automatically according to its content.'''
        raise NotImplementedError()

    def getTextHorizontalAlignment(self) -> int:
        '''Gets the text horizontal alignment type of the comment.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def getColumn(self) -> int:
        '''Gets the column index of the comment.'''
        raise NotImplementedError()

    def isThreadedComment(self) -> bool:
        '''Indicates whether this comment is a threaded comment.'''
        raise NotImplementedError()

    def setVisible(self, value : bool) -> None:
        '''Represents if the comment is visible or not.
        :param value: '''
        raise NotImplementedError()

    def getFont(self) -> Font:
        '''Gets the font of comment.'''
        raise NotImplementedError()

    def setTextVerticalAlignment(self, value : int) -> None:
        '''Sets the text vertical alignment type of the comment.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getWidthInch(self) -> int:
        '''Represents the width of the comment, in unit of inches.'''
        raise NotImplementedError()

    def getWidthCM(self) -> int:
        '''Represents the width of the comment, in unit of centimeters.'''
        raise NotImplementedError()

    def getTextOrientationType(self) -> int:
        '''Gets the text orientation type of the comment.
        See :class:`TextOrientationType`'''
        raise NotImplementedError()

    def getHeightInch(self) -> int:
        '''Represents the height of the comment, in unit of inches.'''
        raise NotImplementedError()

    def setHtmlNote(self, value : str) -> None:
        '''Sets the html string which contains data and some formats in this comment.
        :param value: '''
        raise NotImplementedError()

    def getTextVerticalAlignment(self) -> int:
        '''Gets the text vertical alignment type of the comment.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def getThreadedComments(self) -> ThreadedCommentCollection:
        '''Gets the list of threaded comments;'''
        raise NotImplementedError()

    def setAutoSize(self, value : bool) -> None:
        '''Indicates if size of comment is adjusted automatically according to its content.
        :param value: '''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Represents the Height of the comment, in unit of pixels.'''
        raise NotImplementedError()

    def setHeight(self, value : int) -> None:
        '''Represents the Height of the comment, in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def getAuthor(self) -> str:
        '''Gets Name of the original comment author'''
        raise NotImplementedError()

    def getCommentShape(self) -> CommentShape:
        '''Get a Shape object that represents the shape attached to the specified comment.'''
        raise NotImplementedError()

    def getHeightCM(self) -> int:
        '''Represents the height of the comment, in unit of centimeters.'''
        raise NotImplementedError()

    def getCharacters(self) -> list:
        ''':deprecated: Use Comment.GetRichFormattings() instead.'''
        raise NotImplementedError()

    def getNote(self) -> str:
        '''Represents the content of comment.'''
        raise NotImplementedError()

    def setHeightInch(self, value : int) -> None:
        '''Represents the height of the comment, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def setAuthor(self, value : str) -> None:
        '''Sets Name of the original comment author
        :param value: '''
        raise NotImplementedError()

    def setWidth(self, value : int) -> None:
        '''Represents the width of the comment, in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def setNote(self, value : str) -> None:
        '''Represents the content of comment.
        :param value: '''
        raise NotImplementedError()

    def setWidthInch(self, value : int) -> None:
        '''Represents the width of the comment, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def setTextHorizontalAlignment(self, value : int) -> None:
        '''Sets the text horizontal alignment type of the comment.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Represents the width of the comment, in unit of pixels.'''
        raise NotImplementedError()

    def setWidthCM(self, value : int) -> None:
        '''Represents the width of the comment, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def formatCharacters(self, startIndex : int, length : int, font : Font, flag : StyleFlag) -> None:
        '''Format some characters with the font setting.
        :param startIndex: The start index.
        :param length: The length.
        :param font: The font setting.
        :param flag: The flag of the font setting.'''
        raise NotImplementedError()

    def getRichFormattings(self) -> list[FontSetting]:
        '''Returns all Characters objects
        that represents a range of characters within the comment text.'''
        raise NotImplementedError()


class CommentCollection:
    '''Encapsulates a collection of :class:`Comment` objects.'''

    def clear(self) -> None:
        '''Removes all comments;'''
        raise NotImplementedError()

    @overload
    def removeAt(self, cellName : str) -> None:
        '''Removes the comment of the specific cell.
        :param cellName: The name of cell which contains a comment.'''
        raise NotImplementedError()

    @overload
    def removeAt(self, row : int, column : int) -> None:
        '''Removes the comment of the specific cell.
        :param row: The row index.
        :param column: the column index.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> Comment:
        '''Gets the :class:`Comment` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def get(self, cellName : str) -> Comment:
        '''Gets the :class:`Comment` element at the specified cell.
        :param cellName: Cell name.
        :returns: The element at the specified cell.'''
        raise NotImplementedError()

    @overload
    def get(self, row : int, column : int) -> Comment:
        '''Gets the :class:`Comment` element at the specified row index and column index.
        :param row: Row index.
        :param column: Column index.
        :returns: The element at the specified cell.'''
        raise NotImplementedError()

    @overload
    def addThreadedComment(self, row : int, column : int, text : str, author : ThreadedCommentAuthor) -> int:
        '''Adds a threaded comment.
        :param row: Cell row index.
        :param column: Cell column index.
        :param text: The text of the comment
        :param author: The user of this threaded comment.
        :returns: :class:`ThreadedComment` object index.'''
        raise NotImplementedError()

    @overload
    def addThreadedComment(self, cellName : str, text : str, author : ThreadedCommentAuthor) -> int:
        '''Adds a threaded comment.
        :param cellName: The name of the cell.
        :param text: The text of the comment
        :param author: The user of this threaded comment.
        :returns: :class:`ThreadedComment` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, row : int, column : int) -> int:
        '''Adds a comment to the collection.
        :param row: Cell row index.
        :param column: Cell column index.
        :returns: :class:`Comment` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, cellName : str) -> int:
        '''Adds a comment to the collection.
        :param cellName: Cell name.
        :returns: :class:`Comment` object index.'''
        raise NotImplementedError()

    @overload
    def getThreadedComments(self, row : int, column : int) -> ThreadedCommentCollection:
        '''Gets the threaded comments by row and column index.
        :param row: The row index.
        :param column: The column index.'''
        raise NotImplementedError()

    @overload
    def getThreadedComments(self, cellName : str) -> ThreadedCommentCollection:
        '''Gets the threaded comments by cell name.
        :param cellName: The name of the cell.'''
        raise NotImplementedError()


class CommentShape:
    '''Represents the shape of the comment.'''

    def getComment(self) -> Comment:
        '''Gets the comment object.'''
        raise NotImplementedError()


class CommentTitleType:
    '''Represents comment title type while rendering when comment is set to display at end of sheet.'''

    CELL : CommentTitleType
    '''Represents comment title cell.'''

    COMMENT : CommentTitleType
    '''Represents comment title comment.'''

    NOTE : CommentTitleType
    '''Represents comment title note.'''

    REPLY : CommentTitleType
    '''Represents comment title reply.'''


class ConditionalFormattingCollection:
    '''Encapsulates a collection of :class:`FormatCondition` objects.'''

    def get(self, index : int) -> FormatConditionCollection:
        '''Gets the FormatConditions element at the specified index.
        :param index: The zero based index of the element.'''
        raise NotImplementedError()

    def add(self) -> int:
        '''Adds a FormatConditions to the collection.'''
        raise NotImplementedError()

    def removeArea(self, startRow : int, startColumn : int, totalRows : int, totalColumns : int) -> None:
        '''Remove all conditional formatting in the range.
        :param startRow: The start row of the range.
        :param startColumn: The start column of the range.
        :param totalRows: The number of rows of the range.
        :param totalColumns: The number of columns of the range.'''
        raise NotImplementedError()

    def copy(self, cfs : ConditionalFormattingCollection) -> None:
        '''Copies conditional formatting.
        :param cfs: The conditional formatting'''
        raise NotImplementedError()


class ConditionalFormattingIcon:
    '''Represents  the custom  icon of conditional formatting rule.'''

    def setIndex(self, value : int) -> None:
        '''Sets the icon's index in the icon set.
        :param value: '''
        raise NotImplementedError()

    def getIconImageData(self, type : int, index : int) -> list[int]:
        '''Get the icon set data
        :param type: :class:`IconSetType`. icon's type
        :param index: icon's index'''
        raise NotImplementedError()

    @overload
    def getImageData(self, cell : Cell) -> list[int]:
        '''Gets the image data with the setting of cell.
        :param cell: The setting of cell.
        :returns: Returns the image data of icon.'''
        raise NotImplementedError()

    @overload
    def getImageData(self) -> list[int]:
        '''Gets the icon set data.'''
        raise NotImplementedError()

    def getIndex(self) -> int:
        '''Gets the icon's index in the icon set.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the icon set type.
        See :class:`IconSetType`'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets the icon set type.
        See :class:`IconSetType`
        :param value: '''
        raise NotImplementedError()


class ConditionalFormattingIconCollection:
    '''Represents  a collection of :class:`ConditionalFormattingIcon` objects.'''

    def get(self, index : int) -> ConditionalFormattingIcon:
        '''Gets the ConditionalFormattingIcon element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def add(self, type : int, index : int) -> int:
        '''Adds :class:`ConditionalFormattingIcon` object.
        :param type: :class:`IconSetType`. The value type.
        :param index: The Index.
        :returns: Returns the index of new object in the list.'''
        raise NotImplementedError()

    @overload
    def add(self, cficon : ConditionalFormattingIcon) -> int:
        '''Adds :class:`ConditionalFormattingIcon` object.
        :param cficon: Returns the index of new object in the list.'''
        raise NotImplementedError()


class ConditionalFormattingResult:
    '''Represents the result of conditional formatting which applies to a cell.'''

    def getConditionalFormattingDataBar(self) -> DataBar:
        '''Gets the DataBar object.'''
        raise NotImplementedError()

    def getConditionalFormattingColorScale(self) -> ColorScale:
        '''Gets the ColorScale object.'''
        raise NotImplementedError()

    def getConditionalFormattingIcon(self) -> ConditionalFormattingIcon:
        '''Gets the image of icon set.'''
        raise NotImplementedError()

    def getConditionalStyle(self) -> Style:
        '''Gets the conditional result style.'''
        raise NotImplementedError()

    def getColorScaleResult(self) -> Color:
        '''Gets the display color of color scale.'''
        raise NotImplementedError()


class ConditionalFormattingValue:
    '''Describes the values of the interpolation points in a gradient scale, dataBar or iconSet.'''

    def isGTE(self) -> bool:
        '''Gets the Greater Than Or Equal flag.
        Use only for icon sets, determines whether this threshold value uses
        the greater than or equal to operator.
        'false' indicates 'greater than' is used instead of 'greater than or equal to'.
        Default value is true.'''
        raise NotImplementedError()

    def getValue(self) -> Object:
        '''Gets the value of this conditional formatting value object.
        It should be used in conjunction with Type.'''
        raise NotImplementedError()

    def setGTE(self, value : bool) -> None:
        '''Sets the Greater Than Or Equal flag.
        Use only for icon sets, determines whether this threshold value uses
        the greater than or equal to operator.
        'false' indicates 'greater than' is used instead of 'greater than or equal to'.
        Default value is true.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of this conditional formatting value object.
        Setting the type to FormatConditionValueType.Min or FormatConditionValueType.Max
        will auto set "Value" to null.
        See :class:`FormatConditionValueType`'''
        raise NotImplementedError()

    def setValue(self, value : Object) -> None:
        '''Sets the value of this conditional formatting value object.
        It should be used in conjunction with Type.
        :param value: '''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets the type of this conditional formatting value object.
        Setting the type to FormatConditionValueType.Min or FormatConditionValueType.Max
        will auto set "Value" to null.
        See :class:`FormatConditionValueType`
        :param value: '''
        raise NotImplementedError()


class ConditionalFormattingValueCollection:
    '''Describes a collection of CFValueObject.
    Use only for icon sets.'''

    def get(self, index : int) -> ConditionalFormattingValue:
        '''Get the CFValueObject element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    def add(self, type : int, value : str) -> int:
        '''Adds :class:`ConditionalFormattingValue` object.
        :param type: :class:`FormatConditionValueType`. The value type.
        :param value: The value.
        :returns: Returns the index of new object in the list.'''
        raise NotImplementedError()


class ConnectionDataSourceType:
    '''Specifies external database source type'''

    ODBC_BASED_SOURCE : ConnectionDataSourceType
    '''ODBC-based source'''

    DAO_BASED_SOURCE : ConnectionDataSourceType
    '''DAO-based source'''

    FILE_BASED_DATA_BASE_SOURCE : ConnectionDataSourceType
    '''File based database source'''

    WEB_QUERY : ConnectionDataSourceType
    '''Web query'''

    OLEDB_BASED_SOURCE : ConnectionDataSourceType
    '''OLE DB-based source'''

    TEXT_BASED_SOURCE : ConnectionDataSourceType
    '''Text-based source'''

    ADO_RECORD_SET : ConnectionDataSourceType
    '''ADO record set'''

    DSP : ConnectionDataSourceType
    '''DSP'''

    OLEDB_DATA_MODEL : ConnectionDataSourceType
    '''OLE DB data source created by the Spreadsheet Data Model.'''

    DATA_FEED_DATA_MODEL : ConnectionDataSourceType
    '''Data feed data source created by the Spreadsheet Data Model.'''

    WORKSHEET_DATA_MODEL : ConnectionDataSourceType
    '''Worksheet data source created by the Spreadsheet Data Model.'''

    TABLE : ConnectionDataSourceType
    '''Worksheet data source created by the Spreadsheet Data Model.'''

    TEXT_DATA_MODEL : ConnectionDataSourceType
    '''Text data source created by the Spreadsheet Data Model.'''

    UNKNOWN : ConnectionDataSourceType
    '''Text data source created by the Spreadsheet Data Model.'''


class ConnectionParameter:
    '''Specifies properties about any parameters used with external data connections
    Parameters are valid for ODBC and web queries.'''

    def getName(self) -> str:
        '''The name of the parameter.'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Type of parameter used.
        If the parameterType=value, then the value from boolean, double, integer,
        or string will be used.  In this case, it is expected that only one of
        {boolean, double, integer, or string} will be specified.
        See :class:`ConnectionParameterType`
        :param value: '''
        raise NotImplementedError()

    def setCellReference(self, value : str) -> None:
        '''Cell reference indicating which cell's value to use for the query parameter. Used only when parameterType is cell.
        :param value: '''
        raise NotImplementedError()

    def setValue(self, value : Object) -> None:
        '''Non-integer numeric value,Integer value,String value or Boolean value
        to use as the query parameter. Used only when parameterType is value.
        :param value: '''
        raise NotImplementedError()

    def getValue(self) -> Object:
        '''Non-integer numeric value,Integer value,String value or Boolean value
        to use as the query parameter. Used only when parameterType is value.'''
        raise NotImplementedError()

    def getCellReference(self) -> str:
        '''Cell reference indicating which cell's value to use for the query parameter. Used only when parameterType is cell.'''
        raise NotImplementedError()

    def setSqlType(self, value : int) -> None:
        '''SQL data type of the parameter. Only valid for ODBC sources.
        See :class:`SqlDataType`
        :param value: '''
        raise NotImplementedError()

    def getRefreshOnChange(self) -> bool:
        '''Flag indicating whether the query should automatically refresh when the contents of a
        cell that provides the parameter value changes. If true, then external data is refreshed
        using the new parameter value every time there's a change. If false, then external data
        is only refreshed when requested by the user, or some other event triggers refresh (e.g., workbook opened).'''
        raise NotImplementedError()

    def getSqlType(self) -> int:
        '''SQL data type of the parameter. Only valid for ODBC sources.
        See :class:`SqlDataType`'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''The name of the parameter.
        :param value: '''
        raise NotImplementedError()

    def setRefreshOnChange(self, value : bool) -> None:
        '''Flag indicating whether the query should automatically refresh when the contents of a
        cell that provides the parameter value changes. If true, then external data is refreshed
        using the new parameter value every time there's a change. If false, then external data
        is only refreshed when requested by the user, or some other event triggers refresh (e.g., workbook opened).
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Type of parameter used.
        If the parameterType=value, then the value from boolean, double, integer,
        or string will be used.  In this case, it is expected that only one of
        {boolean, double, integer, or string} will be specified.
        See :class:`ConnectionParameterType`'''
        raise NotImplementedError()

    def getPrompt(self) -> str:
        '''Prompt string for the parameter. Presented to the spreadsheet user along with input UI
        to collect the parameter value before refreshing the external data. Used only when
        parameterType = prompt.'''
        raise NotImplementedError()

    def setPrompt(self, value : str) -> None:
        '''Prompt string for the parameter. Presented to the spreadsheet user along with input UI
        to collect the parameter value before refreshing the external data. Used only when
        parameterType = prompt.
        :param value: '''
        raise NotImplementedError()


class ConnectionParameterCollection:
    '''Specifies the :class:`ConnectionParameter` collection'''

    @overload
    def get(self, index : int) -> ConnectionParameter:
        '''Gets the :class:`ConnectionParameter` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def get(self, connParamName : str) -> ConnectionParameter:
        '''Gets the :class:`ConnectionParameter` element with the specified name.
        :param connParamName: connection parameter name
        :returns: The element with the specified name.'''
        raise NotImplementedError()


class ConnectionParameterType:
    '''Specifies the parameter type of external connection'''

    CELL : ConnectionParameterType
    '''Get the parameter value from a cell on each refresh.'''

    PROMPT : ConnectionParameterType
    '''Prompt the user on each refresh for a parameter value.'''

    VALUE : ConnectionParameterType
    '''Use a constant value on each refresh for the parameter value.'''


class ConsolidationFunction:
    '''Represents consolidation function.'''

    SUM : ConsolidationFunction
    '''Represents Sum function.'''

    COUNT : ConsolidationFunction
    '''Represents Count function.'''

    AVERAGE : ConsolidationFunction
    '''Represents Average function.'''

    MAX : ConsolidationFunction
    '''Represents Max function.'''

    MIN : ConsolidationFunction
    '''Represents Min function.'''

    PRODUCT : ConsolidationFunction
    '''Represents Product function.'''

    COUNT_NUMS : ConsolidationFunction
    '''Represents Count Nums function.'''

    STD_DEV : ConsolidationFunction
    '''Represents StdDev function.'''

    STD_DEVP : ConsolidationFunction
    '''Represents StdDevp function.'''

    VAR : ConsolidationFunction
    '''Represents Var function.'''

    VARP : ConsolidationFunction
    '''Represents Varp function.'''

    DISTINCT_COUNT : ConsolidationFunction
    '''Represents Distinct Count function.'''


class ContentTypeProperty:
    '''Represents identifier information.'''

    def setNillable(self, value : bool) -> None:
        '''Indicates whether the value could be empty.
        :param value: '''
        raise NotImplementedError()

    def getValue(self) -> str:
        '''Returns or sets the value of the content type property.'''
        raise NotImplementedError()

    def isNillable(self) -> bool:
        '''Indicates whether the value could be empty.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Returns or sets the name of the object.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Returns or sets the name of the object.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> str:
        '''Gets the type of the property.'''
        raise NotImplementedError()

    def setValue(self, value : str) -> None:
        '''Returns or sets the value of the content type property.
        :param value: '''
        raise NotImplementedError()

    def setType(self, value : str) -> None:
        '''Sets the type of the property.
        :param value: '''
        raise NotImplementedError()


class ContentTypePropertyCollection:
    '''A collection of :class:`ContentTypeProperty` objects that represent additional information.'''

    @overload
    def get(self, index : int) -> ContentTypeProperty:
        '''Gets the content type property by the specific index.
        :param index: The index.
        :returns: The content type property'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> ContentTypeProperty:
        '''Gets the content type property by the property name.
        :param name: The property name.
        :returns: The content type property'''
        raise NotImplementedError()

    @overload
    def add(self, name : str, value : str) -> int:
        '''Adds content type property information.
        :param name: The name of the content type property.
        :param value: The value of the content type property.'''
        raise NotImplementedError()

    @overload
    def add(self, name : str, value : str, type : str) -> int:
        '''Adds content type property information.
        :param name: The name of the content type property.
        :param value: The value of the content type property.
        :param type: The type of the content type property.'''
        raise NotImplementedError()


class ControlBorderType:
    '''Represents the border type of the ActiveX control.'''

    NONE : ControlBorderType
    '''No border.'''

    SINGLE : ControlBorderType
    '''The single line.'''


class ControlCaptionAlignmentType:
    '''Represents the position of the Caption relative to the control.'''

    LEFT : ControlCaptionAlignmentType
    '''The left of the control.'''

    RIGHT : ControlCaptionAlignmentType
    '''The right of the control.'''


class ControlListStyle:
    '''Represents the visual appearance of the list in a ListBox or ComboBox.'''

    PLAIN : ControlListStyle
    '''Displays a list in which the background of an item is highlighted when it is selected.'''

    OPTION : ControlListStyle
    '''Displays a list in which an option button or a checkbox next to each entry displays the selection state of that item.'''


class ControlMatchEntryType:
    '''Represents how a ListBox or ComboBox searches its list as the user types.'''

    FIRST_LETTER : ControlMatchEntryType
    '''The control searches for the next entry that starts with the character entered.
    Repeatedly typing the same letter cycles through all entries beginning with that letter.'''

    COMPLETE : ControlMatchEntryType
    '''As each character is typed, the control searches for an entry matching all characters entered.'''

    NONE : ControlMatchEntryType
    '''The list will not be searched when characters are typed.'''


class ControlMousePointerType:
    '''Represents the type of icon displayed as the mouse pointer for the control.'''

    DEFAULT : ControlMousePointerType
    '''Standard pointer.'''

    ARROW : ControlMousePointerType
    '''Arrow.'''

    CROSS : ControlMousePointerType
    '''Cross-hair pointer.'''

    I_BEAM : ControlMousePointerType
    '''I-beam.'''

    SIZE_NESW : ControlMousePointerType
    '''Double arrow pointing northeast and southwest.'''

    SIZE_NS : ControlMousePointerType
    '''Double arrow pointing north and south.'''

    SIZE_NWSE : ControlMousePointerType
    '''Double arrow pointing northwest and southeast.'''

    SIZE_WE : ControlMousePointerType
    '''Double arrow pointing west and east.'''

    UP_ARROW : ControlMousePointerType
    '''Up arrow.'''

    HOUR_GLASS : ControlMousePointerType
    '''Hourglass.'''

    NO_DROP : ControlMousePointerType
    '''"Not?symbol (circle with a diagonal line) on top of the object being dragged.'''

    APP_STARTING : ControlMousePointerType
    '''Arrow with an hourglass.'''

    HELP : ControlMousePointerType
    '''Arrow with a question mark.'''

    SIZE_ALL : ControlMousePointerType
    '''"Size-all?cursor (arrows pointing north, south, east, and west).'''

    CUSTOM : ControlMousePointerType
    '''Uses the icon specified by the MouseIcon property.'''


class ControlPictureAlignmentType:
    '''Represents the alignment of the picture inside the Form or Image.'''

    TOP_LEFT : ControlPictureAlignmentType
    '''The top left corner.'''

    TOP_RIGHT : ControlPictureAlignmentType
    '''The top right corner.'''

    CENTER : ControlPictureAlignmentType
    '''The center.'''

    BOTTOM_LEFT : ControlPictureAlignmentType
    '''The bottom left corner.'''

    BOTTOM_RIGHT : ControlPictureAlignmentType
    '''The bottom right corner.'''


class ControlPicturePositionType:
    '''Represents the location of the control's picture relative to its caption.'''

    LEFT_TOP : ControlPicturePositionType
    '''The picture appears to the left of the caption.
    The caption is aligned with the top of the picture.'''

    LEFT_CENTER : ControlPicturePositionType
    '''The picture appears to the left of the caption.
    The caption is centered relative to the picture.'''

    LEFT_BOTTOM : ControlPicturePositionType
    '''The picture appears to the left of the caption.
    The caption is aligned with the bottom of the picture.'''

    RIGHT_TOP : ControlPicturePositionType
    '''The picture appears to the right of the caption.
    The caption is aligned with the top of the picture.'''

    RIGHT_CENTER : ControlPicturePositionType
    '''The picture appears to the right of the caption.
    The caption is centered relative to the picture.'''

    RIGHT_BOTTOM : ControlPicturePositionType
    '''The picture appears to the right of the caption.
    The caption is aligned with the bottom of the picture.'''

    ABOVE_LEFT : ControlPicturePositionType
    '''The picture appears above the caption.
    The caption is aligned with the left edge of the picture.'''

    ABOVE_CENTER : ControlPicturePositionType
    '''The picture appears above the caption.
    The caption is centered below the picture.'''

    ABOVE_RIGHT : ControlPicturePositionType
    '''The picture appears above the caption.
    The caption is aligned with the right edge of the picture.'''

    BELOW_LEFT : ControlPicturePositionType
    '''The picture appears below the caption.
    The caption is aligned with the left edge of the picture.'''

    BELOW_CENTER : ControlPicturePositionType
    '''The picture appears below the caption.
    The caption is centered above the picture.'''

    BELOW_RIGHT : ControlPicturePositionType
    '''The picture appears below the caption.
    The caption is aligned with the right edge of the picture.'''

    CENTER : ControlPicturePositionType
    '''The picture appears in the center of the control.
    The caption is centered horizontally and vertically on top of the picture.'''


class ControlPictureSizeMode:
    '''Represents how to display the picture.'''

    CLIP : ControlPictureSizeMode
    '''Crops any part of the picture that is larger than the control's boundaries.'''

    STRETCH : ControlPictureSizeMode
    '''Stretches the picture to fill the control's area.
    This setting distorts the picture in either the horizontal or vertical direction.'''

    ZOOM : ControlPictureSizeMode
    '''Enlarges the picture, but does not distort the picture in either the horizontal or vertical direction.'''


class ControlScrollBarType:
    '''Represents the type of scroll bar.'''

    NONE : ControlScrollBarType
    '''Displays no scroll bars.'''

    HORIZONTAL : ControlScrollBarType
    '''Displays a horizontal scroll bar.'''

    BARS_VERTICAL : ControlScrollBarType
    '''Displays a vertical scroll bar.'''

    BARS_BOTH : ControlScrollBarType
    '''Displays both a horizontal and a vertical scroll bar.'''


class ControlScrollOrientation:
    '''Represents type of scroll orientation'''

    AUTO : ControlScrollOrientation
    '''Control is rendered horizontally when the control's width is greater than its height.
    Control is rendered vertically otherwise.'''

    VERTICAL : ControlScrollOrientation
    '''Control is rendered vertically.'''

    HORIZONTAL : ControlScrollOrientation
    '''Control is rendered horizontally.'''


class ControlSpecialEffectType:
    '''Represents the type of special effect.'''

    FLAT : ControlSpecialEffectType
    '''Flat'''

    RAISED : ControlSpecialEffectType
    '''Raised'''

    SUNKEN : ControlSpecialEffectType
    '''Sunken'''

    ETCHED : ControlSpecialEffectType
    '''Etched'''

    BUMP : ControlSpecialEffectType
    '''Bump'''


class ControlType:
    '''Represents all type of ActiveX control.'''

    COMMAND_BUTTON : ControlType
    '''Button'''

    COMBO_BOX : ControlType
    '''ComboBox'''

    CHECK_BOX : ControlType
    '''CheckBox'''

    LIST_BOX : ControlType
    '''ListBox'''

    TEXT_BOX : ControlType
    '''TextBox'''

    SPIN_BUTTON : ControlType
    '''Spinner'''

    RADIO_BUTTON : ControlType
    '''RadioButton'''

    LABEL : ControlType
    '''Label'''

    IMAGE : ControlType
    '''Image'''

    TOGGLE_BUTTON : ControlType
    '''ToggleButton'''

    SCROLL_BAR : ControlType
    '''ScrollBar'''

    BAR_CODE : ControlType
    '''ScrollBar'''

    UNKNOWN : ControlType
    '''Unknown'''


class ConversionUtility:
    '''Represents utility to convert files to other formats.'''

    @overload
    def convert(self, source : str, saveAs : str) -> None:
        '''Converts Excel files to other formats.
        :param source: The source file name.
        :param saveAs: The file name of expected file.'''
        raise NotImplementedError()

    @overload
    def convert(self, source : str, loadOptions : LoadOptions, saveAs : str, saveOptions : SaveOptions) -> None:
        '''Converts Excel files to other formats.
        :param source: The source file name.
        :param loadOptions: The options of loading the source file.
        :param saveAs: The file name of expected file.
        :param saveOptions: The options of saving the file.'''
        raise NotImplementedError()


class CopyFormatType:
    '''Represents type of copying format when inserting rows.'''

    SAME_AS_ABOVE : CopyFormatType
    '''Formats same as above row.'''

    SAME_AS_BELOW : CopyFormatType
    '''Formats same as below row.'''

    CLEAR : CopyFormatType
    '''Clears formatting.'''


class CopyOptions:
    '''Represents the copy options.'''

    def getReferToDestinationSheet(self) -> bool:
        '''When copying the range in the same file and the chart refers to the source sheet,
        False means the copied chart's data source will not be changed.
        True means the copied chart's data source refers to the destination sheet.'''
        raise NotImplementedError()

    def setReferToDestinationSheet(self, value : bool) -> None:
        '''When copying the range in the same file and the chart refers to the source sheet,
        False means the copied chart's data source will not be changed.
        True means the copied chart's data source refers to the destination sheet.
        :param value: '''
        raise NotImplementedError()

    def setExtendToAdjacentRange(self, value : bool) -> None:
        '''Indicates whether extend ranges when copying the range to adjacent range.
        :param value: '''
        raise NotImplementedError()

    def getCopyInvalidFormulasAsValues(self) -> bool:
        '''If the formula is not valid for the dest destination, only copy values.'''
        raise NotImplementedError()

    def getKeepMacros(self) -> bool:
        '''Indicates whether keeping macros;'''
        raise NotImplementedError()

    def setColumnCharacterWidth(self, value : bool) -> None:
        '''Indicates whether copying column width in unit of characters.
        :param value: '''
        raise NotImplementedError()

    def getColumnCharacterWidth(self) -> bool:
        '''Indicates whether copying column width in unit of characters.'''
        raise NotImplementedError()

    def getExtendToAdjacentRange(self) -> bool:
        '''Indicates whether extend ranges when copying the range to adjacent range.'''
        raise NotImplementedError()

    def setCopyNames(self, value : bool) -> None:
        '''Indicates whether copying the names.
        :param value: '''
        raise NotImplementedError()

    def getReferToSheetWithSameName(self) -> bool:
        '''In ms excel, when copying formulas which refer to other worksheets while copying a worksheet to another one,
        the copied formulas should refer to source workbook.
        However, for some situations user may need the copied formulas refer to worksheets with the same name
        in the same workbook, such as when those worksheets have been copied before this copy operation,
        then this property should be kept as true.'''
        raise NotImplementedError()

    def setKeepMacros(self, value : bool) -> None:
        '''Indicates whether keeping macros;
        :param value: '''
        raise NotImplementedError()

    def setReferToSheetWithSameName(self, value : bool) -> None:
        '''In ms excel, when copying formulas which refer to other worksheets while copying a worksheet to another one,
        the copied formulas should refer to source workbook.
        However, for some situations user may need the copied formulas refer to worksheets with the same name
        in the same workbook, such as when those worksheets have been copied before this copy operation,
        then this property should be kept as true.
        :param value: '''
        raise NotImplementedError()

    def getCopyNames(self) -> bool:
        '''Indicates whether copying the names.'''
        raise NotImplementedError()

    def setCopyInvalidFormulasAsValues(self, value : bool) -> None:
        '''If the formula is not valid for the dest destination, only copy values.
        :param value: '''
        raise NotImplementedError()


class CountryCode:
    '''Represents Excel country identifiers.'''

    DEFAULT : CountryCode
    ''''''

    USA : CountryCode
    '''United States'''

    CANADA : CountryCode
    '''Canada'''

    LATIN_AMERIC : CountryCode
    '''Latin America, except Brazil'''

    RUSSIA : CountryCode
    '''Russia'''

    EGYPT : CountryCode
    '''Egypt'''

    GREECE : CountryCode
    '''Greece'''

    NETHERLANDS : CountryCode
    '''Netherlands'''

    BELGIUM : CountryCode
    '''Belgium'''

    FRANCE : CountryCode
    '''France'''

    SPAIN : CountryCode
    '''Spain'''

    HUNGARY : CountryCode
    '''Hungary'''

    ITALY : CountryCode
    '''Italy'''

    SWITZERLAND : CountryCode
    '''Switzerland'''

    AUSTRIA : CountryCode
    '''Austria'''

    UNITED_KINGDOM : CountryCode
    '''United Kingdom'''

    DENMARK : CountryCode
    '''Denmark'''

    SWEDEN : CountryCode
    '''Sweden'''

    NORWAY : CountryCode
    '''Norway'''

    POLAND : CountryCode
    '''Poland'''

    GERMANY : CountryCode
    '''Germany'''

    MEXICO : CountryCode
    '''Mexico'''

    BRAZIL : CountryCode
    '''Brazil'''

    AUSTRALIA : CountryCode
    '''Australia'''

    NEW_ZEALAND : CountryCode
    '''New Zealand'''

    THAILAND : CountryCode
    '''Thailand'''

    JAPAN : CountryCode
    '''Japan'''

    SOUTH_KOREA : CountryCode
    '''SouthKorea'''

    VIET_NAM : CountryCode
    '''Viet Nam'''

    CHINA : CountryCode
    '''People's Republic of China'''

    TURKEY : CountryCode
    '''Turkey'''

    INDIA : CountryCode
    '''India'''

    ALGERIA : CountryCode
    '''Algeria'''

    MOROCCO : CountryCode
    '''Morocco'''

    LIBYA : CountryCode
    '''Libya'''

    PORTUGAL : CountryCode
    '''Portugal'''

    ICELAND : CountryCode
    '''Iceland'''

    FINLAND : CountryCode
    '''Finland'''

    CZECH : CountryCode
    '''Czech Republic'''

    TAIWAN : CountryCode
    '''Taiwan'''

    LEBANON : CountryCode
    '''Lebanon'''

    JORDAN : CountryCode
    '''Jordan'''

    SYRIA : CountryCode
    '''Syria'''

    IRAQ : CountryCode
    '''Iraq'''

    KUWAIT : CountryCode
    '''Kuwait'''

    SAUDI : CountryCode
    '''Saudi Arabia'''

    UNITED_ARAB_EMIRATES : CountryCode
    '''United Arab Emirates'''

    ISRAEL : CountryCode
    '''Israel'''

    QATAR : CountryCode
    '''Qatar'''

    IRAN : CountryCode
    '''Iran'''


class CredentialsMethodType:
    '''Specifies Credentials method used for server access.'''

    INTEGRATED : CredentialsMethodType
    '''Integrated Authentication'''

    NONE : CredentialsMethodType
    '''No Credentials'''

    PROMPT : CredentialsMethodType
    '''Prompt Credentials'''

    STORED : CredentialsMethodType
    '''Stored Credentials'''


class CrossType:
    '''Represents the axis cross type.'''

    AUTOMATIC : CrossType
    '''Microsoft Excel sets the axis crossing point.'''

    MAXIMUM : CrossType
    '''The axis crosses at the maximum value.'''

    MINIMUM : CrossType
    '''The axis crosses at the minimum value.'''

    CUSTOM : CrossType
    '''The axis crosses at the custom value.'''


class CustomDocumentPropertyCollection:
    '''A collection of custom document properties.'''

    def updateLinkedPropertyValue(self) -> None:
        '''Update custom document property value which links to content.'''
        raise NotImplementedError()

    def updateLinkedRange(self) -> None:
        '''Update custom document property value to linked range.'''
        raise NotImplementedError()

    def addLinkToContent(self, name : str, source : str) -> DocumentProperty:
        '''Creates a new custom document property which links to content.
        :param name: The name of the property.
        :param source: The source of the property. It should be the name of named range.
        :returns: The newly created property object.'''
        raise NotImplementedError()

    @overload
    def add(self, name : str, value : str) -> DocumentProperty:
        '''Creates a new custom document property of the <b>PropertyType.String</b> data type.
        :param name: The name of the property.
        :param value: The value of the property.
        :returns: The newly created property object.'''
        raise NotImplementedError()

    @overload
    def add(self, name : str, value : int) -> DocumentProperty:
        '''Creates a new custom document property of the <b>PropertyType.Number</b> data type.
        :param name: The name of the property.
        :param value: The value of the property.
        :returns: The newly created property object.'''
        raise NotImplementedError()

    @overload
    def add(self, name : str, value : DateTime) -> DocumentProperty:
        '''Creates a new custom document property of the <b>PropertyType.DateTime</b> data type.
        :param name: The name of the property.
        :param value: The value of the property.
        :returns: The newly created property object.'''
        raise NotImplementedError()

    @overload
    def add(self, name : str, value : bool) -> DocumentProperty:
        '''Creates a new custom document property of the <b>PropertyType.Boolean</b> data type.
        :param name: The name of the property.
        :param value: The value of the property.
        :returns: The newly created property object.'''
        raise NotImplementedError()

    @overload
    def add(self, name : str, value : int) -> DocumentProperty:
        '''Creates a new custom document property of the <b>PropertyType.Float</b> data type.
        :param name: The name of the property.
        :param value: The value of the property.
        :returns: The newly created property object.'''
        raise NotImplementedError()


class CustomFilter:
    '''Represents the custom filter.'''

    @overload
    def setCriteria(self, value : Object) -> None:
        '''Sets the criteria.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setCriteria(self, filterOperator : int, criteria : Object) -> None:
        '''Sets the filter criteria.
        :param filterOperator: :class:`FilterOperatorType`. filter operator type
        :param criteria: filter criteria value'''
        raise NotImplementedError()

    def setFilterOperatorType(self, value : int) -> None:
        '''Sets the filter operator type.
        See :class:`FilterOperatorType`
        :param value: '''
        raise NotImplementedError()

    def getCriteria(self) -> Object:
        '''Gets the criteria.'''
        raise NotImplementedError()

    def getFilterOperatorType(self) -> int:
        '''Gets the filter operator type.
        See :class:`FilterOperatorType`'''
        raise NotImplementedError()


class CustomFilterCollection:
    '''Represents the custom filters.'''

    def get(self, index : int) -> CustomFilter:
        '''Gets the custom filter in the specific index.
        :param index: The index.'''
        raise NotImplementedError()

    def setAnd(self, value : bool) -> None:
        '''Indicates whether the two criteria have an "and" relationship.
        :param value: '''
        raise NotImplementedError()

    def getAnd(self) -> bool:
        '''Indicates whether the two criteria have an "and" relationship.'''
        raise NotImplementedError()


class CustomFunctionDefinition:
    '''Definition of custom function for calculating with user's custom engine.'''

    def getArrayModeParameters(self, functionName : str) -> list[int]:
        '''Gets the indices of given custom function's parameters that need to be calculated in array mode.
        :param functionName: Name of the custom function.
        :returns: Indices of the parameters that need to be calculated in array mode for given custom function. Default is null, there is no parameter which needs to be calculated in array mode for the custom function.'''
        raise NotImplementedError()


class CustomGeometry:
    '''Represents a custom geometric shape.'''

    def getPaths(self) -> ShapePathCollection:
        '''Gets path collection information when shape is a NotPrimitive autoshape'''
        raise NotImplementedError()


class CustomImplementationFactory:
    '''Factory to create some instances which may be re-implemented by user for special purpose.'''

    def createRandomInstance(self) -> Random:
        '''Create one instance of random number generator.'''
        raise NotImplementedError()


class CustomPiovtFieldGroupItem:
    '''Represents an item of custom grouped field.'''


class CustomProperty:
    '''Represents identifier information.'''

    def getStringValue(self) -> str:
        ''':deprecated: Use CustomProperty.Value property instead.'''
        raise NotImplementedError()

    def getValue(self) -> str:
        '''Returns or sets the value of the custom property.'''
        raise NotImplementedError()

    def setStringValue(self, value : str) -> None:
        ''':deprecated: Use CustomProperty.Value property instead.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Returns or sets the name of the object.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Returns or sets the name of the object.
        :param value: '''
        raise NotImplementedError()

    def setValue(self, value : str) -> None:
        '''Returns or sets the value of the custom property.
        :param value: '''
        raise NotImplementedError()


class CustomPropertyCollection:
    '''A collection of :class:`CustomProperty` objects that represent additional information.'''

    @overload
    def get(self, index : int) -> CustomProperty:
        '''Gets the custom property by the specific index.
        :param index: The index.
        :returns: The custom property'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> CustomProperty:
        '''Gets the custom property by the property name.
        :param name: The property name.
        :returns: The custom property'''
        raise NotImplementedError()

    def add(self, name : str, value : str) -> int:
        '''Adds custom property information.
        :param name: The name of the custom property.
        :param value: The value of the custom property.'''
        raise NotImplementedError()


class CustomXmlPart:
    '''Represents a Custom XML Data Storage Part (custom XML data within a package).'''

    def setID(self, value : str) -> None:
        '''Sets the id of the custom xml part.
        :param value: '''
        raise NotImplementedError()

    def getData(self) -> list[int]:
        '''Gets the XML content of this Custom XML Data Storage Part.'''
        raise NotImplementedError()

    def setData(self, value : list[int]) -> None:
        '''Sets the XML content of this Custom XML Data Storage Part.
        :param value: '''
        raise NotImplementedError()

    def setSchemaData(self, value : list[int]) -> None:
        '''Sets the XML content of this Custom XML Schema Data Storage Part.
        :param value: '''
        raise NotImplementedError()

    def getID(self) -> str:
        '''Gets the id of the custom xml part.'''
        raise NotImplementedError()

    def getSchemaData(self) -> list[int]:
        '''Gets the XML content of this Custom XML Schema Data Storage Part.'''
        raise NotImplementedError()


class CustomXmlPartCollection:
    '''Represents a Custom XML Data Storage Part (custom XML data within a package).'''

    def selectByID(self, id : str) -> CustomXmlPart:
        '''Gets an item by id.
        :param id: Contains the GUID for the custom XML part.'''
        raise NotImplementedError()

    def get(self, index : int) -> CustomXmlPart:
        '''Gets an item at the specified index.
        :param index: The index.'''
        raise NotImplementedError()

    def add(self, data : list[int], shemaData : list[int]) -> int:
        '''Adds an item to the collection.
        :param data: The XML content of this Custom XML Data Storage Part.
        :param shemaData: The set of XML schemas that are associated with this custom XML part.'''
        raise NotImplementedError()


class CustomXmlShape:
    '''Represents Custom xml shape ,such as Ink.'''


class DataBar:
    '''Describe the DataBar conditional formatting rule.
    This conditional formatting rule displays a gradated
    data bar in the range of cells.'''

    def setAxisPosition(self, value : int) -> None:
        '''Sets the position of the axis of the data bars specified by a conditional formatting rule.
        See :class:`DataBarAxisPosition`
        :param value: '''
        raise NotImplementedError()

    def getBarBorder(self) -> DataBarBorder:
        '''Gets an object that specifies the border of a data bar.'''
        raise NotImplementedError()

    def setBarFillType(self, value : int) -> None:
        '''Sets how a data bar is filled with color.
        See :class:`DataBarFillType`
        :param value: '''
        raise NotImplementedError()

    def getNegativeBarFormat(self) -> NegativeBarFormat:
        '''Gets the NegativeBarFormat object associated with a data bar conditional formatting rule.'''
        raise NotImplementedError()

    def setColor(self, value : Color) -> None:
        '''Sets this DataBar's Color.
        :param value: '''
        raise NotImplementedError()

    def getMinLength(self) -> int:
        '''Represents the min length of data bar .'''
        raise NotImplementedError()

    def getDirection(self) -> int:
        '''Gets the direction the databar is displayed.
        See :class:`TextDirectionType`'''
        raise NotImplementedError()

    def getAxisColor(self) -> Color:
        '''Gets the color of the axis for cells with conditional formatting as data bars.'''
        raise NotImplementedError()

    def getColor(self) -> Color:
        '''Gets this DataBar's Color.'''
        raise NotImplementedError()

    def getAxisPosition(self) -> int:
        '''Gets the position of the axis of the data bars specified by a conditional formatting rule.
        See :class:`DataBarAxisPosition`'''
        raise NotImplementedError()

    def getShowValue(self) -> bool:
        '''Gets the flag indicating whether to show the values of the cells on which this data bar is applied.
        Default value is true.'''
        raise NotImplementedError()

    def setShowValue(self, value : bool) -> None:
        '''Sets the flag indicating whether to show the values of the cells on which this data bar is applied.
        Default value is true.
        :param value: '''
        raise NotImplementedError()

    def getMaxLength(self) -> int:
        '''Represents the max length of data bar .'''
        raise NotImplementedError()

    def getBarFillType(self) -> int:
        '''Gets how a data bar is filled with color.
        See :class:`DataBarFillType`'''
        raise NotImplementedError()

    def setAxisColor(self, value : Color) -> None:
        '''Gets the color of the axis for cells with conditional formatting as data bars.
        :param value: '''
        raise NotImplementedError()

    def setMinLength(self, value : int) -> None:
        '''Represents the min length of data bar .
        :param value: '''
        raise NotImplementedError()

    def getMinCfvo(self) -> ConditionalFormattingValue:
        '''Gets this DataBar's min value object.
        Cannot set null or CFValueObject with type FormatConditionValueType.Max to it.'''
        raise NotImplementedError()

    def setDirection(self, value : int) -> None:
        '''Sets the direction the databar is displayed.
        See :class:`TextDirectionType`
        :param value: '''
        raise NotImplementedError()

    def getMaxCfvo(self) -> ConditionalFormattingValue:
        '''Gets this DataBar's max value object.
        Cannot set null or CFValueObject with type FormatConditionValueType.Min to it.'''
        raise NotImplementedError()

    def toImage(self, cell : Cell, imgOpts : ImageOrPrintOptions) -> list[int]:
        '''Render data bar in cell to image byte array.
        :param cell: Indicate the data bar in which cell to be rendered
        :param imgOpts: ImageOrPrintOptions contains some property of output image'''
        raise NotImplementedError()

    def setMaxLength(self, value : int) -> None:
        '''Represents the max length of data bar .
        :param value: '''
        raise NotImplementedError()


class DataBarAxisPosition:
    '''Specifies the axis position for a range of cells with conditional formatting as data bars.'''

    AUTOMATIC : DataBarAxisPosition
    '''Display the axis at a variable position based on the ratio of the minimum negative value to the maximum positive value in the range.
    Positive values are displayed in a left-to-right direction.
    Negative values are displayed in a right-to-left direction.
    When all values are positive or all values are negative, no axis is displayed.'''

    MIDPOINT : DataBarAxisPosition
    '''Display the axis at the midpoint of the cell regardless of the set of values in the range.
    Positive values are displayed in a left-to-right direction.
    Negative values are displayed in a right-to-left direction.'''

    NONE : DataBarAxisPosition
    '''No axis is displayed, and both positive and negative values are displayed in the left-to-right direction.'''


class DataBarBorder:
    '''Represents the border of the data bars specified by a conditional formatting rule.'''

    def setColor(self, value : Color) -> None:
        '''Sets the border's color of data bars specified by a conditional formatting rule.
        :param value: '''
        raise NotImplementedError()

    def getColor(self) -> Color:
        '''Gets the border's color of data bars specified by a conditional formatting rule.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the border's type of data bars specified by a conditional formatting rule.
        See :class:`DataBarBorderType`'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets the border's type of data bars specified by a conditional formatting rule.
        See :class:`DataBarBorderType`
        :param value: '''
        raise NotImplementedError()


class DataBarBorderType:
    '''Specifies the border type of a data bar.'''

    NONE : DataBarBorderType
    '''The data bar has no border.'''

    SOLID : DataBarBorderType
    '''The data bar has a solid border.'''


class DataBarFillType:
    '''Specifies how a data bar is filled with color.'''

    SOLID : DataBarFillType
    '''The data bar is filled with solid color.'''

    GRADIENT : DataBarFillType
    '''The data bar is filled with a color gradient.'''


class DataBarNegativeColorType:
    '''Specifies whether to use the same border and fill color as positive data bars.'''

    COLOR : DataBarNegativeColorType
    '''Use the color specified in the Negative Value and Axis Setting dialog box
    or by using the ColorType and BorderColorType properties of the NegativeBarFormat object.'''

    SAME_AS_POSITIVE : DataBarNegativeColorType
    '''Use the same color as positive data bars.'''


class DataLabels:
    '''Encapsulates a collection of all the DataLabel objects for the specified Series.'''

    def getShowBubbleSize(self) -> bool:
        '''Represents a specified chart's data label percentage value display behavior. True displays the percentage value. False to hide.'''
        raise NotImplementedError()

    def getText(self) -> str:
        '''Gets the text of data label.'''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''Sets the text of data label.
        :param value: '''
        raise NotImplementedError()

    def setNumberFormat(self, value : str) -> None:
        '''Represents the format string for the DataLabels object.
        :param value: '''
        raise NotImplementedError()

    def setNumberFormatLinked(self, value : bool) -> None:
        '''True if the number format is linked to the cells
        (so that the number format changes in the labels when it changes in the cells).
        :param value: '''
        raise NotImplementedError()

    def isAutoText(self) -> bool:
        '''Indicates the text is auto generated.'''
        raise NotImplementedError()

    def setShowSeriesName(self, value : bool) -> None:
        '''Indicates whether the series name displays for the data labels on a chart.
        True to show the series name. False to hide.
        :param value: '''
        raise NotImplementedError()

    def getArea(self) -> Area:
        '''Gets the :class:`Area`.'''
        raise NotImplementedError()

    def getShowCellRange(self) -> bool:
        '''Indicates whether showing cell range as the data labels.'''
        raise NotImplementedError()

    def setBackgroundMode(self, value : int) -> None:
        '''Sets the display mode of the background
        See :class:`BackgroundMode`
        :param value: '''
        raise NotImplementedError()

    def getFont(self) -> Font:
        '''Gets the font of the DataLabels;'''
        raise NotImplementedError()

    def setShowPercentage(self, value : bool) -> None:
        '''Represents a specified chart's data label percentage value display behavior. True displays the percentage value. False to hide.
        :param value: '''
        raise NotImplementedError()

    def getSeparatorType(self) -> int:
        '''Gets the separator type used for the data labels on a chart.
        See :class:`DataLabelsSeparatorType`'''
        raise NotImplementedError()

    def setSeparatorValue(self, value : str) -> None:
        '''Sets the separator value used for the data labels on a chart.
        :param value: '''
        raise NotImplementedError()

    def getShowValue(self) -> bool:
        '''Represents a specified chart's data label values display behavior. True displays the values. False to hide.'''
        raise NotImplementedError()

    def setDirectionType(self, value : int) -> None:
        '''Sets the direction of text.
        See :class:`ChartTextDirectionType`
        :param value: '''
        raise NotImplementedError()

    def getShapeType(self) -> int:
        '''Gets shape type of data label.
        See :class:`DataLabelShapeType`'''
        raise NotImplementedError()

    def getShowLegendKey(self) -> bool:
        '''Represents a specified chart's data label legend key display behavior.
        True if the data label legend key is visible.'''
        raise NotImplementedError()

    def setShowBubbleSize(self, value : bool) -> None:
        '''Represents a specified chart's data label percentage value display behavior. True displays the percentage value. False to hide.
        :param value: '''
        raise NotImplementedError()

    def getNumberFormatLinked(self) -> bool:
        '''True if the number format is linked to the cells
        (so that the number format changes in the labels when it changes in the cells).'''
        raise NotImplementedError()

    def setTextWrapped(self, value : bool) -> None:
        '''Sets a value indicating whether the text is wrapped.
        :param value: '''
        raise NotImplementedError()

    def getNumber(self) -> int:
        '''Gets the built-in number format.'''
        raise NotImplementedError()

    def setShowCategoryName(self, value : bool) -> None:
        '''Represents a specified chart's data label category name display behavior.True to display the category name for the data labels on a chart. False to hide.
        :param value: '''
        raise NotImplementedError()

    def getPosition(self) -> int:
        '''Represents the position of the data label.
        See :class:`LabelPositionType`'''
        raise NotImplementedError()

    def getShowCategoryName(self) -> bool:
        '''Represents a specified chart's data label category name display behavior.True to display the category name for the data labels on a chart. False to hide.'''
        raise NotImplementedError()

    def setNumber(self, value : int) -> None:
        '''Sets the built-in number format.
        :param value: '''
        raise NotImplementedError()

    def getShowSeriesName(self) -> bool:
        '''Indicates whether the series name displays for the data labels on a chart.
        True to show the series name. False to hide.'''
        raise NotImplementedError()

    def isNeverOverlap(self) -> bool:
        '''Indicates whether the datalabels display never overlap. (For Pie chart)'''
        raise NotImplementedError()

    def setShowCellRange(self, value : bool) -> None:
        '''Indicates whether showing cell range as the data labels.
        :param value: '''
        raise NotImplementedError()

    def getNumberFormat(self) -> str:
        '''Represents the format string for the DataLabels object.'''
        raise NotImplementedError()

    def applyFont(self) -> None:
        '''Apply the font of the datalabels to all child nodes.'''
        raise NotImplementedError()

    def getBackgroundMode(self) -> int:
        '''Gets the display mode of the background
        See :class:`BackgroundMode`'''
        raise NotImplementedError()

    def setNeverOverlap(self, value : bool) -> None:
        '''Indicates whether the datalabels display never overlap. (For Pie chart)
        :param value: '''
        raise NotImplementedError()

    def getBorder(self) -> Line:
        '''Gets the :class:`Line`.'''
        raise NotImplementedError()

    def setPosition(self, value : int) -> None:
        '''Represents the position of the data label.
        See :class:`LabelPositionType`
        :param value: '''
        raise NotImplementedError()

    def setShowValue(self, value : bool) -> None:
        '''Represents a specified chart's data label values display behavior. True displays the values. False to hide.
        :param value: '''
        raise NotImplementedError()

    def setAutoText(self, value : bool) -> None:
        '''Indicates the text is auto generated.
        :param value: '''
        raise NotImplementedError()

    def setShapeType(self, value : int) -> None:
        '''Sets shape type of data label.
        See :class:`DataLabelShapeType`
        :param value: '''
        raise NotImplementedError()

    def isTextWrapped(self) -> bool:
        '''Gets a value indicating whether the text is wrapped.'''
        raise NotImplementedError()

    def getDirectionType(self) -> int:
        '''Gets the direction of text.
        See :class:`ChartTextDirectionType`'''
        raise NotImplementedError()

    def setSeparatorType(self, value : int) -> None:
        '''Sets the separator type used for the data labels on a chart.
        See :class:`DataLabelsSeparatorType`
        :param value: '''
        raise NotImplementedError()

    def getShowPercentage(self) -> bool:
        '''Represents a specified chart's data label percentage value display behavior. True displays the percentage value. False to hide.'''
        raise NotImplementedError()

    def getSeparatorValue(self) -> str:
        '''Gets the separator value used for the data labels on a chart.'''
        raise NotImplementedError()

    def setShowLegendKey(self, value : bool) -> None:
        '''Represents a specified chart's data label legend key display behavior.
        True if the data label legend key is visible.
        :param value: '''
        raise NotImplementedError()


class DataLabelShapeType:
    '''Specifies the preset shape geometry that is to be used for a chart.'''

    RECT : DataLabelShapeType
    '''Represents the rectangle shape.'''

    ROUND_RECT : DataLabelShapeType
    '''Represents the round rectangle shape.'''

    ELLIPSE : DataLabelShapeType
    '''Represents the ellipse shape.'''

    RIGHT_ARROW_CALLOUT : DataLabelShapeType
    '''Represents the right arrow callout shape.'''

    DOWN_ARROW_CALLOUT : DataLabelShapeType
    '''Represents the down arrow callout shape.'''

    LEFT_ARROW_CALLOUT : DataLabelShapeType
    '''Represents the left arrow callout shape.'''

    UP_ARROW_CALLOUT : DataLabelShapeType
    '''Represents the up arrow callout shape.'''

    WEDGE_RECT_CALLOUT : DataLabelShapeType
    '''Represents the wedge rectangle callout shape.'''

    WEDGE_ROUND_RECT_CALLOUT : DataLabelShapeType
    '''Represents the wedge round rectangle callout shape.'''

    WEDGE_ELLIPSE_CALLOUT : DataLabelShapeType
    '''Represents the wedge ellipse callout shape.'''

    LINE_CALLOUT : DataLabelShapeType
    '''Represents the line callout shape.'''

    BENT_LINE_CALLOUT : DataLabelShapeType
    '''Represents the bent line callout  shape.'''

    LINE_WITH_ACCENT_BAR_CALLOUT : DataLabelShapeType
    '''Represents the line with accent bar callout shape.'''

    BENT_LINE_WITH_ACCENT_BAR_CALLOUT : DataLabelShapeType
    '''Represents the bent line with accent bar callout shape.'''

    LINE : DataLabelShapeType
    '''This type is only used for special file processing'''


class DataLabelsSeparatorType:
    '''Represents the separator type of DataLabels.'''

    AUTO : DataLabelsSeparatorType
    '''Represents automatic separator'''

    SPACE : DataLabelsSeparatorType
    '''Represents space(" ")'''

    COMMA : DataLabelsSeparatorType
    '''Represents comma(",")'''

    SEMICOLON : DataLabelsSeparatorType
    '''Represents semicolon(";")'''

    PERIOD : DataLabelsSeparatorType
    '''Represents period(".")'''

    NEW_LINE : DataLabelsSeparatorType
    '''Represents newline("\n")'''

    CUSTOM : DataLabelsSeparatorType
    '''Represents custom separator'''


class DataMashup:
    '''Represents mashup data.'''

    def getPowerQueryFormulas(self) -> PowerQueryFormulaCollection:
        '''Gets all power query formulas.'''
        raise NotImplementedError()

    def getPowerQueryFormulaParameters(self) -> PowerQueryFormulaParameterCollection:
        ''':deprecated: Use DataMashup.PowerQueryFormulas property, instead.'''
        raise NotImplementedError()


class DataModel:
    '''Represents the data model.'''

    def getTables(self) -> DataModelTableCollection:
        '''Gets all tables in the data model.'''
        raise NotImplementedError()

    def getRelationships(self) -> DataModelRelationshipCollection:
        '''Gets all relationships of the tables in the data model.'''
        raise NotImplementedError()


class DataModelConnection:
    '''Specifies a data model connection'''

    def getConnectionString(self) -> str:
        '''The connection information string is used to make contact with an OLE DB or ODBC data source.'''
        raise NotImplementedError()

    def setCommandType(self, value : int) -> None:
        '''Returns :class:`OLEDBCommandType` type.
        See :class:`OLEDBCommandType`
        :param value: '''
        raise NotImplementedError()

    def setConnectionString(self, value : str) -> None:
        '''The connection information string is used to make contact with an OLE DB or ODBC data source.
        :param value: '''
        raise NotImplementedError()

    def getClassType(self) -> int:
        '''Gets the type of this :class:`ExternalConnection` object.
        See :class:`ExternalConnectionClassType`'''
        raise NotImplementedError()

    def getCommandType(self) -> int:
        '''Returns :class:`OLEDBCommandType` type.
        See :class:`OLEDBCommandType`'''
        raise NotImplementedError()

    def setCommand(self, value : str) -> None:
        '''The string containing the database command to pass to the data provider API that will
        interact with the external source in order to retrieve data
        :param value: '''
        raise NotImplementedError()

    def getCommand(self) -> str:
        '''The string containing the database command to pass to the data provider API that will
        interact with the external source in order to retrieve data'''
        raise NotImplementedError()


class DataModelRelationship:
    '''Represents a single relationship in the spreadsheet data model.'''

    def getPrimaryKeyTable(self) -> str:
        '''Gets the name of the primary key table for this relationship.'''
        raise NotImplementedError()

    def getForeignKeyColumn(self) -> str:
        '''Gets the name of the foreign key table column for this relationship.'''
        raise NotImplementedError()

    def getPrimaryKeyColumn(self) -> str:
        '''Gets the name of the primary key table column for this relationship.'''
        raise NotImplementedError()

    def getForeignKeyTable(self) -> str:
        '''Gets the name of the foreign key table for this relationship.'''
        raise NotImplementedError()


class DataModelRelationshipCollection:
    '''Represents the relationships.'''

    def get(self, index : int) -> DataModelRelationship:
        '''Gets the relationship.
        :param index: The index.'''
        raise NotImplementedError()


class DataModelTable:
    '''Represents properties of a single table in spreadsheet data model.'''

    def getConnectionName(self) -> str:
        '''Gets the connection name of the data model table.'''
        raise NotImplementedError()

    def getId(self) -> str:
        '''Gets the id of the data model table.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the data model table.'''
        raise NotImplementedError()


class DataModelTableCollection:
    '''Represents the list of the data model table.'''

    def get(self, index : int) -> DataModelTable:
        '''Gets the data model table by position of the collection.
        :param index: The position of the collection.'''
        raise NotImplementedError()


class DataSorter:
    '''Summary description for DataSorter.'''

    def addColorKey(self, key : int, type : int, order : int, color : Color) -> None:
        '''Adds color sort key.
        :param key: The sorted column index(absolute position, column A is 0, B is 1, ...)
        :param type: :class:`SortOnType`. The sorted color value type.
        :param order: :class:`SortOrder`. The sort order.
        :param color: The custom sort color.'''
        raise NotImplementedError()

    def getCaseSensitive(self) -> bool:
        '''Gets whether case sensitive when comparing string.'''
        raise NotImplementedError()

    def getKeys(self) -> DataSorterKeyCollection:
        '''Gets the key list of data sorter.'''
        raise NotImplementedError()

    def setOrder3(self, value : int) -> None:
        '''Represents sort order of the third key.
        See :class:`SortOrder`
        :param value: '''
        raise NotImplementedError()

    def setOrder2(self, value : int) -> None:
        '''Represents sort order of the second key.
        See :class:`SortOrder`
        :param value: '''
        raise NotImplementedError()

    def setOrder1(self, value : int) -> None:
        '''Represents sort order of the first key.
        See :class:`SortOrder`
        :param value: '''
        raise NotImplementedError()

    def setKey3(self, value : int) -> None:
        '''Represents third sorted column index(absolute position, column A is 0, B is 1, ...).
        :param value: '''
        raise NotImplementedError()

    def setKey2(self, value : int) -> None:
        '''Represents second sorted column index(absolute position, column A is 0, B is 1, ...).
        :param value: '''
        raise NotImplementedError()

    def setKey1(self, value : int) -> None:
        '''Represents first sorted column index(absolute position, column A is 0, B is 1, ...).
        :param value: '''
        raise NotImplementedError()

    def hasHeaders(self) -> bool:
        '''Represents whether the range has headers.'''
        raise NotImplementedError()

    def setCaseSensitive(self, value : bool) -> None:
        '''Sets whether case sensitive when comparing string.
        :param value: '''
        raise NotImplementedError()

    def setSortLeftToRight(self, value : bool) -> None:
        '''True means that sorting orientation is from left to right.
        False means that sorting orientation is from top to bottom.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getOrder3(self) -> int:
        '''Represents sort order of the third key.
        See :class:`SortOrder`'''
        raise NotImplementedError()

    def getOrder2(self) -> int:
        '''Represents sort order of the second key.
        See :class:`SortOrder`'''
        raise NotImplementedError()

    def getOrder1(self) -> int:
        '''Represents sort order of the first key.
        See :class:`SortOrder`'''
        raise NotImplementedError()

    def getSortLeftToRight(self) -> bool:
        '''True means that sorting orientation is from left to right.
        False means that sorting orientation is from top to bottom.
        The default value is false.'''
        raise NotImplementedError()

    def getKey3(self) -> int:
        '''Represents third sorted column index(absolute position, column A is 0, B is 1, ...).'''
        raise NotImplementedError()

    def getKey2(self) -> int:
        '''Represents second sorted column index(absolute position, column A is 0, B is 1, ...).'''
        raise NotImplementedError()

    def getKey1(self) -> int:
        '''Represents first sorted column index(absolute position, column A is 0, B is 1, ...).'''
        raise NotImplementedError()

    def setSortAsNumber(self, value : bool) -> None:
        '''Indicates whether sorting anything that looks like a number.
        :param value: '''
        raise NotImplementedError()

    def clear(self) -> None:
        '''Clear all settings.'''
        raise NotImplementedError()

    def setHasHeaders(self, value : bool) -> None:
        '''Represents whether the range has headers.
        :param value: '''
        raise NotImplementedError()

    @overload
    def addKey(self, key : int, order : int) -> None:
        '''Adds sorted column index and sort order.
        :param key: The sorted column index(absolute position, column A is 0, B is 1, ...)
        :param order: :class:`SortOrder`. The sort order'''
        raise NotImplementedError()

    @overload
    def addKey(self, key : int, order : int, customList : str) -> None:
        '''Adds sorted column index and sort order with custom sort list.
        :param key: The sorted column index(absolute position, column A is 0, B is 1, ...)
        :param order: :class:`SortOrder`. The sort order.
        :param customList: The custom sort list.'''
        raise NotImplementedError()

    @overload
    def addKey(self, key : int, type : int, order : int, customList : Object) -> None:
        '''Adds sorted column index and sort order with custom sort list.
        :param key: The sorted column index(absolute position, column A is 0, B is 1, ...)
        :param type: :class:`SortOnType`. The sorted value type.
        :param order: :class:`SortOrder`. The sort order.
        :param customList: The custom sort list.'''
        raise NotImplementedError()

    @overload
    def addKey(self, key : int, order : int, customList : list[str]) -> None:
        '''Adds sorted column index and sort order with custom sort list.
        :param key: The sorted column index(absolute position, column A is 0, B is 1, ...)
        :param order: :class:`SortOrder`. The sort order.
        :param customList: The custom sort list.'''
        raise NotImplementedError()

    @overload
    def sort(self, cells : Cells, startRow : int, startColumn : int, endRow : int, endColumn : int) -> list[int]:
        '''Sorts the data of the area.
        :param cells: The cells contains the data area.
        :param startRow: The start row of the area.
        :param startColumn: The start column of the area.
        :param endRow: The end row of the area.
        :param endColumn: The end column of the area.
        :returns: the original indices(absolute position, for example, column A is 0, B is 1, ...) of the sorted rows/columns. If no rows/columns needs to be moved by this sorting operation, null will be returned.'''
        raise NotImplementedError()

    @overload
    def sort(self, cells : Cells, area : CellArea) -> list[int]:
        '''Sort the data of the area.
        :param cells: The cells contains the data area.
        :param area: The area needed to sort
        :returns: the original indices(absolute position, for example, column A is 0, B is 1, ...) of the sorted rows/columns. If no rows/columns needs to be moved by this sorting operation, null will be returned.'''
        raise NotImplementedError()

    @overload
    def sort(self) -> list[int]:
        '''Sort the data in the range.'''
        raise NotImplementedError()

    def getSortAsNumber(self) -> bool:
        '''Indicates whether sorting anything that looks like a number.'''
        raise NotImplementedError()


class DataSorterKey:
    '''Represents the key of the data sorter.'''

    def getIconId(self) -> int:
        '''Represents the id of the icon set type.'''
        raise NotImplementedError()

    def getIconSetType(self) -> int:
        '''Represents the icon set type.
        See :class:`IconSetType`'''
        raise NotImplementedError()

    def getOrder(self) -> int:
        '''Indicates the order of sorting.
        See :class:`SortOrder`'''
        raise NotImplementedError()

    def getColor(self) -> Color:
        '''Gets the sorted color.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents the type of sorting.
        See :class:`SortOnType`'''
        raise NotImplementedError()

    def getIndex(self) -> int:
        '''Gets the sorted column index(absolute position, column A is 0, B is 1, ...).'''
        raise NotImplementedError()


class DataSorterKeyCollection:
    '''Represents the key list of data sorter.'''

    def get(self, index : int) -> DataSorterKey:
        '''Gets and sets :class:`DataSorterKey` by index.
        :param index: The index.'''
        raise NotImplementedError()


class DateTime:
    '''Represents an instant in time, typically expressed as a date and time of day.'''

    def getYear(self) -> int:
        '''Gets the year component of the date represented by this instance.'''
        raise NotImplementedError()

    def getMillisecond(self) -> int:
        '''Gets the milliseconds component of the date represented by this instance.'''
        raise NotImplementedError()

    def addDays(self, value : int) -> DateTime:
        '''Adds the specified number of days to the value of this instance.
        :param value: A number of whole and fractional days. The value parameter can be negative or positive.
        :returns: A DateTime object whose value is the sum of the date and time represented by this instance and the number of days represented by value.'''
        raise NotImplementedError()

    def getDay(self) -> int:
        '''Gets the day of the month represented by this instance.'''
        raise NotImplementedError()

    def getMonth(self) -> int:
        '''Gets the month component of the date represented by this instance.'''
        raise NotImplementedError()

    def equals(self, value : Object) -> bool:
        '''Returns a value indicating whether this instance is equal to a specified object.
        :param value: An object to compare to this instance.
        :returns: true if value is an instance of DateTime and equals the value of this instance; otherwise, false.'''
        raise NotImplementedError()

    def getMinute(self) -> int:
        '''Gets the minute component of the date represented by this instance.'''
        raise NotImplementedError()

    def getNow(self) -> DateTime:
        '''Gets a DateTime object that is set to the current date and time on this computer, expressed as the local time.'''
        raise NotImplementedError()

    def addMilliseconds(self, value : int) -> DateTime:
        '''Adds the specified number of milliseconds to the value of this instance.
        :param value: A number of whole and fractional milliseconds. The value parameter can be negative or positive. Note that this value is rounded to the nearest integer.
        :returns: A DateTime object whose value is the sum of the date and time represented by this instance and the number of milliseconds represented by value.'''
        raise NotImplementedError()

    def addYears(self, value : int) -> DateTime:
        '''Adds the specified number of years to the value of this instance.
        :param value: A number of years. The value parameter can be negative or positive.
        :returns: A DateTime object whose value is the sum of the date and time represented by this instance and the number of years represented by value.'''
        raise NotImplementedError()

    def getDayOfYear(self) -> int:
        '''Gets the day of the year represented by this instance.'''
        raise NotImplementedError()

    @overload
    def compareTo(self, value : Object) -> int:
        '''Compares the value of this instance to a specified object that contains a
        specified DateTime value, and returns an integer that indicates whether
        this instance is earlier than, the same as, or later than the specified DateTime value.
        :param value: A boxed DateTime object to compare, or null.
        :returns: A signed number indicating the relative values of this instance and value. Value Description Less than zero This instance is earlier than value. Zero This instance is the same as value. Greater than zero This instance is later than value, or value is null.'''
        raise NotImplementedError()

    @overload
    def compareTo(self, value : DateTime) -> int:
        '''Compares the value of this instance to a specified DateTime value
        and returns an integer that indicates whether this instance is earlier than,
        the same as, or later than the specified DateTime value.
        :param value: A DateTime object to compare.
        :returns: A signed number indicating the relative values of this instance and the value parameter. Value Description Less than zero This instance is earlier than value. Zero This instance is the same as value. Greater than zero This instance is later than value.'''
        raise NotImplementedError()

    def toString(self) -> str:
        '''Converts the value of the current DateTime object to its equivalent string representation.'''
        raise NotImplementedError()

    def toLocalTime(self) -> DateTime:
        '''Converts the value of the current DateTime object to local time.'''
        raise NotImplementedError()

    def hashCode(self) -> int:
        '''Returns the hash code for this instance.'''
        raise NotImplementedError()

    def addHours(self, value : int) -> DateTime:
        '''Adds the specified number of hours to the value of this instance.
        :param value: A number of whole and fractional hours. The value parameter can be negative or positive.
        :returns: A DateTime object whose value is the sum of the date and time represented by this instance and the number of hours represented by value.'''
        raise NotImplementedError()

    def addSeconds(self, value : int) -> DateTime:
        '''Adds the specified number of seconds to the value of this instance.
        :param value: A number of whole and fractional seconds. The value parameter can be negative or positive.
        :returns: A DateTime object whose value is the sum of the date and time represented by this instance and the number of seconds represented by value.'''
        raise NotImplementedError()

    def getSecond(self) -> int:
        '''Gets the seconds component of the date represented by this instance.'''
        raise NotImplementedError()

    def getHour(self) -> int:
        '''Gets the hour component of the date represented by this instance.'''
        raise NotImplementedError()

    def toDate(self) -> Date:
        '''Converts the value of the current DateTime object to Date object.'''
        raise NotImplementedError()

    def getDayOfWeek(self) -> int:
        '''Gets the day of the week represented by this instance.'''
        raise NotImplementedError()

    def toCalendar(self) -> Calendar:
        '''Converts the value of the current DateTime object to Calendar object.'''
        raise NotImplementedError()

    def addMonths(self, months : int) -> DateTime:
        '''Adds the specified number of months to the value of this instance.
        :param months: A number of months. The months parameter can be negative or positive.
        :returns: A DateTime object whose value is the sum of the date and time represented by this instance and months.'''
        raise NotImplementedError()

    def toUniversalTime(self) -> DateTime:
        '''Converts the value of the current DateTime object to Coordinated Universal Time(UTC).'''
        raise NotImplementedError()

    def addMinutes(self, value : int) -> DateTime:
        '''Adds the specified number of minutes to the value of this instance.
        :param value: A number of whole and fractional minutes. The value parameter can be negative or positive.
        :returns: A DateTime object whose value is the sum of the date and time represented by this instance and the number of minutes represented by value.'''
        raise NotImplementedError()


class DateTimeGroupingType:
    '''Specifies how to group dateTime values.'''

    DAY : DateTimeGroupingType
    '''Group by day.'''

    HOUR : DateTimeGroupingType
    '''Group by hour.'''

    MINUTE : DateTimeGroupingType
    '''Group by Minute.'''

    MONTH : DateTimeGroupingType
    '''Group by Month.'''

    SECOND : DateTimeGroupingType
    '''Group by Second.'''

    YEAR : DateTimeGroupingType
    '''Group by Year.'''


class DateTimeGroupItem:
    '''Represents the datetime's group setting.'''

    def setMinute(self, value : int) -> None:
        '''Sets the minute of the grouped date time.
        :param value: '''
        raise NotImplementedError()

    def setMonth(self, value : int) -> None:
        '''Sets the month of the grouped date time.
        :param value: '''
        raise NotImplementedError()

    def getMonth(self) -> int:
        '''Gets the month of the grouped date time.'''
        raise NotImplementedError()

    def setYear(self, value : int) -> None:
        '''Sets the year of the grouped date time.
        :param value: '''
        raise NotImplementedError()

    def getMinValue(self) -> DateTime:
        '''Gets the min value.'''
        raise NotImplementedError()

    def getHour(self) -> int:
        '''Gets the hour of the grouped date time.'''
        raise NotImplementedError()

    def getDay(self) -> int:
        '''Gets the day of the grouped date time.'''
        raise NotImplementedError()

    def getYear(self) -> int:
        '''Gets the year of the grouped date time.'''
        raise NotImplementedError()

    def setDateTimeGroupingType(self, value : int) -> None:
        '''Sets the group type.
        See :class:`DateTimeGroupingType`
        :param value: '''
        raise NotImplementedError()

    def getSecond(self) -> int:
        '''Gets the second of the grouped date time.'''
        raise NotImplementedError()

    def getDateTimeGroupingType(self) -> int:
        '''Gets the group type.
        See :class:`DateTimeGroupingType`'''
        raise NotImplementedError()

    def getMinute(self) -> int:
        '''Gets the minute of the grouped date time.'''
        raise NotImplementedError()

    def setHour(self, value : int) -> None:
        '''Sets the hour of the grouped date time.
        :param value: '''
        raise NotImplementedError()

    def setSecond(self, value : int) -> None:
        '''Sets the second of the grouped date time.
        :param value: '''
        raise NotImplementedError()

    def setDay(self, value : int) -> None:
        '''Sets the day of the grouped date time.
        :param value: '''
        raise NotImplementedError()


class DBConnection:
    '''Specifies all properties associated with an ODBC or OLE DB external data connection.'''

    def getCommand(self) -> str:
        '''The string containing the database command to pass to the data provider API that will
        interact with the external source in order to retrieve data'''
        raise NotImplementedError()

    def getSecondCommand(self) -> str:
        '''Specifies a second command text string that is persisted when PivotTable server-based
        page fields are in use.
        For ODBC connections, serverCommand is usually a broader query than command (no
        WHERE clause is present in the former). Based on these 2 commands(Command and ServerCommand),
        parameter UI can be populated and parameterized queries can be constructed'''
        raise NotImplementedError()

    def getCommandType(self) -> int:
        '''Specifies the OLE DB command type.
        1. Query specifies a cube name
        2. Query specifies a SQL statement
        3. Query specifies a table name
        4. Query specifies that default information has been given, and it is up to the provider how to interpret.
        5. Query is against a web based List Data Provider.
        See :class:`OLEDBCommandType`'''
        raise NotImplementedError()

    def getConnectionInfo(self) -> str:
        ''':deprecated: Use ExternalConnection.ConnectionString property instead.'''
        raise NotImplementedError()

    def getConnectionString(self) -> str:
        '''The connection information string is used to make contact with an OLE DB or ODBC data source.'''
        raise NotImplementedError()

    def getSeverCommand(self) -> str:
        ''':deprecated: Use ExternalConnection.SecondCommand property instead.'''
        raise NotImplementedError()

    def setCommandType(self, value : int) -> None:
        '''Specifies the OLE DB command type.
        1. Query specifies a cube name
        2. Query specifies a SQL statement
        3. Query specifies a table name
        4. Query specifies that default information has been given, and it is up to the provider how to interpret.
        5. Query is against a web based List Data Provider.
        See :class:`OLEDBCommandType`
        :param value: '''
        raise NotImplementedError()

    def getClassType(self) -> int:
        '''Gets the type of this :class:`ExternalConnection` object.
        See :class:`ExternalConnectionClassType`'''
        raise NotImplementedError()

    def setConnectionInfo(self, value : str) -> None:
        ''':deprecated: Use ExternalConnection.ConnectionString property instead.'''
        raise NotImplementedError()

    def setSecondCommand(self, value : str) -> None:
        '''Specifies a second command text string that is persisted when PivotTable server-based
        page fields are in use.
        For ODBC connections, serverCommand is usually a broader query than command (no
        WHERE clause is present in the former). Based on these 2 commands(Command and ServerCommand),
        parameter UI can be populated and parameterized queries can be constructed
        :param value: '''
        raise NotImplementedError()

    def setSeverCommand(self, value : str) -> None:
        ''':deprecated: Use ExternalConnection.SecondCommand property instead.'''
        raise NotImplementedError()

    def setConnectionString(self, value : str) -> None:
        '''The connection information string is used to make contact with an OLE DB or ODBC data source.
        :param value: '''
        raise NotImplementedError()

    def setCommand(self, value : str) -> None:
        '''The string containing the database command to pass to the data provider API that will
        interact with the external source in order to retrieve data
        :param value: '''
        raise NotImplementedError()

    def getPowerQueryFormula(self) -> PowerQueryFormula:
        '''Gets the definition of power query formula.'''
        raise NotImplementedError()


class DefaultEditLanguage:
    '''Represents the default edit language.'''

    AUTO : DefaultEditLanguage
    '''Represents auto detecting edit language according to the text itself.'''

    ENGLISH : DefaultEditLanguage
    '''Represents English language.'''

    CJK : DefaultEditLanguage
    '''Represents Chinese, Japanese, Korean language.'''


class DefaultStyleSettings:
    '''Settings for the default values of workbook's style properties.'''

    def setVerticalAlignment(self, value : int) -> None:
        '''Sets the default value for vertical alignment
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getBuiltInPreference(self) -> bool:
        '''Indicates whether property for number format is preferrable when the style defines both built-in number and custom pattern.
        Default value is false, that means by default custom pattern will be used to format values as long as it is not empty for one style.'''
        raise NotImplementedError()

    def getVerticalAlignment(self) -> int:
        '''Gets the default value for vertical alignment
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def setBuiltInPreference(self, value : bool) -> None:
        '''Indicates whether property for number format is preferrable when the style defines both built-in number and custom pattern.
        Default value is false, that means by default custom pattern will be used to format values as long as it is not empty for one style.
        :param value: '''
        raise NotImplementedError()

    def setFontSize(self, value : int) -> None:
        '''Sets the default standard font size for the workbook.
        :param value: '''
        raise NotImplementedError()

    def setFontName(self, value : str) -> None:
        '''Sets the default font name for the workbook
        :param value: '''
        raise NotImplementedError()

    def getFontSize(self) -> int:
        '''Gets the default standard font size for the workbook.'''
        raise NotImplementedError()

    def getFontName(self) -> str:
        '''Gets the default font name for the workbook'''
        raise NotImplementedError()

    def setHorizontalAlignment(self, value : int) -> None:
        '''Sets the default value for horizontal alignment
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getHorizontalAlignment(self) -> int:
        '''Gets the default value for horizontal alignment
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()


class DeleteBlankOptions:
    '''Represents the setting of deleting blank cells/rows/columns.'''

    def getMergedCellsShrinkType(self) -> int:
        '''Indicates how to process merged cells when deleting blank rows/columns.
        See :class:`MergedCellsShrinkType`'''
        raise NotImplementedError()

    def setMergedCellsShrinkType(self, value : int) -> None:
        '''Indicates how to process merged cells when deleting blank rows/columns.
        See :class:`MergedCellsShrinkType`
        :param value: '''
        raise NotImplementedError()

    def getEmptyStringAsBlank(self) -> bool:
        '''Whether one cell will be taken as blank when its value is empty string.
        Default value is true.'''
        raise NotImplementedError()

    def setEmptyFormulaValueAsBlank(self, value : bool) -> None:
        '''Whether one cell will be taken as blank when it is formula and the calculated result is null or empty string.
        Default value is false.
        :param value: '''
        raise NotImplementedError()

    def getStartIndex(self) -> int:
        '''Specifies the start row/column index of the range to check and delete blank rows/columns.'''
        raise NotImplementedError()

    def setDrawingsAsBlank(self, value : bool) -> None:
        '''Whether drawing related objects such as picture, shape, chart... will be taken as blank.
        Default value is true.
        :param value: '''
        raise NotImplementedError()

    def getDrawingsAsBlank(self) -> bool:
        '''Whether drawing related objects such as picture, shape, chart... will be taken as blank.
        Default value is true.'''
        raise NotImplementedError()

    def setStartIndex(self, value : int) -> None:
        '''Specifies the start row/column index of the range to check and delete blank rows/columns.
        :param value: '''
        raise NotImplementedError()

    def getEmptyFormulaValueAsBlank(self) -> bool:
        '''Whether one cell will be taken as blank when it is formula and the calculated result is null or empty string.
        Default value is false.'''
        raise NotImplementedError()

    def setEndIndex(self, value : int) -> None:
        '''Specifies the end row/column index(inclusive) of the range to check and delete blank rows/columns.
        Default value is -1 and -1 means the maximum range of all objects(cells, drawings, ...) that need to be checked.
        :param value: '''
        raise NotImplementedError()

    def setEmptyStringAsBlank(self, value : bool) -> None:
        '''Whether one cell will be taken as blank when its value is empty string.
        Default value is true.
        :param value: '''
        raise NotImplementedError()

    def getEndIndex(self) -> int:
        '''Specifies the end row/column index(inclusive) of the range to check and delete blank rows/columns.
        Default value is -1 and -1 means the maximum range of all objects(cells, drawings, ...) that need to be checked.'''
        raise NotImplementedError()


class DeleteOptions:
    '''Represents the setting of deleting rows/columns.'''

    def setFormulaChangeMonitor(self, value : AbstractFormulaChangeMonitor) -> None:
        '''Sets the monitor for tracking changes caused by the deletion.
        :param value: '''
        raise NotImplementedError()

    def getFormulaChangeMonitor(self) -> AbstractFormulaChangeMonitor:
        '''Gets the monitor for tracking changes caused by the deletion.'''
        raise NotImplementedError()

    def setUpdateReference(self, value : bool) -> None:
        '''Indicates if update references in other worksheets.
        :param value: '''
        raise NotImplementedError()

    def getUpdateReference(self) -> bool:
        '''Indicates if update references in other worksheets.'''
        raise NotImplementedError()


class DelimiterEquationNode:
    '''This class specifies the delimiter equation, consisting of opening and closing delimiters (such as parentheses, braces, brackets, and vertical bars), and a component contained inside.
    The delimiter may have more than one component, with a designated separator character between each component.'''

    def getEndChar(self) -> str:
        '''Delimiter ending character.'''
        raise NotImplementedError()

    def setNaryGrow(self, value : bool) -> None:
        '''
        :param value: '''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()

    def getNaryGrow(self) -> bool:
        ''''''
        raise NotImplementedError()

    def getDelimiterShape(self) -> int:
        '''Specifies the shape of delimiters in the delimiter object.
        See :class:`EquationDelimiterShapeType`'''
        raise NotImplementedError()

    def setBeginChar(self, value : str) -> None:
        '''Delimiter beginning character.
        :param value: '''
        raise NotImplementedError()

    def setDelimiterShape(self, value : int) -> None:
        '''Specifies the shape of delimiters in the delimiter object.
        See :class:`EquationDelimiterShapeType`
        :param value: '''
        raise NotImplementedError()

    def setSeparatorChar(self, value : str) -> None:
        '''Delimiter separator character.
        :param value: '''
        raise NotImplementedError()

    def getBeginChar(self) -> str:
        '''Delimiter beginning character.'''
        raise NotImplementedError()

    def getSeparatorChar(self) -> str:
        '''Delimiter separator character.'''
        raise NotImplementedError()

    def setEndChar(self, value : str) -> None:
        '''Delimiter ending character.
        :param value: '''
        raise NotImplementedError()


class DialogBox:
    '''Represents the dialog box.'''


class DifSaveOptions:
    '''Represents the options of saving dif file.'''


class DigitalSignature:
    '''Signature in file.'''

    def getComments(self) -> str:
        '''The purpose to signature.'''
        raise NotImplementedError()

    def getXAdESType(self) -> int:
        '''XAdES type.
        Default value is None(XAdES is off).
        See :class:`XAdESType`'''
        raise NotImplementedError()

    def setId(self, value : java.util.UUID) -> None:
        '''Specifies a GUID which can be cross-referenced with the GUID of the signature line stored in the document content.
        Default value is Empty (all zeroes) Guid.
        :param value: '''
        raise NotImplementedError()

    def getId(self) -> java.util.UUID:
        '''Specifies a GUID which can be cross-referenced with the GUID of the signature line stored in the document content.
        Default value is Empty (all zeroes) Guid.'''
        raise NotImplementedError()

    def setCertificate(self, value : KeyStore) -> None:
        '''Certificate object that was used to sign the document.
        :param value: '''
        raise NotImplementedError()

    def setSignTime(self, value : DateTime) -> None:
        '''The time when the document was signed.
        :param value: '''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''Specifies the text of actual signature in the digital signature.
        Default value is Empty.
        :param value: '''
        raise NotImplementedError()

    def setProviderId(self, value : java.util.UUID) -> None:
        '''Specifies the class ID of the signature provider.
        Default value is Empty (all zeroes) Guid.
        :param value: '''
        raise NotImplementedError()

    def getSignTime(self) -> DateTime:
        '''The time when the document was signed.'''
        raise NotImplementedError()

    def setXAdESType(self, value : int) -> None:
        '''XAdES type.
        Default value is None(XAdES is off).
        See :class:`XAdESType`
        :param value: '''
        raise NotImplementedError()

    def getCertificate(self) -> KeyStore:
        '''Certificate object that was used to sign the document.'''
        raise NotImplementedError()

    def setImage(self, value : list[int]) -> None:
        '''Specifies an image for the digital signature.
        Default value is null.
        :param value: '''
        raise NotImplementedError()

    def getImage(self) -> list[int]:
        '''Specifies an image for the digital signature.
        Default value is null.'''
        raise NotImplementedError()

    def getText(self) -> str:
        '''Specifies the text of actual signature in the digital signature.
        Default value is Empty.'''
        raise NotImplementedError()

    def setComments(self, value : str) -> None:
        '''The purpose to signature.
        :param value: '''
        raise NotImplementedError()

    def isValid(self) -> bool:
        '''If this digital signature is valid and the document has not been tampered with,
        this value will be true.'''
        raise NotImplementedError()

    def getProviderId(self) -> java.util.UUID:
        '''Specifies the class ID of the signature provider.
        Default value is Empty (all zeroes) Guid.'''
        raise NotImplementedError()


class DigitalSignatureCollection:
    '''Provides a collection of digital signatures attached to a document.
    The following example shows how to validate digital signature.'''

    def iterator(self) -> Iterator:
        '''Get the enumerator for DigitalSignatureCollection,
        this enumerator allows iteration over the collection'''
        raise NotImplementedError()

    def add(self, digitalSignature : DigitalSignature) -> None:
        '''Add one signature to DigitalSignatureCollection.
        :param digitalSignature: Digital signature in collection.'''
        raise NotImplementedError()


class DirectoryType:
    '''Represents the directory  type of the file name.'''

    VOLUME : DirectoryType
    '''Represents an MS-DOS drive letter. It is followed by the drive letter.
    Or UNC file names, such as \\server\share\myfile.xls'''

    SAME_VOLUME : DirectoryType
    '''Indicates that the source workbook is on the same drive as the dependent workbook (the drive letter is omitted)'''

    DOWN_DIRECTORY : DirectoryType
    '''Indicates that the source workbook is in a subdirectory of the current directory.'''

    UP_DIRECTORY : DirectoryType
    '''Indicates that the source workbook is in the parent directory of the current directory.'''


class DisplayDrawingObjects:
    '''Represents whether and how to show objects in the workbook.'''

    DISPLAY_SHAPES : DisplayDrawingObjects
    '''Show all objects'''

    PLACEHOLDERS : DisplayDrawingObjects
    '''Show placeholders'''

    HIDE : DisplayDrawingObjects
    '''Hide all shapes.'''


class DisplayUnitLabel:
    '''Represents the display unit label.'''

    def getText(self) -> str:
        '''Gets the text of display unit label.'''
        raise NotImplementedError()

    def setAutoScaleFont(self, value : bool) -> None:
        '''True if the text in the object changes font size when the object size changes. The default value is True.
        :param value: '''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''Sets the text of display unit label.
        :param value: '''
        raise NotImplementedError()

    def getFont(self) -> Font:
        '''Gets a :meth:`ChartArea.getFont()` object of the specified ChartFrame object.'''
        raise NotImplementedError()

    def getAutoScaleFont(self) -> bool:
        '''True if the text in the object changes font size when the object size changes. The default value is True.'''
        raise NotImplementedError()


class DisplayUnitType:
    '''Represents the type of display unit of chart's axis.'''

    NONE : DisplayUnitType
    '''Display unit is None.'''

    HUNDREDS : DisplayUnitType
    '''Specifies the values on the chart shall be divided by 100.'''

    THOUSANDS : DisplayUnitType
    '''Specifies the values on the chart shall be divided by 1,000.'''

    TEN_THOUSANDS : DisplayUnitType
    '''Specifies the values on the chart shall be divided by 10,000.'''

    HUNDRED_THOUSANDS : DisplayUnitType
    '''Specifies the values on the chart shall be divided by 100,000.'''

    MILLIONS : DisplayUnitType
    '''Specifies the values on the chart shall be divided by 1,000,000.'''

    TEN_MILLIONS : DisplayUnitType
    '''Specifies the values on the chart shall be divided by 10,000,000.'''

    HUNDRED_MILLIONS : DisplayUnitType
    '''Specifies the values on the chart shall be divided by 100,000,000.'''

    BILLIONS : DisplayUnitType
    '''Specifies the values on the chart shall be divided by 1,000,000,000.'''

    TRILLIONS : DisplayUnitType
    '''Specifies the values on the chart shall be divided by 1,000,000,000,000.'''

    PERCENTAGE : DisplayUnitType
    '''The values on the chart shall be divided by 0.01.'''

    CUST : DisplayUnitType
    '''specifies a custom value for the display unit.'''

    CUSTOM : DisplayUnitType
    '''specifies a custom value for the display unit.'''


class DocumentProperty:
    '''Represents a custom or built-in document property.'''

    def isLinkedToContent(self) -> bool:
        '''Indicates whether this property is linked to content'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Returns the name of the property.'''
        raise NotImplementedError()

    def toString(self) -> str:
        '''Returns the property value as a string.'''
        raise NotImplementedError()

    def toDouble(self) -> int:
        '''Returns the property value as double.'''
        raise NotImplementedError()

    def setValue(self, value : Object) -> None:
        '''Sets the value of the property.
        :param value: '''
        raise NotImplementedError()

    def getValue(self) -> Object:
        '''Gets the value of the property.'''
        raise NotImplementedError()

    def toDateTime(self) -> DateTime:
        '''Returns the property value as DateTime in local timezone.'''
        raise NotImplementedError()

    def isGeneratedName(self) -> bool:
        '''Returns true if this property does not have a name in the OLE2 storage
        and a unique name was generated only for the public API.'''
        raise NotImplementedError()

    def toBool(self) -> bool:
        '''Returns the property value as bool.'''
        raise NotImplementedError()

    def toInt(self) -> int:
        '''Returns the property value as integer.'''
        raise NotImplementedError()

    def getSource(self) -> str:
        '''The linked content source.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the data type of the property.
        See :class:`PropertyType`'''
        raise NotImplementedError()


class DocumentPropertyCollection:
    '''Base class for :class:`BuiltInDocumentPropertyCollection` and :class:`CustomDocumentPropertyCollection` collections.'''

    def remove(self, name : str) -> None:
        '''Removes a property with the specified name from the collection.
        :param name: The case-insensitive name of the property.'''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Removes a property at the specified index.
        :param index: The zero based index.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> DocumentProperty:
        '''Returns a :class:`DocumentProperty` object by the name of the property.
        :param name: The case-insensitive name of the property to retrieve.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> DocumentProperty:
        '''Returns a :class:`DocumentProperty` object by index.
        :param index: Zero-based index of the :class:`DocumentProperty` to retrieve.'''
        raise NotImplementedError()

    def contains(self, name : str) -> bool:
        '''Returns true if a property with the specified name exists in the collection.
        :param name: The case-insensitive name of the property.
        :returns: True if the property exists in the collection; false otherwise.'''
        raise NotImplementedError()

    def indexOf(self, name : str) -> int:
        '''Gets the index of a property by name.
        :param name: The case-insensitive name of the property.
        :returns: The zero based index. Negative value if not found.'''
        raise NotImplementedError()


class DocxSaveOptions:
    '''Represents options of saving .docx file.'''


class DrawObject:
    '''DrawObject will be initialized and returned when rendering.'''

    def getTotalPages(self) -> int:
        '''Indicates total pages in current rendering.'''
        raise NotImplementedError()

    def getImageBytes(self) -> list[int]:
        '''Indicates image bytes of rendered Chart, Shape when rendering.'''
        raise NotImplementedError()

    def getCell(self) -> Cell:
        '''Indicates the Cell object when rendering.
        All properties of cell can be accessed.'''
        raise NotImplementedError()

    def getCurrentPage(self) -> int:
        '''Indicates the page index of DrawObject.
        Page index is based on zero.
        One Sheet contains several pages when rendering.'''
        raise NotImplementedError()

    def getSheetIndex(self) -> int:
        '''Indicates current sheet index of DrawObject.'''
        raise NotImplementedError()

    def getShape(self) -> Shape:
        '''Indicates the Shape object when rendering.
        All properties of shape can be accessed.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Indicates the type of DrawObject.
        See :class:`DrawObjectEnum`'''
        raise NotImplementedError()


class DrawObjectEnum:
    '''Indicate Cell or Image of DrawObject.'''

    IMAGE : DrawObjectEnum
    '''Indicate DrawObject is an Image'''

    CELL : DrawObjectEnum
    '''indicate DrawObject is an Cell'''


class DrawObjectEventHandler:
    '''Interface to get DrawObject and Bound when rendering.'''

    def draw(self, drawObject : DrawObject, x : float, y : float, width : float, height : float) -> None:
        '''Implements this interface to get DrawObject and Bound when rendering.
        :param drawObject: DrawObject will be initialized and returned when rendering
        :param x: Left of DrawObject
        :param y: Top of DrawObject
        :param width: Width of DrawObject
        :param height: Height of DrawObject'''
        raise NotImplementedError()


class DropBars:
    '''Represents the up/down bars in a chart.'''

    def getBorder(self) -> Line:
        '''Gets the border :class:`Line`.'''
        raise NotImplementedError()

    def getArea(self) -> Area:
        '''Gets the :class:`Area`.'''
        raise NotImplementedError()


class DropButtonStyle:
    '''Represents the symbol displayed on the drop button.'''

    PLAIN : DropButtonStyle
    '''Displays a button with no symbol.'''

    ARROW : DropButtonStyle
    '''Displays a button with a down arrow.'''

    ELLIPSIS : DropButtonStyle
    '''Displays a button with an ellipsis (...).'''

    REDUCE : DropButtonStyle
    '''Displays a button with a horizontal line like an underscore character.'''


class DxfCollection:
    '''Represents the master differential formatting records.'''

    def get(self, index : int) -> Style:
        '''Gets the element at the specified index.
        :param index: The specified index.'''
        raise NotImplementedError()


class DynamicFilter:
    '''Represents the dynamic filter.'''

    def getValue(self) -> Object:
        '''Gets the dynamic filter value.'''
        raise NotImplementedError()

    def getMaxValue(self) -> Object:
        '''Gets the dynamic filter max value.'''
        raise NotImplementedError()

    def getDynamicFilterType(self) -> int:
        '''Gets the dynamic filter type.
        See :class:`DynamicFilterType`'''
        raise NotImplementedError()

    def setDynamicFilterType(self, value : int) -> None:
        '''Sets the dynamic filter type.
        See :class:`DynamicFilterType`
        :param value: '''
        raise NotImplementedError()

    def setValue(self, value : Object) -> None:
        '''Sets the dynamic filter value.
        :param value: '''
        raise NotImplementedError()

    def setMaxValue(self, value : Object) -> None:
        '''Sets the dynamic filter max value.
        :param value: '''
        raise NotImplementedError()


class DynamicFilterType:
    '''Dynamic filter type.'''

    ABOVE_AVERAGE : DynamicFilterType
    '''Shows values that are above average.'''

    BELOW_AVERAGE : DynamicFilterType
    '''Shows values that are below average.'''

    LAST_MONTH : DynamicFilterType
    '''Shows last month's dates.'''

    LAST_QUARTER : DynamicFilterType
    '''Shows last quarter's dates.'''

    LAST_WEEK : DynamicFilterType
    '''Shows last week's dates.'''

    LAST_YEAR : DynamicFilterType
    '''Shows last year's dates.'''

    JANUARY : DynamicFilterType
    '''Shows the dates that are in January, regardless of year.'''

    OCTOBER : DynamicFilterType
    '''Shows the dates that are in October, regardless of year.'''

    NOVEMBER : DynamicFilterType
    '''Shows the dates that are in November, regardless of year.'''

    DECEMBER : DynamicFilterType
    '''Shows the dates that are in December, regardless of year.'''

    FEBRUARY : DynamicFilterType
    '''Shows the dates that are in February, regardless of year.'''

    MARCH : DynamicFilterType
    '''Shows the dates that are in March, regardless of year.'''

    APRIL : DynamicFilterType
    '''Shows the dates that are in April, regardless of year.'''

    MAY : DynamicFilterType
    '''Shows the dates that are in May, regardless of year.'''

    JUNE : DynamicFilterType
    '''Shows the dates that are in June, regardless of year.'''

    JULY : DynamicFilterType
    '''Shows the dates that are in July, regardless of year.'''

    AUGUST : DynamicFilterType
    '''Shows the dates that are in August, regardless of year.'''

    SEPTEMBER : DynamicFilterType
    '''Shows the dates that are in September, regardless of year.'''

    NEXT_MONTH : DynamicFilterType
    '''Shows next month's dates.'''

    NEXT_QUARTER : DynamicFilterType
    '''Shows next quarter's dates.'''

    NEXT_WEEK : DynamicFilterType
    '''Shows next week's dates.'''

    NEXT_YEAR : DynamicFilterType
    '''Shows next year's dates.'''

    NONE : DynamicFilterType
    '''None.'''

    QUARTER_1 : DynamicFilterType
    '''Shows the dates that are in the 1st quarter, regardless of year.'''

    QUARTER_2 : DynamicFilterType
    '''Shows the dates that are in the 2nd quarter, regardless of year.'''

    QUARTER_3 : DynamicFilterType
    '''Shows the dates that are in the 3rd quarter, regardless of year.'''

    QUARTER_4 : DynamicFilterType
    '''Shows the dates that are in the 4th quarter, regardless of year.'''

    THIS_MONTH : DynamicFilterType
    '''Shows this month's dates.'''

    THIS_QUARTER : DynamicFilterType
    '''Shows this quarter's dates.'''

    THIS_WEEK : DynamicFilterType
    '''Shows this week's dates.'''

    THIS_YEAR : DynamicFilterType
    '''Shows this year's dates.'''

    TODAY : DynamicFilterType
    '''Shows today's dates.'''

    TOMORROW : DynamicFilterType
    '''Shows tomorrow's dates.'''

    YEAR_TO_DATE : DynamicFilterType
    '''Shows the dates between the beginning of the year and today, inclusive.'''

    YESTERDAY : DynamicFilterType
    '''Shows yesterday's dates.'''


class EbookLoadOptions:
    '''Represents options when importing an ebook file.'''


class EbookSaveOptions:
    '''Represents the options for saving ebook file.'''


class EmfRenderSetting:
    '''Setting for rendering Emf metafile.'''

    EMF_ONLY : EmfRenderSetting
    '''Only rendering Emf records.'''

    EMF_PLUS_PREFER : EmfRenderSetting
    '''Prefer rendering EmfPlus records.'''


class Encoding:
    '''Represents a character encoding.'''

    def getUnicode(self) -> Encoding:
        '''Gets an encoding for the UTF-16 format using the little endian byte order.'''
        raise NotImplementedError()

    @overload
    def equals(self, o : Object) -> bool:
        '''Determines whether the specified Object is equal to the current instance.
        :param o: The Object to compare with the current instance.
        :returns: true if value is an instance of Encoding and is equal to the current instance; otherwise, false.'''
        raise NotImplementedError()

    @overload
    def equals(self, other : Encoding) -> bool:
        '''Determines whether the specified Encoding object is equal to the current instance.
        :param other: The Encoding object to compare with the current instance.
        :returns: true if value is equal to the current instance; otherwise, false.'''
        raise NotImplementedError()

    def getASCII(self) -> Encoding:
        '''Gets an encoding for the ASCII (7-bit) character set.'''
        raise NotImplementedError()

    def getBigEndianUnicode(self) -> Encoding:
        '''Gets an encoding for the UTF-16 format using the big endian byte order.'''
        raise NotImplementedError()

    @overload
    def getEncoding(self, codePage : int) -> Encoding:
        '''Returns the encoding associated with the specified code page identifier.
        :param codePage: The code page identifier of the preferred encoding. -or- 0, to use the default encoding.
        :returns: The Encoding object associated with the specified code page.'''
        raise NotImplementedError()

    @overload
    def getEncoding(self, charsetName : str) -> Encoding:
        '''Returns an encoding associated with the specified charset name.
        :param charsetName: specified charset name
        :returns: The Encoding object associated with the specified charset name.'''
        raise NotImplementedError()

    @overload
    def getEncoding(self, charset : Charset) -> Encoding:
        '''Returns an encoding associated with the specified charset object.
        :param charset: specified charset object
        :returns: The Encoding object associated with the specified charset object.'''
        raise NotImplementedError()

    def getDefault(self) -> Encoding:
        '''Gets an encoding for the operating system's current ANSI code page.'''
        raise NotImplementedError()

    def getUTF8(self) -> Encoding:
        '''Gets an encoding for the UTF-8 format.'''
        raise NotImplementedError()

    def getUTF7(self) -> Encoding:
        '''Gets an encoding for the UTF-7 format.'''
        raise NotImplementedError()

    def getUTF8NoBOM(self) -> Encoding:
        '''Gets an encoding for the UTF-8 format without the UTF-8 identifier.'''
        raise NotImplementedError()


class EncryptionType:
    '''Encryption Type.
    Only used by excel2003.
    We will encrypt 2007/2010 workbook using SHA AES the same as Excel does, and this EncryptionType will be ignored.'''

    XOR : EncryptionType
    '''XOR encryption algorithm.'''

    COMPATIBLE : EncryptionType
    '''Office 97/2000 compatible.'''

    ENHANCED_CRYPTOGRAPHIC_PROVIDER_V_1 : EncryptionType
    '''Enhanced encryption.'''

    STRONG_CRYPTOGRAPHIC_PROVIDER : EncryptionType
    '''Strong encryption algorithm.'''


class EquationCharacterPositionType:
    '''Specifies the position of a particular subobject within its parent'''

    TOP : EquationCharacterPositionType
    '''At the top of the parent object'''

    BOTTOM : EquationCharacterPositionType
    '''At the bottom of the parent object'''


class EquationCombiningCharacterType:
    '''Type of combining characters.'''

    UNKNOWN : EquationCombiningCharacterType
    '''Use unknown type when not found in existing type.'''

    DOT_ABOVE : EquationCombiningCharacterType
    '''"" Unicode: u0307
    Combining Dot Above'''

    DIAERESIS : EquationCombiningCharacterType
    '''"" Unicode: u0308
    Combining Diaeresis'''

    THREE_DOTS_ABOVE : EquationCombiningCharacterType
    '''"? Unicode: u20db
    Combining Three Dots Above'''

    CIRCUMFLEX_ACCENT : EquationCombiningCharacterType
    '''"" Unicode: u0302
    Combining Circumflex Accent'''

    CARON : EquationCombiningCharacterType
    '''"" Unicode: u030c
    Combining Caron'''

    ACUTE_ACCENT : EquationCombiningCharacterType
    '''"" Unicode: u0301
    Combining Acute Accent'''

    GRAVE_ACCENT : EquationCombiningCharacterType
    '''"" Unicode: u0300
    Combining Grave Accent'''

    BREVE : EquationCombiningCharacterType
    '''"" Unicode: u0306
    Combining Combining Breve'''

    TILDE : EquationCombiningCharacterType
    '''"" Unicode: u0303
    Combining Tilde'''

    OVERLINE : EquationCombiningCharacterType
    '''"" Unicode: u0305
    Combining Overline'''

    DOUBLE_OVERLINE : EquationCombiningCharacterType
    '''"" Unicode: u033f
    Combining Double Overline'''

    TOP_CURLY_BRACKET : EquationCombiningCharacterType
    '''"? Unicode: u23de
    Combining Top Curly Bracket'''

    BOTTOM_CURLY_BRACKET : EquationCombiningCharacterType
    '''"? Unicode: u23df
    Combining Bottom Curly Bracket'''

    LEFT_ARROW_ABOVE : EquationCombiningCharacterType
    '''"? Unicode: u20d6
    Combining Left Arrow Above'''

    RIGHT_ARROW_ABOVE : EquationCombiningCharacterType
    '''"? Unicode: u20d7
    Combining Right Arrow Above'''

    LEFT_RIGHT_ARROW_ABOVE : EquationCombiningCharacterType
    '''"? Unicode: u20e1
    Combining Left Right Arrow Above'''

    LEFT_HARPOON_ABOVE : EquationCombiningCharacterType
    '''"? Unicode: u20d0
    Combining Left Harpoon Above'''

    RIGHT_HARPOON_ABOVE : EquationCombiningCharacterType
    '''"? Unicode: u20d1
    Combining Right Harpoon Above'''

    LEFTWARDS_ARROW : EquationCombiningCharacterType
    '''"? Unicode: u2190
    Leftwards Arrow'''

    RIGHTWARDS_ARROW : EquationCombiningCharacterType
    '''"? Unicode: u2192
    Rightwards Arrow'''

    LEFT_RIGHT_ARROW : EquationCombiningCharacterType
    '''"? Unicode: u2194
    Left Right Arrow'''

    LEFTWARDS_DOUBLE_ARROW : EquationCombiningCharacterType
    '''"? Unicode: u21d0
    Leftwards Double Arrow'''

    RIGHTWARDS_DOUBLE_ARROW : EquationCombiningCharacterType
    '''"? Unicode: u21d2
    Rightwards Double Arrow'''

    LEFT_RIGHT_DOUBLE_ARROW : EquationCombiningCharacterType
    '''"? Unicode: u21d4
    Left Right Double Arrow'''


class EquationComponentNode:
    '''This class specifies the components of an equation or mathematical expression.
    Different types of components combined into different equations.
    For example, a fraction consists of two parts, a numerator component and a denominator component.
    For more component types, please refer to 'EquationNodeType'.'''

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class EquationDelimiterShapeType:
    '''This specifies the shape of delimiters in the delimiter object.'''

    CENTERED : EquationDelimiterShapeType
    '''The divider is centered around the entire height of its content.'''

    MATCH : EquationDelimiterShapeType
    '''The divider is altered to exactly match their contents' height.'''


class EquationFractionType:
    '''This specifies the display style of the fraction bar.'''

    BAR : EquationFractionType
    '''This specifies that the numerator is above and the denominator below is separated by a bar in the middle.'''

    NO_BAR : EquationFractionType
    '''This specifies that the numerator is above and the denominator below is not separated by a bar in the middle.'''

    LINEAR : EquationFractionType
    '''This specifies that the numerator is on the left and the denominator is on the right, separated by a '/' in between.'''

    SKEWED : EquationFractionType
    '''This specifies that the numerator is on the upper left and the denominator is on the lower right, separated by a "/".'''


class EquationHorizontalJustificationType:
    '''This specifies the default horizontal justification of equations in the document.'''

    CENTER : EquationHorizontalJustificationType
    '''Centered'''

    CENTER_GROUP : EquationHorizontalJustificationType
    '''Centered as Group'''

    LEFT : EquationHorizontalJustificationType
    '''Left Justified'''

    RIGHT : EquationHorizontalJustificationType
    '''Right Justified'''


class EquationLimitLocationType:
    '''Specifies the limit location on an operator.'''

    UND_OVR : EquationLimitLocationType
    '''Specifies that the limit is centered above or below the operator.'''

    SUB_SUP : EquationLimitLocationType
    '''Specifies that the limit is on the right side of the operator.'''


class EquationMathematicalOperatorType:
    '''Mathematical Operators Type'''

    UNKNOWN : EquationMathematicalOperatorType
    '''Use unknown type when not found in existing type.'''

    FOR_ALL : EquationMathematicalOperatorType
    '''"" Unicode:\u2200'''

    COMPLEMENT : EquationMathematicalOperatorType
    '''"? Unicode:\u2201'''

    PARTIAL_DIFFERENTIAL : EquationMathematicalOperatorType
    '''"? Unicode:\u2202'''

    EXISTS : EquationMathematicalOperatorType
    '''"? Unicode:\u2203'''

    NOT_EXISTS : EquationMathematicalOperatorType
    '''"? Unicode:\u2204'''

    EMPTY_SET : EquationMathematicalOperatorType
    '''"? Unicode:\u2205'''

    INCREMENT : EquationMathematicalOperatorType
    '''"? Unicode:\u2206'''

    NABLA : EquationMathematicalOperatorType
    '''"? Unicode:\u2207'''

    ELEMENT_OF : EquationMathematicalOperatorType
    '''"? Unicode:\u2208'''

    NOT_AN_ELEMENT_OF : EquationMathematicalOperatorType
    '''"? Unicode:\u2209'''

    SMALL_ELEMENT_OF : EquationMathematicalOperatorType
    '''"? Unicode:\u220a'''

    CONTAIN : EquationMathematicalOperatorType
    '''"? Unicode:\u220b'''

    NOT_CONTAIN : EquationMathematicalOperatorType
    '''"? Unicode:\u220c'''

    SMALL_CONTAIN : EquationMathematicalOperatorType
    '''"? Unicode:\u220d'''

    END_OF_PROOF : EquationMathematicalOperatorType
    '''"? Unicode:\u220e'''

    NARY_PRODUCT : EquationMathematicalOperatorType
    '''"? Unicode:\u220f'''

    NARY_COPRODUCT : EquationMathematicalOperatorType
    '''"? Unicode:\u2210'''

    NARY_SUMMATION : EquationMathematicalOperatorType
    '''"? Unicode:\u2211'''

    LOGICAL_AND : EquationMathematicalOperatorType
    '''"? Unicode:\u2227'''

    LOGICAL_OR : EquationMathematicalOperatorType
    '''"? Unicode:\u2228'''

    INTERSECTION : EquationMathematicalOperatorType
    '''"? Unicode:\u2229'''

    UNION : EquationMathematicalOperatorType
    '''"? Unicode:\u222a'''

    INTEGRAL : EquationMathematicalOperatorType
    '''"? Unicode:\u222b'''

    DOUBLE_INTEGRAL : EquationMathematicalOperatorType
    '''"? Unicode:\u222c'''

    TRIPLE_INTEGRAL : EquationMathematicalOperatorType
    '''"? Unicode:\u222d'''

    CONTOUR_INTEGRAL : EquationMathematicalOperatorType
    '''"? Unicode:\u222e'''

    SURFACE_INTEGRAL : EquationMathematicalOperatorType
    '''"? Unicode:\u222f'''

    VOLUME_INTEGRAL : EquationMathematicalOperatorType
    '''"? Unicode:\u2230'''

    CLOCKWISE : EquationMathematicalOperatorType
    '''"? Unicode:\u2231'''

    CLOCKWISE_CONTOUR_INTEGRAL : EquationMathematicalOperatorType
    '''"? Unicode:\u2232'''

    ANTICLOCKWISE_CONTOUR_INTEGRAL : EquationMathematicalOperatorType
    '''"? Unicode:\u2233'''

    NARY_LOGICAL_AND : EquationMathematicalOperatorType
    '''"" Unicode:\u22c0'''

    NARY_LOGICAL_OR : EquationMathematicalOperatorType
    '''"? Unicode:\u22c1'''

    NARY_INTERSECTION : EquationMathematicalOperatorType
    '''"? Unicode:\u22c2'''

    NARY_UNION : EquationMathematicalOperatorType
    '''"? Unicode:\u22c3'''


class EquationNode:
    '''Abstract class for deriving other equation nodes.'''

    def getEquationType(self) -> int:
        '''Get the equation type of the current node
        See :class:`EquationNodeType`'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()

    def removeAllChildren(self) -> None:
        '''Removes all the child nodes of the current node.'''
        raise NotImplementedError()

    def toLaTeX(self) -> str:
        '''Convert this equtation to LaTeX expression.'''
        raise NotImplementedError()

    def remove(self) -> None:
        '''Removes itself from the parent.'''
        raise NotImplementedError()

    @overload
    def addChild(self, equationType : int) -> EquationNode:
        '''Insert a node of the specified type at the end of the child node list of the current node.
        :param equationType: :class:`EquationNodeType`. Types of Equation Nodes
        :returns: If the specified type exists, the corresponding node is returned, and if the type does not exist, a node of unknown type is returned.'''
        raise NotImplementedError()

    @overload
    def addChild(self, node : EquationNode) -> None:
        '''Inserts the specified node at the end of the current node's list of child nodes.
        :param node: The specified node'''
        raise NotImplementedError()

    def setParentNode(self, value : EquationNode) -> None:
        '''Specifies the parent node of the current node
        :param value: '''
        raise NotImplementedError()

    def insertAfter(self, equationType : int) -> EquationNode:
        '''Inserts the specified node after the current node.
        :param equationType: :class:`EquationNodeType`. Types of Equation Nodes
        :returns: If the specified type exists, the corresponding node is returned, and if the type does not exist, a node of unknown type is returned.'''
        raise NotImplementedError()

    def insertBefore(self, equationType : int) -> EquationNode:
        '''Inserts the specified node before the current node.
        :param equationType: :class:`EquationNodeType`. Types of Equation Nodes
        :returns: If the specified type exists, the corresponding node is returned, and if the type does not exist, a node of unknown type is returned.'''
        raise NotImplementedError()

    def insertChild(self, index : int, equationType : int) -> EquationNode:
        '''Inserts a node of the specified type at the specified index position in the current node's child node list.
        :param index: index value
        :param equationType: :class:`EquationNodeType`. Types of Equation Nodes
        :returns: If the specified type exists, the corresponding node is returned, and if the type does not exist, a node of unknown type is returned.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents the type of the node.
        See :class:`TextNodeType`'''
        raise NotImplementedError()

    @overload
    def removeChild(self, node : EquationNode) -> None:
        '''Removes the specified node from the current node's children.
        :param node: Node to be deleted.'''
        raise NotImplementedError()

    @overload
    def removeChild(self, index : int) -> None:
        '''Removes the node at the specified index from the current node's children.
        :param index: Index of the node'''
        raise NotImplementedError()

    def getChild(self, index : int) -> EquationNode:
        '''Returns the node at the specified index among the children of the current node.
        :param index: Index of the node
        :returns: Returns the corresponding node if the specified node exists, otherwise returns null.'''
        raise NotImplementedError()

    def createNode(self, equationType : int, workbook : Workbook, parent : EquationNode) -> EquationNode:
        '''Create a node of the specified type.
        :param equationType: :class:`EquationNodeType`. Types of Equation Nodes
        :param workbook: The workbook object associated with the equation
        :param parent: The parent node where this node is located
        :returns: If the specified type exists, the corresponding node is returned, and if the type does not exist, a node of unknown type is returned.'''
        raise NotImplementedError()

    def toMathML(self) -> str:
        '''Convert this equtation to MathML expression.'''
        raise NotImplementedError()

    def getParentNode(self) -> EquationNode:
        '''Specifies the parent node of the current node'''
        raise NotImplementedError()


class EquationNodeParagraph:
    '''This class specifies a mathematical paragraph containing one or more MathEquationNode(OMath) elements.'''

    def getJustification(self) -> int:
        '''This specifies justification of the math paragraph (a series of adjacent equations within the same paragraph). A math paragraph can be Left Justified, Right Justified, Centered, or Centered as Group. By default, the math paragraph is Centered as Group. This means that the equations can be aligned with respect to each other, but the entire group of equations is centered as a whole.
        See :class:`EquationHorizontalJustificationType`'''
        raise NotImplementedError()

    def setJustification(self, value : int) -> None:
        '''This specifies justification of the math paragraph (a series of adjacent equations within the same paragraph). A math paragraph can be Left Justified, Right Justified, Centered, or Centered as Group. By default, the math paragraph is Centered as Group. This means that the equations can be aligned with respect to each other, but the entire group of equations is centered as a whole.
        See :class:`EquationHorizontalJustificationType`
        :param value: '''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class EquationNodeType:
    '''Equation node type.
    Notice:
    (1)[1-99] Currently there is only one node in the scope, and its enumeration value is 1. The node it specifies is used to store mathematical text.
    (2)[100-199] Indicates that the node is a component of some special function nodes.
    (3)[200-] Indicates that the node has some special functions.'''

    UN_KNOW : EquationNodeType
    '''UnKnow'''

    TEXT : EquationNodeType
    '''specifies a node that stores math text'''

    BASE : EquationNodeType
    '''Specifies a Base component'''

    DENOMINATOR : EquationNodeType
    '''Specifies a Denominator component'''

    NUMERATOR : EquationNodeType
    '''Specifies a Numerator component'''

    FUNCTION_NAME : EquationNodeType
    '''Specifies a FunctionName component'''

    SUBSCRIPT : EquationNodeType
    '''Specifies a Subscript component'''

    SUPERSCRIPT : EquationNodeType
    '''Specifies a Superscript component'''

    DEGREE : EquationNodeType
    '''Specifies a Degree component'''

    MATRIX_ROW : EquationNodeType
    '''Specifies a MatrixRow component.A single row of the matrix'''

    LIMIT : EquationNodeType
    '''Represents a sub-object of Lower-Limit function or Upper-Limit function'''

    EQUATION_PARAGRAPH : EquationNodeType
    '''Specifies a mathematical paragraph(oMathPara).'''

    MATHEMATICAL_EQUATION : EquationNodeType
    '''Specifies an equation or mathematical expression(OMath).'''

    FRACTION_EQUATION : EquationNodeType
    '''Specifies fractional equation'''

    FUNCTION_EQUATION : EquationNodeType
    '''Specifies function equation'''

    DELIMITER_EQUATION : EquationNodeType
    '''Specifies delimiter equation'''

    NARY_EQUATION : EquationNodeType
    '''Specifies n-ary operator equation'''

    RADICAL_EQUATION : EquationNodeType
    '''Specifies the radical equation'''

    SUPERSCRIPT_EQUATION : EquationNodeType
    '''Specifies superscript equation'''

    SUBSCRIPT_EQUATION : EquationNodeType
    '''Specifies subscript equation'''

    SUB_SUP_EQUATION : EquationNodeType
    '''Specifies an equation with superscripts and subscripts to the right of the operands.'''

    PRE_SUB_SUP_EQUATION : EquationNodeType
    '''Specifies an equation with superscripts and subscripts to the left of the operands.'''

    ACCENT_EQUATION : EquationNodeType
    '''Specifies accent equation'''

    BAR_EQUATION : EquationNodeType
    '''Specifies bar equation'''

    BORDER_BOX_EQUATION : EquationNodeType
    '''Specifies border box equation'''

    BOX_EQUATION : EquationNodeType
    '''Specifies box equation'''

    GROUP_CHARACTER_EQUATION : EquationNodeType
    '''Specifies Group-Character equation'''

    MATRIX_EQUATION : EquationNodeType
    '''Specifies the Matrix equation,'''

    LOWER_LIMIT : EquationNodeType
    '''Specifies the Lower-Limit function'''

    UPPER_LIMIT : EquationNodeType
    '''Specifies the Upper-Limit function'''

    MATHEMATICAL : EquationNodeType
    '''Specifies an equation or mathematical expression(OMath).'''

    FRACTION : EquationNodeType
    '''Specifies fractional equation'''

    FUNCTION : EquationNodeType
    '''Specifies function equation'''

    DELIMITER : EquationNodeType
    '''Specifies delimiter equation'''

    NARY : EquationNodeType
    '''Specifies n-ary operator equation'''

    RADICAL : EquationNodeType
    '''Specifies the radical equation'''

    SUP : EquationNodeType
    '''Specifies superscript equation'''

    SUB : EquationNodeType
    '''Specifies subscript equation'''

    SUB_SUP : EquationNodeType
    '''Specifies an equation with superscripts and subscripts to the right of the operands.'''

    PRE_SUB_SUP : EquationNodeType
    '''Specifies an equation with superscripts and subscripts to the left of the operands.'''

    ACCENT : EquationNodeType
    '''Specifies accent equation'''

    BAR : EquationNodeType
    '''Specifies bar equation'''

    BORDER_BOX : EquationNodeType
    '''Specifies border box equation'''

    BOX : EquationNodeType
    '''Specifies box equation'''

    GROUP_CHR : EquationNodeType
    '''Specifies Group-Character equation'''

    MATRIX : EquationNodeType
    '''Specifies the Matrix equation,'''

    ARRAY_EQUATION : EquationNodeType
    '''Specifies the Equation-Array function. The function consists of one or more equations.'''


class EquationVerticalJustificationType:
    '''This specifies the default vertical justification of equations in the document.'''

    TOP : EquationVerticalJustificationType
    '''top'''

    CENTER : EquationVerticalJustificationType
    '''center'''

    BOTTOM : EquationVerticalJustificationType
    '''bottom'''


class ErrorBar:
    '''Represents error bar of data series.'''

    def getPlusValue(self) -> str:
        '''Represents positive error amount when error bar type is Custom.'''
        raise NotImplementedError()

    def getAmount(self) -> int:
        '''Represents amount of error bar.'''
        raise NotImplementedError()

    def setDisplayType(self, value : int) -> None:
        '''Represents the display type of error bar.
        See :class:`ErrorBarDisplayType`
        :param value: '''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Represents error bar amount type.
        See :class:`ErrorBarType`
        :param value: '''
        raise NotImplementedError()

    def getMinusValue(self) -> str:
        '''Represents negative error amount when error bar type is Custom.'''
        raise NotImplementedError()

    def setAmount(self, value : int) -> None:
        '''Represents amount of error bar.
        :param value: '''
        raise NotImplementedError()

    def setShowMarkerTTop(self, value : bool) -> None:
        '''Indicates if formatting error bars with a T-top.
        :param value: '''
        raise NotImplementedError()

    def getDisplayType(self) -> int:
        '''Represents the display type of error bar.
        See :class:`ErrorBarDisplayType`'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents error bar amount type.
        See :class:`ErrorBarType`'''
        raise NotImplementedError()

    def setMinusValue(self, value : str) -> None:
        '''Represents negative error amount when error bar type is Custom.
        :param value: '''
        raise NotImplementedError()

    def setPlusValue(self, value : str) -> None:
        '''Represents positive error amount when error bar type is Custom.
        :param value: '''
        raise NotImplementedError()

    def getShowMarkerTTop(self) -> bool:
        '''Indicates if formatting error bars with a T-top.'''
        raise NotImplementedError()


class ErrorBarDisplayType:
    '''Represents error bar display type.'''

    BOTH : ErrorBarDisplayType
    '''Both'''

    MINUS : ErrorBarDisplayType
    '''Minus'''

    NONE : ErrorBarDisplayType
    '''None'''

    PLUS : ErrorBarDisplayType
    '''Plus'''


class ErrorBarType:
    '''Represents error bar amount type.'''

    CUSTOM : ErrorBarType
    '''InnerCustom value type.'''

    FIXED_VALUE : ErrorBarType
    '''Fixed value type.'''

    PERCENT : ErrorBarType
    '''Percentage type'''

    ST_DEV : ErrorBarType
    '''Standard deviation type.'''

    ST_ERROR : ErrorBarType
    '''Standard error type.'''


class ErrorCellValueType:
    '''Represents a cell value which contains an error.'''

    BLOCKED : ErrorCellValueType
    '''Represents the value of a cell containing a #BLOCKED! error.'''

    BUSY : ErrorCellValueType
    '''Represents the value of a cell containing a #BUSY! error.'''

    CALC : ErrorCellValueType
    '''Represents the value of a cell containing a #CALC! error.'''

    CONNECT : ErrorCellValueType
    '''Represents the value of a cell containing a #CONNECT! error.'''

    NAME : ErrorCellValueType
    '''Represents the value of a cell containing a #NAME? error.'''

    FIELD : ErrorCellValueType
    '''Represents the value of a cell containing a #FIELD! error.'''

    SPILL : ErrorCellValueType
    '''Represents the value of a cell containing a #SPILL! error.'''

    UNKNOWN : ErrorCellValueType
    '''Represents the value of a cell containing a #UNKNOWN! error.'''

    TIME_OUT : ErrorCellValueType
    '''Represents the value of a cell containing a #TIMEOUT! error.'''

    EXTERNAL : ErrorCellValueType
    '''Represents the value of a cell containing an #EXTERNAL! error.'''


class ErrorCheckOption:
    '''Error check setting applied on certain ranges.'''

    def addRange(self, ca : CellArea) -> int:
        '''Adds one influenced range by this setting.
        :param ca: the range to be added.
        :returns: the index of the added range in the range list of this setting.'''
        raise NotImplementedError()

    def isErrorCheck(self, errorCheckType : int) -> bool:
        '''Checks whether given error type will be checked.
        :param errorCheckType: :class:`ErrorCheckType`. error type can be checked
        :returns: return true if given error type will be checked(green triangle will be shown for cell if the check failed).'''
        raise NotImplementedError()

    def setErrorCheck(self, errorCheckType : int, isCheck : bool) -> None:
        '''Sets whether given error type will be checked.
        :param errorCheckType: :class:`ErrorCheckType`. error type can be checked.
        :param isCheck: true if given error type needs to be checked(green triangle will be shown for cell if the check failed).'''
        raise NotImplementedError()

    def removeRange(self, index : int) -> None:
        '''Removes one range by given index.
        :param index: the index of the range to be removed.'''
        raise NotImplementedError()

    def getCountOfRange(self) -> int:
        '''Gets the count of ranges that influenced by this setting.'''
        raise NotImplementedError()

    def getRange(self, index : int) -> CellArea:
        '''Gets the influenced range of this setting by given index.
        :param index: the index of range
        :returns: return influenced range at given index.'''
        raise NotImplementedError()


class ErrorCheckOptionCollection:
    '''Represents all error check option.'''

    def get(self, index : int) -> ErrorCheckOption:
        '''Gets :class:`ErrorCheckOption` object by the given index.
        :param index: The index
        :returns: Return :class:`ErrorCheckOption` object'''
        raise NotImplementedError()

    def add(self) -> int:
        '''Add an error check option.'''
        raise NotImplementedError()


class ErrorCheckType:
    '''Represents all error check type.'''

    EVALUATION_ERROR : ErrorCheckType
    '''Ignore errors when cells contain formulas that result in an error.'''

    CALC : ErrorCheckType
    '''p><strong>Remarks</strong></p>
    NOTE: This member is now obsolete. Instead,
    please use ErrorCheckType.EvaluationError enum.
    This method will be removed 12 months later since October 2023.
    Aspose apologizes for any inconvenience you may have experienced.'''

    EMPTY_CELL_REF : ErrorCheckType
    '''Ignore errors when formulas refer to empty cells.'''

    NUMBER_STORED_AS_TEXT : ErrorCheckType
    '''Ignore errors when numbers are formatted as text or are preceded by an apostrophe'''

    TEXT_NUMBER : ErrorCheckType
    '''Ignore errors when numbers are formatted as text or are preceded by an apostrophe'''

    INCONSIST_RANGE : ErrorCheckType
    '''Ignore errors when formulas omit certain cells in a region.'''

    INCONSIST_FORMULA : ErrorCheckType
    '''Ignore errors when a formula in a region of your worksheet differs from other formulas in the same region.'''

    TWO_DIGIT_TEXT_YEAR : ErrorCheckType
    '''Ignore errors when formulas contain text formatted cells with years represented as 2 digits.'''

    TEXT_DATE : ErrorCheckType
    '''Ignore errors when formulas contain text formatted cells with years represented as 2 digits.'''

    UNLOCKED_FORMULA : ErrorCheckType
    '''Ignore errors when unlocked cells contain formulas.'''

    UNPROCTED_FORMULA : ErrorCheckType
    '''Ignore errors when unlocked cells contain formulas.'''

    TABLE_DATA_VALIDATION : ErrorCheckType
    '''Ignore errors when a cell's value in a Table does not comply with the Data Validation rules specified.'''

    VALIDATION : ErrorCheckType
    '''Ignore errors when a cell's value in a Table does not comply with the Data Validation rules specified.'''

    CALCULATED_COLUMN : ErrorCheckType
    '''Ignore errors when cells contain a value different from a calculated column formula.'''


class ExceptionType:
    '''Represents custom exception type code.'''

    CHART : ExceptionType
    '''Invalid chart setting.'''

    DATA_TYPE : ExceptionType
    '''Invalid data type setting.'''

    DATA_VALIDATION : ExceptionType
    '''Invalid data validation setting.'''

    CONDITIONAL_FORMATTING : ExceptionType
    '''Invalid data validation setting.'''

    FILE_FORMAT : ExceptionType
    '''Invalid file format.'''

    FORMULA : ExceptionType
    '''Invalid formula.'''

    INVALID_DATA : ExceptionType
    '''Invalid data.'''

    INVALID_OPERATOR : ExceptionType
    '''Invalid operator.'''

    INCORRECT_PASSWORD : ExceptionType
    '''Incorrect password.'''

    LICENSE : ExceptionType
    '''License related errors.'''

    LIMITATION : ExceptionType
    '''Out of MS Excel limitation error.'''

    PAGE_SETUP : ExceptionType
    '''Invalid page setup setting.'''

    PIVOT_TABLE : ExceptionType
    '''Invalid pivotTable setting.'''

    SHAPE : ExceptionType
    '''Invalid drawing object setting.'''

    SPARKLINE : ExceptionType
    '''Invalid sparkline object setting.'''

    SHEET_NAME : ExceptionType
    '''Invalid worksheet name.'''

    SHEET_TYPE : ExceptionType
    '''Invalid worksheet type.'''

    INTERRUPTED : ExceptionType
    '''The process is interrupted.'''

    IO : ExceptionType
    '''The file is invalid.'''

    PERMISSION : ExceptionType
    '''Permission is required to open this file.'''

    UNSUPPORTED_FEATURE : ExceptionType
    '''Unsupported feature.'''

    UNSUPPORTED_STREAM : ExceptionType
    '''Unsupported stream to be opened.'''

    UNDISCLOSED_INFORMATION : ExceptionType
    '''Files contains some undisclosed information.'''

    FILE_CORRUPTED : ExceptionType
    '''File content is corrupted.'''

    DEFINED_NAME : ExceptionType
    '''Invalid defined name'''

    FONT : ExceptionType
    '''Invalid font'''

    AUTO_FILTER : ExceptionType
    '''Invalid auto filter setting.'''

    FONT_SUBSTITUTION : ExceptionType
    '''Font substitution warning type
    when a font has not been found, this warning type can be get.'''


class ExportObjectEvent:
    '''The event triggered when exporting an object, such as Picture.'''

    def getSource(self) -> Object:
        '''Gets the object to be exported.'''
        raise NotImplementedError()


class ExportRangeToJsonOptions:
    '''Indicates the options that exporting range to json.'''

    def setExportAsString(self, value : bool) -> None:
        '''Exports the string value of the cells to json.
        :param value: '''
        raise NotImplementedError()

    def setIndent(self, value : str) -> None:
        '''Indicates the indent.
        :param value: '''
        raise NotImplementedError()

    def getExportEmptyCells(self) -> bool:
        '''Indicates whether exporting empty cells as null.'''
        raise NotImplementedError()

    def setHasHeaderRow(self, value : bool) -> None:
        '''Indicates whether the range contains header row.
        :param value: '''
        raise NotImplementedError()

    def hasHeaderRow(self) -> bool:
        '''Indicates whether the range contains header row.'''
        raise NotImplementedError()

    def setExportEmptyCells(self, value : bool) -> None:
        '''Indicates whether exporting empty cells as null.
        :param value: '''
        raise NotImplementedError()

    def getIndent(self) -> str:
        '''Indicates the indent.'''
        raise NotImplementedError()

    def getExportAsString(self) -> bool:
        '''Exports the string value of the cells to json.'''
        raise NotImplementedError()


class ExportTableOptions:
    '''Represents all export table options.'''

    def setSkipErrorValue(self, value : bool) -> None:
        '''Indicates whether skip invalid value for the column.
        For example,if the column type is decimal ,the value is greater than decimal.MaxValue
        and this property is true,we will not throw exception again.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getCheckMixedValueType(self) -> bool:
        '''False, Aspose.Cells will set the DataColumn's type by the value type of the first row for performance.
        True, Aspose.Cells will check whether the value type in the column are mixed before set the DataColumn's type
        And the value type are mixed, the DataColumn's type will be string.'''
        raise NotImplementedError()

    def getPlotVisibleColumns(self) -> bool:
        '''Only exports visible columns.'''
        raise NotImplementedError()

    def setVertical(self, value : bool) -> None:
        '''True if a row in Workbook file represents a row in DataTable. False if a column in Workbook file represents a row in DataTable.
        :param value: '''
        raise NotImplementedError()

    def getExportColumnName(self) -> bool:
        '''Indicates whether the data in the first row are exported to the column name of the DataTable.
        The default value is false.'''
        raise NotImplementedError()

    def getPlotVisibleCells(self) -> bool:
        '''Only exports visible cells.'''
        raise NotImplementedError()

    def setFormatStrategy(self, value : int) -> None:
        '''Sets the format strategy when exporting the value as string value.
        See :class:`CellValueFormatStrategy`
        :param value: '''
        raise NotImplementedError()

    def setIndexes(self, value : list[int]) -> None:
        '''The indexes of columns/rows which should be exported out.
        :param value: '''
        raise NotImplementedError()

    def isVertical(self) -> bool:
        '''True if a row in Workbook file represents a row in DataTable. False if a column in Workbook file represents a row in DataTable.'''
        raise NotImplementedError()

    def setPlotVisibleColumns(self, value : bool) -> None:
        '''Only exports visible columns.
        :param value: '''
        raise NotImplementedError()

    def getRenameStrategy(self) -> int:
        '''Strategy for duplicate names of columns.
        See :class:`RenameStrategy`'''
        raise NotImplementedError()

    def setAllowDBNull(self, value : bool) -> None:
        '''This value indicates whether DBNulls are allowed in this table.
        :param value: '''
        raise NotImplementedError()

    def getAllowDBNull(self) -> bool:
        '''This value indicates whether DBNulls are allowed in this table.'''
        raise NotImplementedError()

    def setPlotVisibleCells(self, value : bool) -> None:
        '''Only exports visible cells.
        :param value: '''
        raise NotImplementedError()

    def getExportAsString(self) -> bool:
        '''Exports the string value of the cells to the DataTable.'''
        raise NotImplementedError()

    def getPlotVisibleRows(self) -> bool:
        '''Only exports visible rows.'''
        raise NotImplementedError()

    def getSkipErrorValue(self) -> bool:
        '''Indicates whether skip invalid value for the column.
        For example,if the column type is decimal ,the value is greater than decimal.MaxValue
        and this property is true,we will not throw exception again.
        The default value is false.'''
        raise NotImplementedError()

    def getExportAsHtmlString(self) -> bool:
        '''Exports the html string value of the cells to the DataTable.'''
        raise NotImplementedError()

    def getFormatStrategy(self) -> int:
        '''Gets the format strategy when exporting the value as string value.
        See :class:`CellValueFormatStrategy`'''
        raise NotImplementedError()

    def setCheckMixedValueType(self, value : bool) -> None:
        '''False, Aspose.Cells will set the DataColumn's type by the value type of the first row for performance.
        True, Aspose.Cells will check whether the value type in the column are mixed before set the DataColumn's type
        And the value type are mixed, the DataColumn's type will be string.
        :param value: '''
        raise NotImplementedError()

    def setExportColumnName(self, value : bool) -> None:
        '''Indicates whether the data in the first row are exported to the column name of the DataTable.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def preprocessExportedValue(self, cellRow : int, cellColumn : int, value : CellValue) -> bool:
        '''Preprocess the value of current cell to be exported.
        :param cellRow: the row index of current cell
        :param cellColumn: the column index of cell
        :param value: value and type of current cell
        :returns: Whether current cell has been replaced with different type and/or value.'''
        raise NotImplementedError()

    def setPlotVisibleRows(self, value : bool) -> None:
        '''Only exports visible rows.
        :param value: '''
        raise NotImplementedError()

    def setRenameStrategy(self, value : int) -> None:
        '''Strategy for duplicate names of columns.
        See :class:`RenameStrategy`
        :param value: '''
        raise NotImplementedError()

    def getIndexes(self) -> list[int]:
        '''The indexes of columns/rows which should be exported out.'''
        raise NotImplementedError()

    def setExportAsString(self, value : bool) -> None:
        '''Exports the string value of the cells to the DataTable.
        :param value: '''
        raise NotImplementedError()

    def setExportAsHtmlString(self, value : bool) -> None:
        '''Exports the html string value of the cells to the DataTable.
        :param value: '''
        raise NotImplementedError()



class ExternalConnection:
    '''Specifies an external data connection'''

    def setSavePassword(self, value : bool) -> None:
        '''True if the password is to be saved as part of the connection string; otherwise, False.
        :param value: '''
        raise NotImplementedError()

    def getRefreshOnLoad(self) -> bool:
        '''True if this connection should be refreshed when opening the file; otherwise, false.'''
        raise NotImplementedError()

    def setNew(self, value : bool) -> None:
        '''True if the connection has not been refreshed for the first time; otherwise, false.
        This state can happen when the user saves the file before a query has finished returning.
        :param value: '''
        raise NotImplementedError()

    def setBackgroundRefresh(self, value : bool) -> None:
        '''Indicates whether the connection can be refreshed in the background (asynchronously).
        true if preferred usage of the connection is to refresh asynchronously in the background;
        false if preferred usage of the connection is to refresh synchronously in the foreground.
        :param value: '''
        raise NotImplementedError()

    def getSecondCommand(self) -> str:
        '''Specifies a second command text string that is persisted when PivotTable server-based
        page fields are in use.
        For ODBC connections, serverCommand is usually a broader query than command (no
        WHERE clause is present in the former). Based on these 2 commands(Command and ServerCommand),
        parameter UI can be populated and parameterized queries can be constructed'''
        raise NotImplementedError()

    def getConnectionFile(self) -> str:
        '''Gets the connection file.'''
        raise NotImplementedError()

    def getReconnectionMethod(self) -> int:
        ''':deprecated: Use ExternalConnection.ReconnectionMethodType property instead.'''
        raise NotImplementedError()

    def setCommand(self, value : str) -> None:
        '''The string containing the database command to pass to the data provider API that will
        interact with the external source in order to retrieve data
        :param value: '''
        raise NotImplementedError()

    def getSaveData(self) -> bool:
        '''True if the external data fetched over the connection to populate a table is to be saved
        with the workbook; otherwise, false.'''
        raise NotImplementedError()

    def getCommandType(self) -> int:
        '''Specifies the OLE DB command type.
        1. Query specifies a cube name
        2. Query specifies a SQL statement
        3. Query specifies a table name
        4. Query specifies that default information has been given, and it is up to the provider how to interpret.
        5. Query is against a web based List Data Provider.
        See :class:`OLEDBCommandType`'''
        raise NotImplementedError()

    def isNew(self) -> bool:
        '''True if the connection has not been refreshed for the first time; otherwise, false.
        This state can happen when the user saves the file before a query has finished returning.'''
        raise NotImplementedError()

    def setSourceFile(self, value : str) -> None:
        '''Used when the external data source is file-based.
        When a connection to such a data source fails, the spreadsheet application attempts to connect directly to this file. May be
        expressed in URI or system-specific file path notation.
        :param value: '''
        raise NotImplementedError()

    def setSaveData(self, value : bool) -> None:
        '''True if the external data fetched over the connection to populate a table is to be saved
        with the workbook; otherwise, false.
        :param value: '''
        raise NotImplementedError()

    def getBackgroundRefresh(self) -> bool:
        '''Indicates whether the connection can be refreshed in the background (asynchronously).
        true if preferred usage of the connection is to refresh asynchronously in the background;
        false if preferred usage of the connection is to refresh synchronously in the foreground.'''
        raise NotImplementedError()

    def getKeepAlive(self) -> bool:
        '''True when the spreadsheet application should make efforts to keep the connection
        open. When false, the application should close the connection after retrieving the
        information.'''
        raise NotImplementedError()

    def setSSOId(self, value : str) -> None:
        '''Identifier for Single Sign On (SSO) used for authentication between an intermediate
        spreadsheetML server and the external data source.
        :param value: '''
        raise NotImplementedError()

    def setReconnectionMethodType(self, value : int) -> None:
        '''Specifies what the spreadsheet application should do when a connection fails.
        The default value is ReConnectionMethodType.Required.
        See :class:`ReConnectionMethodType`
        :param value: '''
        raise NotImplementedError()

    def getOdcFile(self) -> str:
        '''Specifies the full path to external connection file from which this connection was
        created. If a connection fails during an attempt to refresh data, and reconnectionMethod=1,
        then the spreadsheet application will try again using information from the external connection file
        instead of the connection object embedded within the workbook.'''
        raise NotImplementedError()

    def getType(self) -> int:
        ''':deprecated: Use ExternalConnection.SourceType property instead.'''
        raise NotImplementedError()

    def isDeleted(self) -> bool:
        '''Indicates whether the associated workbook connection has been deleted.  true if the
        connection has been deleted; otherwise, false.'''
        raise NotImplementedError()

    def getConnectionId(self) -> int:
        ''':deprecated: Use ExternalConnection.Id property instead.'''
        raise NotImplementedError()

    def getSSOId(self) -> str:
        '''Identifier for Single Sign On (SSO) used for authentication between an intermediate
        spreadsheetML server and the external data source.'''
        raise NotImplementedError()

    def getParameters(self) -> ConnectionParameterCollection:
        '''Gets :class:`ConnectionParameterCollection` for an ODBC or web query.'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        ''':deprecated: Use ExternalConnection.SourceType property instead.'''
        raise NotImplementedError()

    def getSourceType(self) -> int:
        '''Gets the external connection DataSource type.
        See :class:`ConnectionDataSourceType`'''
        raise NotImplementedError()

    def setRefreshOnLoad(self, value : bool) -> None:
        '''True if this connection should be refreshed when opening the file; otherwise, false.
        :param value: '''
        raise NotImplementedError()

    def setSecondCommand(self, value : str) -> None:
        '''Specifies a second command text string that is persisted when PivotTable server-based
        page fields are in use.
        For ODBC connections, serverCommand is usually a broader query than command (no
        WHERE clause is present in the former). Based on these 2 commands(Command and ServerCommand),
        parameter UI can be populated and parameterized queries can be constructed
        :param value: '''
        raise NotImplementedError()

    def getClassType(self) -> int:
        '''Gets the type of this :class:`ExternalConnection` object.
        See :class:`ExternalConnectionClassType`'''
        raise NotImplementedError()

    def getPowerQueryFormula(self) -> PowerQueryFormula:
        '''Gets the definition of power query formula.'''
        raise NotImplementedError()

    def getCommand(self) -> str:
        '''The string containing the database command to pass to the data provider API that will
        interact with the external source in order to retrieve data'''
        raise NotImplementedError()

    def setCredentials(self, value : int) -> None:
        ''':deprecated: Use ExternalConnection.CredentialsMethodType property instead.'''
        raise NotImplementedError()

    def setCredentialsMethodType(self, value : int) -> None:
        '''Specifies the authentication method to be used when establishing (or re-establishing) the connection.
        See :class:`CredentialsMethodType`
        :param value: '''
        raise NotImplementedError()

    def getRefreshInternal(self) -> int:
        '''Specifies the number of minutes between automatic refreshes of the connection.'''
        raise NotImplementedError()

    def getSavePassword(self) -> bool:
        '''True if the password is to be saved as part of the connection string; otherwise, False.'''
        raise NotImplementedError()

    def setReconnectionMethod(self, value : int) -> None:
        ''':deprecated: Use ExternalConnection.ReconnectionMethodType property instead.'''
        raise NotImplementedError()

    def setDeleted(self, value : bool) -> None:
        '''Indicates whether the associated workbook connection has been deleted.  true if the
        connection has been deleted; otherwise, false.
        :param value: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Specifies the name of the connection. Each connection must have a unique name.'''
        raise NotImplementedError()

    def getReconnectionMethodType(self) -> int:
        '''Specifies what the spreadsheet application should do when a connection fails.
        The default value is ReConnectionMethodType.Required.
        See :class:`ReConnectionMethodType`'''
        raise NotImplementedError()

    def getCredentialsMethodType(self) -> int:
        '''Specifies the authentication method to be used when establishing (or re-establishing) the connection.
        See :class:`CredentialsMethodType`'''
        raise NotImplementedError()

    def setOnlyUseConnectionFile(self, value : bool) -> None:
        '''Indicates whether the spreadsheet application should always and only use the
        connection information in the external connection file indicated by the odcFile attribute
        when the connection is refreshed.  If false, then the spreadsheet application
        should follow the procedure indicated by the reconnectionMethod attribute
        :param value: '''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Specifies the name of the connection. Each connection must have a unique name.
        :param value: '''
        raise NotImplementedError()

    def setConnectionString(self, value : str) -> None:
        '''The connection information string is used to make contact with an OLE DB or ODBC data source.
        :param value: '''
        raise NotImplementedError()

    def setKeepAlive(self, value : bool) -> None:
        '''True when the spreadsheet application should make efforts to keep the connection
        open. When false, the application should close the connection after retrieving the
        information.
        :param value: '''
        raise NotImplementedError()

    def getCredentials(self) -> int:
        ''':deprecated: Use ExternalConnection.CredentialsMethodType property instead.'''
        raise NotImplementedError()

    def setConnectionDescription(self, value : str) -> None:
        '''Specifies the user description for this connection
        :param value: '''
        raise NotImplementedError()

    def getConnectionString(self) -> str:
        '''The connection information string is used to make contact with an OLE DB or ODBC data source.'''
        raise NotImplementedError()

    def getOnlyUseConnectionFile(self) -> bool:
        '''Indicates whether the spreadsheet application should always and only use the
        connection information in the external connection file indicated by the odcFile attribute
        when the connection is refreshed.  If false, then the spreadsheet application
        should follow the procedure indicated by the reconnectionMethod attribute'''
        raise NotImplementedError()

    def setSourceType(self, value : int) -> None:
        '''Sets the external connection DataSource type.
        See :class:`ConnectionDataSourceType`
        :param value: '''
        raise NotImplementedError()

    def setCommandType(self, value : int) -> None:
        '''Specifies the OLE DB command type.
        1. Query specifies a cube name
        2. Query specifies a SQL statement
        3. Query specifies a table name
        4. Query specifies that default information has been given, and it is up to the provider how to interpret.
        5. Query is against a web based List Data Provider.
        See :class:`OLEDBCommandType`
        :param value: '''
        raise NotImplementedError()

    def setOdcFile(self, value : str) -> None:
        '''Specifies the full path to external connection file from which this connection was
        created. If a connection fails during an attempt to refresh data, and reconnectionMethod=1,
        then the spreadsheet application will try again using information from the external connection file
        instead of the connection object embedded within the workbook.
        :param value: '''
        raise NotImplementedError()

    def getId(self) -> int:
        '''Gets the id of the connection.'''
        raise NotImplementedError()

    def getSourceFile(self) -> str:
        '''Used when the external data source is file-based.
        When a connection to such a data source fails, the spreadsheet application attempts to connect directly to this file. May be
        expressed in URI or system-specific file path notation.'''
        raise NotImplementedError()

    def getConnectionDescription(self) -> str:
        '''Specifies the user description for this connection'''
        raise NotImplementedError()

    def setRefreshInternal(self, value : int) -> None:
        '''Specifies the number of minutes between automatic refreshes of the connection.
        :param value: '''
        raise NotImplementedError()


class ExternalConnectionClassType:
    '''Represents the type of connection'''

    DATABASE : ExternalConnectionClassType
    '''ODBC or OLE DB'''

    WEB_QUERY : ExternalConnectionClassType
    '''Web query'''

    TEXT_BASED : ExternalConnectionClassType
    '''Based on text'''

    DATA_MODEL : ExternalConnectionClassType
    '''Data model'''

    UNKOWN : ExternalConnectionClassType
    ''''''


class ExternalConnectionCollection:
    '''Specifies the :class:`ExternalConnection` collection'''

    @overload
    def get(self, index : int) -> ExternalConnection:
        '''Gets the :class:`ExternalConnection` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def get(self, connectionName : str) -> ExternalConnection:
        '''Gets the :class:`ExternalConnection` element with the specified name.
        :param connectionName: the name of data connection
        :returns: The element with the specified name.'''
        raise NotImplementedError()

    def getExternalConnectionById(self, connId : int) -> ExternalConnection:
        '''Gets the :class:`ExternalConnection` element with the specified id.
        :param connId: external connection id
        :returns: The element with the specified id.'''
        raise NotImplementedError()


class ExternalLink:
    '''Represents an external link in a workbook.'''

    def isReferred(self) -> bool:
        '''Indicates whether this external link is referenced by others.'''
        raise NotImplementedError()

    def addExternalName(self, text : str, referTo : str) -> None:
        '''Adds an external name.
        :param text: The text of the external name.
        :param referTo: The referTo of the external name. It must be a cell or the range.'''
        raise NotImplementedError()

    def getOriginalDataSource(self) -> str:
        '''Represents stored data source of the external link.'''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Indicates whether this external link is visible in MS Excel.'''
        raise NotImplementedError()

    def getDataSource(self) -> str:
        '''Represents data source of the external link.'''
        raise NotImplementedError()

    def getPathType(self) -> str:
        '''Get the path type of this external link'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of external link.
        See :class:`ExternalLinkType`'''
        raise NotImplementedError()

    def setDataSource(self, value : str) -> None:
        '''Represents data source of the external link.
        :param value: '''
        raise NotImplementedError()

    def setOriginalDataSource(self, value : str) -> None:
        '''Represents stored data source of the external link.
        :param value: '''
        raise NotImplementedError()


class ExternalLinkCollection:
    '''Represents external links collection in a workbook.'''

    @overload
    def clear(self) -> None:
        '''Removes all external links.'''
        raise NotImplementedError()

    @overload
    def clear(self, updateReferencesAsLocal : bool) -> None:
        '''Removes all external links.
        :param updateReferencesAsLocal: '''
        raise NotImplementedError()

    @overload
    def removeAt(self, index : int) -> None:
        '''Removes the specified external link from the workbook.
        :param index: the index of the external link to be removed.'''
        raise NotImplementedError()

    @overload
    def removeAt(self, index : int, updateReferencesAsLocal : bool) -> None:
        '''Removes the specified external link from the workbook.
        :param index: the index of the external link to be removed.
        :param updateReferencesAsLocal: '''
        raise NotImplementedError()

    def getCount(self) -> int:
        '''Gets the number of elements actually contained in the collection.'''
        raise NotImplementedError()

    def get(self, index : int) -> ExternalLink:
        '''Gets the :class:`ExternalLink` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    def iterator(self) -> Iterator:
        '''Get an enumerator that iterates through this collection.'''
        raise NotImplementedError()

    @overload
    def add(self, fileName : str, sheetNames : list[str]) -> int:
        '''Adds an external link.
        :param fileName: The external file name.
        :param sheetNames: All sheet names of the external file.
        :returns: The position of the external name in this list.'''
        raise NotImplementedError()

    @overload
    def add(self, directoryType : int, fileName : str, sheetNames : list[str]) -> int:
        '''Add an external link .
        :param directoryType: :class:`DirectoryType`. The directory type of the file name.
        :param fileName: the file name.
        :param sheetNames: All sheet names of the external file.
        :returns: The position of the external name in this list.'''
        raise NotImplementedError()


class ExternalLinkType:
    '''Represents the type of external link.'''

    DDE_LINK : ExternalLinkType
    '''Represents the DDE link.'''

    EXTERNAL : ExternalLinkType
    '''Represents external link.'''


class FileFontSource:
    '''Represents the single TrueType font file stored in the file system.'''

    def getType(self) -> int:
        '''Returns the type of the font source.
        See :class:`FontSourceType`'''
        raise NotImplementedError()

    def getFilePath(self) -> str:
        '''Path to font file.'''
        raise NotImplementedError()


class FileFormatInfo:
    '''Contains data returned by :class:`FileFormatUtil` file format detection methods.'''

    def isEncrypted(self) -> bool:
        '''Returns true if the document is encrypted and requires a password to open.'''
        raise NotImplementedError()

    def isProtectedByRMS(self) -> bool:
        '''Gets whether the file is protected by Microsoft Rights Management Server.'''
        raise NotImplementedError()

    def getLoadFormat(self) -> int:
        '''Gets the detected load format.
        See :class:`LoadFormat`'''
        raise NotImplementedError()

    def getFileFormatType(self) -> int:
        '''Gets the detected file format.
        See :class:`FileFormatType`'''
        raise NotImplementedError()


class FileFormatType:
    '''Represents the file format types.'''

    CSV : FileFormatType
    '''Comma-Separated Values(CSV) text file.'''

    XLSX : FileFormatType
    '''Office Open XML SpreadsheetML file (macro-free).'''

    XLSM : FileFormatType
    '''Office Open XML SpreadsheetML Macro-Enabled file.'''

    XLTX : FileFormatType
    '''Office Open XML SpreadsheetML Template (macro-free).'''

    XLTM : FileFormatType
    '''Office Open XML SpreadsheetML Macro-Enabled Template.'''

    XLAM : FileFormatType
    '''Office Open XML SpreadsheetML addinMacro-Enabled file.'''

    TSV : FileFormatType
    '''Tab-Separated Values(TSV) text file.'''

    TAB_DELIMITED : FileFormatType
    '''Tab-Separated Values(TSV) text file, same with :attr:`LoadFormat.TSV`.'''

    HTML : FileFormatType
    '''HTML format.'''

    M_HTML : FileFormatType
    '''MHTML (Web archive) format.'''

    ODS : FileFormatType
    '''Open Document Sheet(ODS) file.'''

    EXCEL_97_TO_2003 : FileFormatType
    '''Excel97-2003 spreadsheet file.'''

    SPREADSHEET_ML : FileFormatType
    '''Excel 2003 XML Data file.'''

    XLSB : FileFormatType
    '''The Excel Binary File Format (.xlsb)'''

    UNKNOWN : FileFormatType
    '''Represents unrecognized format, cannot be loaded.'''

    PDF : FileFormatType
    '''PDF (Adobe Portable Document) format.'''

    XPS : FileFormatType
    '''XPS (XML Paper Specification) format.'''

    TIFF : FileFormatType
    '''Represents a TIFF file.'''

    SVG : FileFormatType
    '''SVG file.'''

    EXCEL_95 : FileFormatType
    '''Represents an Excel95 xls file.'''

    EXCEL_4 : FileFormatType
    '''Represents an Excel4.0 xls file.'''

    EXCEL_3 : FileFormatType
    '''Represents an Excel3.0 xls file.'''

    EXCEL_2 : FileFormatType
    '''Represents an Excel2.1 xls file.'''

    PPTX : FileFormatType
    '''Represents a pptx file.'''

    DOCX : FileFormatType
    '''Represents a docx file.'''

    DIF : FileFormatType
    '''Data Interchange Format.'''

    DOC : FileFormatType
    '''Represents a doc file.'''

    PPT : FileFormatType
    '''Represents a ppt file.'''

    MAPI_MESSAGE : FileFormatType
    '''Represents a email file.'''

    MS_EQUATION : FileFormatType
    '''Represents the MS Equation 3.0 object.'''

    OLE_10_NATIVE : FileFormatType
    '''Represents the embedded native object.'''

    VSD : FileFormatType
    '''Represents MS Visio VSD binary format.'''

    VSDX : FileFormatType
    '''Represents MS Visio 2013 VSDX file format.'''

    DOCM : FileFormatType
    '''Represents a docm file.'''

    DOTX : FileFormatType
    '''Represents a dotx file.'''

    DOTM : FileFormatType
    '''Represents a dotm file.'''

    PPTM : FileFormatType
    '''Represents a pptm file.'''

    POTX : FileFormatType
    '''Represents a Potx file.'''

    POTM : FileFormatType
    '''Represents a Potm file.'''

    PPSX : FileFormatType
    '''Represents a ppsx file.'''

    PPSM : FileFormatType
    '''Represents a ppsm file.'''

    OOXML : FileFormatType
    '''Represents office open xml file(such as xlsx, docx,pptx, etc).'''

    ODT : FileFormatType
    '''Represents an ODT file.'''

    ODP : FileFormatType
    '''Represents a ODP file.'''

    ODF : FileFormatType
    '''Represents an ODF file.'''

    ODG : FileFormatType
    '''Represents an ODG file.'''

    XML : FileFormatType
    '''Represents a simple xml file.'''

    XLT : FileFormatType
    '''Excel97-2003 spreadsheet template.'''

    OTT : FileFormatType
    '''Represents an OTT file.'''

    BMP : FileFormatType
    '''Represents a BMP file.'''

    OTS : FileFormatType
    '''Represents an ots file.'''

    NUMBERS : FileFormatType
    '''Represents Numbers 9.0 file format by Apple Inc.'''

    NUMBERS_09 : FileFormatType
    '''Represents Numbers 9.0 file format by Apple Inc.'''

    MARKDOWN : FileFormatType
    '''Represents markdown document.'''

    GRAPH_CHART : FileFormatType
    '''Represents embedded graph chart.'''

    FODS : FileFormatType
    '''Represents OpenDocument Flat XML Spreadsheet (.fods) file format.'''

    SXC : FileFormatType
    '''Represents StarOffice Calc Spreadsheet (.sxc) file format.'''

    OTP : FileFormatType
    '''Represents a OTP file.'''

    NUMBERS_35 : FileFormatType
    '''Represents Numbers 3.5 file format since 2014 by Apple Inc'''

    OLE : FileFormatType
    '''Represents the embedded ole object.'''

    EMF : FileFormatType
    '''Windows Enhanced Metafile.'''

    WMF : FileFormatType
    '''Windows Metafile.'''

    JPG : FileFormatType
    '''JPEG JFIF.'''

    PNG : FileFormatType
    '''Portable Network Graphics.'''

    GIF : FileFormatType
    '''Gif'''

    WEB_P : FileFormatType
    '''Webp'''

    JSON : FileFormatType
    '''Json'''

    SQL_SCRIPT : FileFormatType
    '''Sql'''

    X_HTML : FileFormatType
    '''Rrepesents XHtml file.'''

    ONE_NOTE : FileFormatType
    '''Rrepesents One Note file.'''

    MICROSOFT_CABINET : FileFormatType
    '''Rrepesents Microsoft Cabinet file.'''

    RTF : FileFormatType
    '''Rtf'''

    EPUB : FileFormatType
    '''EPUB'''

    AZW_3 : FileFormatType
    '''AZW3'''

    CHM : FileFormatType
    '''CHM'''

    OXPS : FileFormatType
    '''OXPS (Open XML Paper Specification) format.'''

    G_ZIP : FileFormatType
    '''Rrepesents GZip file.'''


class FileFormatUtil:
    '''Provides utility methods for converting file format enums to strings or file extensions and back.'''

    def saveFormatToLoadFormat(self, saveFormat : int) -> int:
        '''Converts a SaveFormat value to a LoadFormat value if possible.
        :param saveFormat: :class:`SaveFormat`. The save format.
        :returns: :class:`LoadFormat`. The load format'''
        raise NotImplementedError()

    def verifyPassword(self, stream : InputStream, password : str) -> bool:
        '''Detects and returns the information about a format of an excel stored in a stream.
        :param stream: 
        :param password: The password for encrypted ooxml files.
        :returns: Returns whether the password is corrected.'''
        raise NotImplementedError()

    @overload
    def detectFileFormat(self, stream : InputStream) -> FileFormatInfo:
        '''Detects and returns the information about a format of an excel stored in a stream.
        :param stream: The stream
        :returns: A :class:`FileFormatInfo` object that contains the detected information.'''
        raise NotImplementedError()

    @overload
    def detectFileFormat(self, stream : InputStream, password : str) -> FileFormatInfo:
        '''Detects and returns the information about a format of an excel stored in a stream.
        :param stream: 
        :param password: The password for encrypted ooxml files.
        :returns: A :class:`FileFormatInfo` object that contains the detected information.'''
        raise NotImplementedError()

    @overload
    def detectFileFormat(self, filePath : str) -> FileFormatInfo:
        '''Detects and returns the information about a format of an excel stored in a file.
        :param filePath: The file path.
        :returns: A :class:`FileFormatInfo` object that contains the detected information.'''
        raise NotImplementedError()

    @overload
    def detectFileFormat(self, filePath : str, password : str) -> FileFormatInfo:
        '''Detects and returns the information about a format of an excel stored in a file.
        :param filePath: The file path.
        :param password: The password for encrypted ooxml files.
        :returns: A :class:`FileFormatInfo` object that contains the detected information.'''
        raise NotImplementedError()

    def extensionToSaveFormat(self, extension : str) -> int:
        '''Converts a file name extension into a SaveFormat value.
        :param extension: The file extension. Can be with or without a leading dot. Case-insensitive.
        :returns: :class:`SaveFormat`.'''
        raise NotImplementedError()

    def fileFormatToSaveFormat(self, format : int) -> int:
        '''Converting file format to save format.
        :param format: :class:`FileFormatType`. The file format type.
        :returns: :class:`SaveFormat`.'''
        raise NotImplementedError()

    def loadFormatToSaveFormat(self, loadFormat : int) -> int:
        '''Converts a LoadFormat value to a SaveFormat value if possible.
        :param loadFormat: :class:`LoadFormat`. The load format.
        :returns: :class:`SaveFormat`. The save format.'''
        raise NotImplementedError()

    def saveFormatToExtension(self, format : int) -> str:
        '''Converts a save format enumerated value into a file extension.
        :param format: :class:`SaveFormat`. The save format.
        :returns: The returned extension is a lower-case string with a leading dot.'''
        raise NotImplementedError()

    def loadFormatToExtension(self, loadFormat : int) -> str:
        '''Converts a load format enumerated value into a file extension.
        :param loadFormat: :class:`LoadFormat`. The loaded file format.
        :returns: The returned extension is a lower-case string with a leading dot.'''
        raise NotImplementedError()

    def isTemplateFormat(self, extension : str) -> bool:
        '''Returns true if the extension is .xlt, .xltX, .xltm,.ots.
        :param extension: '''
        raise NotImplementedError()


class Fill:
    '''Represents the fill format of the shape.'''

    def hashCode(self) -> int:
        '''Gets the hash code.'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''/
        :param obj: '''
        raise NotImplementedError()


class FillFormat:
    '''Encapsulates the object that represents fill formatting for a shape.'''

    def getGradientStyle(self) -> int:
        '''Returns the gradient style for the specified fill.
        See :class:`GradientStyleType`'''
        raise NotImplementedError()

    def getGradientColorType(self) -> int:
        '''Returns the gradient color type for the specified fill.
        See :class:`GradientColorType`'''
        raise NotImplementedError()

    def getImageData(self) -> list[int]:
        '''Gets the picture image data.'''
        raise NotImplementedError()

    def getSetType(self) -> int:
        ''':deprecated: Use FillFormat.FillType instead.'''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()

    def setPictureFormatType(self, value : int) -> None:
        '''Sets the picture format type.
        See :class:`FillPictureType`
        :param value: '''
        raise NotImplementedError()

    def setTexture(self, value : int) -> None:
        '''Represents the texture type for the specified fill.
        See :class:`TextureType`
        :param value: '''
        raise NotImplementedError()

    def getGradientColor2(self) -> Color:
        '''Returns the gradient color 2 for the specified fill.'''
        raise NotImplementedError()

    def getGradientColor1(self) -> Color:
        '''Returns the gradient color 1 for the specified fill.'''
        raise NotImplementedError()

    def getGradientFill(self) -> GradientFill:
        '''Gets :meth:`FillFormat.getGradientFill()` object.'''
        raise NotImplementedError()

    def setTransparency(self, value : int) -> None:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def setOneColorGradient(self, color : Color, degree : int, style : int, variant : int) -> None:
        '''Sets the specified fill to a one-color gradient.
        Only applies for Excel 2007.
        :param color: One gradient color.
        :param degree: The gradient degree. Can be a value from 0.0 (dark) through 1.0 (light).
        :param style: :class:`GradientStyleType`. Gradient shading style.
        :param variant: The gradient variant. Can be a value from 1 through 4, corresponding to one of the four variants on the Gradient tab in the Fill Effects dialog box. If style is GradientStyle.FromCenter, the Variant argument can only be 1 or 2.'''
        raise NotImplementedError()

    def setScale(self, value : int) -> None:
        '''Sets the picture format scale.
        :param value: '''
        raise NotImplementedError()

    def getScale(self) -> int:
        '''Gets the picture format scale.'''
        raise NotImplementedError()

    def getFillType(self) -> int:
        '''Gets fill type
        See :class:`FillType`'''
        raise NotImplementedError()

    @overload
    def setTwoColorGradient(self, color1 : Color, color2 : Color, style : int, variant : int) -> None:
        '''Sets the specified fill to a two-color gradient.
        Only applies for Excel 2007.
        :param color1: One gradient color.
        :param color2: Two gradient color.
        :param style: :class:`GradientStyleType`. Gradient shading style.
        :param variant: The gradient variant. Can be a value from 1 through 4, corresponding to one of the four variants on the Gradient tab in the Fill Effects dialog box. If style is GradientStyle.FromCenter, the Variant argument can only be 1 or 2.'''
        raise NotImplementedError()

    @overload
    def setTwoColorGradient(self, color1 : Color, transparency1 : int, color2 : Color, transparency2 : int, style : int, variant : int) -> None:
        '''Sets the specified fill to a two-color gradient.
        Only applies for Excel 2007.
        :param color1: One gradient color.
        :param transparency1: The degree of transparency of the color1 as a value from 0.0 (opaque) through 1.0 (clear).
        :param color2: Two gradient color.
        :param transparency2: The degree of transparency of the color2 as a value from 0.0 (opaque) through 1.0 (clear).
        :param style: :class:`GradientStyleType`. Gradient shading style.
        :param variant: The gradient variant. Can be a value from 1 through 4, corresponding to one of the four variants on the Gradient tab in the Fill Effects dialog box. If style is GradientStyle.FromCenter, the Variant argument can only be 1 or 2.'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        ''':deprecated: Use FillFormat.FillType  instead.'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''
        :param obj: '''
        raise NotImplementedError()

    def getPattern(self) -> int:
        '''Represents an area's display pattern.
        See :class:`FillPattern`'''
        raise NotImplementedError()

    def setImageData(self, value : list[int]) -> None:
        '''Sets the picture image data.
        :param value: '''
        raise NotImplementedError()

    def getSolidFill(self) -> SolidFill:
        '''Gets :meth:`FillFormat.getSolidFill()` object.'''
        raise NotImplementedError()

    def setSetType(self, value : int) -> None:
        ''':deprecated: Use FillFormat.FillType instead.'''
        raise NotImplementedError()

    def getTextureFill(self) -> TextureFill:
        '''Gets :meth:`FillFormat.getTextureFill()` object.'''
        raise NotImplementedError()

    def getGradientDegree(self) -> int:
        '''Returns the gradient degree for the specified fill.
        Only applies for Excel 2007.'''
        raise NotImplementedError()

    def setFillType(self, value : int) -> None:
        '''Sets fill type
        See :class:`FillType`
        :param value: '''
        raise NotImplementedError()

    def hashCode(self) -> int:
        '''Gets the hash code.'''
        raise NotImplementedError()

    def getType(self) -> int:
        ''':deprecated: Use FillFormat.FillType  instead.'''
        raise NotImplementedError()

    def getGradientVariant(self) -> int:
        '''Returns the gradient variant for the specified fill.
        Only applies for Excel 2007.'''
        raise NotImplementedError()

    def getTexture(self) -> int:
        '''Represents the texture type for the specified fill.
        See :class:`TextureType`'''
        raise NotImplementedError()

    def getPatternFill(self) -> PatternFill:
        '''Gets :meth:`FillFormat.getPatternFill()` object.'''
        raise NotImplementedError()

    def getPictureFormatType(self) -> int:
        '''Gets the picture format type.
        See :class:`FillPictureType`'''
        raise NotImplementedError()

    def setPattern(self, value : int) -> None:
        '''Represents an area's display pattern.
        See :class:`FillPattern`
        :param value: '''
        raise NotImplementedError()

    def setPresetColorGradient(self, presetColor : int, style : int, variant : int) -> None:
        '''Sets the specified fill to a preset-color gradient.
        Only applies for Excel 2007.
        :param presetColor: :class:`GradientPresetType`. Preset color type
        :param style: :class:`GradientStyleType`. Gradient shading style.
        :param variant: The gradient variant. Can be a value from 1 through 4, corresponding to one of the four variants on the Gradient tab in the Fill Effects dialog box. If style is GradientStyle.FromCenter, the Variant argument can only be 1 or 2.'''
        raise NotImplementedError()

    def getPresetColor(self) -> int:
        '''Returns the gradient preset color for the specified fill.
        See :class:`GradientPresetType`'''
        raise NotImplementedError()


class FillPattern:
    '''Enumerates shape fill pattern types.'''

    NONE : FillPattern
    '''Represents no background.'''

    SOLID : FillPattern
    '''Represents solid pattern.'''

    GRAY_5 : FillPattern
    '''Represents 5% gray pattern.'''

    GRAY_10 : FillPattern
    '''Represents 10% gray pattern.'''

    GRAY_20 : FillPattern
    '''Represents 20% gray pattern.'''

    GRAY_30 : FillPattern
    '''Represents 30% gray pattern.'''

    GRAY_40 : FillPattern
    '''Represents 40% gray pattern.'''

    GRAY_50 : FillPattern
    '''Represents 50% gray pattern.'''

    GRAY_60 : FillPattern
    '''Represents 60% gray pattern.'''

    GRAY_70 : FillPattern
    '''Represents 70% gray pattern.'''

    GRAY_75 : FillPattern
    '''Represents 75% gray pattern.'''

    GRAY_80 : FillPattern
    '''Represents 80% gray pattern.'''

    GRAY_90 : FillPattern
    '''Represents 90% gray pattern.'''

    GRAY_25 : FillPattern
    '''Represents 25% gray pattern.'''

    LIGHT_DOWNWARD_DIAGONAL : FillPattern
    '''Represents light downward diagonal pattern.'''

    LIGHT_UPWARD_DIAGONAL : FillPattern
    '''Represents light upward diagonal pattern.'''

    DARK_DOWNWARD_DIAGONAL : FillPattern
    '''Represents dark downward diagonal pattern.'''

    DARK_UPWARD_DIAGONAL : FillPattern
    '''Represents dark upward diagonal pattern.'''

    WIDE_DOWNWARD_DIAGONAL : FillPattern
    '''Represents wide downward diagonal pattern.'''

    WIDE_UPWARD_DIAGONAL : FillPattern
    '''Represents wide upward diagonal pattern.'''

    LIGHT_VERTICAL : FillPattern
    '''Represents light vertical pattern.'''

    LIGHT_HORIZONTAL : FillPattern
    '''Represents light horizontal pattern.'''

    NARROW_VERTICAL : FillPattern
    '''Represents narrow vertical pattern.'''

    NARROW_HORIZONTAL : FillPattern
    '''Represents narrow horizontal pattern.'''

    DARK_VERTICAL : FillPattern
    '''Represents dark vertical pattern.'''

    DARK_HORIZONTAL : FillPattern
    '''Represents dark horizontal pattern.'''

    DASHED_DOWNWARD_DIAGONAL : FillPattern
    '''Represents dashed downward diagonal pattern.'''

    DASHED_UPWARD_DIAGONAL : FillPattern
    '''Represents dashed upward diagonal pattern.'''

    DASHED_VERTICAL : FillPattern
    '''Represents dashed vertical pattern.'''

    DASHED_HORIZONTAL : FillPattern
    '''Represents dashed horizontal pattern.'''

    SMALL_CONFETTI : FillPattern
    '''Represents small confetti pattern.'''

    LARGE_CONFETTI : FillPattern
    '''Represents large confetti pattern.'''

    ZIG_ZAG : FillPattern
    '''Represents zig zag pattern.'''

    WAVE : FillPattern
    '''Represents wave pattern.'''

    DIAGONAL_BRICK : FillPattern
    '''Represents diagonal brick pattern.'''

    HORIZONTAL_BRICK : FillPattern
    '''Represents horizontal brick pattern.'''

    WEAVE : FillPattern
    '''Represents weave pattern.'''

    PLAID : FillPattern
    '''Represents plaid pattern.'''

    DIVOT : FillPattern
    '''Represents divot pattern.'''

    DOTTED_GRID : FillPattern
    '''Represents dotted grid pattern.'''

    DOTTED_DIAMOND : FillPattern
    '''Represents dotted diamond pattern.'''

    SHINGLE : FillPattern
    '''Represents shingle pattern.'''

    TRELLIS : FillPattern
    '''Represents trellis pattern.'''

    SPHERE : FillPattern
    '''Represents sphere pattern.'''

    SMALL_GRID : FillPattern
    '''Represents small grid pattern.'''

    LARGE_GRID : FillPattern
    '''Represents large grid pattern.'''

    SMALL_CHECKER_BOARD : FillPattern
    '''Represents small checker board pattern.'''

    LARGE_CHECKER_BOARD : FillPattern
    '''Represents large checker board pattern.'''

    OUTLINED_DIAMOND : FillPattern
    '''Represents outlined diamond pattern.'''

    SOLID_DIAMOND : FillPattern
    '''Represents solid diamond pattern.'''

    UNKNOWN : FillPattern
    '''Represents unknown pattern.'''


class FillPictureType:
    '''Represents the picture fill type.'''

    STRETCH : FillPictureType
    '''Stretch'''

    STACK : FillPictureType
    '''Stack'''

    STACK_AND_SCALE : FillPictureType
    '''StackAndScale'''


class FillType:
    '''Fill format type.'''

    AUTOMATIC : FillType
    '''Represents automatic formatting type.'''

    NONE : FillType
    '''Represents none formatting type.'''

    SOLID : FillType
    '''Solid fill format.'''

    GRADIENT : FillType
    '''Gradient fill format.'''

    TEXTURE : FillType
    '''Texture fill format(includes picture fill).'''

    PATTERN : FillType
    '''Pattern fill format.'''

    GROUP : FillType
    '''Inherit the fill properties of the group.'''


class FilterCategory:
    '''Represents the category of the filter.'''

    NONE : FilterCategory
    '''No Filter.'''

    LABEL : FilterCategory
    '''Caption Filter.'''

    NUMBER_VALUE : FilterCategory
    '''Number Value Filter.'''

    DATE : FilterCategory
    '''Date Value Filter.'''

    TOP_10 : FilterCategory
    '''Top10 Value Filter.'''


class FilterColumn:
    '''Represents a filter for a single column. The Filter object is a member of the Filters collection'''

    def setFieldIndex(self, value : int) -> None:
        '''Sets the column offset in the range.
        :param value: '''
        raise NotImplementedError()

    def getFilterType(self) -> int:
        '''Gets the type fo filtering data.
        See :class:`FilterType`'''
        raise NotImplementedError()

    def getFilter(self) -> Object:
        '''Gets the condition of filtering data.'''
        raise NotImplementedError()

    def setDropdownVisible(self, value : bool) -> None:
        '''Indicates whether the AutoFilter button for this column is visible.
        :param value: '''
        raise NotImplementedError()

    def setFilterType(self, value : int) -> None:
        '''Sets the type fo filtering data.
        See :class:`FilterType`
        :param value: '''
        raise NotImplementedError()

    def setFilter(self, value : Object) -> None:
        '''Sets the condition of filtering data.
        :param value: '''
        raise NotImplementedError()

    def isDropdownVisible(self) -> bool:
        '''Indicates whether the AutoFilter button for this column is visible.'''
        raise NotImplementedError()

    def getFieldIndex(self) -> int:
        '''Gets the column offset in the range.'''
        raise NotImplementedError()


class FilterColumnCollection:
    '''A collection of Filter objects that represents all the filters in an autofiltered range.'''

    def removeAt(self, index : int) -> None:
        '''
        :param index: '''
        raise NotImplementedError()

    def get(self, fieldIndex : int) -> FilterColumn:
        '''Gets :class:`FilterColumn` object at the special field.
        :param fieldIndex: The integer offset of the field on which you want to base the filter
        :returns: Returns :class:`FilterColumn` object.'''
        raise NotImplementedError()

    def getByIndex(self, index : int) -> FilterColumn:
        '''Returns a single Filter object from a collection.
        :param index: '''
        raise NotImplementedError()


class FilterOperatorType:
    '''Custom Filter operator type.'''

    LESS_OR_EQUAL : FilterOperatorType
    '''Represents LessOrEqual operator.'''

    LESS_THAN : FilterOperatorType
    '''Represents LessThan operator.'''

    EQUAL : FilterOperatorType
    '''Represents Equal operator.'''

    GREATER_THAN : FilterOperatorType
    '''Represents GreaterThan operator.'''

    NOT_EQUAL : FilterOperatorType
    '''Represents NotEqual operator.'''

    GREATER_OR_EQUAL : FilterOperatorType
    '''Represents GreaterOrEqual operator.'''

    NONE : FilterOperatorType
    '''Represents no comparison.'''

    BEGINS_WITH : FilterOperatorType
    '''Begins with the text.'''

    ENDS_WITH : FilterOperatorType
    '''Ends with the text.'''

    CONTAINS : FilterOperatorType
    '''Contains the text.'''

    NOT_CONTAINS : FilterOperatorType
    '''Not contains the text.'''

    NOT_BEGINS_WITH : FilterOperatorType
    '''Not begins with the text.'''

    NOT_ENDS_WITH : FilterOperatorType
    '''Not ends with the text.'''


class FilterType:
    '''The filter type.'''

    COLOR_FILTER : FilterType
    '''Filter by fill color of the cell.'''

    CUSTOM_FILTERS : FilterType
    '''Custom filter type.'''

    DYNAMIC_FILTER : FilterType
    '''Dynamic filter type.'''

    MULTIPLE_FILTERS : FilterType
    '''When multiple values are chosen to filter by, or when a group of date values are chosen to filter by,
    this element groups those criteria together.'''

    ICON_FILTER : FilterType
    '''Filter by icon of conditional formatting.'''

    TOP_10 : FilterType
    '''Top 10 filter.'''

    NONE : FilterType
    '''No filter.'''


class FindOptions:
    '''Represents find options.'''

    def setLookInType(self, value : int) -> None:
        '''Look in type.
        See :class:`LookInType`
        :param value: '''
        raise NotImplementedError()

    def getCaseSensitive(self) -> bool:
        '''Indicates if the searched string is case sensitive.'''
        raise NotImplementedError()

    def getSearchNext(self) -> bool:
        ''':deprecated: Use FindOptions.SearchBackward property instead.'''
        raise NotImplementedError()

    def getLookAtType(self) -> int:
        '''Look at type.
        See :class:`LookAtType`'''
        raise NotImplementedError()

    def setSearchBackward(self, value : bool) -> None:
        '''Whether search backward for cells.
        :param value: '''
        raise NotImplementedError()

    def setStyle(self, value : Style) -> None:
        '''The format to search for.
        :param value: '''
        raise NotImplementedError()

    def getValueTypeSensitive(self) -> bool:
        '''Indicates whether searched cell value type should be same with the searched key.'''
        raise NotImplementedError()

    def getStyle(self) -> Style:
        '''The format to search for.'''
        raise NotImplementedError()

    def setSearchNext(self, value : bool) -> None:
        ''':deprecated: Use FindOptions.SearchBackward property instead.'''
        raise NotImplementedError()

    def getSeachOrderByRows(self) -> bool:
        ''':deprecated: Use FindOptions.SearchOrderByRows property instead.'''
        raise NotImplementedError()

    def getSearchOrderByRows(self) -> bool:
        '''Indicates whether search order by rows or columns.'''
        raise NotImplementedError()

    def setCaseSensitive(self, value : bool) -> None:
        '''Indicates if the searched string is case sensitive.
        :param value: '''
        raise NotImplementedError()

    def getConvertNumericData(self) -> bool:
        '''Gets a value that indicates whether converting the searched string value to numeric data.'''
        raise NotImplementedError()

    def isRangeSet(self) -> bool:
        '''Indicates whether the searched range is set.'''
        raise NotImplementedError()

    def setValueTypeSensitive(self, value : bool) -> None:
        '''Indicates whether searched cell value type should be same with the searched key.
        :param value: '''
        raise NotImplementedError()

    def setSeachOrderByRows(self, value : bool) -> None:
        ''':deprecated: Use FindOptions.SearchOrderByRows property instead.'''
        raise NotImplementedError()

    def getRegexKey(self) -> bool:
        '''Indicates whether the searched key is regex.
        If true the searched key will be taken as regex and parsed. Otherwise the key will be parsed according to the rules in ms excel.'''
        raise NotImplementedError()

    def getLookInType(self) -> int:
        '''Look in type.
        See :class:`LookInType`'''
        raise NotImplementedError()

    def setConvertNumericData(self, value : bool) -> None:
        '''Sets a value that indicates whether converting the searched string value to numeric data.
        :param value: '''
        raise NotImplementedError()

    def setSearchOrderByRows(self, value : bool) -> None:
        '''Indicates whether search order by rows or columns.
        :param value: '''
        raise NotImplementedError()

    def setRegexKey(self, value : bool) -> None:
        '''Indicates whether the searched key is regex.
        If true the searched key will be taken as regex and parsed. Otherwise the key will be parsed according to the rules in ms excel.
        :param value: '''
        raise NotImplementedError()

    def getSearchBackward(self) -> bool:
        '''Whether search backward for cells.'''
        raise NotImplementedError()

    def setLookAtType(self, value : int) -> None:
        '''Look at type.
        See :class:`LookAtType`
        :param value: '''
        raise NotImplementedError()

    def setRange(self, ca : CellArea) -> None:
        '''Sets the searched range.
        :param ca: the searched range.'''
        raise NotImplementedError()

    def getRange(self) -> CellArea:
        '''Gets and sets the searched range.'''
        raise NotImplementedError()


class Floor:
    '''Encapsulates the object that represents the floor of a 3-D chart.'''

    def getBorder(self) -> Line:
        '''Gets the border :class:`Line`.'''
        raise NotImplementedError()

    def setBorder(self, value : Line) -> None:
        '''Sets the border :class:`Line`.
        :param value: '''
        raise NotImplementedError()


class FolderFontSource:
    '''Represents the folder that contains TrueType font files.'''

    def getScanSubFolders(self) -> bool:
        '''Determines whether or not to scan the subfolders.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Returns the type of the font source.
        See :class:`FontSourceType`'''
        raise NotImplementedError()

    def getFolderPath(self) -> str:
        '''Path to fonts folder.'''
        raise NotImplementedError()


class Font:
    '''Encapsulates the font object used in a spreadsheet.'''

    def setSubscript(self, value : bool) -> None:
        '''Sets a value indicating whether the font is subscript.
        :param value: '''
        raise NotImplementedError()

    def getCapsType(self) -> int:
        '''Gets the text caps type.
        See :class:`TextCapsType`'''
        raise NotImplementedError()

    def setThemeColor(self, value : ThemeColor) -> None:
        '''Sets the theme color.
        :param value: '''
        raise NotImplementedError()

    def getCharset(self) -> int:
        '''Represent the character set.'''
        raise NotImplementedError()

    def toString(self) -> str:
        '''Returns a string represents the current Cell object.'''
        raise NotImplementedError()

    def isSuperscript(self) -> bool:
        '''Gets a value indicating whether the font is super script.'''
        raise NotImplementedError()

    def setItalic(self, value : bool) -> None:
        '''Sets a value indicating whether the font is italic.
        :param value: '''
        raise NotImplementedError()

    def getDoubleSize(self) -> int:
        '''Gets the double size of the font.'''
        raise NotImplementedError()

    def setCapsType(self, value : int) -> None:
        '''Sets the text caps type.
        See :class:`TextCapsType`
        :param value: '''
        raise NotImplementedError()

    def setNormalizeHeights(self, value : bool) -> None:
        '''Indicates whether the normalization of height that is to be applied to the text run.
        :param value: '''
        raise NotImplementedError()

    def setUnderline(self, value : int) -> None:
        '''Sets the font underline type.
        See :class:`FontUnderlineType`
        :param value: '''
        raise NotImplementedError()

    def setColor(self, value : Color) -> None:
        '''Sets the :class:`Color` of the font.
        :param value: '''
        raise NotImplementedError()

    def isItalic(self) -> bool:
        '''Gets a value indicating whether the font is italic.'''
        raise NotImplementedError()

    def getArgbColor(self) -> int:
        '''Gets the color with a 32-bit ARGB value.'''
        raise NotImplementedError()

    def getColor(self) -> Color:
        '''Gets the :class:`Color` of the font.'''
        raise NotImplementedError()

    def getSchemeType(self) -> int:
        '''Gets the scheme type of the font.
        See :class:`FontSchemeType`'''
        raise NotImplementedError()

    def equals(self, font : Font) -> bool:
        '''Checks if two fonts are equals.
        :param font: Compared font object.
        :returns: True if equal to the compared font object.'''
        raise NotImplementedError()

    def getStrikeType(self) -> int:
        '''Gets the strike type of the text.
        See :class:`TextStrikeType`'''
        raise NotImplementedError()

    def isStrikeout(self) -> bool:
        '''Gets a value indicating whether the font is single strikeout.'''
        raise NotImplementedError()

    def setCharset(self, value : int) -> None:
        '''Represent the character set.
        :param value: '''
        raise NotImplementedError()

    def setBold(self, value : bool) -> None:
        '''Sets a value indicating whether the font is bold.
        :param value: '''
        raise NotImplementedError()

    def getScriptOffset(self) -> int:
        '''Gets the script offset,in unit of percentage'''
        raise NotImplementedError()

    def isSubscript(self) -> bool:
        '''Gets a value indicating whether the font is subscript.'''
        raise NotImplementedError()

    def setDoubleSize(self, value : int) -> None:
        '''Sets the double size of the font.
        :param value: '''
        raise NotImplementedError()

    def getThemeColor(self) -> ThemeColor:
        '''Gets the theme color.'''
        raise NotImplementedError()

    def isBold(self) -> bool:
        '''Gets a value indicating whether the font is bold.'''
        raise NotImplementedError()

    def getSize(self) -> int:
        '''Gets the size of the font.'''
        raise NotImplementedError()

    def setSize(self, value : int) -> None:
        '''Sets the size of the font.
        :param value: '''
        raise NotImplementedError()

    def setSuperscript(self, value : bool) -> None:
        '''Sets a value indicating whether the font is super script.
        :param value: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the :meth:`ChartArea.getFont()`.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the :meth:`ChartArea.getFont()`.
        :param value: '''
        raise NotImplementedError()

    def isNormalizeHeights(self) -> bool:
        '''Indicates whether the normalization of height that is to be applied to the text run.'''
        raise NotImplementedError()

    def getUnderline(self) -> int:
        '''Gets the font underline type.
        See :class:`FontUnderlineType`'''
        raise NotImplementedError()

    def setArgbColor(self, value : int) -> None:
        '''Sets the color with a 32-bit ARGB value.
        :param value: '''
        raise NotImplementedError()

    def setScriptOffset(self, value : int) -> None:
        '''Sets the script offset,in unit of percentage
        :param value: '''
        raise NotImplementedError()

    def setStrikeType(self, value : int) -> None:
        '''Gets the strike type of the text.
        See :class:`TextStrikeType`
        :param value: '''
        raise NotImplementedError()

    def setSchemeType(self, value : int) -> None:
        '''Sets the scheme type of the font.
        See :class:`FontSchemeType`
        :param value: '''
        raise NotImplementedError()

    def setStrikeout(self, value : bool) -> None:
        '''Sets a value indicating whether the font is single strikeout.
        :param value: '''
        raise NotImplementedError()


class FontConfigs:
    '''Specifies font settings'''

    def setDefaultFontName(self, value : str) -> None:
        '''Sets the default font name.
        :param value: '''
        raise NotImplementedError()

    def setFontFolder(self, fontFolder : str, recursive : bool) -> None:
        '''Sets the fonts folder
        :param fontFolder: The folder that contains TrueType fonts.
        :param recursive: Determines whether or not to scan subfolders.'''
        raise NotImplementedError()

    def getFontSources(self) -> list[FontSourceBase]:
        '''Gets a copy of the array that contains the list of sources'''
        raise NotImplementedError()

    def setFontFolders(self, fontFolders : list[str], recursive : bool) -> None:
        '''Sets the fonts folders
        :param fontFolders: The folders that contains TrueType fonts.
        :param recursive: Determines whether or not to scan subfolders.'''
        raise NotImplementedError()

    def setFontSubstitutes(self, originalFontName : str, substituteFontNames : list[str]) -> None:
        '''Font substitute names for given original font name.
        :param originalFontName: Original font name.
        :param substituteFontNames: List of font substitute names to be used if original font is not presented.'''
        raise NotImplementedError()

    def getFontSubstitutes(self, originalFontName : str) -> list[str]:
        '''Returns array containing font substitute names to be used if original font is not presented.
        :param originalFontName: originalFontName
        :returns: An array containing font substitute names to be used if original font is not presented.'''
        raise NotImplementedError()

    def setFontExclusiveSources(self, exclusiveSources : list[FontSourceBase]) -> None:
        '''Sets the fonts exclusive sources. Only fonts in the sources will be used.
        :param exclusiveSources: An array of sources that contain TrueType fonts.'''
        raise NotImplementedError()

    def setFontSources(self, sources : list[FontSourceBase]) -> None:
        '''Sets the fonts sources.
        :param sources: An array of sources that contain TrueType fonts.'''
        raise NotImplementedError()

    def isFontAvailable(self, fontName : str) -> bool:
        '''Indicate whether the font is available.
        :param fontName: font name
        :returns: true if font is available, otherwise false.'''
        raise NotImplementedError()

    def getDefaultFontName(self) -> str:
        '''Gets the default font name.'''
        raise NotImplementedError()


class FontSchemeType:
    '''Represents the scheme type of the font.'''

    NONE : FontSchemeType
    '''None'''

    MAJOR : FontSchemeType
    '''Major scheme.'''

    MINOR : FontSchemeType
    '''Minor scheme.'''


class FontSetting:
    '''Represents a range of characters within the cell text.'''

    def setWordArtStyle(self, style : int) -> None:
        '''Sets the preset WordArt style.
        :param style: :class:`PresetWordArtStyle`. The preset WordArt style.'''
        raise NotImplementedError()

    def getTextOptions(self) -> TextOptions:
        '''Returns the text options.'''
        raise NotImplementedError()

    def getLength(self) -> int:
        '''Gets the length of the characters.'''
        raise NotImplementedError()

    def getStartIndex(self) -> int:
        '''Gets the start index of the characters.'''
        raise NotImplementedError()

    def getFont(self) -> Font:
        '''Returns the font of this object.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of text node.
        See :class:`TextNodeType`'''
        raise NotImplementedError()


class FontSettingCollection:
    '''Represents the list of :class:`FontSetting`.'''

    def insertText(self, index : int, text : str) -> None:
        '''Insert index at the position.
        :param index: The start index.
        :param text: The text.'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''
        :param obj: '''
        raise NotImplementedError()

    def deleteText(self, index : int, count : int) -> None:
        '''Delete some characters.
        :param index: The start index.
        :param count: The count of characters.'''
        raise NotImplementedError()

    @overload
    def replace(self, index : int, count : int, text : str) -> None:
        '''Replace the text.
        :param index: The start index.
        :param count: The count of characters.
        :param text: The text.'''
        raise NotImplementedError()

    @overload
    def replace(self, oldValue : str, newValue : str) -> None:
        '''Replace the text.
        :param oldValue: The old text.
        :param newValue: The new text.'''
        raise NotImplementedError()

    def get(self, index : int) -> FontSetting:
        '''Gets the :class:`FontSetting` by the index.
        :param index: The index.'''
        raise NotImplementedError()

    def getTextParagraphs(self) -> TextParagraphCollection:
        '''Gets all paragraphs.'''
        raise NotImplementedError()

    def appendText(self, text : str) -> None:
        '''Appends the text.
        :param text: The text.'''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''Sets the text of the shape.
        :param value: '''
        raise NotImplementedError()

    def clear(self) -> None:
        '''Clear all setting.'''
        raise NotImplementedError()

    def setHtmlString(self, value : str) -> None:
        '''Sets the html string which contains data and some formats in this shape.
        :param value: '''
        raise NotImplementedError()

    def getTextAlignment(self) -> ShapeTextAlignment:
        '''Represents the alignment setting of the text body.'''
        raise NotImplementedError()

    def hashCode(self) -> int:
        ''''''
        raise NotImplementedError()

    def format(self, startIndex : int, length : int, font : Font, flag : StyleFlag) -> None:
        '''Format the text with font setting.
        :param startIndex: The start index.
        :param length: The length.
        :param font: The font.
        :param flag: The flags of the font.'''
        raise NotImplementedError()

    def getParagraphEnumerator(self) -> Iterator:
        '''Gets the enumerator of the paragraphs.'''
        raise NotImplementedError()

    def getText(self) -> str:
        '''Gets the text of the shape.'''
        raise NotImplementedError()

    def getHtmlString(self) -> str:
        '''Gets the html string which contains data and some formats in this shape.'''
        raise NotImplementedError()

    def setWordArtStyle(self, style : int) -> None:
        '''Sets the preset WordArt style.
        :param style: :class:`PresetWordArtStyle`. The preset WordArt style.'''
        raise NotImplementedError()


class FontSourceBase:
    '''This is an abstract base class for the classes that allow the user to specify various font sources'''

    def getType(self) -> int:
        '''Returns the type of the font source.
        See :class:`FontSourceType`'''
        raise NotImplementedError()


class FontSourceType:
    '''Specifies the type of a font source.'''

    FONT_FILE : FontSourceType
    '''represents single font file.'''

    FONTS_FOLDER : FontSourceType
    '''represents folder with font files.'''

    MEMORY_FONT : FontSourceType
    '''represents single font in memory.'''


class FontUnderlineType:
    '''Enumerates the font underline types.'''

    NONE : FontUnderlineType
    '''Represents no underline.'''

    SINGLE : FontUnderlineType
    '''Represents single underline.'''

    DOUBLE : FontUnderlineType
    '''Represents double underline.'''

    ACCOUNTING : FontUnderlineType
    '''Represents single accounting underline.'''

    DOUBLE_ACCOUNTING : FontUnderlineType
    '''Represents double accounting underline.'''

    DASH : FontUnderlineType
    '''Represents Dashed Underline'''

    DASH_DOT_DOT_HEAVY : FontUnderlineType
    '''Represents Thick Dash-Dot-Dot Underline'''

    DASH_DOT_HEAVY : FontUnderlineType
    '''Represents Thick Dash-Dot Underline'''

    DASHED_HEAVY : FontUnderlineType
    '''Represents Thick Dashed Underline'''

    DASH_LONG : FontUnderlineType
    '''Represents Long Dashed Underline'''

    DASH_LONG_HEAVY : FontUnderlineType
    '''Represents Thick Long Dashed Underline'''

    DOT_DASH : FontUnderlineType
    '''Represents Dash-Dot Underline'''

    DOT_DOT_DASH : FontUnderlineType
    '''Represents Dash-Dot-Dot Underline'''

    DOTTED : FontUnderlineType
    '''Represents Dotted Underline'''

    DOTTED_HEAVY : FontUnderlineType
    '''Represents Thick Dotted Underline'''

    HEAVY : FontUnderlineType
    '''Represents Thick Underline'''

    WAVE : FontUnderlineType
    '''Represents Wave Underline'''

    WAVY_DOUBLE : FontUnderlineType
    '''Represents Double Wave Underline'''

    WAVY_HEAVY : FontUnderlineType
    '''Represents Heavy Wave Underline'''

    WORDS : FontUnderlineType
    '''Represents Underline Non-Space Characters Only'''


class Format3D:
    '''This class specifies the 3D shape properties for a chart element or shape.'''

    def getSurfaceLightingType(self) -> int:
        '''Gets the lighting type which is to be applied to the scene of the shape.
        Default value is LightRigType.ThreePoint.
        See :class:`LightRigType`'''
        raise NotImplementedError()

    def getSurfaceMaterialType(self) -> int:
        '''Gets the material type which is combined with the lighting properties to give the final look and feel of a shape.
        Default value is PresetMaterialType.WarmMatte.
        See :class:`PresetMaterialType`'''
        raise NotImplementedError()

    def getTopBevel(self) -> Bevel:
        '''Gets the :class:`Bevel` object that holds the properties associated with defining a bevel on the top or front face of a shape.'''
        raise NotImplementedError()

    def getLightingAngle(self) -> int:
        '''Gets the lighting angle. Range from 0 to 359.9 degrees.'''
        raise NotImplementedError()

    def setSurfaceLightingType(self, value : int) -> None:
        '''Sets the lighting type which is to be applied to the scene of the shape.
        Default value is LightRigType.ThreePoint.
        See :class:`LightRigType`
        :param value: '''
        raise NotImplementedError()

    def setSurfaceMaterialType(self, value : int) -> None:
        '''Sets the material type which is combined with the lighting properties to give the final look and feel of a shape.
        Default value is PresetMaterialType.WarmMatte.
        See :class:`PresetMaterialType`
        :param value: '''
        raise NotImplementedError()

    def hasTopBevelData(self) -> bool:
        '''Indicates if the shape has top bevel data.'''
        raise NotImplementedError()

    def setLightingAngle(self, value : int) -> None:
        '''Sets the lighting angle. Range from 0 to 359.9 degrees.
        :param value: '''
        raise NotImplementedError()


class FormatCondition:
    '''Represents conditional formatting condition.'''

    def setPriority(self, value : int) -> None:
        '''The priority of this conditional formatting rule. This value is used to determine which
        format should be evaluated and rendered. Lower numeric values are higher priority than
        higher numeric values, where '1' is the highest priority.
        :param value: '''
        raise NotImplementedError()

    def getText(self) -> str:
        '''The text value in a "text contains" conditional formatting rule.
        Valid only for type = containsText, notContainsText, beginsWith and endsWith.
        The default value is null.'''
        raise NotImplementedError()

    def getColorScale(self) -> ColorScale:
        '''Get the conditional formatting's "ColorScale" instance.
        The default instance is a "green-yellow-red" 3ColorScale .
        Valid only for type = ColorScale.'''
        raise NotImplementedError()

    def getTop10(self) -> Top10:
        '''Get the conditional formatting's "Top10" instance.
        The default instance's rule highlights cells whose
        values fall in the top 10 bracket.
        Valid only for type is Top10.'''
        raise NotImplementedError()

    def getIconSet(self) -> IconSet:
        '''Get the conditional formatting's "IconSet" instance.
        The default instance's IconSetType is TrafficLights31.
        Valid only for type = IconSet.'''
        raise NotImplementedError()

    def setStyle(self, value : Style) -> None:
        '''Gets or setts style of conditional formatted cell ranges.
        :param value: '''
        raise NotImplementedError()

    def getStyle(self) -> Style:
        '''Gets or setts style of conditional formatted cell ranges.'''
        raise NotImplementedError()

    def getTimePeriod(self) -> int:
        '''The applicable time period in a "date occurring? conditional formatting rule.
        Valid only for type = timePeriod.
        The default value is TimePeriodType.Today.
        See :class:`TimePeriodType`'''
        raise NotImplementedError()

    def getOperator(self) -> int:
        '''Gets the conditional format operator type.
        See :class:`OperatorType`'''
        raise NotImplementedError()

    def setFormulas(self, formula1 : str, formula2 : str, isR1C1 : bool, isLocal : bool) -> None:
        '''Sets the value or expression associated with this format condition.
        :param formula1: The value or expression associated with this format condition.
        :param formula2: The value or expression associated with this format condition. The input format is same with formula1
        :param isR1C1: Whether the formula is R1C1 formula.
        :param isLocal: Whether the formula is locale formatted.'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets whether the conditional format Type.
        See :class:`FormatConditionType`
        :param value: '''
        raise NotImplementedError()

    def setTimePeriod(self, value : int) -> None:
        '''The applicable time period in a "date occurring? conditional formatting rule.
        Valid only for type = timePeriod.
        The default value is TimePeriodType.Today.
        See :class:`TimePeriodType`
        :param value: '''
        raise NotImplementedError()

    def setOperator(self, value : int) -> None:
        '''Sets the conditional format operator type.
        See :class:`OperatorType`
        :param value: '''
        raise NotImplementedError()

    @overload
    def getFormula2(self, isR1C1 : bool, isLocal : bool) -> str:
        '''Gets the value or expression associated with this format condition.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :returns: The value or expression associated with this format condition.'''
        raise NotImplementedError()

    @overload
    def getFormula2(self, isR1C1 : bool, isLocal : bool, row : int, column : int) -> str:
        '''Gets the value or expression of the conditional formatting of the cell.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :param row: The row index.
        :param column: The column index.
        :returns: The value or expression associated with the conditional formatting of the cell.'''
        raise NotImplementedError()

    @overload
    def getFormula2(self) -> str:
        '''Gets the value or expression associated with conditional formatting.'''
        raise NotImplementedError()

    @overload
    def getFormula2(self, row : int, column : int) -> str:
        '''Gets the formula of the conditional formatting of the cell.
        :param row: The row index.
        :param column: The column index.
        :returns: The formula.'''
        raise NotImplementedError()

    @overload
    def getFormula1(self, isR1C1 : bool, isLocal : bool) -> str:
        '''Gets the value or expression associated with this format condition.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :returns: The value or expression associated with this format condition.'''
        raise NotImplementedError()

    @overload
    def getFormula1(self, isR1C1 : bool, isLocal : bool, row : int, column : int) -> str:
        '''Gets the value or expression of the conditional formatting of the cell.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :param row: The row index.
        :param column: The column index.
        :returns: The value or expression associated with the conditional formatting of the cell.'''
        raise NotImplementedError()

    @overload
    def getFormula1(self) -> str:
        '''Gets the value or expression associated with conditional formatting.'''
        raise NotImplementedError()

    @overload
    def getFormula1(self, row : int, column : int) -> str:
        '''Gets the formula of the conditional formatting of the cell.
        :param row: The row index.
        :param column: The column index.
        :returns: The formula.'''
        raise NotImplementedError()

    def getDataBar(self) -> DataBar:
        '''Get the conditional formatting's "DataBar" instance.
        The default instance's color is blue.
        Valid only for type is DataBar.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets whether the conditional format Type.
        See :class:`FormatConditionType`'''
        raise NotImplementedError()

    def getStopIfTrue(self) -> bool:
        '''True, no rules with lower priority may be applied over this rule, when this rule evaluates to true.
        Only applies for Excel 2007;'''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''The text value in a "text contains" conditional formatting rule.
        Valid only for type = containsText, notContainsText, beginsWith and endsWith.
        The default value is null.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setFormula2(self, formula : str, isR1C1 : bool, isLocal : bool) -> None:
        '''Sets the value or expression associated with this format condition.
        :param formula: The value or expression associated with this format condition.
        :param isR1C1: Whether the formula is R1C1 formula.
        :param isLocal: Whether the formula is locale formatted.'''
        raise NotImplementedError()

    @overload
    def setFormula2(self, value : str) -> None:
        '''Sets the value or expression associated with conditional formatting.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setFormula1(self, formula : str, isR1C1 : bool, isLocal : bool) -> None:
        '''Sets the value or expression associated with this format condition.
        :param formula: The value or expression associated with this format condition.
        :param isR1C1: Whether the formula is R1C1 formula.
        :param isLocal: Whether the formula is locale formatted.'''
        raise NotImplementedError()

    @overload
    def setFormula1(self, value : str) -> None:
        '''Sets the value or expression associated with conditional formatting.
        :param value: '''
        raise NotImplementedError()

    def getAboveAverage(self) -> AboveAverage:
        '''Get the conditional formatting's "AboveAverage" instance.
        The default instance's rule highlights cells that are
        above the average for all values in the range.
        Valid only for type = AboveAverage.'''
        raise NotImplementedError()

    def getPriority(self) -> int:
        '''The priority of this conditional formatting rule. This value is used to determine which
        format should be evaluated and rendered. Lower numeric values are higher priority than
        higher numeric values, where '1' is the highest priority.'''
        raise NotImplementedError()

    def setStopIfTrue(self, value : bool) -> None:
        '''True, no rules with lower priority may be applied over this rule, when this rule evaluates to true.
        Only applies for Excel 2007;
        :param value: '''
        raise NotImplementedError()


class FormatConditionCollection:
    '''Represents conditional formatting.
    The FormatConditions can contain up to three conditional formats.'''

    def removeCondition(self, index : int) -> None:
        '''Removes the formatting condition by index.
        :param index: The index of the formatting condition to be removed.'''
        raise NotImplementedError()

    def addArea(self, cellArea : CellArea) -> int:
        '''Adds a conditional formatted cell range.
        :param cellArea: Conditional formatted cell range.
        :returns: Conditional formatted cell rang index.'''
        raise NotImplementedError()

    @overload
    def removeArea(self, index : int) -> None:
        '''Removes conditional formatted cell range by index.
        :param index: The index of the conditional formatted cell range to be removed.'''
        raise NotImplementedError()

    @overload
    def removeArea(self, startRow : int, startColumn : int, totalRows : int, totalColumns : int) -> bool:
        '''Remove conditional formatting int the range.
        :param startRow: The startRow of the range.
        :param startColumn: The startColumn of the range.
        :param totalRows: The number of rows of the range.
        :param totalColumns: The number of columns of the range.
        :returns: Returns TRUE, this FormatCondtionCollection should be removed.'''
        raise NotImplementedError()

    def getCount(self) -> int:
        '''Gets the count of the conditions.'''
        raise NotImplementedError()

    @overload
    def addCondition(self, type : int, operatorType : int, formula1 : str, formula2 : str) -> int:
        '''Adds a formatting condition.
        :param type: :class:`FormatConditionType`. The type of format condition.
        :param operatorType: :class:`OperatorType`. The operator type
        :param formula1: The value or expression associated with conditional formatting.
        :param formula2: The value or expression associated with conditional formatting.
        :returns: Formatting condition object index;'''
        raise NotImplementedError()

    @overload
    def addCondition(self, type : int) -> int:
        '''Add a format condition.
        :param type: :class:`FormatConditionType`. Format condition type.
        :returns: Formatting condition object index;'''
        raise NotImplementedError()

    def get(self, index : int) -> FormatCondition:
        '''Gets the formatting condition by index.
        :param index: the index of the formatting condition to return.
        :returns: the formatting condition'''
        raise NotImplementedError()

    def getCellArea(self, index : int) -> CellArea:
        '''Gets the conditional formatted cell range by index.
        :param index: the index of the conditional formatted cell range.
        :returns: the conditional formatted cell range'''
        raise NotImplementedError()

    def getRangeCount(self) -> int:
        '''Gets count of conditionally formatted ranges.'''
        raise NotImplementedError()

    def add(self, cellArea : CellArea, type : int, operatorType : int, formula1 : str, formula2 : str) -> list[int]:
        '''Adds a formatting condition and effected cell rang to the FormatConditions
        The FormatConditions can contain up to three conditional formats.
        References to the other sheets are not allowed in the formulas of conditional formatting.
        :param cellArea: Conditional formatted cell range.
        :param type: :class:`FormatConditionType`. Type of conditional formatting.It could be one of the members of FormatConditionType.
        :param operatorType: :class:`OperatorType`. Comparison operator.It could be one of the members of OperatorType.
        :param formula1: The value or expression associated with conditional formatting.
        :param formula2: The value or expression associated with conditional formatting
        :returns: [0]:Formatting condition object index;[1] Effected cell rang index.'''
        raise NotImplementedError()


class FormatConditionType:
    '''Conditional format rule type.'''

    CELL_VALUE : FormatConditionType
    '''This conditional formatting rule compares a cell value
    to a formula calculated result, using an operator.'''

    EXPRESSION : FormatConditionType
    '''This conditional formatting rule contains a formula to
    evaluate. When the formula result is true, the cell is
    highlighted.'''

    TOP_10 : FormatConditionType
    '''This conditional formatting rule highlights cells whose
    values fall in the top N or bottom N bracket, as
    specified.'''

    UNIQUE_VALUES : FormatConditionType
    '''This conditional formatting rule highlights unique
    values in the range.'''

    DUPLICATE_VALUES : FormatConditionType
    '''This conditional formatting rule highlights duplicated
    values.'''

    CONTAINS_TEXT : FormatConditionType
    '''This conditional formatting rule highlights cells
    containing given text. Equivalent to using the SEARCH()
    sheet function to determine whether the cell contains
    the text.'''

    NOT_CONTAINS_TEXT : FormatConditionType
    '''This conditional formatting rule highlights cells that
    do not contain given text. Equivalent of using SEARCH()
    sheet function to determine whether the cell contains
    the text or not.'''

    BEGINS_WITH : FormatConditionType
    '''This conditional formatting rule highlights cells in the
    range that begin with the given text. Equivalent to
    using the LEFT() sheet function and comparing values.'''

    ENDS_WITH : FormatConditionType
    '''This conditional formatting rule highlights cells ending
    with given text. Equivalent to using the RIGHT() sheet
    function and comparing values.'''

    CONTAINS_BLANKS : FormatConditionType
    '''This conditional formatting rule highlights cells that
    are completely blank. Equivalent of using LEN(TRIM()).
    This means that if the cell contains only characters
    that TRIM() would remove, then it is considered blank.
    An empty cell is also considered blank.'''

    NOT_CONTAINS_BLANKS : FormatConditionType
    '''This conditional formatting rule highlights cells that
    are not blank. Equivalent of using LEN(TRIM()). This
    means that if the cell contains only characters that
    TRIM() would remove, then it is considered blank. An
    empty cell is also considered blank.'''

    CONTAINS_ERRORS : FormatConditionType
    '''This conditional formatting rule highlights cells with
    formula errors. Equivalent to using ISERROR() sheet
    function to determine if there is a formula error.'''

    NOT_CONTAINS_ERRORS : FormatConditionType
    '''This conditional formatting rule highlights cells
    without formula errors. Equivalent to using ISERROR()
    sheet function to determine if there is a formula error.'''

    TIME_PERIOD : FormatConditionType
    '''This conditional formatting rule highlights cells
    containing dates in the specified time period. The
    underlying value of the cell is evaluated, therefore the
    cell does not need to be formatted as a date to be
    evaluated. For example, with a cell containing the
    value 38913 the conditional format shall be applied if
    the rule requires a value of 7/14/2006.'''

    ABOVE_AVERAGE : FormatConditionType
    '''This conditional formatting rule highlights cells that
    are above or below the average for all values in the
    range.'''

    COLOR_SCALE : FormatConditionType
    '''This conditional formatting rule creates a gradated
    color scale on the cells.'''

    DATA_BAR : FormatConditionType
    '''This conditional formatting rule displays a gradated
    data bar in the range of cells.'''

    ICON_SET : FormatConditionType
    '''This conditional formatting rule applies icons to cells
    according to their values.'''


class FormatConditionValueType:
    '''Condition value type.'''

    FORMULA : FormatConditionValueType
    '''The minimum/ midpoint / maximum value for the
    gradient is determined by a formula.'''

    MAX : FormatConditionValueType
    '''Indicates that the maximum value in the range shall be
    used as the maximum value for the gradient.'''

    MIN : FormatConditionValueType
    '''Indicates that the minimum value in the range shall be
    used as the minimum value for the gradient.'''

    NUMBER : FormatConditionValueType
    '''Indicates that the minimum / midpoint / maximum
    value for the gradient is specified by a constant
    numeric value.'''

    PERCENT : FormatConditionValueType
    '''Value indicates a percentage between the minimum
    and maximum values in the range shall be used as the
    minimum / midpoint / maximum value for the gradient.'''

    PERCENTILE : FormatConditionValueType
    '''Value indicates a percentile ranking in the range shall
    be used as the minimum / midpoint / maximum value
    for the gradient.'''

    AUTOMATIC_MAX : FormatConditionValueType
    '''Indicates that the Automatic maximum value in the range shall be
    used as the Automatic maximum value for the gradient.'''

    AUTOMATIC_MIN : FormatConditionValueType
    '''Indicates that the Automatic minimum value in the range shall be
    used as the Automatic minimum value for the gradient.'''


class FormatSetType:
    '''Fill format set type.'''

    NONE : FormatSetType
    '''No Fill format.'''

    IS_GRADIENT_SET : FormatSetType
    '''Gradient fill format.'''

    IS_TEXTURE_SET : FormatSetType
    '''Texture fill format.'''

    IS_PATTERN_SET : FormatSetType
    '''Pattern fill format.'''


class FormattingType:
    '''Represents the type of formatting applied to an :class:`Area` object or a :class:`Line` object.'''

    AUTOMATIC : FormattingType
    '''Represents automatic formatting type.'''

    CUSTOM : FormattingType
    '''Represents custom formatting type.'''

    NONE : FormattingType
    '''Represents none formatting type.'''


class FormulaParseOptions:
    '''Represents options when parsing formula.'''

    def getR1C1Style(self) -> bool:
        '''Whether the formula is R1C1 reference style. Default is false.'''
        raise NotImplementedError()

    def getCheckAddIn(self) -> bool:
        '''Whether check addins in existing external links of current workbook for user defined function without external link.
        Default is true(if user defined function matches one addin in existing external links, then take it as the addin).'''
        raise NotImplementedError()

    def getLocaleDependent(self) -> bool:
        '''Whether the formula is locale formatted. Default is false.'''
        raise NotImplementedError()

    def setLocaleDependent(self, value : bool) -> None:
        '''Whether the formula is locale formatted. Default is false.
        :param value: '''
        raise NotImplementedError()

    def setCheckAddIn(self, value : bool) -> None:
        '''Whether check addins in existing external links of current workbook for user defined function without external link.
        Default is true(if user defined function matches one addin in existing external links, then take it as the addin).
        :param value: '''
        raise NotImplementedError()

    def getCustomFunctionDefinition(self) -> CustomFunctionDefinition:
        '''Definition for parsing custom functions.'''
        raise NotImplementedError()

    def setR1C1Style(self, value : bool) -> None:
        '''Whether the formula is R1C1 reference style. Default is false.
        :param value: '''
        raise NotImplementedError()

    def setParse(self, value : bool) -> None:
        '''Whether parse given formula. Default is true.
        If it is false, then given formula string will be kept as it is for the cell until user call other methods to parse them
        or parsed formula data is required by other operations such as calculating formulas.
        :param value: '''
        raise NotImplementedError()

    def setCustomFunctionDefinition(self, value : CustomFunctionDefinition) -> None:
        '''Definition for parsing custom functions.
        :param value: '''
        raise NotImplementedError()

    def getParse(self) -> bool:
        '''Whether parse given formula. Default is true.
        If it is false, then given formula string will be kept as it is for the cell until user call other methods to parse them
        or parsed formula data is required by other operations such as calculating formulas.'''
        raise NotImplementedError()


class FormulaSettings:
    '''Settings of formulas and calculation.'''

    def setPreservePaddingSpaces(self, value : bool) -> None:
        '''Indicates whether preserve those spaces and line breaks that are padded between formula tokens
        while getting and setting formulas.
        Default value is false.
        :param value: '''
        raise NotImplementedError()

    def setCalculateOnSave(self, value : bool) -> None:
        '''Indicates whether recalculate the workbook before saving the document, when in manual calculation mode.
        :param value: '''
        raise NotImplementedError()

    def getEnableIterativeCalculation(self) -> bool:
        '''Indicates whether enable iterative calculation to resolve circular references.'''
        raise NotImplementedError()

    def getCalculateOnSave(self) -> bool:
        '''Indicates whether recalculate the workbook before saving the document, when in manual calculation mode.'''
        raise NotImplementedError()

    def setMaxChange(self, value : int) -> None:
        '''The maximum change to resolve a circular reference.
        :param value: '''
        raise NotImplementedError()

    def setMaxIteration(self, value : int) -> None:
        '''The maximum iterations to resolve a circular reference.
        :param value: '''
        raise NotImplementedError()

    def getPrecisionAsDisplayed(self) -> bool:
        '''Whether the precision of calculated result be set as they are displayed while calculating formulas'''
        raise NotImplementedError()

    def setEnableIterativeCalculation(self, value : bool) -> None:
        '''Indicates whether enable iterative calculation to resolve circular references.
        :param value: '''
        raise NotImplementedError()

    def getCalculationId(self) -> str:
        '''Specifies the version of the calculation engine used to calculate values in the workbook.'''
        raise NotImplementedError()

    def setPrecisionAsDisplayed(self, value : bool) -> None:
        '''Whether the precision of calculated result be set as they are displayed while calculating formulas
        :param value: '''
        raise NotImplementedError()

    def setCalculationMode(self, value : int) -> None:
        '''Sets the mode for workbook calculation in ms excel.
        See :class:`CalcModeType`
        :param value: '''
        raise NotImplementedError()

    def getMaxIteration(self) -> int:
        '''The maximum iterations to resolve a circular reference.'''
        raise NotImplementedError()

    def getCalculationMode(self) -> int:
        '''Gets the mode for workbook calculation in ms excel.
        See :class:`CalcModeType`'''
        raise NotImplementedError()

    def getEnableCalculationChain(self) -> bool:
        '''Whether enable calculation chain for formulas. Default is false.'''
        raise NotImplementedError()

    def setCalculationId(self, value : str) -> None:
        '''Specifies the version of the calculation engine used to calculate values in the workbook.
        :param value: '''
        raise NotImplementedError()

    def setCalculateOnOpen(self, value : bool) -> None:
        '''Indicates whether the application is required to perform a full calculation when the workbook is opened.
        :param value: '''
        raise NotImplementedError()

    def getMaxChange(self) -> int:
        '''The maximum change to resolve a circular reference.'''
        raise NotImplementedError()

    def getForceFullCalculation(self) -> bool:
        '''Indicates whether calculates all formulas every time when a calculation is triggered.'''
        raise NotImplementedError()

    def getCalculateOnOpen(self) -> bool:
        '''Indicates whether the application is required to perform a full calculation when the workbook is opened.'''
        raise NotImplementedError()

    def getPreservePaddingSpaces(self) -> bool:
        '''Indicates whether preserve those spaces and line breaks that are padded between formula tokens
        while getting and setting formulas.
        Default value is false.'''
        raise NotImplementedError()

    def setForceFullCalculation(self, value : bool) -> None:
        '''Indicates whether calculates all formulas every time when a calculation is triggered.
        :param value: '''
        raise NotImplementedError()

    def setEnableCalculationChain(self, value : bool) -> None:
        '''Whether enable calculation chain for formulas. Default is false.
        :param value: '''
        raise NotImplementedError()


class FractionEquationNode:
    '''This class  specifies the fraction equation, consisting of a numerator and denominator separated by a fraction bar. The fraction bar can be horizontal or diagonal, depending on the fraction properties. The fraction equation is also used to represent the stack function, which places one element above another, with no fraction bar.'''

    def setFractionType(self, value : int) -> None:
        '''This specifies the type of fraction ; the default is 'Bar'.
        See :class:`EquationFractionType`
        :param value: '''
        raise NotImplementedError()

    def getFractionType(self) -> int:
        '''This specifies the type of fraction ; the default is 'Bar'.
        See :class:`EquationFractionType`'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class FunctionEquationNode:
    '''This class specifies the Function-Apply equation, which consists of a function name and an argument acted upon.
    The types of the name and argument components are 'EquationNodeType.FunctionName' and 'EquationNodeType.Base' respectively.'''

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class Geometry:
    '''Represents a geometric shape.'''

    def getShapeAdjustValues(self) -> ShapeGuideCollection:
        '''Gets a collection of shape adjust value'''
        raise NotImplementedError()


class GlobalizationSettings:
    '''Represents the globalization settings.'''

    def getColumnSeparatorOfFormulaArray(self) -> str:
        '''Gets the separator for the items in array's row data in formula.'''
        raise NotImplementedError()

    def getTableRowTypeOfTotals(self) -> str:
        '''Gets the type name of table rows that consists of the total row of referenced table.
        Default is "Totals", so in formula "#Totals" represents the total row of referenced table.'''
        raise NotImplementedError()

    def setChartSettings(self, value : ChartGlobalizationSettings) -> None:
        '''Sets the globalization settings for Chart.
        :param value: '''
        raise NotImplementedError()

    def getPivotGrandTotalName(self) -> str:
        ''':deprecated: Use PivotGlobalizationSettings.GetTextOfGrandTotal() method instead.'''
        raise NotImplementedError()

    def getTableRowTypeOfHeaders(self) -> str:
        '''Gets the type name of table rows that consists of the table header.
        Default is "Headers", so in formula "#Headers" represents the table header.'''
        raise NotImplementedError()

    def getTotalName(self, functionType : int) -> str:
        '''Gets the total name of the function.
        :param functionType: :class:`ConsolidationFunction`. The function type.
        :returns: The total name of the function.'''
        raise NotImplementedError()

    def getSubTotalName(self, subTotalType : int) -> str:
        ''':deprecated: Use PivotGlobalizationSettings.GetTextOfSubTotal() method instead.'''
        raise NotImplementedError()

    def setPivotSettings(self, value : PivotGlobalizationSettings) -> None:
        '''Sets the globalization settings for pivot table.
        :param value: '''
        raise NotImplementedError()

    def getColumnLabelsOfPivotTable(self) -> str:
        ''':deprecated: Use PivotGlobalizationSettings.GetTextOfColumnLabels() method instead.'''
        raise NotImplementedError()

    def getMultipleItemsName(self) -> str:
        ''':deprecated: Use PivotGlobalizationSettings.GetTextOfMultipleItems() method instead.'''
        raise NotImplementedError()

    def getEmptyDataName(self) -> str:
        ''':deprecated: Use PivotGlobalizationSettings.GetTextOfEmptyData() method instead.'''
        raise NotImplementedError()

    def getGrandTotalName(self, functionType : int) -> str:
        '''Gets the grand total name of the function.
        :param functionType: :class:`ConsolidationFunction`. The function type.
        :returns: The grand total name of the function.'''
        raise NotImplementedError()

    def getLocalBuiltInName(self, standardName : str) -> str:
        '''Gets the locale dependent text for built-in Name according to given standard text.
        :param standardName: Standard(en-US locale) text of built-in Name.
        :returns: Locale dependent text. The locale was specified by the Workbook for which this settings is used.'''
        raise NotImplementedError()

    def getStandardHeaderFooterFontStyleName(self, localfontStyleName : str) -> str:
        '''Gets standard English font style name(Regular, Bold, Italic) for Header/Footer according to given locale font style name.
        :param localfontStyleName: Locale font style name for Header/Footer.
        :returns: Standard English font style name(Regular, Bold, Italic)'''
        raise NotImplementedError()

    def getCollationKey(self, v : str, ignoreCase : bool) -> Comparable:
        '''Transforms the string into a comparable object according to certain collation rules.
        :param v: String value needs to be compared with others.
        :param ignoreCase: whether ignore case when comparing values
        :returns: Object can be used to compare or sort string values'''
        raise NotImplementedError()

    def getDataFieldHeaderNameOfPivotTable(self) -> str:
        ''':deprecated: Use PivotGlobalizationSettings.GetTextOfDataFieldHeader() method instead.'''
        raise NotImplementedError()

    def getStandardBuiltInName(self, localName : str) -> str:
        '''Gets the standard text of built-in Name according to given locale dependent text.
        :param localName: Locale dependent text of built-in Name. The locale was specified by the Workbook for which this settings is used.
        :returns: Standard(en-US locale) text.'''
        raise NotImplementedError()

    def getProtectionNameOfPivotTable(self) -> str:
        ''':deprecated: Use PivotGlobalizationSettings.GetTextOfProtectedName(string) method instead.'''
        raise NotImplementedError()

    def getAllName(self) -> str:
        ''':deprecated: Use PivotGlobalizationSettings.GetTextOfAll() method instead.'''
        raise NotImplementedError()

    def getBooleanValueString(self, bv : bool) -> str:
        '''Gets the display string value for cell's boolean value
        :param bv: boolean value
        :returns: By default returns "TRUE" for true value and "FALSE" for false value.'''
        raise NotImplementedError()

    def getRowSeparatorOfFormulaArray(self) -> str:
        '''Gets the separator for rows in array data in formula.'''
        raise NotImplementedError()

    def getDefaultSheetName(self) -> str:
        '''Gets the default sheet name for adding worksheet automatically.
        Default is "Sheet".'''
        raise NotImplementedError()

    def getRowLabelsNameOfPivotTable(self) -> str:
        ''':deprecated: Use PivotGlobalizationSettings.GetTextOfRowLabels() method instead.'''
        raise NotImplementedError()

    def getTableRowTypeOfAll(self) -> str:
        '''Gets the type name of table rows that consists of all rows in referenced table.
        Default is "All", so in formula "#All" represents all rows in referenced table.'''
        raise NotImplementedError()

    def getStandardFunctionName(self, localName : str) -> str:
        '''Gets the standard function name according to given locale dependent function name.
        :param localName: Locale dependent function name. The locale was specified by the Workbook for which this settings is used.
        :returns: Standard(en-US locale) function name.'''
        raise NotImplementedError()

    def getErrorValueString(self, err : str) -> str:
        '''Gets the display string value for cell's error value
        :param err: error values such as #VALUE!,#NAME?
        :returns: By default returns the error value itself'''
        raise NotImplementedError()

    def getTableRowTypeOfCurrent(self) -> str:
        '''Gets the type name of table rows that consists of the current row in referenced table.
        Default is "This Row", so in formula "#This Row" represents the current row in referenced table.'''
        raise NotImplementedError()

    def getTableRowTypeOfData(self) -> str:
        '''Gets the type name of table rows that consists of data region of referenced table.
        Default is "Data", so in formula "#Data" represents the data region of the table.'''
        raise NotImplementedError()

    def getLocalFunctionName(self, standardName : str) -> str:
        '''Gets the locale dependent function name according to given standard function name.
        :param standardName: Standard(en-US locale) function name.
        :returns: Locale dependent function name. The locale was specified by the Workbook for which this settings is used.'''
        raise NotImplementedError()

    def getChartSettings(self) -> ChartGlobalizationSettings:
        '''Gets the globalization settings for Chart.'''
        raise NotImplementedError()

    def getCommentTitleName(self, type : int) -> str:
        '''Gets the locale dependent comment title name according to comment title type.
        :param type: :class:`CommentTitleType`.'''
        raise NotImplementedError()

    def getListSeparator(self) -> str:
        '''Gets the separator for list, parameters of function, ...etc.'''
        raise NotImplementedError()

    def getPivotTotalName(self) -> str:
        ''':deprecated: Use PivotGlobalizationSettings.GetTextOfTotal() method instead.'''
        raise NotImplementedError()

    def compare(self, v1 : str, v2 : str, ignoreCase : bool) -> int:
        '''Compares two string values according to certain collation rules.
        :param v1: the first string
        :param v2: the second string
        :param ignoreCase: whether ignore case when comparing values
        :returns: Integer that indicates the lexical relationship between the two comparands'''
        raise NotImplementedError()

    def getPivotSettings(self) -> PivotGlobalizationSettings:
        '''Gets the globalization settings for pivot table.'''
        raise NotImplementedError()


class GlowEffect:
    '''This class specifies a glow effect, in which a color blurred outline
    is added outside the edges of the object.'''

    def setTransparency(self, value : int) -> None:
        '''Sets the degree of transparency of the glow effect. Range from 0.0 (opaque) to 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def setRadius(self, value : int) -> None:
        ''':deprecated: Use GlowEffect.Size property instead.'''
        raise NotImplementedError()

    def setColor(self, value : CellsColor) -> None:
        '''Gets the color of the glow effect.
        :param value: '''
        raise NotImplementedError()

    def getSize(self) -> int:
        '''Gets the radius of the glow, in unit of points.'''
        raise NotImplementedError()

    def getColor(self) -> CellsColor:
        '''Gets the color of the glow effect.'''
        raise NotImplementedError()

    def setSize(self, value : int) -> None:
        '''Sets the radius of the glow, in unit of points.
        :param value: '''
        raise NotImplementedError()

    def getRadius(self) -> int:
        ''':deprecated: Use GlowEffect.Size property instead.'''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Gets the degree of transparency of the glow effect. Range from 0.0 (opaque) to 1.0 (clear).'''
        raise NotImplementedError()


class GradientColorType:
    '''Represents the gradient color type for the specified fill.'''

    NONE : GradientColorType
    '''No gradient color'''

    ONE_COLOR : GradientColorType
    '''One gradient color'''

    PRESET_COLORS : GradientColorType
    '''Preset gradient colors'''

    TWO_COLORS : GradientColorType
    '''Two gradient colors'''


class GradientDirectionType:
    '''Represents all direction type of gradient.'''

    FROM_UPPER_LEFT_CORNER : GradientDirectionType
    '''FromUpperLeftCorner'''

    FROM_UPPER_RIGHT_CORNER : GradientDirectionType
    '''FromUpperRightCorner'''

    FROM_LOWER_LEFT_CORNER : GradientDirectionType
    '''FromLowerLeftCorner'''

    FROM_LOWER_RIGHT_CORNER : GradientDirectionType
    '''FromLowerRightCorner'''

    FROM_CENTER : GradientDirectionType
    '''FromCenter'''

    UNKNOWN : GradientDirectionType
    '''Unknown'''


class GradientFill:
    '''Represents the gradient fill.'''

    def getGradientStyle(self) -> int:
        '''Gets gradient style type. Applies to Excel97-2003
        See :class:`GradientStyleType`'''
        raise NotImplementedError()

    def getGradientColorType(self) -> int:
        '''Gets gradient color type. Applies to Excel97-2003
        See :class:`GradientColorType`'''
        raise NotImplementedError()

    def getGradientColor2(self) -> Color:
        '''Gets gradient color 2. Applies to Excel97-2003'''
        raise NotImplementedError()

    def getGradientColor1(self) -> Color:
        '''Gets gradient color 1. Applies to Excel97-2003'''
        raise NotImplementedError()

    def setAngle(self, value : float) -> None:
        '''The angle of linear fill.
        :param value: '''
        raise NotImplementedError()

    def getAngle(self) -> float:
        '''The angle of linear fill.'''
        raise NotImplementedError()

    def setOneColorGradient(self, color : Color, degree : int, style : int, variant : int) -> None:
        '''Sets the specified fill to a one-color gradient.
        Only applies for Excel 2007.
        :param color: One gradient color.
        :param degree: The gradient degree. Can be a value from 0.0 (dark) through 1.0 (light).
        :param style: :class:`GradientStyleType`. Gradient shading style.
        :param variant: The gradient variant. Can be a value from 1 through 4, corresponding to one of the four variants on the Gradient tab in the Fill Effects dialog box. If style is GradientStyle.FromCenter, the Variant argument can only be 1 or 2.'''
        raise NotImplementedError()

    def getFillType(self) -> int:
        '''Gets the gradient fill type.
        See :class:`GradientFillType`'''
        raise NotImplementedError()

    def setPresetThemeGradient(self, gradientType : int, themeColorType : int) -> None:
        '''Sets preset theme gradient fill.
        :param gradientType: :class:`PresetThemeGradientType`. The preset gradient type.
        :param themeColorType: :class:`ThemeColorType`. The theme color type.'''
        raise NotImplementedError()

    @overload
    def setTwoColorGradient(self, color1 : Color, color2 : Color, style : int, variant : int) -> None:
        '''Sets the specified fill to a two-color gradient.
        Only applies for Excel 2007.
        :param color1: One gradient color.
        :param color2: Two gradient color.
        :param style: :class:`GradientStyleType`. Gradient shading style.
        :param variant: The gradient variant. Can be a value from 1 through 4, corresponding to one of the four variants on the Gradient tab in the Fill Effects dialog box. If style is GradientStyle.FromCenter, the Variant argument can only be 1 or 2.'''
        raise NotImplementedError()

    @overload
    def setTwoColorGradient(self, color1 : Color, transparency1 : int, color2 : Color, transparency2 : int, style : int, variant : int) -> None:
        '''Sets the specified fill to a two-color gradient.
        Only applies for Excel 2007.
        :param color1: One gradient color.
        :param transparency1: The degree of transparency of the color1 as a value from 0.0 (opaque) through 1.0 (clear).
        :param color2: Two gradient color.
        :param transparency2: The degree of transparency of the color2 as a value from 0.0 (opaque) through 1.0 (clear).
        :param style: :class:`GradientStyleType`. Gradient shading style.
        :param variant: The gradient variant. Can be a value from 1 through 4, corresponding to one of the four variants on the Gradient tab in the Fill Effects dialog box. If style is GradientStyle.FromCenter, the Variant argument can only be 1 or 2.'''
        raise NotImplementedError()

    def setPresetColor(self, value : int) -> None:
        '''Returns the gradient preset color for the specified fill. Applies to Excel97-2003
        See :class:`GradientPresetType`
        :param value: '''
        raise NotImplementedError()

    def getDirectionType(self) -> int:
        '''Gets the gradient direction type.
        See :class:`GradientDirectionType`'''
        raise NotImplementedError()

    def getGradientStops(self) -> GradientStopCollection:
        '''Represents the gradient stop collection.'''
        raise NotImplementedError()

    def getVariant(self) -> int:
        '''Gets variant. Applies to Excel97-2003'''
        raise NotImplementedError()

    def getGradientDegree(self) -> int:
        '''Gets gradient degree. Applies to Excel97-2003'''
        raise NotImplementedError()

    def setGradient(self, type : int, angle : int, direction : int) -> None:
        '''Set the gradient fill type and direction.
        :param type: :class:`GradientFillType`. Gradient fill type.
        :param angle: The angle. Only applies for GradientFillType.Linear.
        :param direction: :class:`GradientDirectionType`. The direction type. Only applies for GradientFillType.Radial and GradientFillType.Rectangle.'''
        raise NotImplementedError()

    def setPresetColorGradient(self, presetColor : int, style : int, variant : int) -> None:
        '''Sets the specified fill to a preset-color gradient.
        Only applies for Excel 97-2003
        :param presetColor: :class:`GradientPresetType`. Preset color type
        :param style: :class:`GradientStyleType`. Gradient shading style.
        :param variant: The gradient variant. Can be a value from 1 through 4, corresponding to one of the four variants on the Gradient tab in the Fill Effects dialog box. If style is GradientStyle.FromCenter, the Variant argument can only be 1 or 2.'''
        raise NotImplementedError()

    def getPresetColor(self) -> int:
        '''Returns the gradient preset color for the specified fill. Applies to Excel97-2003
        See :class:`GradientPresetType`'''
        raise NotImplementedError()


class GradientFillType:
    '''Represents all Gradient fill type.'''

    LINEAR : GradientFillType
    '''Linear'''

    RADIAL : GradientFillType
    '''Radial'''

    RECTANGLE : GradientFillType
    '''Rectangle'''

    PATH : GradientFillType
    '''Path'''


class GradientPresetType:
    '''Represents gradient preset color type.'''

    BRASS : GradientPresetType
    '''Brass preset color'''

    CALM_WATER : GradientPresetType
    '''Calm Water preset color'''

    CHROME : GradientPresetType
    '''Chrome preset color'''

    CHROME_II : GradientPresetType
    '''Chrome II preset color'''

    DAYBREAK : GradientPresetType
    '''Daybreak preset color'''

    DESERT : GradientPresetType
    '''Desert preset color'''

    EARLY_SUNSET : GradientPresetType
    '''Early Sunset preset color'''

    FIRE : GradientPresetType
    '''Fire preset color'''

    FOG : GradientPresetType
    '''Fog preset color'''

    GOLD : GradientPresetType
    '''Gold preset color'''

    GOLD_II : GradientPresetType
    '''Gold II preset color'''

    HORIZON : GradientPresetType
    '''Horizon preset color'''

    LATE_SUNSET : GradientPresetType
    '''Late Sunset preset color'''

    MAHOGANY : GradientPresetType
    '''Mahogany preset color'''

    MOSS : GradientPresetType
    '''Moss preset color'''

    NIGHTFALL : GradientPresetType
    '''Nightfall preset color'''

    OCEAN : GradientPresetType
    '''Ocean preset color'''

    PARCHMENT : GradientPresetType
    '''Parchment preset color'''

    PEACOCK : GradientPresetType
    '''Peacock preset color'''

    RAINBOW : GradientPresetType
    '''Rainbow preset color'''

    RAINBOW_II : GradientPresetType
    '''Rainbow II preset color'''

    SAPPHIRE : GradientPresetType
    '''Sapphire preset color'''

    SILVER : GradientPresetType
    '''Silver preset color'''

    WHEAT : GradientPresetType
    '''Wheat preset color'''

    UNKNOWN : GradientPresetType
    '''Unknown preset color.
    Only for the preset color (which is not same as any known preset color) in the template workbook.'''


class GradientStop:
    '''Represents the gradient stop.'''

    def setTransparency(self, value : int) -> None:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def getCellsColor(self) -> CellsColor:
        '''Gets the color of this gradient stop.'''
        raise NotImplementedError()

    def setPosition(self, value : int) -> None:
        '''The position of the stop.
        :param value: '''
        raise NotImplementedError()

    def getPosition(self) -> int:
        '''The position of the stop.'''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()


class GradientStopCollection:
    '''Represents the gradient stop collection.'''

    def get(self, index : int) -> GradientStop:
        '''Gets the gradient stop by the index.
        :param index: The index.
        :returns: The gradient stop.'''
        raise NotImplementedError()

    @overload
    def add(self, position : int, color : CellsColor, alpha : int) -> None:
        '''Add a gradient stop.
        :param position: The position of the stop,in unit of percentage.
        :param color: The color of the stop.
        :param alpha: The alpha of the color.'''
        raise NotImplementedError()

    @overload
    def add(self, position : int, color : Color, alpha : int) -> None:
        '''Add a gradient stop.
        :param position: The position of the stop,in unit of percentage.
        :param color: The color of the stop.
        :param alpha: The alpha of the color.'''
        raise NotImplementedError()


class GradientStyleType:
    '''Represents gradient shading style.'''

    DIAGONAL_DOWN : GradientStyleType
    '''Diagonal down shading style'''

    DIAGONAL_UP : GradientStyleType
    '''Diagonal up shading style'''

    FROM_CENTER : GradientStyleType
    '''From center shading style'''

    FROM_CORNER : GradientStyleType
    '''From corner shading style'''

    HORIZONTAL : GradientStyleType
    '''Horizontal shading style'''

    VERTICAL : GradientStyleType
    '''Vertical shading style'''

    UNKNOWN : GradientStyleType
    '''Unknown shading style.Only for the shading style(which is not for any member of the GradientStyleType) in the template file.'''



class GridlineType:
    '''Enumerates grid line Type.'''

    DOTTED : GridlineType
    '''Represents dotted line.'''

    HAIR : GridlineType
    '''Represents hair line.'''


class GroupBox:
    '''Encapsulates the object that represents a groupbox in a spreadsheet.'''

    def setShadow(self, value : bool) -> None:
        '''Indicates whether the groupbox has shadow.
        :param value: '''
        raise NotImplementedError()

    def getShadow(self) -> bool:
        '''Indicates whether the groupbox has shadow.'''
        raise NotImplementedError()


class GroupCharacterEquationNode:
    '''This class specifies the Group-Character function, consisting of a character drawn above or below text, often with the purpose of visually grouping items.'''

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()

    def getVertJc(self) -> int:
        '''This attribute, combined with pos of groupChrPr, specifies the vertical layout of the groupChr object. Where pos specifies the position of the grouping character, vertJc specifies the alignment of the object with respect to the baseline.
        See :class:`EquationCharacterPositionType`'''
        raise NotImplementedError()

    def setChrType(self, value : int) -> None:
        '''Specify combining characters by type value.
        See :class:`EquationCombiningCharacterType`
        :param value: '''
        raise NotImplementedError()

    def getChrType(self) -> int:
        '''Specify combining characters by type value.
        See :class:`EquationCombiningCharacterType`'''
        raise NotImplementedError()

    def setVertJc(self, value : int) -> None:
        '''This attribute, combined with pos of groupChrPr, specifies the vertical layout of the groupChr object. Where pos specifies the position of the grouping character, vertJc specifies the alignment of the object with respect to the baseline.
        See :class:`EquationCharacterPositionType`
        :param value: '''
        raise NotImplementedError()

    def setPosition(self, value : int) -> None:
        '''This attribute specifies the position of the character in the object
        See :class:`EquationCharacterPositionType`
        :param value: '''
        raise NotImplementedError()

    def setGroupChr(self, value : str) -> None:
        '''Specifies a symbol(default U+23DF).
        It is strongly recommended to use attribute ChrType to set accent character.
        Use this property setting if you cannot find the character you need in a known type.
        :param value: '''
        raise NotImplementedError()

    def getPosition(self) -> int:
        '''This attribute specifies the position of the character in the object
        See :class:`EquationCharacterPositionType`'''
        raise NotImplementedError()

    def getGroupChr(self) -> str:
        '''Specifies a symbol(default U+23DF).
        It is strongly recommended to use attribute ChrType to set accent character.
        Use this property setting if you cannot find the character you need in a known type.'''
        raise NotImplementedError()


class GroupFill:
    '''Represents this fill format should inherit the fill properties of the group.'''


class GroupShape:
    '''Represents the group shape which contains the individual shapes.'''

    def get(self, index : int) -> Shape:
        '''Gets the child shape by index.
        :param index: the child shape index.
        :returns: return the child shape.'''
        raise NotImplementedError()

    def getGroupedShapes(self) -> list[Shape]:
        '''Gets the shapes grouped by this shape.'''
        raise NotImplementedError()

    def ungroup(self) -> None:
        '''Ungroups the shape items.'''
        raise NotImplementedError()


class HeaderFooterCommand:
    '''Represents the command of header/footer'''

    def getText(self) -> str:
        '''Gets the text of the command.'''
        raise NotImplementedError()

    def getFont(self) -> Font:
        '''Gets the font of the command's value.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the header/footer' command type .
        See :class:`HeaderFooterCommandType`'''
        raise NotImplementedError()


class HeaderFooterCommandType:
    '''Represents the command type of header and footer.'''

    TEXT : HeaderFooterCommandType
    '''The text.'''

    CURRENT_PAGE : HeaderFooterCommandType
    '''Current page number'''

    PAGECOUNT : HeaderFooterCommandType
    '''Page count'''

    CURRENT_DATE : HeaderFooterCommandType
    '''Current date'''

    CURRENT_TIME : HeaderFooterCommandType
    '''Current time'''

    SHEET_NAME : HeaderFooterCommandType
    '''Sheet name'''

    FILE_NAME : HeaderFooterCommandType
    '''File name without path'''

    FILE_PATH : HeaderFooterCommandType
    '''File path without file name'''

    PICTURE : HeaderFooterCommandType
    '''Picture'''


class HighlightChangesOptions:
    '''Represents options of highlighting revsions or changes of shared Excel files.'''


class HorizontalPageBreak:
    '''Encapsulates the object that represents a horizontal page break.'''

    def getEndColumn(self) -> int:
        '''Gets the end column index of this horizontal page break.'''
        raise NotImplementedError()

    def getStartColumn(self) -> int:
        '''Gets the start column index of this horizontal page break.'''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets the zero based row index.'''
        raise NotImplementedError()


class HorizontalPageBreakCollection:
    '''Encapsulates a collection of :class:`HorizontalPageBreak` objects.'''

    def removeAt(self, index : int) -> None:
        '''Removes the HPageBreak element at a specified name.
        :param index: Element index, zero based.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> HorizontalPageBreak:
        '''Gets the :class:`HorizontalPageBreak` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def get(self, cellName : str) -> HorizontalPageBreak:
        '''Gets the :class:`HorizontalPageBreak` element with the specified cell name.
        :param cellName: Cell name.
        :returns: The element with the specified cell name.'''
        raise NotImplementedError()

    @overload
    def add(self, row : int, startColumn : int, endColumn : int) -> int:
        '''Adds a horizontal page break to the collection.
        :param row: Row index, zero based.
        :param startColumn: Start column index, zero based.
        :param endColumn: End column index, zero based.
        :returns: :class:`HorizontalPageBreak` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, row : int) -> int:
        '''Adds a horizontal page break to the collection.
        :param row: Cell row index, zero based.
        :returns: :class:`HorizontalPageBreak` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, row : int, column : int) -> int:
        '''Adds a horizontal page break to the collection.
        :param row: Cell row index, zero based.
        :param column: Cell column index, zero based.
        :returns: :class:`HorizontalPageBreak` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, cellName : str) -> int:
        '''Adds a horizontal page break to the collection.
        :param cellName: Cell name.
        :returns: :class:`HorizontalPageBreak` object index.'''
        raise NotImplementedError()


class HtmlCrossType:
    '''Represents five types of html cross string.'''

    DEFAULT : HtmlCrossType
    '''Display like MS Excel,depends on the next cell.
    If the next cell is null,the string will cross,or it will be truncated'''

    MS_EXPORT : HtmlCrossType
    '''Display the string like MS Excel exporting html.'''

    CROSS : HtmlCrossType
    '''Display HTML cross string, this performance for creating large html files will be more than ten times faster than setting the value to Default or FitToCell.'''

    CROSS_HIDE_RIGHT : HtmlCrossType
    '''Display HTML cross string and hide the right string when the texts overlap.'''

    FIT_TO_CELL : HtmlCrossType
    '''Only displaying the string within the width of cell.'''


class HtmlExportDataOptions:
    '''Represents the options for exporting html data.'''

    TABLE : HtmlExportDataOptions
    '''Export file to html which only contains table part.'''

    ALL : HtmlExportDataOptions
    '''Export all the data to html.'''


class HtmlFormatHandlingType:
    '''Specifies how to handle formatting from the HTML source'''

    ALL : HtmlFormatHandlingType
    '''Transfer all HTML formatting into the worksheet along with data.'''

    NONE : HtmlFormatHandlingType
    '''Bring data in as unformatted text (setting data types still occurs).'''

    RTF : HtmlFormatHandlingType
    '''Translate HTML formatting to rich text formatting on the data brought into the worksheet.'''


class HtmlHiddenColDisplayType:
    '''Represents two types of showing the hidden columns in html.'''

    HIDDEN : HtmlHiddenColDisplayType
    '''Hidden the hidden columns in html page.'''

    REMOVE : HtmlHiddenColDisplayType
    '''Remove the hidden columns in html page.'''


class HtmlHiddenRowDisplayType:
    '''Represents two types of showing the hidden rows in html.'''

    HIDDEN : HtmlHiddenRowDisplayType
    '''Hidden the hidden rows in html page.'''

    REMOVE : HtmlHiddenRowDisplayType
    '''Remove the hidden rows in html page.'''


class HtmlLinkTargetType:
    '''Represents the type of target attribute in HTML <a/> tag.'''

    BLANK : HtmlLinkTargetType
    '''Opens the linked document in a new window or tab'''

    PARENT : HtmlLinkTargetType
    '''Opens the linked document in the parent frame'''

    SELF : HtmlLinkTargetType
    '''Opens the linked document in the same frame as it was clicked (this is default)'''

    TOP : HtmlLinkTargetType
    '''Opens the linked document in the full body of the window'''


class HtmlLoadOptions:
    '''Represents options when importing a html file.'''

    def setLoadFormulas(self, value : bool) -> None:
        '''Indicates whether importing formulas if the original html file contains formulas
        :param value: '''
        raise NotImplementedError()

    def setConvertFormulasData(self, value : bool) -> None:
        ''':deprecated: Use HtmlLoadOptions.HasFormula property instead.'''
        raise NotImplementedError()

    def getAutoFitColsAndRows(self) -> bool:
        '''Indicates whether auto-fit columns and rows. The default value is false.'''
        raise NotImplementedError()

    def setSupportDivTag(self, value : bool) -> None:
        '''Indicates whether support the layout of <code>&lt;div&gt;</code> tag when the html file contains it.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getTableLoadOptions(self) -> HtmlTableLoadOptionCollection:
        '''Get the HtmlTableLoadOptionCollection instance'''
        raise NotImplementedError()

    def getAttachedFilesDirectory(self) -> str:
        ''':deprecated: Use HtmlLoadOptions.StreamProvider property instead.'''
        raise NotImplementedError()

    def getProgId(self) -> str:
        '''Gets the program id of creating the file.
        Only for MHT files.'''
        raise NotImplementedError()

    def hasFormula(self) -> bool:
        '''Indicates whether the text is formula if it starts with "=".'''
        raise NotImplementedError()

    def setDeleteRedundantSpaces(self, value : bool) -> None:
        '''Indicates whether delete redundant spaces when the text wraps lines using <code>&lt;br&gt;</code> tag.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getDeleteRedundantSpaces(self) -> bool:
        '''Indicates whether delete redundant spaces when the text wraps lines using <code>&lt;br&gt;</code> tag.
        The default value is false.'''
        raise NotImplementedError()

    def setHasFormula(self, value : bool) -> None:
        '''Indicates whether the text is formula if it starts with "=".
        :param value: '''
        raise NotImplementedError()

    def setAutoFitColsAndRows(self, value : bool) -> None:
        '''Indicates whether auto-fit columns and rows. The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getConvertFormulasData(self) -> bool:
        ''':deprecated: Use HtmlLoadOptions.HasFormula property instead.'''
        raise NotImplementedError()

    def getSupportDivTag(self) -> bool:
        '''Indicates whether support the layout of <code>&lt;div&gt;</code> tag when the html file contains it.
        The default value is false.'''
        raise NotImplementedError()

    def getLoadFormulas(self) -> bool:
        '''Indicates whether importing formulas if the original html file contains formulas'''
        raise NotImplementedError()

    def setAttachedFilesDirectory(self, value : str) -> None:
        ''':deprecated: Use HtmlLoadOptions.StreamProvider property instead.'''
        raise NotImplementedError()

    def getStreamProvider(self) -> IStreamProvider:
        '''Gets the StreamProviderImportHtmlFile for importing objects.'''
        raise NotImplementedError()

    def setStreamProvider(self, value : IStreamProvider) -> None:
        '''Sets the StreamProviderImportHtmlFile for importing objects.
        :param value: '''
        raise NotImplementedError()


class HtmlOfficeMathOutputType:
    '''Represents how export OfficeMath to HTML.'''

    IMAGE : HtmlOfficeMathOutputType
    '''Converts OfficeMath to HTML as image specified by &lt;img&gt; tag.'''

    MATH_ML : HtmlOfficeMathOutputType
    '''Converts OfficeMath to HTML using MathML.'''


class HtmlSaveOptions:
    '''Represents the options for saving html file.'''

    def getTableCssId(self) -> str:
        '''Gets the prefix of the type css name such as tr,col,td and so on, they are contained in the table element
        which has the specific TableCssId attribute. The default value is "".'''
        raise NotImplementedError()

    def setHtmlCrossStringType(self, value : int) -> None:
        '''Indicates if a cross-cell string will be displayed in the same way as MS Excel when saving an Excel file in html format.
        By default the value is Default, so, for cross-cell strings, there is little difference between the html files created by Aspose.Cells and MS Excel.
        But the performance for creating large html files,setting the value to Cross would be several times faster than setting it to Default or Fit2Cell.
        See :class:`HtmlCrossType`
        :param value: '''
        raise NotImplementedError()

    def setTableCssId(self, value : str) -> None:
        '''Sets the prefix of the type css name such as tr,col,td and so on, they are contained in the table element
        which has the specific TableCssId attribute. The default value is "".
        :param value: '''
        raise NotImplementedError()

    def getExportActiveWorksheetOnly(self) -> bool:
        '''Indicates if only exporting the active worksheet to html file.
        If true then only the active worksheet will be exported to html file;
        If false then the whole workbook will be exported to html file.
        The default value is false.'''
        raise NotImplementedError()

    def setPageTitle(self, value : str) -> None:
        '''The title of the html page.
        Only for saving to html stream.
        :param value: '''
        raise NotImplementedError()

    def setExpImageToTempDir(self, value : bool) -> None:
        '''Indicates whether exporting image files to temp directory.
        Only for saving to html stream.
        :param value: '''
        raise NotImplementedError()

    def setExportCommentsType(self, value : int) -> None:
        '''Represents type of exporting comments to html files.
        See :class:`PrintCommentsType`
        :param value: '''
        raise NotImplementedError()

    def getExportWorksheetCSSSeparately(self) -> bool:
        '''Indicating whether export the worksheet css separately.The default value is false.'''
        raise NotImplementedError()

    def setExportGridLines(self, value : bool) -> None:
        '''Indicating whether exporting the gridlines.The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getExportRowColumnHeadings(self) -> bool:
        '''Indicates whether exports sheet's row and column headings when saving to HTML files.'''
        raise NotImplementedError()

    def getAttachedFilesDirectory(self) -> str:
        '''The directory that the attached files will be saved to.
        Only for saving to html stream.'''
        raise NotImplementedError()

    def setMergeEmptyTdForcely(self, value : bool) -> None:
        ''':deprecated: Use HtmlSaveOptions.MergeEmptyTdType instead.'''
        raise NotImplementedError()

    def getExportExtraHeadings(self) -> bool:
        '''Indicates whether exporting extra headings when the length of text is longer than max display column.
        The default value is false. If you want to import the html file to excel, please keep the default value.'''
        raise NotImplementedError()

    def setWorksheetScalable(self, value : bool) -> None:
        '''Indicates if zooming in or out the html via worksheet zoom level when saving file to html, the default value is false.
        :param value: '''
        raise NotImplementedError()

    def setCssStyles(self, value : str) -> None:
        '''Sets the additional css styles for the formatter.
        Only works when :meth:`HtmlSaveOptions.getSaveAsSingleFile()` is True.
        <example>
        CssStyles="body { padding: 5px }";
        </example>
        :param value: '''
        raise NotImplementedError()

    def getExportFormula(self) -> bool:
        '''Indicates whether exporting formula when saving file to html. The default value is true.
        If you want to import the output html to excel, please keep the default value.'''
        raise NotImplementedError()

    def getLinkTargetType(self) -> int:
        '''Indicating the type of target attribute in <code>&lt;a&gt;</code> link. The default value is HtmlLinkTargetType.Parent.
        See :class:`HtmlLinkTargetType`'''
        raise NotImplementedError()

    def getDisableDownlevelRevealedComments(self) -> bool:
        '''Indicates if disable Downlevel-revealed conditional comments when exporting file to html, the default value is false.'''
        raise NotImplementedError()

    def setExportObjectListener(self, value : IExportObjectListener) -> None:
        ''':deprecated: Use HtmlSaveOptions.IStreamProvider property instead.'''
        raise NotImplementedError()

    def setExportBogusRowData(self, value : bool) -> None:
        '''Indicating whether exporting bogus bottom row data. The default value is true.If you want to import the html or mht file
        to excel, please keep the default value.
        :param value: '''
        raise NotImplementedError()

    def setExportFormula(self, value : bool) -> None:
        '''Indicates whether exporting formula when saving file to html. The default value is true.
        If you want to import the output html to excel, please keep the default value.
        :param value: '''
        raise NotImplementedError()

    def getHideOverflowWrappedText(self) -> bool:
        '''Indicates whether to hide overflow text when the cell format is set to wrap text.
        The default value is false'''
        raise NotImplementedError()

    def setExportPageFooters(self, value : bool) -> None:
        '''Indicates whether exporting page headers.
        :param value: '''
        raise NotImplementedError()

    def getExportGridLines(self) -> bool:
        '''Indicating whether exporting the gridlines.The default value is false.'''
        raise NotImplementedError()

    def getPageTitle(self) -> str:
        '''The title of the html page.
        Only for saving to html stream.'''
        raise NotImplementedError()

    def getExportFrameScriptsAndProperties(self) -> bool:
        '''Indicating whether exporting frame scripts and document properties. The default value is true.If you want to import the html or mht file
        to excel, please keep the default value.'''
        raise NotImplementedError()

    def setExportWorksheetCSSSeparately(self, value : bool) -> None:
        '''Indicating whether export the worksheet css separately.The default value is false.
        :param value: '''
        raise NotImplementedError()

    def setDisableDownlevelRevealedComments(self, value : bool) -> None:
        '''Indicates if disable Downlevel-revealed conditional comments when exporting file to html, the default value is false.
        :param value: '''
        raise NotImplementedError()

    def getImageOptions(self) -> ImageOrPrintOptions:
        '''Get the ImageOrPrintOptions object before exporting'''
        raise NotImplementedError()

    def setExportSimilarBorderStyle(self, value : bool) -> None:
        '''Indicating whether exporting the similar border style when the border style is not supported by browsers.
        If you want to import the html or mht file to excel, please keep the default value.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def setEncoding(self, value : Encoding) -> None:
        '''If not set,use Encoding.UTF8 as default enconding type.
        :param value: '''
        raise NotImplementedError()

    def getExportObjectListener(self) -> IExportObjectListener:
        ''':deprecated: Use HtmlSaveOptions.IStreamProvider property instead.'''
        raise NotImplementedError()

    def setExportHiddenWorksheet(self, value : bool) -> None:
        '''Indicating if exporting the hidden worksheet content.The default value is true.
        :param value: '''
        raise NotImplementedError()

    def setIgnoreInvisibleShapes(self, value : bool) -> None:
        '''Indicate whether exporting those not visible shapes
        :param value: '''
        raise NotImplementedError()

    def getDisableCss(self) -> bool:
        '''Indicates whether only inline styles are applied, without relying on CSS.
        The default value is false.'''
        raise NotImplementedError()

    def setDisableCss(self, value : bool) -> None:
        '''Indicates whether only inline styles are applied, without relying on CSS.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getExportSimilarBorderStyle(self) -> bool:
        '''Indicating whether exporting the similar border style when the border style is not supported by browsers.
        If you want to import the html or mht file to excel, please keep the default value.
        The default value is false.'''
        raise NotImplementedError()

    def setFullPathLink(self, value : bool) -> None:
        '''Indicating whether using full path link in sheet00x.htm,filelist.xml and tabstrip.htm.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getWorksheetScalable(self) -> bool:
        '''Indicates if zooming in or out the html via worksheet zoom level when saving file to html, the default value is false.'''
        raise NotImplementedError()

    def getCssStyles(self) -> str:
        '''Gets the additional css styles for the formatter.
        Only works when :meth:`HtmlSaveOptions.getSaveAsSingleFile()` is True.
        <example>
        CssStyles="body { padding: 5px }";
        </example>'''
        raise NotImplementedError()

    def setExportCellCoordinate(self, value : bool) -> None:
        '''Indicates whether exporting excel coordinate of nonblank cells when saving file to html. The default value is false.
        If you want to import the output html to excel, please keep the default value.
        :param value: '''
        raise NotImplementedError()

    def setDefaultFontName(self, value : str) -> None:
        '''Specify the default font name for exporting html, the default font will be used  when the font of style is not existing,
        If this property is null, Aspose.Cells will use universal font which have the same family with the original font,
        the default value is null.
        :param value: '''
        raise NotImplementedError()

    def setLinkTargetType(self, value : int) -> None:
        '''Indicating the type of target attribute in <code>&lt;a&gt;</code> link. The default value is HtmlLinkTargetType.Parent.
        See :class:`HtmlLinkTargetType`
        :param value: '''
        raise NotImplementedError()

    def getExportPageFooters(self) -> bool:
        '''Indicates whether exporting page headers.'''
        raise NotImplementedError()

    def setParseHtmlTagInCell(self, value : bool) -> None:
        '''Indicates whether html tag(such as <code>&lt;div&gt;&lt;/div&gt;</code>) in cell should be parsed as cell value or preserved as it is.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def setExportPrintAreaOnly(self, value : bool) -> None:
        '''Indicates if only exporting the print area to html file. The default value is false.
        :param value: '''
        raise NotImplementedError()

    def setAttachedFilesDirectory(self, value : str) -> None:
        '''The directory that the attached files will be saved to.
        Only for saving to html stream.
        :param value: '''
        raise NotImplementedError()

    def setExportDataOptions(self, value : int) -> None:
        '''Indicating the rule of exporting html file data.The default value is All.
        See :class:`HtmlExportDataOptions`
        :param value: '''
        raise NotImplementedError()

    def setExportActiveWorksheetOnly(self, value : bool) -> None:
        '''Indicates if only exporting the active worksheet to html file.
        If true then only the active worksheet will be exported to html file;
        If false then the whole workbook will be exported to html file.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getExportCellCoordinate(self) -> bool:
        '''Indicates whether exporting excel coordinate of nonblank cells when saving file to html. The default value is false.
        If you want to import the output html to excel, please keep the default value.'''
        raise NotImplementedError()

    def getExportDataOptions(self) -> int:
        '''Indicating the rule of exporting html file data.The default value is All.
        See :class:`HtmlExportDataOptions`'''
        raise NotImplementedError()

    def setExportSingleTab(self, value : bool) -> None:
        '''Indicates whether exporting the single tab when the file only has one worksheet.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def isFullPathLink(self) -> bool:
        '''Indicating whether using full path link in sheet00x.htm,filelist.xml and tabstrip.htm.
        The default value is false.'''
        raise NotImplementedError()

    def getExportWorksheetProperties(self) -> bool:
        '''Indicating whether exporting worksheet properties.The default value is true.If you want to import
        the html or mht file to excel, please keep the default value.'''
        raise NotImplementedError()

    def getHtmlCrossStringType(self) -> int:
        '''Indicates if a cross-cell string will be displayed in the same way as MS Excel when saving an Excel file in html format.
        By default the value is Default, so, for cross-cell strings, there is little difference between the html files created by Aspose.Cells and MS Excel.
        But the performance for creating large html files,setting the value to Cross would be several times faster than setting it to Default or Fit2Cell.
        See :class:`HtmlCrossType`'''
        raise NotImplementedError()

    def setExcludeUnusedStyles(self, value : bool) -> None:
        '''Indicating whether excludes unused styles.
        For the generated html files, excluding unused styles can make the file size smaller
        without affecting the visual effects. So the default value of this property is true.
        If user needs to keep all styles in the workbook for the generated html(such as the scenario that user
        needs to restore the workbook from the generated html later), please set this property as false.
        :param value: '''
        raise NotImplementedError()

    def setFilePathProvider(self, value : IFilePathProvider) -> None:
        '''Sets the IFilePathProvider for exporting Worksheet to html separately.
        :param value: '''
        raise NotImplementedError()

    def getEncodeEntityAsCode(self) -> bool:
        '''Indicates whether the html character entities are replaced with decimal code.
        (e.g. "&amp;nbsp;" is replaced with "&amp;#160;").
        The default value is false.'''
        raise NotImplementedError()

    def getEncoding(self) -> Encoding:
        '''If not set,use Encoding.UTF8 as default enconding type.'''
        raise NotImplementedError()

    def getAttachedFilesUrlPrefix(self) -> str:
        '''Specify the Url prefix of attached files such as image in the html file.
        Only for saving to html stream.'''
        raise NotImplementedError()

    def setExportDocumentProperties(self, value : bool) -> None:
        '''Indicating whether exporting document properties.The default value is true.If you want to import
        the html or mht file to excel, please keep the default value.
        :param value: '''
        raise NotImplementedError()

    def setMobileCompatible(self, value : bool) -> None:
        '''Indicates whether the output HTML is compatible with mobile devices.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getPresentationPreference(self) -> bool:
        '''Indicating if html or mht file is presentation preference.
        The default value is false.
        if you want to get more beautiful presentation,please set the value to true.'''
        raise NotImplementedError()

    def getAddGenericFont(self) -> bool:
        '''Indicates whether to add a generic font to CSS font-family.
        The default value is true'''
        raise NotImplementedError()

    def getExportDocumentProperties(self) -> bool:
        '''Indicating whether exporting document properties.The default value is true.If you want to import
        the html or mht file to excel, please keep the default value.'''
        raise NotImplementedError()

    def getMergeEmptyTdForcely(self) -> bool:
        ''':deprecated: Use HtmlSaveOptions.MergeEmptyTdType instead.'''
        raise NotImplementedError()

    def getExportWorkbookProperties(self) -> bool:
        '''Indicating whether exporting workbook properties.The default value is true.If you want to import
        the html or mht file to excel, please keep the default value.'''
        raise NotImplementedError()

    def getFilePathProvider(self) -> IFilePathProvider:
        '''Gets the IFilePathProvider for exporting Worksheet to html separately.'''
        raise NotImplementedError()

    def setSaveAsSingleFile(self, value : bool) -> None:
        '''Indicates whether save the html as single file.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getDefaultFontName(self) -> str:
        '''Specify the default font name for exporting html, the default font will be used  when the font of style is not existing,
        If this property is null, Aspose.Cells will use universal font which have the same family with the original font,
        the default value is null.'''
        raise NotImplementedError()

    def getImageScalable(self) -> bool:
        '''Indicates whether using scalable unit to describe the image width
        when using scalable unit to describe the column width.
        The default value is true.'''
        raise NotImplementedError()

    def setExportRowColumnHeadings(self, value : bool) -> None:
        '''Indicates whether exports sheet's row and column headings when saving to HTML files.
        :param value: '''
        raise NotImplementedError()

    def getExportSingleTab(self) -> bool:
        '''Indicates whether exporting the single tab when the file only has one worksheet.
        The default value is false.'''
        raise NotImplementedError()

    def setExportPageHeaders(self, value : bool) -> None:
        '''Indicates whether exporting page headers.
        :param value: '''
        raise NotImplementedError()

    def setImageScalable(self, value : bool) -> None:
        '''Indicates whether using scalable unit to describe the image width
        when using scalable unit to describe the column width.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def setJsBrowserCompatible(self, value : bool) -> None:
        '''Indicates whether JavaScript is compatible with browsers that do not support JavaScript.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def setAddGenericFont(self, value : bool) -> None:
        '''Indicates whether to add a generic font to CSS font-family.
        The default value is true
        :param value: '''
        raise NotImplementedError()

    def getExportPageHeaders(self) -> bool:
        '''Indicates whether exporting page headers.'''
        raise NotImplementedError()

    def getSaveAsSingleFile(self) -> bool:
        '''Indicates whether save the html as single file.
        The default value is false.'''
        raise NotImplementedError()

    def isBorderCollapsed(self) -> bool:
        '''Indicates whether the table borders are collapsed.
        The default value is true.'''
        raise NotImplementedError()

    def setExportWorkbookProperties(self, value : bool) -> None:
        '''Indicating whether exporting workbook properties.The default value is true.If you want to import
        the html or mht file to excel, please keep the default value.
        :param value: '''
        raise NotImplementedError()

    def isExportComments(self) -> bool:
        '''Indicates if exporting comments when saving file to html, the default value is false.'''
        raise NotImplementedError()

    def setBorderCollapsed(self, value : bool) -> None:
        '''Indicates whether the table borders are collapsed.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def setHiddenRowDisplayType(self, value : int) -> None:
        '''Hidden row(the height of this row is 0) in excel,before save this into html format,
        if HtmlHiddenRowDisplayType is "Remove",the hidden row would not been output,
        if the value is "Hidden", the row would been output,but was hidden,the default value is "Hidden"
        See :class:`HtmlHiddenRowDisplayType`
        :param value: '''
        raise NotImplementedError()

    def getExportBogusRowData(self) -> bool:
        '''Indicating whether exporting bogus bottom row data. The default value is true.If you want to import the html or mht file
        to excel, please keep the default value.'''
        raise NotImplementedError()

    def setHiddenColDisplayType(self, value : int) -> None:
        '''Hidden column(the width of this column is 0) in excel,before save this into html format,
        if HtmlHiddenColDisplayType is "Remove",the hidden column would not been output,
        if the value is "Hidden", the column would been output,but was hidden,the default value is "Hidden"
        See :class:`HtmlHiddenColDisplayType`
        :param value: '''
        raise NotImplementedError()

    def setOfficeMathOutputMode(self, value : int) -> None:
        '''Indicates how export OfficeMath objects to HTML, Default value is Image.
        See :class:`HtmlOfficeMathOutputType`
        :param value: '''
        raise NotImplementedError()

    def getExportCommentsType(self) -> int:
        '''Represents type of exporting comments to html files.
        See :class:`PrintCommentsType`'''
        raise NotImplementedError()

    def setCellNameAttribute(self, value : str) -> None:
        '''Specifies the attribute that indicates the CellName to be written.
        (e.g. If the value is "id", then for cell "A1", the output will be:&lt;td id='A1'&gt;).
        The default value is null.
        :param value: '''
        raise NotImplementedError()

    def getCellNameAttribute(self) -> str:
        '''Specifies the attribute that indicates the CellName to be written.
        (e.g. If the value is "id", then for cell "A1", the output will be:&lt;td id='A1'&gt;).
        The default value is null.'''
        raise NotImplementedError()

    def setIECompatible(self, value : bool) -> None:
        '''Indicating whether the output HTML is compatible with IE browser.
        The defalut value is false
        :param value: '''
        raise NotImplementedError()

    def setExportImagesAsBase64(self, value : bool) -> None:
        '''Specifies whether images are saved in Base64 format to HTML, MHTML or EPUB.
        :param value: '''
        raise NotImplementedError()

    def getHiddenRowDisplayType(self) -> int:
        '''Hidden row(the height of this row is 0) in excel,before save this into html format,
        if HtmlHiddenRowDisplayType is "Remove",the hidden row would not been output,
        if the value is "Hidden", the row would been output,but was hidden,the default value is "Hidden"
        See :class:`HtmlHiddenRowDisplayType`'''
        raise NotImplementedError()

    def setCalculateFormula(self, value : bool) -> None:
        '''Indicates whether to calculate formulas before saving html file.
        :param value: '''
        raise NotImplementedError()

    def getHiddenColDisplayType(self) -> int:
        '''Hidden column(the width of this column is 0) in excel,before save this into html format,
        if HtmlHiddenColDisplayType is "Remove",the hidden column would not been output,
        if the value is "Hidden", the column would been output,but was hidden,the default value is "Hidden"
        See :class:`HtmlHiddenColDisplayType`'''
        raise NotImplementedError()

    def getOfficeMathOutputMode(self) -> int:
        '''Indicates how export OfficeMath objects to HTML, Default value is Image.
        See :class:`HtmlOfficeMathOutputType`'''
        raise NotImplementedError()

    def setHideOverflowWrappedText(self, value : bool) -> None:
        '''Indicates whether to hide overflow text when the cell format is set to wrap text.
        The default value is false
        :param value: '''
        raise NotImplementedError()

    def setMergeEmptyTdType(self, value : int) -> None:
        '''The option to merge contiguous empty cells(empty td elements)
        The default value is MergeEmptyTdType.Default.
        See :class:`MergeEmptyTdType`
        :param value: '''
        raise NotImplementedError()

    def setExportExtraHeadings(self, value : bool) -> None:
        '''Indicates whether exporting extra headings when the length of text is longer than max display column.
        The default value is false. If you want to import the html file to excel, please keep the default value.
        :param value: '''
        raise NotImplementedError()

    def getStreamProvider(self) -> IStreamProvider:
        '''Gets the IStreamProvider for exporting objects.'''
        raise NotImplementedError()

    def getExportPrintAreaOnly(self) -> bool:
        '''Indicates if only exporting the print area to html file. The default value is false.'''
        raise NotImplementedError()

    def getWidthScalable(self) -> bool:
        '''Indicates whether exporting column width in unit of scale to html.
        The default value is false.'''
        raise NotImplementedError()

    def getCalculateFormula(self) -> bool:
        '''Indicates whether to calculate formulas before saving html file.'''
        raise NotImplementedError()

    def getExportImagesAsBase64(self) -> bool:
        '''Specifies whether images are saved in Base64 format to HTML, MHTML or EPUB.'''
        raise NotImplementedError()

    def setShowAllSheets(self, value : bool) -> None:
        '''Indicates whether showing all sheets when saving  as a single html file.
        :param value: '''
        raise NotImplementedError()

    def setExportArea(self, value : CellArea) -> None:
        '''Sets the exporting CellArea of current active Worksheet.
        If you set this attribute, the print area of current active Worksheet will be omitted.
        Only the specified area will be exported when saving the file to html.
        :param value: '''
        raise NotImplementedError()

    def setExportFrameScriptsAndProperties(self, value : bool) -> None:
        '''Indicating whether exporting frame scripts and document properties. The default value is true.If you want to import the html or mht file
        to excel, please keep the default value.
        :param value: '''
        raise NotImplementedError()

    def setWidthScalable(self, value : bool) -> None:
        '''Indicates whether exporting column width in unit of scale to html.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def isJsBrowserCompatible(self) -> bool:
        '''Indicates whether JavaScript is compatible with browsers that do not support JavaScript.
        The default value is true.'''
        raise NotImplementedError()

    def setExportWorksheetProperties(self, value : bool) -> None:
        '''Indicating whether exporting worksheet properties.The default value is true.If you want to import
        the html or mht file to excel, please keep the default value.
        :param value: '''
        raise NotImplementedError()

    def getCellCssPrefix(self) -> str:
        '''Gets the prefix of the css name,the default value is "".'''
        raise NotImplementedError()

    def getFormatDataIgnoreColumnWidth(self) -> bool:
        '''Indicating whether show the whole formatted data of cell when overflowing the column.
        If true then ignore the column width and the whole data of cell will be exported.
        If false then the data will be exported same as Excel.
        The default value is false.'''
        raise NotImplementedError()

    def setExportComments(self, value : bool) -> None:
        '''Indicates if exporting comments when saving file to html, the default value is false.
        :param value: '''
        raise NotImplementedError()

    def setCellCssPrefix(self, value : str) -> None:
        '''Sets the prefix of the css name,the default value is "".
        :param value: '''
        raise NotImplementedError()

    def getParseHtmlTagInCell(self) -> bool:
        '''Indicates whether html tag(such as <code>&lt;div&gt;&lt;/div&gt;</code>) in cell should be parsed as cell value or preserved as it is.
        The default value is true.'''
        raise NotImplementedError()

    def getExportHiddenWorksheet(self) -> bool:
        '''Indicating if exporting the hidden worksheet content.The default value is true.'''
        raise NotImplementedError()

    def getIgnoreInvisibleShapes(self) -> bool:
        '''Indicate whether exporting those not visible shapes'''
        raise NotImplementedError()

    def getExcludeUnusedStyles(self) -> bool:
        '''Indicating whether excludes unused styles.
        For the generated html files, excluding unused styles can make the file size smaller
        without affecting the visual effects. So the default value of this property is true.
        If user needs to keep all styles in the workbook for the generated html(such as the scenario that user
        needs to restore the workbook from the generated html later), please set this property as false.'''
        raise NotImplementedError()

    def setAttachedFilesUrlPrefix(self, value : str) -> None:
        '''Specify the Url prefix of attached files such as image in the html file.
        Only for saving to html stream.
        :param value: '''
        raise NotImplementedError()

    def getAddTooltipText(self) -> bool:
        '''Indicates whether adding tooltip text when the data can't be fully displayed.
        The default value is false.'''
        raise NotImplementedError()

    def getExportHeadings(self) -> bool:
        ''':deprecated: Use HtmlSaveOptions.ExportRowColumnHeadings instead.'''
        raise NotImplementedError()

    def getShowAllSheets(self) -> bool:
        '''Indicates whether showing all sheets when saving  as a single html file.'''
        raise NotImplementedError()

    def isIECompatible(self) -> bool:
        '''Indicating whether the output HTML is compatible with IE browser.
        The defalut value is false'''
        raise NotImplementedError()

    def isExpImageToTempDir(self) -> bool:
        '''Indicates whether exporting image files to temp directory.
        Only for saving to html stream.'''
        raise NotImplementedError()

    def getExportArea(self) -> CellArea:
        '''Gets the exporting CellArea of current active Worksheet.
        If you set this attribute, the print area of current active Worksheet will be omitted.
        Only the specified area will be exported when saving the file to html.'''
        raise NotImplementedError()

    def setPresentationPreference(self, value : bool) -> None:
        '''Indicating if html or mht file is presentation preference.
        The default value is false.
        if you want to get more beautiful presentation,please set the value to true.
        :param value: '''
        raise NotImplementedError()

    def isMobileCompatible(self) -> bool:
        '''Indicates whether the output HTML is compatible with mobile devices.
        The default value is false.'''
        raise NotImplementedError()

    def getMergeEmptyTdType(self) -> int:
        '''The option to merge contiguous empty cells(empty td elements)
        The default value is MergeEmptyTdType.Default.
        See :class:`MergeEmptyTdType`'''
        raise NotImplementedError()

    def setEncodeEntityAsCode(self, value : bool) -> None:
        '''Indicates whether the html character entities are replaced with decimal code.
        (e.g. "&amp;nbsp;" is replaced with "&amp;#160;").
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def setFormatDataIgnoreColumnWidth(self, value : bool) -> None:
        '''Indicating whether show the whole formatted data of cell when overflowing the column.
        If true then ignore the column width and the whole data of cell will be exported.
        If false then the data will be exported same as Excel.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def setStreamProvider(self, value : IStreamProvider) -> None:
        '''Sets the IStreamProvider for exporting objects.
        :param value: '''
        raise NotImplementedError()

    def setAddTooltipText(self, value : bool) -> None:
        '''Indicates whether adding tooltip text when the data can't be fully displayed.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def setExportHeadings(self, value : bool) -> None:
        ''':deprecated: Use HtmlSaveOptions.ExportRowColumnHeadings instead.'''
        raise NotImplementedError()


class HtmlTableLoadOption:
    '''Represents the option when import table from html.'''

    def getName(self) -> str:
        ''':deprecated: Please use HtmlTableLoadOption.Id instead'''
        raise NotImplementedError()

    def setId(self, value : str) -> None:
        '''Sets the id of table to import from html
        :param value: '''
        raise NotImplementedError()

    def getId(self) -> str:
        '''Gets the id of table to import from html'''
        raise NotImplementedError()

    def getTargetSheetIndex(self) -> int:
        '''Gets the target index of worksheet where the table is to be located.'''
        raise NotImplementedError()

    def getTableIndex(self) -> int:
        '''Gets the index of table to import from html.'''
        raise NotImplementedError()

    def getTableToListObject(self) -> bool:
        '''Indicates whether generate list objects from imported table.
        The default value is false.'''
        raise NotImplementedError()

    def setOriginalSheetIndex(self, value : int) -> None:
        '''Sets the original index of worksheet in the html.
        :param value: '''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        ''':deprecated: Please use HtmlTableLoadOption.Id instead'''
        raise NotImplementedError()

    def setTableToListObject(self, value : bool) -> None:
        '''Indicates whether generate list objects from imported table.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def setTableIndex(self, value : int) -> None:
        '''Sets the index of table to import from html.
        :param value: '''
        raise NotImplementedError()

    def setTargetSheetIndex(self, value : int) -> None:
        '''Sets the target index of worksheet where the table is to be located.
        :param value: '''
        raise NotImplementedError()

    def getOriginalSheetIndex(self) -> int:
        '''Gets the original index of worksheet in the html.'''
        raise NotImplementedError()


class HtmlTableLoadOptionCollection:
    '''Represents the table options when importing html.'''

    def getTableToListObject(self) -> bool:
        '''Indicates whether generate list objects from imported tables.
        The default value is false.'''
        raise NotImplementedError()

    def get(self, index : int) -> HtmlTableLoadOption:
        '''Gets the :class:`HtmlTableLoadOption` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    def setTableToListObject(self, value : bool) -> None:
        '''Indicates whether generate list objects from imported tables.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    @overload
    def add(self, item : HtmlTableLoadOption) -> int:
        '''Adds one HtmlTableLoadOption into this collection.
        :param item: one HtmlTableLoadOption
        :returns: the index of the added item'''
        raise NotImplementedError()

    @overload
    def add(self, tableIndex : int) -> int:
        '''Add a HtmlTableLoadOption to the list.
        :param tableIndex: Table index'''
        raise NotImplementedError()

    @overload
    def add(self, tableId : str) -> int:
        '''Add a HtmlTableLoadOption to the list.
        :param tableId: Table ID'''
        raise NotImplementedError()

    @overload
    def add(self, tableIndex : int, targetSheetIndex : int) -> int:
        '''Add a HtmlTableLoadOption to the list.
        :param tableIndex: Table index
        :param targetSheetIndex: The target index of worksheet in Excel'''
        raise NotImplementedError()

    @overload
    def add(self, tableId : str, targetSheetIndex : int) -> int:
        '''Add a HtmlTableLoadOption to the list.
        :param tableId: Table ID
        :param targetSheetIndex: The target index of worksheet in Excel'''
        raise NotImplementedError()

    @overload
    def add(self, tableIndex : int, targetSheetIndex : int, originalSheetIndex : int) -> int:
        '''Add a HtmlTableLoadOption to the list.
        :param tableIndex: Table index
        :param targetSheetIndex: The target index of worksheet in Excel
        :param originalSheetIndex: The original index of worksheet in the html'''
        raise NotImplementedError()

    @overload
    def add(self, tableId : str, targetSheetIndex : int, originalSheetIndex : int) -> int:
        '''Add a HtmlTableLoadOption to the list.
        :param tableId: Table ID
        :param targetSheetIndex: The target index of worksheet in Excel
        :param originalSheetIndex: The original index of worksheet in the html'''
        raise NotImplementedError()


class Hyperlink:
    '''Encapsulates the object that represents a hyperlink.'''

    def getArea(self) -> CellArea:
        '''Gets the range of hyperlink.'''
        raise NotImplementedError()

    def setTextToDisplay(self, value : str) -> None:
        '''Represents the text to be displayed for the specified hyperlink. The default value is the address of the hyperlink.
        :param value: '''
        raise NotImplementedError()

    def setScreenTip(self, value : str) -> None:
        '''Returns or sets the ScreenTip text for the specified hyperlink.
        :param value: '''
        raise NotImplementedError()

    def getTextToDisplay(self) -> str:
        '''Represents the text to be displayed for the specified hyperlink. The default value is the address of the hyperlink.'''
        raise NotImplementedError()

    def setAddress(self, value : str) -> None:
        '''Represents the address of a hyperlink.
        :param value: '''
        raise NotImplementedError()

    def getLinkType(self) -> int:
        '''Gets the link type.
        See :class:`TargetModeType`'''
        raise NotImplementedError()

    def getAddress(self) -> str:
        '''Represents the address of a hyperlink.'''
        raise NotImplementedError()

    def getScreenTip(self) -> str:
        '''Returns or sets the ScreenTip text for the specified hyperlink.'''
        raise NotImplementedError()

    def delete(self) -> None:
        '''Deletes this hyperlink'''
        raise NotImplementedError()


class HyperlinkCollection:
    '''Encapsulates a collection of :class:`Hyperlink` objects.'''

    def clear(self) -> None:
        '''Clears all hyperlinks.'''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Remove the hyperlink  at the specified index in this collection.
        :param index: The zero based index of the element.'''
        raise NotImplementedError()

    def get(self, index : int) -> Hyperlink:
        '''Gets the :class:`Hyperlink` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def add(self, firstRow : int, firstColumn : int, totalRows : int, totalColumns : int, address : str) -> int:
        '''Adds a hyperlink to a specified cell or a range of cells.
        :param firstRow: First row of the hyperlink range.
        :param firstColumn: First column of the hyperlink range.
        :param totalRows: Number of rows in this hyperlink range.
        :param totalColumns: Number of columns of this hyperlink range.
        :param address: Address of the hyperlink.
        :returns: :class:`Hyperlink` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, cellName : str, totalRows : int, totalColumns : int, address : str) -> int:
        '''Adds a hyperlink to a specified cell or a range of cells.
        :param cellName: Cell name.
        :param totalRows: Number of rows in this hyperlink range.
        :param totalColumns: Number of columns of this hyperlink range.
        :param address: Address of the hyperlink.
        :returns: :class:`Hyperlink` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, startCellName : str, endCellName : str, address : str, textToDisplay : str, screenTip : str) -> int:
        '''Adds a hyperlink to a specified cell or a range of cells.
        :param startCellName: The top-left cell of the range.
        :param endCellName: The bottom-right cell of the range.
        :param address: Address of the hyperlink.
        :param textToDisplay: The text to be displayed for the specified hyperlink.
        :param screenTip: The screenTip text for the specified hyperlink.
        :returns: :class:`Hyperlink` object index.'''
        raise NotImplementedError()











class ICellsDataTable:
    '''Represents data table.'''

    def getCount(self) -> int:
        '''Gets the count of the records. -1 for unknown records count.'''
        raise NotImplementedError()

    @overload
    def get(self, columnIndex : int) -> Object:
        '''Gets the data stored in the column specified by index.
        :param columnIndex: The zero-based index of the column.'''
        raise NotImplementedError()

    @overload
    def get(self, columnName : str) -> Object:
        '''Gets the data stored in the column specified by column name.
        :param columnName: The column name.'''
        raise NotImplementedError()

    def next(self) -> bool:
        '''Moves the cursor down one row from its current position.'''
        raise NotImplementedError()

    def getColumns(self) -> list[str]:
        '''Gets the columns' name.'''
        raise NotImplementedError()

    def beforeFirst(self) -> None:
        '''Move the cursor to the front of this object, just before the first row.'''
        raise NotImplementedError()


















class IconFilter:
    '''Represents icon filter.'''

    def getIconId(self) -> int:
        '''Gets Zero-based index of an icon in an icon set.'''
        raise NotImplementedError()

    def getIconSetType(self) -> int:
        '''Gets which icon set is used in the filter criteria.
        See :class:`IconSetType`'''
        raise NotImplementedError()

    def setIconId(self, value : int) -> None:
        '''Sets Zero-based index of an icon in an icon set.
        :param value: '''
        raise NotImplementedError()

    def setIconSetType(self, value : int) -> None:
        '''Sets which icon set is used in the filter criteria.
        See :class:`IconSetType`
        :param value: '''
        raise NotImplementedError()


class IconSet:
    '''Describe the IconSet conditional formatting rule.
    This conditional formatting rule applies icons to cells
    according to their values.'''

    def getShowValue(self) -> bool:
        '''Gets the flag indicating whether to show the values of the cells on which this icon set is applied.
        Default value is true.'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets the icon set type to display.
        Setting the type will auto check if the current Cfvos's count is
        accord with the new type. If not accord, old Cfvos will be cleaned and
        default Cfvos will be added.
        See :class:`IconSetType`
        :param value: '''
        raise NotImplementedError()

    def setReverse(self, value : bool) -> None:
        '''Sets the flag indicating whether to reverses the default order of the icons in this icon set.
        Default value is false.
        :param value: '''
        raise NotImplementedError()

    def getReverse(self) -> bool:
        '''Gets the flag indicating whether to reverses the default order of the icons in this icon set.
        Default value is false.'''
        raise NotImplementedError()

    def getCfvos(self) -> ConditionalFormattingValueCollection:
        '''Get the CFValueObjects instance.'''
        raise NotImplementedError()

    def getCfIcons(self) -> ConditionalFormattingIconCollection:
        '''Get the:class:`ConditionalFormattingIcon` from the collection'''
        raise NotImplementedError()

    def setShowValue(self, value : bool) -> None:
        '''Sets the flag indicating whether to show the values of the cells on which this icon set is applied.
        Default value is true.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the icon set type to display.
        Setting the type will auto check if the current Cfvos's count is
        accord with the new type. If not accord, old Cfvos will be cleaned and
        default Cfvos will be added.
        See :class:`IconSetType`'''
        raise NotImplementedError()

    def isCustom(self) -> bool:
        '''Indicates whether the icon set is custom.
        Default value is false.'''
        raise NotImplementedError()


class IconSetType:
    '''Icon set type for conditional formatting.
    The threshold values for triggering the different icons within a set are
    configurable, and the icon order is reversible.'''

    ARROWS_3 : IconSetType
    '''3 arrows icon set.'''

    ARROWS_GRAY_3 : IconSetType
    '''3 gray arrows icon set.'''

    FLAGS_3 : IconSetType
    '''3 flags icon set.'''

    SIGNS_3 : IconSetType
    '''3 signs icon set.'''

    SYMBOLS_3 : IconSetType
    '''3 symbols icon set (circled).'''

    SYMBOLS_32 : IconSetType
    '''3 Symbols icon set (uncircled).'''

    TRAFFIC_LIGHTS_31 : IconSetType
    '''3 traffic lights icon set (unrimmed).'''

    TRAFFIC_LIGHTS_32 : IconSetType
    '''3 traffic lights icon set with thick black border.'''

    ARROWS_4 : IconSetType
    '''4 arrows icon set.'''

    ARROWS_GRAY_4 : IconSetType
    '''4 gray arrows icon set.'''

    RATING_4 : IconSetType
    '''4 ratings icon set.'''

    RED_TO_BLACK_4 : IconSetType
    '''4 'red to black' icon set.'''

    TRAFFIC_LIGHTS_4 : IconSetType
    '''4 traffic lights icon set.'''

    ARROWS_5 : IconSetType
    '''5 arrows icon set.'''

    ARROWS_GRAY_5 : IconSetType
    '''5 gray arrows icon set.'''

    QUARTERS_5 : IconSetType
    '''5 quarters icon set.'''

    RATING_5 : IconSetType
    '''5 rating icon set.'''

    STARS_3 : IconSetType
    '''3 stars set'''

    BOXES_5 : IconSetType
    '''5 boxes set'''

    TRIANGLES_3 : IconSetType
    '''3 triangles set'''

    NONE : IconSetType
    '''None'''

    CUSTOM_SET : IconSetType
    '''CustomSet.
    This element is read-only.'''

    SMILIES_3 : IconSetType
    '''3 smilies.
    Only for .ods.'''

    COLOR_SMILIES_3 : IconSetType
    '''3 color smilies.
    Only for .ods.'''



class ICustomParser:
    '''Allows users to add their custom value parser for parsing string values to other proper cell value object.'''

    def parseObject(self, value : str) -> Object:
        '''Parses given string to proper value object.
        :param value: The string value to be parsed
        :returns: Parsed value object from given string. If given string cannot be parsed to proper value object, returns null.'''
        raise NotImplementedError()

    def getFormat(self) -> str:
        '''Gets the formatting pattern corresponding to the parsed value by last invocation of :meth:`ICustomParser.parseObject(String)`.'''
        raise NotImplementedError()



class IExportObjectListener:
    '''Allows users to manipulate objects while exporting.
    The following example creates a Workbook, opens a file named designer.xls in it and makes the horizontal and vertical scroll bars invisible for the Workbook. It then replaces two string values with an Integer value and string value respectively within the spreadsheet and finally sends the updated file to the client browser.'''

    def exportObject(self, e : ExportObjectEvent) -> Object:
        '''Export one object.
        :param e: The event triggered when one object needs to be exported.
        :returns: The information about the result of exporting object. <ul> <li>For exporting objects when export workbook to HTML format, the result is URL string to access the saved Image from the html file which contains this exported object. </li> </ul>'''
        raise NotImplementedError()


class IFilePathProvider:
    '''Represents the exported file path provider.'''

    def getFullName(self, sheetName : str) -> str:
        '''Gets the full path of the file by Worksheet name when exporting Worksheet to html separately.
        So the references among the Worksheets can be exported correctly.
        :param sheetName: Worksheet name
        :returns: the full path of the file'''
        raise NotImplementedError()

























class ImageActiveXControl:
    '''Represents the image control.'''

    def isAutoSize(self) -> bool:
        '''Indicates whether the control will automatically resize to display its entire contents.'''
        raise NotImplementedError()

    def setBorderOleColor(self, value : int) -> None:
        '''Sets the ole color of the background.
        :param value: '''
        raise NotImplementedError()

    def getBorderStyle(self) -> int:
        '''Gets the type of border used by the control.
        See :class:`ControlBorderType`'''
        raise NotImplementedError()

    def getPictureAlignment(self) -> int:
        '''Gets the alignment of the picture inside the Form or Image.
        See :class:`ControlPictureAlignmentType`'''
        raise NotImplementedError()

    def setPicture(self, value : list[int]) -> None:
        '''Sets the data of the picture.
        :param value: '''
        raise NotImplementedError()

    def getPicture(self) -> list[int]:
        '''Gets the data of the picture.'''
        raise NotImplementedError()

    def isTiled(self) -> bool:
        '''Indicates whether the picture is tiled across the background.'''
        raise NotImplementedError()

    def setPictureSizeMode(self, value : int) -> None:
        '''Sets how to display the picture.
        See :class:`ControlPictureSizeMode`
        :param value: '''
        raise NotImplementedError()

    def getSpecialEffect(self) -> int:
        '''Gets the special effect of the control.
        See :class:`ControlSpecialEffectType`'''
        raise NotImplementedError()

    def getBorderOleColor(self) -> int:
        '''Gets the ole color of the background.'''
        raise NotImplementedError()

    def setSpecialEffect(self, value : int) -> None:
        '''Sets the special effect of the control.
        See :class:`ControlSpecialEffectType`
        :param value: '''
        raise NotImplementedError()

    def getPictureSizeMode(self) -> int:
        '''Gets how to display the picture.
        See :class:`ControlPictureSizeMode`'''
        raise NotImplementedError()

    def setPictureAlignment(self, value : int) -> None:
        '''Sets the alignment of the picture inside the Form or Image.
        See :class:`ControlPictureAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def setAutoSize(self, value : bool) -> None:
        '''Indicates whether the control will automatically resize to display its entire contents.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()

    def setBorderStyle(self, value : int) -> None:
        '''Sets the type of border used by the control.
        See :class:`ControlBorderType`
        :param value: '''
        raise NotImplementedError()

    def setTiled(self, value : bool) -> None:
        '''Indicates whether the picture is tiled across the background.
        :param value: '''
        raise NotImplementedError()


class ImageBinarizationMethod:
    '''Specifies the method used to binarize image.'''

    THRESHOLD : ImageBinarizationMethod
    '''Specifies threshold method.'''

    FLOYD_STEINBERG_DITHERING : ImageBinarizationMethod
    '''Specifies dithering using Floyd-Steinberg error diffusion method.'''


class ImageFormat:
    '''Specifies the file format of the image.'''

    def getGif(self) -> ImageFormat:
        '''Gets the Graphics Interchange Format (GIF) image format.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Get the string name of this ImageFormat instance'''
        raise NotImplementedError()

    def getJpeg(self) -> ImageFormat:
        '''Gets the Joint Photographic Experts Group (JPEG) image format.'''
        raise NotImplementedError()

    def getWmf(self) -> ImageFormat:
        '''Gets the Windows metafile (WMF) image format.'''
        raise NotImplementedError()

    def getBmp(self) -> ImageFormat:
        '''Gets the bitmap (BMP) image format.'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Returns a value that indicates whether the specified object is an ImageFormat
        object that is equivalent to this ImageFormat object.
        :param obj: The object to test.
        :returns: true if o is an ImageFormat object that is equivalent to this ImageFormat object; otherwise, false.'''
        raise NotImplementedError()

    def getImageFormatFromSuffixName(self, name : str) -> ImageFormat:
        '''Get the image format according to suffix name
        :param name: suffix name
        :returns: >An ImageFormat object according to the suffix name.'''
        raise NotImplementedError()

    def getPng(self) -> ImageFormat:
        '''Gets the W3C Portable Network Graphics (PNG) image format.'''
        raise NotImplementedError()

    def getEmf(self) -> ImageFormat:
        '''Gets the enhanced metafile (EMF) image format.'''
        raise NotImplementedError()

    def getTiff(self) -> ImageFormat:
        '''Gets the Tagged Image File Format (TIFF) image format.'''
        raise NotImplementedError()

    def getIcon(self) -> ImageFormat:
        '''Gets the Windows icon image format.'''
        raise NotImplementedError()

    def getExif(self) -> ImageFormat:
        '''Gets the Exchangeable Image File (Exif) format.'''
        raise NotImplementedError()

    def getMemoryBmp(self) -> ImageFormat:
        '''Gets a memory bitmap image format.'''
        raise NotImplementedError()


class ImageOrPrintOptions:
    '''Allows to specify options when rendering worksheet to images, printing worksheet or rendering chart to image.'''

    def setTransparent(self, value : bool) -> None:
        '''Indicates if the background of generated image should be transparent.
        :param value: '''
        raise NotImplementedError()

    def setDrawObjectEventHandler(self, value : DrawObjectEventHandler) -> None:
        '''Implements this interface to get DrawObject and Bound when rendering.
        :param value: '''
        raise NotImplementedError()

    def isCellAutoFit(self) -> bool:
        ''':deprecated: Use Worksheet.AutoFitColumns(AutoFitterOptions) and Worksheet.AutoFitRows(AutoFitterOptions) instead.'''
        raise NotImplementedError()

    def getOutputBlankPageWhenNothingToPrint(self) -> bool:
        '''Indicates whether to output a blank page when there is nothing to print.'''
        raise NotImplementedError()

    def setQuality(self, value : int) -> None:
        '''Sets a value determining the quality of the generated  images
        to apply only when saving pages to the <code>Jpeg</code> format. The default value is 100
        :param value: '''
        raise NotImplementedError()

    def getDefaultEditLanguage(self) -> int:
        '''Gets default edit language.
        See :class:`DefaultEditLanguage`'''
        raise NotImplementedError()

    def setEmfRenderSetting(self, value : int) -> None:
        '''Setting for rendering Emf metafile.
        See :class:`EmfRenderSetting`
        :param value: '''
        raise NotImplementedError()

    def getCheckWorkbookDefaultFont(self) -> bool:
        '''When characters in the Excel are Unicode and not be set with correct font in cell style,
        They may appear as block in pdf,image.
        Set this to true to try to use workbook's default font to show these characters first.'''
        raise NotImplementedError()

    @overload
    def setDesiredSize(self, desiredWidth : int, desiredHeight : int) -> None:
        ''':deprecated: Use SetDesiredSize(int, int, bool) by setting param keepAspectRatio to false instead.'''
        raise NotImplementedError()

    @overload
    def setDesiredSize(self, desiredWidth : int, desiredHeight : int, keepAspectRatio : bool) -> None:
        '''Sets desired width and height of image.
        :param desiredWidth: desired width in pixels
        :param desiredHeight: desired height in pixels
        :param keepAspectRatio: whether to keep aspect ratio of origin image'''
        raise NotImplementedError()

    def getPageIndex(self) -> int:
        '''Gets the 0-based index of the first page to save.'''
        raise NotImplementedError()

    def setOnePagePerSheet(self, value : bool) -> None:
        '''If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
        The paper size of pagesetup will be invalid, and the other settings of pagesetup
        will still take effect.
        :param value: '''
        raise NotImplementedError()

    def getGridlineType(self) -> int:
        '''Gets gridline type.
        See :class:`GridlineType`'''
        raise NotImplementedError()

    def getWarningCallback(self) -> IWarningCallback:
        '''Gets warning callback.'''
        raise NotImplementedError()

    def getAllColumnsInOnePagePerSheet(self) -> bool:
        '''If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
        The width of paper size of pagesetup will be invalid, and the other settings of pagesetup
        will still take effect.'''
        raise NotImplementedError()

    def getHorizontalResolution(self) -> int:
        '''Gets the horizontal resolution for generated images, in dots per inch.'''
        raise NotImplementedError()

    def setTextCrossType(self, value : int) -> None:
        '''Sets displaying text type when the text width is larger than cell width.
        See :class:`TextCrossType`
        :param value: '''
        raise NotImplementedError()

    def setPageSavingCallback(self, value : IPageSavingCallback) -> None:
        '''Control/Indicate progress of page saving process.
        :param value: '''
        raise NotImplementedError()

    def getDefaultFont(self) -> str:
        '''When characters in the Excel are Unicode and not be set with correct font in cell style,
        They may appear as block in pdf,image.
        Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
        If this property is not set, Aspose.Cells will use system default font to show these unicode characters.'''
        raise NotImplementedError()

    def setOptimized(self, value : bool) -> None:
        '''Indicates whether to optimize the output elements.
        :param value: '''
        raise NotImplementedError()

    def setOnlyArea(self, value : bool) -> None:
        '''If this property is true , one Area will be output, and no scale will take effect.
        :param value: '''
        raise NotImplementedError()

    def getEmfRenderSetting(self) -> int:
        '''Setting for rendering Emf metafile.
        See :class:`EmfRenderSetting`'''
        raise NotImplementedError()

    def getTransparent(self) -> bool:
        '''Indicates if the background of generated image should be transparent.'''
        raise NotImplementedError()

    def setHorizontalResolution(self, value : int) -> None:
        '''Sets the horizontal resolution for generated images, in dots per inch.
        :param value: '''
        raise NotImplementedError()

    def getTiffColorDepth(self) -> int:
        '''Gets bit depth to apply only when saving pages to the <code>Tiff</code> format.
        See :class:`ColorDepth`'''
        raise NotImplementedError()

    def getPageCount(self) -> int:
        '''Gets the number of pages to save.'''
        raise NotImplementedError()

    def setVerticalResolution(self, value : int) -> None:
        '''Sets the vertical resolution for generated images, in dots per inch.
        :param value: '''
        raise NotImplementedError()

    def getDrawObjectEventHandler(self) -> DrawObjectEventHandler:
        '''Implements this interface to get DrawObject and Bound when rendering.'''
        raise NotImplementedError()

    def getChartImageType(self) -> ImageFormat:
        ''':deprecated: Chart and Shape are always rendered as vector elements(e.g. point, line) for rendering quality.'''
        raise NotImplementedError()

    def setSVGFitToViewPort(self, value : bool) -> None:
        '''if this property is true, the generated svg will fit to view port.
        :param value: '''
        raise NotImplementedError()

    def isFontSubstitutionCharGranularity(self) -> bool:
        '''Indicates whether to only substitute the font of character when the cell font is not compatibility for it.'''
        raise NotImplementedError()

    def getSaveFormat(self) -> int:
        ''':deprecated: For Tiff/Svg, use ImageType; For Xps, use Workbook.Save(string, SaveOptions) with XpsSaveOptions'''
        raise NotImplementedError()

    def getPrintingPage(self) -> int:
        '''Indicates which pages will not be printed.
        See :class:`PrintingPageType`'''
        raise NotImplementedError()

    def getSVGFitToViewPort(self) -> bool:
        '''if this property is true, the generated svg will fit to view port.'''
        raise NotImplementedError()

    def setWarningCallback(self, value : IWarningCallback) -> None:
        '''Sets warning callback.
        :param value: '''
        raise NotImplementedError()

    def setImageType(self, value : int) -> None:
        '''Sets the format of the generated images.
        default value: PNG.
        See :meth:`ImageOrPrintOptions.getImageType()`
        :param value: '''
        raise NotImplementedError()

    def getSheetSet(self) -> SheetSet:
        '''Gets the sheets to render. Default is all visible sheets in the workbook: :meth:`com.aspose.cells.SheetSet.getVisible()`.'''
        raise NotImplementedError()

    def setGridlineType(self, value : int) -> None:
        '''Sets gridline type.
        See :class:`GridlineType`
        :param value: '''
        raise NotImplementedError()

    def setCheckWorkbookDefaultFont(self, value : bool) -> None:
        '''When characters in the Excel are Unicode and not be set with correct font in cell style,
        They may appear as block in pdf,image.
        Set this to true to try to use workbook's default font to show these characters first.
        :param value: '''
        raise NotImplementedError()

    def getPageSavingCallback(self) -> IPageSavingCallback:
        '''Control/Indicate progress of page saving process.'''
        raise NotImplementedError()

    def getQuality(self) -> int:
        '''Gets a value determining the quality of the generated  images
        to apply only when saving pages to the <code>Jpeg</code> format. The default value is 100'''
        raise NotImplementedError()

    def setPageIndex(self, value : int) -> None:
        '''Sets the 0-based index of the first page to save.
        :param value: '''
        raise NotImplementedError()

    def setAllColumnsInOnePagePerSheet(self, value : bool) -> None:
        '''If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
        The width of paper size of pagesetup will be invalid, and the other settings of pagesetup
        will still take effect.
        :param value: '''
        raise NotImplementedError()

    def getTiffPhotometricInterpretation(self) -> int:
        '''Gets the type of PhotometricInterpretation to apply only when saving pages to the <code>Tiff</code> format.'''
        raise NotImplementedError()

    def getTextCrossType(self) -> int:
        '''Gets displaying text type when the text width is larger than cell width.
        See :class:`TextCrossType`'''
        raise NotImplementedError()

    def setCellAutoFit(self, value : bool) -> None:
        ''':deprecated: Use Worksheet.AutoFitColumns(AutoFitterOptions) and Worksheet.AutoFitRows(AutoFitterOptions) instead.'''
        raise NotImplementedError()

    def setRenderingHint(self, key : Key, value : Object) -> None:
        '''Sets the value of a single preference for the rendering algorithms. Hint categories include controls for rendering quality and overall time/quality trade-off in the rendering process. Refer to the RenderingHints class for definitions of some common keys and values.
        :param key: the key of the hint to be set.
        :param value: the value indicating preferences for the specified hint category.'''
        raise NotImplementedError()

    def setSheetSet(self, value : SheetSet) -> None:
        '''Sets the sheets to render. Default is all visible sheets in the workbook: :meth:`com.aspose.cells.SheetSet.getVisible()`.
        :param value: '''
        raise NotImplementedError()

    def setPrintWithStatusDialog(self, value : bool) -> None:
        '''If PrintWithStatusDialog = true , there will be a dialog that shows current print status.
        else no such dialog will show.
        :param value: '''
        raise NotImplementedError()

    def getVerticalResolution(self) -> int:
        '''Gets the vertical resolution for generated images, in dots per inch.'''
        raise NotImplementedError()

    def setPrintingPage(self, value : int) -> None:
        '''Indicates which pages will not be printed.
        See :class:`PrintingPageType`
        :param value: '''
        raise NotImplementedError()

    def setTiffColorDepth(self, value : int) -> None:
        '''Sets bit depth to apply only when saving pages to the <code>Tiff</code> format.
        See :class:`ColorDepth`
        :param value: '''
        raise NotImplementedError()

    def getTiffCompression(self) -> int:
        '''Gets the type of compression to apply only when saving pages to the <code>Tiff</code> format.
        See :class:`TiffCompression`'''
        raise NotImplementedError()

    def isOptimized(self) -> bool:
        '''Indicates whether to optimize the output elements.'''
        raise NotImplementedError()

    def getPrintWithStatusDialog(self) -> bool:
        '''If PrintWithStatusDialog = true , there will be a dialog that shows current print status.
        else no such dialog will show.'''
        raise NotImplementedError()

    def setSaveFormat(self, value : int) -> None:
        ''':deprecated: For Tiff/Svg, use ImageType; For Xps, use Workbook.Save(string, SaveOptions) with XpsSaveOptions'''
        raise NotImplementedError()

    def setEmbededImageNameInSvg(self, value : str) -> None:
        '''Indicate the filename of embedded image in svg.
        This should be full path with directory like "c:\\xpsEmbedded"
        :param value: '''
        raise NotImplementedError()

    def setPageCount(self, value : int) -> None:
        '''Sets the number of pages to save.
        :param value: '''
        raise NotImplementedError()

    def setChartImageType(self, value : ImageFormat) -> None:
        ''':deprecated: Chart and Shape are always rendered as vector elements(e.g. point, line) for rendering quality.'''
        raise NotImplementedError()

    def setDefaultEditLanguage(self, value : int) -> None:
        '''Sets default edit language.
        See :class:`DefaultEditLanguage`
        :param value: '''
        raise NotImplementedError()

    def getEmbededImageNameInSvg(self) -> str:
        '''Indicate the filename of embedded image in svg.
        This should be full path with directory like "c:\\xpsEmbedded"'''
        raise NotImplementedError()

    def setTiffPhotometricInterpretation(self, value : int) -> None:
        '''Sets the type of PhotometricInterpretation to apply only when saving pages to the <code>Tiff</code> format.
        :param value: '''
        raise NotImplementedError()

    def getOnePagePerSheet(self) -> bool:
        '''If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
        The paper size of pagesetup will be invalid, and the other settings of pagesetup
        will still take effect.'''
        raise NotImplementedError()

    def setFontSubstitutionCharGranularity(self, value : bool) -> None:
        '''Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
        :param value: '''
        raise NotImplementedError()

    def setDefaultFont(self, value : str) -> None:
        '''When characters in the Excel are Unicode and not be set with correct font in cell style,
        They may appear as block in pdf,image.
        Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
        If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
        :param value: '''
        raise NotImplementedError()

    def getImageType(self) -> int:
        '''Gets the format of the generated images.
        default value: PNG.
        See :meth:`ImageOrPrintOptions.getImageType()`'''
        raise NotImplementedError()

    def getOnlyArea(self) -> bool:
        '''If this property is true , one Area will be output, and no scale will take effect.'''
        raise NotImplementedError()

    def setTiffCompression(self, value : int) -> None:
        '''Sets the type of compression to apply only when saving pages to the <code>Tiff</code> format.
        See :class:`TiffCompression`
        :param value: '''
        raise NotImplementedError()

    def setOutputBlankPageWhenNothingToPrint(self, value : bool) -> None:
        '''Indicates whether to output a blank page when there is nothing to print.
        :param value: '''
        raise NotImplementedError()


class ImageSaveOptions:
    '''Represents image save options.
    For advanced usage, please use :class:`WorkbookRender` or :class:`SheetRender`.'''

    def setStreamProvider(self, value : IStreamProvider) -> None:
        '''Sets the IStreamProvider for exporting objects.
        :param value: '''
        raise NotImplementedError()

    def getStreamProvider(self) -> IStreamProvider:
        '''Gets the IStreamProvider for exporting objects.'''
        raise NotImplementedError()

    def getImageOrPrintOptions(self) -> ImageOrPrintOptions:
        '''Additional image creation options.'''
        raise NotImplementedError()


class ImageType:
    '''Specifies the type (format) of an image.'''

    UNKNOWN : ImageType
    '''An unknown image type.'''

    EMF : ImageType
    '''Windows Enhanced Metafile.'''

    WMF : ImageType
    '''Windows Metafile.'''

    PICT : ImageType
    '''Macintosh PICT.'''

    JPEG : ImageType
    '''JPEG JFIF.'''

    PNG : ImageType
    '''Portable Network Graphics.'''

    BMP : ImageType
    '''Windows Bitmap'''

    GIF : ImageType
    '''Gif'''

    TIFF : ImageType
    '''Tiff'''

    SVG : ImageType
    '''Svg'''

    SVM : ImageType
    '''Svm'''

    GLTF : ImageType
    '''glTF'''

    OFFICE_COMPATIBLE_EMF : ImageType
    '''Windows Enhanced Metafile which is more compatible with Office.'''

    WEB_P : ImageType
    '''Weppy image format'''




class ImportTableOptions:
    '''Represents the options of importing data into cells.'''

    def getShiftFirstRowDown(self) -> bool:
        '''Indicates whether shifting the first row down when inserting rows.'''
        raise NotImplementedError()

    def setColumnIndexes(self, value : list[int]) -> None:
        '''Sets the columns(0-based) to import from data source. null means all columns should be imported.
        :param value: '''
        raise NotImplementedError()

    def setDateFormat(self, value : str) -> None:
        '''Sets date format string for cells with imported datetime values.
        :param value: '''
        raise NotImplementedError()

    def setNumberFormats(self, value : list[str]) -> None:
        '''Sets the number formats
        :param value: '''
        raise NotImplementedError()

    def setTotalRows(self, value : int) -> None:
        '''Sets total row count to import from data source. -1 means all rows of given data source.
        :param value: '''
        raise NotImplementedError()

    def getDefaultValues(self) -> list[Object]:
        '''Default value for the value in the table is null.'''
        raise NotImplementedError()

    def getInsertRows(self) -> bool:
        '''Indicates whether new rows should be added for importing data records.'''
        raise NotImplementedError()

    def setExportCaptionAsFieldName(self, value : bool) -> None:
        '''Indicates whether exporting caption as field name
        :param value: '''
        raise NotImplementedError()

    def getConvertNumericData(self) -> bool:
        '''Gets a value that indicates whether the string value should be converted to numeric or date value.'''
        raise NotImplementedError()

    def setShiftFirstRowDown(self, value : bool) -> None:
        '''Indicates whether shifting the first row down when inserting rows.
        :param value: '''
        raise NotImplementedError()

    def setFormulas(self, value : list[bool]) -> None:
        '''Indicates whether the data are formulas.
        :param value: '''
        raise NotImplementedError()

    def setInsertRows(self, value : bool) -> None:
        '''Indicates whether new rows should be added for importing data records.
        :param value: '''
        raise NotImplementedError()

    def setFieldNameShown(self, value : bool) -> None:
        '''Indicates whether field name should be imported.
        :param value: '''
        raise NotImplementedError()

    def setCheckMergedCells(self, value : bool) -> None:
        '''Indicates whether checking merged cells.
        :param value: '''
        raise NotImplementedError()

    def getExportCaptionAsFieldName(self) -> bool:
        '''Indicates whether exporting caption as field name'''
        raise NotImplementedError()

    def getDateFormat(self) -> str:
        '''Gets date format string for cells with imported datetime values.'''
        raise NotImplementedError()

    def setTotalColumns(self, value : int) -> None:
        '''Sets total column count to import from data source. -1 means all rows of given data source.
        :param value: '''
        raise NotImplementedError()

    def setConvertNumericData(self, value : bool) -> None:
        '''Sets a value that indicates whether the string value should be converted to numeric or date value.
        :param value: '''
        raise NotImplementedError()

    def isFormulas(self) -> list[bool]:
        '''Indicates whether the data are formulas.'''
        raise NotImplementedError()

    def setHtmlString(self, value : bool) -> None:
        '''Indicates whether the value contains html tags.
        :param value: '''
        raise NotImplementedError()

    def getTotalRows(self) -> int:
        '''Gets total row count to import from data source. -1 means all rows of given data source.'''
        raise NotImplementedError()

    def getConvertGridStyle(self) -> bool:
        '''Indicates whether apply the style of the grid view to cells.'''
        raise NotImplementedError()

    def isFieldNameShown(self) -> bool:
        '''Indicates whether field name should be imported.'''
        raise NotImplementedError()

    def isHtmlString(self) -> bool:
        '''Indicates whether the value contains html tags.'''
        raise NotImplementedError()

    def getTotalColumns(self) -> int:
        '''Gets total column count to import from data source. -1 means all rows of given data source.'''
        raise NotImplementedError()

    def setDefaultValues(self, value : list[Object]) -> None:
        '''Default value for the value in the table is null.
        :param value: '''
        raise NotImplementedError()

    def setConvertGridStyle(self, value : bool) -> None:
        '''Indicates whether apply the style of the grid view to cells.
        :param value: '''
        raise NotImplementedError()

    def getCheckMergedCells(self) -> bool:
        '''Indicates whether checking merged cells.'''
        raise NotImplementedError()

    def getColumnIndexes(self) -> list[int]:
        '''Gets the columns(0-based) to import from data source. null means all columns should be imported.'''
        raise NotImplementedError()

    def getNumberFormats(self) -> list[str]:
        '''Gets the number formats'''
        raise NotImplementedError()


class IndividualFontConfigs:
    '''Font configs for each :class:`Workbook` object.'''

    def setFontFolders(self, fontFolders : list[str], recursive : bool) -> None:
        '''Sets the fonts folders
        :param fontFolders: The folders that contains TrueType fonts.
        :param recursive: Determines whether or not to scan subfolders.'''
        raise NotImplementedError()

    def setFontExclusiveSources(self, exclusiveSources : list[FontSourceBase]) -> None:
        '''Sets the fonts exclusive sources. Only fonts in the sources will be used.
        :param exclusiveSources: An array of sources that contain TrueType fonts.'''
        raise NotImplementedError()

    def getFontSources(self) -> list[FontSourceBase]:
        '''Gets a copy of the array that contains the list of sources'''
        raise NotImplementedError()

    def setFontSources(self, sources : list[FontSourceBase]) -> None:
        '''Sets the fonts sources.
        :param sources: An array of sources that contain TrueType fonts.'''
        raise NotImplementedError()

    def getFontSubstitutes(self, originalFontName : str) -> list[str]:
        '''Returns array containing font substitute names to be used if original font is not presented.
        :param originalFontName: originalFontName
        :returns: An array containing font substitute names to be used if original font is not presented.'''
        raise NotImplementedError()

    def setFontFolder(self, fontFolder : str, recursive : bool) -> None:
        '''Sets the fonts folder
        :param fontFolder: The folder that contains TrueType fonts.
        :param recursive: Determines whether or not to scan subfolders.'''
        raise NotImplementedError()

    def setFontSubstitutes(self, originalFontName : str, substituteFontNames : list[str]) -> None:
        '''Font substitute names for given original font name.
        :param originalFontName: Original font name.
        :param substituteFontNames: List of font substitute names to be used if original font is not presented.'''
        raise NotImplementedError()


class InputMethodEditorMode:
    '''Represents the default run-time mode of the Input Method Editor.'''

    NO_CONTROL : InputMethodEditorMode
    '''Does not control IME.'''

    ON : InputMethodEditorMode
    '''IME on.'''

    OFF : InputMethodEditorMode
    '''IME off. English mode.'''

    DISABLE : InputMethodEditorMode
    '''IME off.User can't turn on IME by keyboard.'''

    HIRAGANA : InputMethodEditorMode
    '''IME on with Full-width hiragana mode.'''

    KATAKANA : InputMethodEditorMode
    '''IME on with Full-width katakana mode.'''

    KATAKANA_HALF : InputMethodEditorMode
    '''IME on with Half-width katakana mode.'''

    ALPHA_FULL : InputMethodEditorMode
    '''IME on with Full-width Alphanumeric mode.'''

    ALPHA : InputMethodEditorMode
    '''IME on with Half-width Alphanumeric mode.'''

    HANGUL_FULL : InputMethodEditorMode
    '''IME on with Full-width hangul mode.'''

    HANGUL : InputMethodEditorMode
    '''IME on with Half-width hangul mode.'''

    HANZI_FULL : InputMethodEditorMode
    '''IME on with Full-width hanzi mode.'''

    HANZI : InputMethodEditorMode
    '''IME on with Half-width hanzi mode.'''


class InsertOptions:
    '''Represents the options of inserting.'''

    def setFormulaChangeMonitor(self, value : AbstractFormulaChangeMonitor) -> None:
        '''Sets the monitor for tracking changes caused by the insertion.
        :param value: '''
        raise NotImplementedError()

    def getFormulaChangeMonitor(self) -> AbstractFormulaChangeMonitor:
        '''Gets the monitor for tracking changes caused by the insertion.'''
        raise NotImplementedError()

    def setCopyFormatType(self, value : int) -> None:
        '''See :class:`CopyFormatType`
        :param value: '''
        raise NotImplementedError()

    def setUpdateReference(self, value : bool) -> None:
        '''Indicates if references in other worksheets will be updated.
        :param value: '''
        raise NotImplementedError()

    def getUpdateReference(self) -> bool:
        '''Indicates if references in other worksheets will be updated.'''
        raise NotImplementedError()

    def getCopyFormatType(self) -> int:
        '''See :class:`CopyFormatType`'''
        raise NotImplementedError()


class InterruptMonitor:
    '''Represents all operator about the interrupt.'''

    def isInterruptionRequested(self) -> bool:
        '''Mark the monitor as requesting interruption'''
        raise NotImplementedError()

    def interrupt(self) -> None:
        '''Interrupt the current operator.'''
        raise NotImplementedError()



class IPageSavingCallback:
    '''Control/Indicate progress of page saving process.'''

    def pageStartSaving(self, args : PageStartSavingArgs) -> None:
        '''Control/Indicate a page starts to be output.
        :param args: Info for a page starts saving process.'''
        raise NotImplementedError()

    def pageEndSaving(self, args : PageEndSavingArgs) -> None:
        '''Control/Indicate a page ends to be output.
        :param args: Info for a page ends saving process.'''
        raise NotImplementedError()
















class ISmartMarkerCallBack:
    '''Represents callback interface of processing smartmarker.'''

    def process(self, sheetIndex : int, rowIndex : int, colIndex : int, tableName : str, columnName : str) -> None:
        '''Callback for processing a smart marker.
        :param sheetIndex: The sheet index.
        :param rowIndex: The row index.
        :param colIndex: The column index.
        :param tableName: The table name of smartmarker.
        :param columnName: The table name of smartmarker.'''
        raise NotImplementedError()





class IStreamProvider:
    '''Represents the exported stream provider.'''

    def closeStream(self, options : StreamProviderOptions) -> None:
        '''Closes the stream.
        :param options: '''
        raise NotImplementedError()

    def initStream(self, options : StreamProviderOptions) -> None:
        '''Gets the stream.
        :param options: '''
        raise NotImplementedError()













class IWarningCallback:
    '''Callback interface of warning.'''

    def warning(self, warningInfo : WarningInfo) -> None:
        '''Our callback only needs to implement the "Warning" method.
        :param warningInfo: warning info'''
        raise NotImplementedError()




class JsonExportHyperlinkType:
    '''Represents type of exporting hyperlinks to json.'''

    DISPLAY_STRING : JsonExportHyperlinkType
    '''Export display string'''

    ADDRESS : JsonExportHyperlinkType
    '''Export url'''

    HTML_STRING : JsonExportHyperlinkType
    '''Export as html string.'''


class JsonLayoutOptions:
    '''Represents the options of json layout type.'''

    def getTitleStyle(self) -> Style:
        '''Gets the style of the title.'''
        raise NotImplementedError()

    def getKeptSchema(self) -> bool:
        '''Indicates whether keeping schema of this json.'''
        raise NotImplementedError()

    def setDateFormat(self, value : str) -> None:
        '''Sets the format of date value.
        :param value: '''
        raise NotImplementedError()

    def setIgnoreTitle(self, value : bool) -> None:
        '''Ingores titles of attributes
        :param value: '''
        raise NotImplementedError()

    def setConvertNumericOrDate(self, value : bool) -> None:
        '''Indicates whether converting the string in json to numeric or date value.
        :param value: '''
        raise NotImplementedError()

    def getIgnoreObjectTitle(self) -> bool:
        ''':deprecated: Use JsonLayoutOptions.IgnoreTitle property instead.'''
        raise NotImplementedError()

    def setTitleStyle(self, value : Style) -> None:
        '''Sets the style of the title.
        :param value: '''
        raise NotImplementedError()

    def setKeptSchema(self, value : bool) -> None:
        '''Indicates whether keeping schema of this json.
        :param value: '''
        raise NotImplementedError()

    def getArrayAsTable(self) -> bool:
        '''Processes Array as table.'''
        raise NotImplementedError()

    def getIgnoreArrayTitle(self) -> bool:
        ''':deprecated: Use JsonLayoutOptions.IgnoreTitle property instead.'''
        raise NotImplementedError()

    def setArrayAsTable(self, value : bool) -> None:
        '''Processes Array as table.
        :param value: '''
        raise NotImplementedError()

    def setNumberFormat(self, value : str) -> None:
        '''Sets the format of numeric value.
        :param value: '''
        raise NotImplementedError()

    def setIgnoreArrayTitle(self, value : bool) -> None:
        ''':deprecated: Use JsonLayoutOptions.IgnoreTitle property instead.'''
        raise NotImplementedError()

    def getDateFormat(self) -> str:
        '''Gets the format of date value.'''
        raise NotImplementedError()

    def getIgnoreTitle(self) -> bool:
        '''Ingores titles of attributes'''
        raise NotImplementedError()

    def getIgnoreNull(self) -> bool:
        '''Indicates whether ignoring null value.'''
        raise NotImplementedError()

    def getNumberFormat(self) -> str:
        '''Gets the format of numeric value.'''
        raise NotImplementedError()

    def setIgnoreNull(self, value : bool) -> None:
        '''Indicates whether ignoring null value.
        :param value: '''
        raise NotImplementedError()

    def getConvertNumericOrDate(self) -> bool:
        '''Indicates whether converting the string in json to numeric or date value.'''
        raise NotImplementedError()

    def setIgnoreObjectTitle(self, value : bool) -> None:
        ''':deprecated: Use JsonLayoutOptions.IgnoreTitle property instead.'''
        raise NotImplementedError()


class JsonLoadOptions:
    '''Represents the options of loading json files'''

    def setLayoutOptions(self, value : JsonLayoutOptions) -> None:
        '''The options of import json.
        :param value: '''
        raise NotImplementedError()

    def getStartCell(self) -> str:
        '''Gets the start cell.'''
        raise NotImplementedError()

    def getKeptSchema(self) -> bool:
        '''Indicates whether keeping schema of this json.'''
        raise NotImplementedError()

    def getLayoutOptions(self) -> JsonLayoutOptions:
        '''The options of import json.'''
        raise NotImplementedError()

    def setMultipleWorksheets(self, value : bool) -> None:
        '''Indicates whether importing each attribute of JsonObject object as one worksheet when all child nodes are array nodes.
        :param value: '''
        raise NotImplementedError()

    def getMultipleWorksheets(self) -> bool:
        '''Indicates whether importing each attribute of JsonObject object as one worksheet when all child nodes are array nodes.'''
        raise NotImplementedError()

    def setStartCell(self, value : str) -> None:
        '''Sets the start cell.
        :param value: '''
        raise NotImplementedError()

    def setKeptSchema(self, value : bool) -> None:
        '''Indicates whether keeping schema of this json.
        :param value: '''
        raise NotImplementedError()


class JsonSaveOptions:
    '''Represents the options of saving the workbook as a json file.'''

    def setSheetIndexes(self, value : list[int]) -> None:
        '''Represents the indexes of exported sheets.
        :param value: '''
        raise NotImplementedError()

    def hasHeaderRow(self) -> bool:
        '''Indicates whether the range contains header row.'''
        raise NotImplementedError()

    def getExportHyperlinkType(self) -> int:
        '''Represents the type of exporting hyperlink to json.
        See :class:`JsonExportHyperlinkType`'''
        raise NotImplementedError()

    def setIndent(self, value : str) -> None:
        '''Indicates the indent.
        :param value: '''
        raise NotImplementedError()

    def getSkipEmptyRows(self) -> bool:
        '''Indicates whether skipping emtpy rows.'''
        raise NotImplementedError()

    def getSheetIndexes(self) -> list[int]:
        '''Represents the indexes of exported sheets.'''
        raise NotImplementedError()

    def setExportArea(self, value : CellArea) -> None:
        '''Sets the exporting range.
        :param value: '''
        raise NotImplementedError()

    def setAlwaysExportAsJsonObject(self, value : bool) -> None:
        '''Indicates whether always exporting excel to json as object, even there is only a worksheet in the file.
        :param value: '''
        raise NotImplementedError()

    def setSchemas(self, value : list[str]) -> None:
        '''The original json schema of each worksheet.
        :param value: '''
        raise NotImplementedError()

    def getToExcelStruct(self) -> bool:
        '''Indicates whether converting to json struct of the Excel file.'''
        raise NotImplementedError()

    def getIndent(self) -> str:
        '''Indicates the indent.'''
        raise NotImplementedError()

    def setSkipEmptyRows(self, value : bool) -> None:
        '''Indicates whether skipping emtpy rows.
        :param value: '''
        raise NotImplementedError()

    def getExportAsString(self) -> bool:
        '''Exports the string value of the cells to json.'''
        raise NotImplementedError()

    def getExportEmptyCells(self) -> bool:
        '''Indicates whether exporting empty cells as null.'''
        raise NotImplementedError()

    def getAlwaysExportAsJsonObject(self) -> bool:
        '''Indicates whether always exporting excel to json as object, even there is only a worksheet in the file.'''
        raise NotImplementedError()

    def setToExcelStruct(self, value : bool) -> None:
        '''Indicates whether converting to json struct of the Excel file.
        :param value: '''
        raise NotImplementedError()

    def setExportEmptyCells(self, value : bool) -> None:
        '''Indicates whether exporting empty cells as null.
        :param value: '''
        raise NotImplementedError()

    def getExportArea(self) -> CellArea:
        '''Gets the exporting range.'''
        raise NotImplementedError()

    def setHasHeaderRow(self, value : bool) -> None:
        '''Indicates whether the range contains header row.
        :param value: '''
        raise NotImplementedError()

    def getExportNestedStructure(self) -> bool:
        '''Exported as parent-child hierarchy Json structure.'''
        raise NotImplementedError()

    def setExportNestedStructure(self, value : bool) -> None:
        '''Exported as parent-child hierarchy Json structure.
        :param value: '''
        raise NotImplementedError()

    def setExportHyperlinkType(self, value : int) -> None:
        '''Represents the type of exporting hyperlink to json.
        See :class:`JsonExportHyperlinkType`
        :param value: '''
        raise NotImplementedError()

    def getSchemas(self) -> list[str]:
        '''The original json schema of each worksheet.'''
        raise NotImplementedError()

    def setExportAsString(self, value : bool) -> None:
        '''Exports the string value of the cells to json.
        :param value: '''
        raise NotImplementedError()


class JsonUtility:
    '''Represents the utility class of processing json.'''

    def importData(self, json : str, cells : Cells, row : int, column : int, option : JsonLayoutOptions) -> list[int]:
        '''Import the json string.
        :param json: The json string.
        :param cells: The Cells.
        :param row: The row index.
        :param column: The column index.
        :param option: The options of import json string.'''
        raise NotImplementedError()

    @overload
    def exportRangeToJson(self, range : Range, options : ExportRangeToJsonOptions) -> str:
        ''':deprecated: Use ExportRangeToJson(Range range, JsonSaveOptions options) method instead.'''
        raise NotImplementedError()

    @overload
    def exportRangeToJson(self, range : Range, options : JsonSaveOptions) -> str:
        '''Exporting the range to json file.
        :param range: The range.
        :param options: The options of exporting.
        :returns: The json string value.'''
        raise NotImplementedError()


class Label:
    '''Encapsulates the object that represents a label in a spreadsheet.'''


class LabelActiveXControl:
    '''Represents the label ActiveX control.'''

    def setPicturePosition(self, value : int) -> None:
        '''Sets the location of the control's picture relative to its caption.
        See :class:`ControlPicturePositionType`
        :param value: '''
        raise NotImplementedError()

    def setBorderOleColor(self, value : int) -> None:
        '''Sets the ole color of the background.
        :param value: '''
        raise NotImplementedError()

    def getAccelerator(self) -> str:
        '''Gets the accelerator key for the control.'''
        raise NotImplementedError()

    def getBorderStyle(self) -> int:
        '''Gets the type of border used by the control.
        See :class:`ControlBorderType`'''
        raise NotImplementedError()

    def getPicturePosition(self) -> int:
        '''Gets the location of the control's picture relative to its caption.
        See :class:`ControlPicturePositionType`'''
        raise NotImplementedError()

    def setPicture(self, value : list[int]) -> None:
        '''Sets the data of the picture.
        :param value: '''
        raise NotImplementedError()

    def getPicture(self) -> list[int]:
        '''Gets the data of the picture.'''
        raise NotImplementedError()

    def getSpecialEffect(self) -> int:
        '''Gets the special effect of the control.
        See :class:`ControlSpecialEffectType`'''
        raise NotImplementedError()

    def getBorderOleColor(self) -> int:
        '''Gets the ole color of the background.'''
        raise NotImplementedError()

    def setSpecialEffect(self, value : int) -> None:
        '''Sets the special effect of the control.
        See :class:`ControlSpecialEffectType`
        :param value: '''
        raise NotImplementedError()

    def setCaption(self, value : str) -> None:
        '''Sets the descriptive text that appears on a control.
        :param value: '''
        raise NotImplementedError()

    def getCaption(self) -> str:
        '''Gets the descriptive text that appears on a control.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()

    def setAccelerator(self, value : str) -> None:
        '''Sets the accelerator key for the control.
        :param value: '''
        raise NotImplementedError()

    def setBorderStyle(self, value : int) -> None:
        '''Sets the type of border used by the control.
        See :class:`ControlBorderType`
        :param value: '''
        raise NotImplementedError()

    def setWordWrapped(self, value : bool) -> None:
        '''Indicates whether the contents of the control automatically wrap at the end of a line.
        :param value: '''
        raise NotImplementedError()

    def isWordWrapped(self) -> bool:
        '''Indicates whether the contents of the control automatically wrap at the end of a line.'''
        raise NotImplementedError()


class LabelPositionType:
    '''Represents data label position type.'''

    CENTER : LabelPositionType
    '''Applies only to bar, 2d/3d pie charts'''

    INSIDE_BASE : LabelPositionType
    '''Applies only to bar, 2d/3d pie charts'''

    INSIDE_END : LabelPositionType
    '''Applies only to bar charts'''

    OUTSIDE_END : LabelPositionType
    '''Applies only to bar, 2d/3d pie charts'''

    ABOVE : LabelPositionType
    '''Applies only to line charts'''

    BELOW : LabelPositionType
    '''Applies only to line charts'''

    LEFT : LabelPositionType
    '''Applies only to line charts'''

    RIGHT : LabelPositionType
    '''Applies only to line charts'''

    BEST_FIT : LabelPositionType
    '''Applies only to 2d/3d pie charts'''

    MOVED : LabelPositionType
    '''User moved the data labels, Only for reading chart from template file.'''


class Legend:
    '''Encapsulates the object that represents the chart legend.'''

    def setPosition(self, value : int) -> None:
        '''Sets the legend position type.
        See :class:`LegendPositionType`
        :param value: '''
        raise NotImplementedError()

    def isOverLay(self) -> bool:
        '''Gets whether showing the legend without overlapping the chart.'''
        raise NotImplementedError()

    def getLegendEntriesLabels(self) -> list:
        ''':deprecated: Use Legend.GetLegendLabels method, instead.'''
        raise NotImplementedError()

    def getLegendEntries(self) -> LegendEntryCollection:
        '''Gets a collection of all the LegendEntry objects in the specified chart legend.
        Setting the legend entries of the surface chart is not supported.
        So it will return null if the chart type is surface chart type.'''
        raise NotImplementedError()

    def getPosition(self) -> int:
        '''Gets the legend position type.
        See :class:`LegendPositionType`'''
        raise NotImplementedError()

    def setOverLay(self, value : bool) -> None:
        '''Sets whether showing the legend without overlapping the chart.
        :param value: '''
        raise NotImplementedError()

    def getLegendLabels(self) -> list[str]:
        '''Gets the labels of the legend entries after call Chart.Calculate() method.'''
        raise NotImplementedError()


class LegendEntry:
    '''Represents a legend entry in a chart legend.'''

    def getBackgroundMode(self) -> int:
        '''Gets the display mode of the background
        See :class:`BackgroundMode`'''
        raise NotImplementedError()

    def setDeleted(self, value : bool) -> None:
        '''Sets whether the legend entry is deleted.
        :param value: '''
        raise NotImplementedError()

    def getAutoScaleFont(self) -> bool:
        '''True if the text in the object changes font size when the object size changes.
        The default value is True.'''
        raise NotImplementedError()

    def getFont(self) -> Font:
        '''Gets a :meth:`ChartArea.getFont()` object of the specified ChartFrame object.'''
        raise NotImplementedError()

    def setTextNoFill(self, value : bool) -> None:
        '''Sets no fill of the text.
        :param value: '''
        raise NotImplementedError()

    def setBackgroundMode(self, value : int) -> None:
        '''Sets the display mode of the background
        See :class:`BackgroundMode`
        :param value: '''
        raise NotImplementedError()

    def getBackground(self) -> int:
        ''':deprecated: Use LegendEntry.BackgroundMode property instead.'''
        raise NotImplementedError()

    def isDeleted(self) -> bool:
        '''Gets whether the legend entry is deleted.'''
        raise NotImplementedError()

    def getTextFont(self) -> Font:
        ''':deprecated: Use LegendEntry.Font property instead.'''
        raise NotImplementedError()

    def setBackground(self, value : int) -> None:
        ''':deprecated: Use LegendEntry.BackgroundMode property instead.'''
        raise NotImplementedError()

    def isTextNoFill(self) -> bool:
        '''Gets no fill of the text.'''
        raise NotImplementedError()

    def setAutoScaleFont(self, value : bool) -> None:
        '''True if the text in the object changes font size when the object size changes.
        The default value is True.
        :param value: '''
        raise NotImplementedError()


class LegendEntryCollection:
    '''Represents a collection of all the :class:`LegendEntry` objects in the specified chart legend.'''

    def get(self, index : int) -> LegendEntry:
        '''Gets the :class:`LegendEntry` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()


class LegendPositionType:
    '''Enumerates the legend position types.'''

    BOTTOM : LegendPositionType
    '''Displays the legend to the bottom of the chart's plot area.'''

    CORNER : LegendPositionType
    '''Displays the legend to the corner of the chart's plot area.'''

    LEFT : LegendPositionType
    '''Displays the legend to the left of the chart's plot area.'''

    NOT_DOCKED : LegendPositionType
    '''Represents that the legend is not docked.'''

    RIGHT : LegendPositionType
    '''Displays the legend to the right of the chart's plot area.'''

    TOP : LegendPositionType
    '''Displays the legend to the top of the chart's plot area.'''


class License:
    '''Provides methods to license the component.'''

    @overload
    def setLicense(self, licenseName : str) -> None:
        '''Licenses the component.
        :param licenseName: '''
        raise NotImplementedError()

    @overload
    def setLicense(self, stream : java.io.InputStream) -> None:
        '''Licenses the component.
        :param stream: A stream that contains the license.'''
        raise NotImplementedError()


class LightCellsDataHandler:
    '''Represents cells data handler for reading large spreadsheet files in light weight mode.'''

    def startRow(self, rowIndex : int) -> bool:
        '''Prepares to process a row.
        :param rowIndex: the index of next row to be processed
        :returns: whether this row(properties or cells data) needs to be processed. false to ignore this row and its cells and check the next row.'''
        raise NotImplementedError()

    def processCell(self, cell : Cell) -> bool:
        '''Starts to process one cell.
        :param cell: 
        :returns: whether this cell needs to be kept in cells model of current sheet. Commonly it should be false so that all cells will not be kept in memory after being processed and then memory be saved. For some special purpose such as user needs to access some cells later after the whole workbook having been processed, user can make this method return true to keep those special cells in Cells model and access them later by APIs such as Cells[row, column]. However, keeping cells data in Cells model will requires more memory and if all cells are kept then reading template file in LightCells mode will become same with reading it in normal way.'''
        raise NotImplementedError()

    def startCell(self, columnIndex : int) -> bool:
        '''Prepares to process a cell.
        :param columnIndex: column index of the cell to be processed
        :returns: whether this cell needs to be processed. false to ignore the cell and check the next one until reach the end of cells data of current row'''
        raise NotImplementedError()

    def processRow(self, row : Row) -> bool:
        '''Starts to process one row.
        :param row: 
        :returns: whether this row's cells need to be processed. false to ignore all cells in this row.'''
        raise NotImplementedError()

    def startSheet(self, sheet : Worksheet) -> bool:
        '''Starts to process a worksheet.
        :param sheet: the worksheet to read cells data.
        :returns: whether this sheet's cells data needs to be processed. false to ignore this sheet.'''
        raise NotImplementedError()


class LightCellsDataProvider:
    '''Represents Data provider for saving large spreadsheet files in light weight mode.'''

    def startRow(self, row : Row) -> None:
        '''Starts to save data of one row.
        :param row: '''
        raise NotImplementedError()

    def nextCell(self) -> int:
        '''Gets next cell to be saved.'''
        raise NotImplementedError()

    def nextRow(self) -> int:
        '''Gets the next row to be saved.'''
        raise NotImplementedError()

    def startCell(self, cell : Cell) -> None:
        '''Starts to save data of one cell.
        :param cell: '''
        raise NotImplementedError()

    def isGatherString(self) -> bool:
        '''Checks whether the current string value of cell needs to be gathered into a global pool.'''
        raise NotImplementedError()

    def startSheet(self, sheetIndex : int) -> bool:
        '''Starts to save a worksheet.
        :param sheetIndex: index of current sheet to be saved.
        :returns: true if this provider will provide data for the given sheet; false if given sheet should use its normal data model(Cells).'''
        raise NotImplementedError()


class LightRigDirectionType:
    '''Represents the light rig direction type.'''

    BOTTOM : LightRigDirectionType
    '''Bottom'''

    BOTTOM_LEFT : LightRigDirectionType
    '''Bottom left.'''

    BOTTOM_RIGHT : LightRigDirectionType
    '''Bottom Right.'''

    LEFT : LightRigDirectionType
    '''Left.'''

    RIGHT : LightRigDirectionType
    '''Right.'''

    TOP : LightRigDirectionType
    '''Top.'''

    TOP_LEFT : LightRigDirectionType
    '''Top left.'''

    TOP_RIGHT : LightRigDirectionType
    '''Top Right.'''


class LightRigType:
    '''Represents a preset light right that can be applied to a shape'''

    BALANCED : LightRigType
    '''Balanced'''

    BRIGHT_ROOM : LightRigType
    '''Bright room'''

    CHILLY : LightRigType
    '''Chilly'''

    CONTRASTING : LightRigType
    '''Contrasting'''

    FLAT : LightRigType
    '''Flat'''

    FLOOD : LightRigType
    '''Flood'''

    FREEZING : LightRigType
    '''Freezing'''

    GLOW : LightRigType
    '''Glow'''

    HARSH : LightRigType
    '''Harsh'''

    LEGACY_FLAT_1 : LightRigType
    '''LegacyFlat1'''

    LEGACY_FLAT_2 : LightRigType
    '''LegacyFlat2'''

    LEGACY_FLAT_3 : LightRigType
    '''LegacyFlat3'''

    LEGACY_FLAT_4 : LightRigType
    '''LegacyFlat4'''

    LEGACY_HARSH_1 : LightRigType
    '''LegacyHarsh1'''

    LEGACY_HARSH_2 : LightRigType
    '''LegacyHarsh2'''

    LEGACY_HARSH_3 : LightRigType
    '''LegacyHarsh3'''

    LEGACY_HARSH_4 : LightRigType
    '''LegacyHarsh4'''

    LEGACY_NORMAL_1 : LightRigType
    '''LegacyNormal1'''

    LEGACY_NORMAL_2 : LightRigType
    '''LegacyNormal2'''

    LEGACY_NORMAL_3 : LightRigType
    '''LegacyNormal3'''

    LEGACY_NORMAL_4 : LightRigType
    '''LegacyNormal4'''

    MORNING : LightRigType
    '''Morning'''

    SOFT : LightRigType
    '''Soft'''

    SUNRISE : LightRigType
    '''Sunrise'''

    SUNSET : LightRigType
    '''Sunset'''

    THREE_POINT : LightRigType
    '''Three point'''

    TWO_POINT : LightRigType
    '''Two point'''

    NONE : LightRigType
    '''No light rig.'''


class LimLowUppEquationNode:
    '''This class specifies the limit function.'''

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class Line:
    '''Encapsulates the object that represents the line format.'''

    def setThemeColor(self, value : ThemeColor) -> None:
        '''Sets the theme color.
        :param value: '''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Represents whether the line is visible.'''
        raise NotImplementedError()

    def getEndArrowWidth(self) -> int:
        '''Specifies the width of the arrowhead for the end of a line.
        See :class:`MsoArrowheadWidth`'''
        raise NotImplementedError()

    def getCompoundType(self) -> int:
        '''Specifies the compound line type
        See :class:`MsoLineStyle`'''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Returns or sets the degree of transparency of the line as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()

    def isAutomaticColor(self) -> bool:
        '''Indicates whether the color of line is automatic assigned.'''
        raise NotImplementedError()

    def getWeightPx(self) -> int:
        '''Gets the weight of the line in unit of pixels.'''
        raise NotImplementedError()

    def getWeight(self) -> int:
        '''Gets the :class:`WeightType` of the line.
        See :class:`WeightType`'''
        raise NotImplementedError()

    def setVisible(self, value : bool) -> None:
        '''Represents whether the line is visible.
        :param value: '''
        raise NotImplementedError()

    def getWeightPt(self) -> int:
        '''Gets the weight of the line in unit of points.'''
        raise NotImplementedError()

    def setBeginType(self, value : int) -> None:
        '''Specifies an arrowhead for the begin of a line.
        See :class:`MsoArrowheadStyle`
        :param value: '''
        raise NotImplementedError()

    def getJoinType(self) -> int:
        '''Specifies the joining caps.
        See :class:`LineJoinType`'''
        raise NotImplementedError()

    def setEndType(self, value : int) -> None:
        '''Specifies an arrowhead for the end of a line.
        See :class:`MsoArrowheadStyle`
        :param value: '''
        raise NotImplementedError()

    def getFormattingType(self) -> int:
        '''Gets format type.
        See :class:`ChartLineFormattingType`'''
        raise NotImplementedError()

    def setColor(self, value : Color) -> None:
        '''Represents the :class:`Color` of the line.
        :param value: '''
        raise NotImplementedError()

    def setCapType(self, value : int) -> None:
        '''Specifies the ending caps.
        See :class:`LineCapType`
        :param value: '''
        raise NotImplementedError()

    def getGradientFill(self) -> GradientFill:
        '''Represents gradient fill.'''
        raise NotImplementedError()

    def setEndArrowLength(self, value : int) -> None:
        '''Specifies the length of the arrowhead for the end of a line.
        See :class:`MsoArrowheadLength`
        :param value: '''
        raise NotImplementedError()

    def setCompoundType(self, value : int) -> None:
        '''Specifies the compound line type
        See :class:`MsoLineStyle`
        :param value: '''
        raise NotImplementedError()

    def setWeight(self, value : int) -> None:
        '''Sets the :class:`WeightType` of the line.
        See :class:`WeightType`
        :param value: '''
        raise NotImplementedError()

    def getColor(self) -> Color:
        '''Represents the :class:`Color` of the line.'''
        raise NotImplementedError()

    def getBeginArrowWidth(self) -> int:
        '''Specifies the width of the arrowhead for the begin of a line.
        See :class:`MsoArrowheadWidth`'''
        raise NotImplementedError()

    def setWeightPx(self, value : int) -> None:
        '''Sets the weight of the line in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def setWeightPt(self, value : int) -> None:
        '''Sets the weight of the line in unit of points.
        :param value: '''
        raise NotImplementedError()

    def setEndArrowWidth(self, value : int) -> None:
        '''Specifies the width of the arrowhead for the end of a line.
        See :class:`MsoArrowheadWidth`
        :param value: '''
        raise NotImplementedError()

    def getThemeColor(self) -> ThemeColor:
        '''Gets the theme color.'''
        raise NotImplementedError()

    def setJoinType(self, value : int) -> None:
        '''Specifies the joining caps.
        See :class:`LineJoinType`
        :param value: '''
        raise NotImplementedError()

    def setTransparency(self, value : int) -> None:
        '''Returns or sets the degree of transparency of the line as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def getDashType(self) -> int:
        '''Specifies the dash line type
        See :class:`MsoLineDashStyle`'''
        raise NotImplementedError()

    def setBeginArrowLength(self, value : int) -> None:
        '''Specifies the length of the arrowhead for the begin of a line.
        See :class:`MsoArrowheadLength`
        :param value: '''
        raise NotImplementedError()

    def setStyle(self, value : int) -> None:
        '''Represents the style of the line.
        See :class:`LineType`
        :param value: '''
        raise NotImplementedError()

    def setBeginArrowWidth(self, value : int) -> None:
        '''Specifies the width of the arrowhead for the begin of a line.
        See :class:`MsoArrowheadWidth`
        :param value: '''
        raise NotImplementedError()

    def getStyle(self) -> int:
        '''Represents the style of the line.
        See :class:`LineType`'''
        raise NotImplementedError()

    def setAuto(self, value : bool) -> None:
        '''Indicates whether this line style is auto assigned.
        :param value: '''
        raise NotImplementedError()

    def getBeginArrowLength(self) -> int:
        '''Specifies the length of the arrowhead for the begin of a line.
        See :class:`MsoArrowheadLength`'''
        raise NotImplementedError()

    def isAuto(self) -> bool:
        '''Indicates whether this line style is auto assigned.'''
        raise NotImplementedError()

    def setFormattingType(self, value : int) -> None:
        '''Sets format type.
        See :class:`ChartLineFormattingType`
        :param value: '''
        raise NotImplementedError()

    def getBeginType(self) -> int:
        '''Specifies an arrowhead for the begin of a line.
        See :class:`MsoArrowheadStyle`'''
        raise NotImplementedError()

    def getCapType(self) -> int:
        '''Specifies the ending caps.
        See :class:`LineCapType`'''
        raise NotImplementedError()

    def getEndType(self) -> int:
        '''Specifies an arrowhead for the end of a line.
        See :class:`MsoArrowheadStyle`'''
        raise NotImplementedError()

    def setDashType(self, value : int) -> None:
        '''Specifies the dash line type
        See :class:`MsoLineDashStyle`
        :param value: '''
        raise NotImplementedError()

    def getEndArrowLength(self) -> int:
        '''Specifies the length of the arrowhead for the end of a line.
        See :class:`MsoArrowheadLength`'''
        raise NotImplementedError()


class LineCapType:
    '''Represents the caps of a line'''

    SQUARE : LineCapType
    '''Square protrudes by half line width.'''

    ROUND : LineCapType
    '''Rounded ends.'''

    FLAT : LineCapType
    '''Line ends at end point.'''

    NONE : LineCapType
    '''None cap'''


class LineFormat:
    '''Represents all setting of the line.'''

    def setJoinType(self, value : int) -> None:
        '''Specifies the line join type.
        See :class:`LineJoinType`
        :param value: '''
        raise NotImplementedError()

    def setCapType(self, value : int) -> None:
        '''Specifies the ending caps.
        See :class:`LineCapType`
        :param value: '''
        raise NotImplementedError()

    def setDashStyle(self, value : int) -> None:
        '''Specifies the line dash type.
        See :class:`MsoLineDashStyle`
        :param value: '''
        raise NotImplementedError()

    def setBeginArrowheadLength(self, value : int) -> None:
        '''Sets the begin arrow length type of the line.
        See :class:`MsoArrowheadLength`
        :param value: '''
        raise NotImplementedError()

    def setWeight(self, value : int) -> None:
        '''Sets the weight of the line in unit of points.
        :param value: '''
        raise NotImplementedError()

    def getCompoundType(self) -> int:
        '''Specifies the line compound type.
        See :class:`MsoLineStyle`'''
        raise NotImplementedError()

    def getEndArrowheadLength(self) -> int:
        '''Gets the end arrow length type of the line.
        See :class:`MsoArrowheadLength`'''
        raise NotImplementedError()

    def getWeight(self) -> int:
        '''Gets the weight of the line in unit of points.'''
        raise NotImplementedError()

    def setEndArrowheadLength(self, value : int) -> None:
        '''Sets the end arrow length type of the line.
        See :class:`MsoArrowheadLength`
        :param value: '''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determines whether this instance has the same value as another specified :class:`LineFormat` object.
        :param obj: The :class:`LineFormat` object to compare with this instance.
        :returns: true if the value of the obj parameter is the same as the value of this instance; otherwise, false. If obj is null, this method returns false.'''
        raise NotImplementedError()

    def getBeginArrowheadWidth(self) -> int:
        '''Gets the begin arrow width type of the line.
        See :class:`MsoArrowheadWidth`'''
        raise NotImplementedError()

    def getEndArrowheadWidth(self) -> int:
        '''Gets the end arrow width type of the line.
        See :class:`MsoArrowheadWidth`'''
        raise NotImplementedError()

    def getDashStyle(self) -> int:
        '''Specifies the line dash type.
        See :class:`MsoLineDashStyle`'''
        raise NotImplementedError()

    def getBeginArrowheadStyle(self) -> int:
        '''Gets the begin arrow type of the line.
        See :class:`MsoArrowheadStyle`'''
        raise NotImplementedError()

    def getEndArrowheadStyle(self) -> int:
        '''Gets the end arrow type of the line.
        See :class:`MsoArrowheadStyle`'''
        raise NotImplementedError()

    def getCapType(self) -> int:
        '''Specifies the ending caps.
        See :class:`LineCapType`'''
        raise NotImplementedError()

    def hashCode(self) -> int:
        '''Gets the hash code.'''
        raise NotImplementedError()

    def setBeginArrowheadWidth(self, value : int) -> None:
        '''Sets the begin arrow width type of the line.
        See :class:`MsoArrowheadWidth`
        :param value: '''
        raise NotImplementedError()

    def setEndArrowheadWidth(self, value : int) -> None:
        '''Sets the end arrow width type of the line.
        See :class:`MsoArrowheadWidth`
        :param value: '''
        raise NotImplementedError()

    def getJoinType(self) -> int:
        '''Specifies the line join type.
        See :class:`LineJoinType`'''
        raise NotImplementedError()

    def setBeginArrowheadStyle(self, value : int) -> None:
        '''Sets the begin arrow type of the line.
        See :class:`MsoArrowheadStyle`
        :param value: '''
        raise NotImplementedError()

    def getBeginArrowheadLength(self) -> int:
        '''Gets the begin arrow length type of the line.
        See :class:`MsoArrowheadLength`'''
        raise NotImplementedError()

    def setCompoundType(self, value : int) -> None:
        '''Specifies the line compound type.
        See :class:`MsoLineStyle`
        :param value: '''
        raise NotImplementedError()

    def setEndArrowheadStyle(self, value : int) -> None:
        '''Sets the end arrow type of the line.
        See :class:`MsoArrowheadStyle`
        :param value: '''
        raise NotImplementedError()


class LineJoinType:
    '''Represents the join styles of a line.'''

    ROUND : LineJoinType
    '''Round joint'''

    BEVEL : LineJoinType
    '''Bevel joint'''

    MITER : LineJoinType
    '''Miter joint'''

    NONE : LineJoinType
    '''None joint'''


class LineShape:
    '''Represents the line shape.'''

    def getEndArrowheadStyle(self) -> int:
        ''':deprecated: Use Shape.Line.EndArrowheadStyle property instead.'''
        raise NotImplementedError()

    def getEndArrowheadWidth(self) -> int:
        ''':deprecated: Use Shape.Line.EndArrowheadWidth property instead.'''
        raise NotImplementedError()

    def setEndArrowheadStyle(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.EndArrowheadStyle property instead.'''
        raise NotImplementedError()

    def setEndArrowheadWidth(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.EndArrowheadWidth property instead.'''
        raise NotImplementedError()

    def setEndArrowheadLength(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.EndArrowheadLength property instead.'''
        raise NotImplementedError()

    def getBeginArrowheadStyle(self) -> int:
        ''':deprecated: Use Shape.Line.BeginArrowheadStyle property instead.'''
        raise NotImplementedError()

    def getBeginArrowheadWidth(self) -> int:
        ''':deprecated: Use Shape.Line.BeginArrowheadWidth property instead.'''
        raise NotImplementedError()

    def setBeginArrowheadLength(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.BeginArrowheadLength property instead.'''
        raise NotImplementedError()

    def getBeginArrowheadLength(self) -> int:
        ''':deprecated: Use Shape.Line.BeginArrowheadLength property instead.'''
        raise NotImplementedError()

    def setBeginArrowheadStyle(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.BeginArrowheadStyle property instead.'''
        raise NotImplementedError()

    def setBeginArrowheadWidth(self, value : int) -> None:
        ''':deprecated: Use Shape.Line.BeginArrowheadWidth property instead.'''
        raise NotImplementedError()

    def getEndArrowheadLength(self) -> int:
        ''':deprecated: Use Shape.Line.EndArrowheadLength property instead.'''
        raise NotImplementedError()


class LineSpaceSizeType:
    '''Represents the unit type of line space size.'''

    PERCENTAGE : LineSpaceSizeType
    '''Represents in unit of a percentage of the text size.'''

    POINTS : LineSpaceSizeType
    '''Represents in unit of points.'''


class LineType:
    '''Enumerates the type of :class:`Picture` border or :class:`Chart` line.'''

    DARK_GRAY : LineType
    '''Represents a dark gray line.'''

    DASH : LineType
    '''Represent a dash line.'''

    DASH_DOT : LineType
    '''Represents a dash-dot line'''

    DASH_DOT_DOT : LineType
    '''Represents a dash-dot-dot line.'''

    DOT : LineType
    '''Represents a dotted line.'''

    LIGHT_GRAY : LineType
    '''Represents a light gray line.'''

    MEDIUM_GRAY : LineType
    '''Represents a medium gray line.'''

    SOLID : LineType
    '''Represent a solid line.'''


class ListBox:
    '''Represents a list box object.'''

    def getSelectedIndex(self) -> int:
        '''Gets the index number of the currently selected item in a list box or combo box.
        Zero-based.'''
        raise NotImplementedError()

    def isSelected(self, itemIndex : int) -> bool:
        '''Indicates whether the item is selected.
        :param itemIndex: The item index.
        :returns: whether the item is selected.'''
        raise NotImplementedError()

    def selectedItem(self, itemIndex : int, isSelected : bool) -> None:
        '''Sets whether the item is selected
        :param itemIndex: The item index
        :param isSelected: Whether the item is selected.'''
        raise NotImplementedError()

    def getSelectedCells(self) -> list[Cell]:
        '''Gets the selected cells.
        Returns null if the input range is not set or no item is selected'''
        raise NotImplementedError()

    def getShadow(self) -> bool:
        '''Indicates whether the combobox has 3-D shading.'''
        raise NotImplementedError()

    def getSelectionType(self) -> int:
        '''Gets the selection mode of the specified list box.
        See :class:`SelectionType`'''
        raise NotImplementedError()

    def setSelectionType(self, value : int) -> None:
        '''Sets the selection mode of the specified list box.
        See :class:`SelectionType`
        :param value: '''
        raise NotImplementedError()

    def getItemCount(self) -> int:
        '''Gets the number of items in the list box.'''
        raise NotImplementedError()

    def setShadow(self, value : bool) -> None:
        '''Indicates whether the combobox has 3-D shading.
        :param value: '''
        raise NotImplementedError()

    def getPageChange(self) -> int:
        '''Specifies the amount by which the control's value is changed
        when the user clicks on the scrollbar's page up or page down region.'''
        raise NotImplementedError()

    def setSelectedIndex(self, value : int) -> None:
        '''Sets the index number of the currently selected item in a list box or combo box.
        Zero-based.
        :param value: '''
        raise NotImplementedError()

    def setPageChange(self, value : int) -> None:
        '''Specifies the amount by which the control's value is changed
        when the user clicks on the scrollbar's page up or page down region.
        :param value: '''
        raise NotImplementedError()


class ListBoxActiveXControl:
    '''Represents a ListBox ActiveX control.'''

    def getColumnCount(self) -> int:
        '''Represents the number of columns to display in a ComboBox or ListBox.'''
        raise NotImplementedError()

    def getShowColumnHeads(self) -> bool:
        '''Indicates whether column headings are displayed.'''
        raise NotImplementedError()

    def setIntegralHeight(self, value : bool) -> None:
        '''Indicates whether the control will only show complete lines of text without showing any partial lines.
        :param value: '''
        raise NotImplementedError()

    def setValue(self, value : str) -> None:
        '''Sets the value of the control.
        :param value: '''
        raise NotImplementedError()

    def getValue(self) -> str:
        '''Gets the value of the control.'''
        raise NotImplementedError()

    def getMatchEntry(self) -> int:
        '''Indicates how a ListBox or ComboBox searches its list as the user types.
        See :class:`ControlMatchEntryType`'''
        raise NotImplementedError()

    def setSelectionType(self, value : int) -> None:
        '''Indicates whether the control permits multiple selections.
        See :class:`SelectionType`
        :param value: '''
        raise NotImplementedError()

    def setSpecialEffect(self, value : int) -> None:
        '''Sets the special effect of the control.
        See :class:`ControlSpecialEffectType`
        :param value: '''
        raise NotImplementedError()

    def getBorderOleColor(self) -> int:
        '''Gets the ole color of the background.'''
        raise NotImplementedError()

    def getBorderStyle(self) -> int:
        '''Gets the type of border used by the control.
        See :class:`ControlBorderType`'''
        raise NotImplementedError()

    def getBoundColumn(self) -> int:
        '''Represents how the Value property is determined for a ComboBox or ListBox
        when the MultiSelect properties value (fmMultiSelectSingle).'''
        raise NotImplementedError()

    def setListWidth(self, value : int) -> None:
        '''Sets the width in unit of points.
        :param value: '''
        raise NotImplementedError()

    def getColumnWidths(self) -> int:
        '''Gets the width of the column.'''
        raise NotImplementedError()

    def setListStyle(self, value : int) -> None:
        '''Sets the visual appearance.
        See :class:`ControlListStyle`
        :param value: '''
        raise NotImplementedError()

    def getSelectionType(self) -> int:
        '''Indicates whether the control permits multiple selections.
        See :class:`SelectionType`'''
        raise NotImplementedError()

    def getSpecialEffect(self) -> int:
        '''Gets the special effect of the control.
        See :class:`ControlSpecialEffectType`'''
        raise NotImplementedError()

    def setScrollBars(self, value : int) -> None:
        '''Indicates specifies whether the control has vertical scroll bars, horizontal scroll bars, both, or neither.
        See :class:`ControlScrollBarType`
        :param value: '''
        raise NotImplementedError()

    def setColumnCount(self, value : int) -> None:
        '''Represents the number of columns to display in a ComboBox or ListBox.
        :param value: '''
        raise NotImplementedError()

    def getIntegralHeight(self) -> bool:
        '''Indicates whether the control will only show complete lines of text without showing any partial lines.'''
        raise NotImplementedError()

    def setColumnWidths(self, value : int) -> None:
        '''Sets the width of the column.
        :param value: '''
        raise NotImplementedError()

    def setBorderOleColor(self, value : int) -> None:
        '''Sets the ole color of the background.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()

    def setMatchEntry(self, value : int) -> None:
        '''Indicates how a ListBox or ComboBox searches its list as the user types.
        See :class:`ControlMatchEntryType`
        :param value: '''
        raise NotImplementedError()

    def setBorderStyle(self, value : int) -> None:
        '''Sets the type of border used by the control.
        See :class:`ControlBorderType`
        :param value: '''
        raise NotImplementedError()

    def getTextColumn(self) -> int:
        '''Represents the column in a ComboBox or ListBox to display to the user.'''
        raise NotImplementedError()

    def getListWidth(self) -> int:
        '''Gets the width in unit of points.'''
        raise NotImplementedError()

    def setBoundColumn(self, value : int) -> None:
        '''Represents how the Value property is determined for a ComboBox or ListBox
        when the MultiSelect properties value (fmMultiSelectSingle).
        :param value: '''
        raise NotImplementedError()

    def getScrollBars(self) -> int:
        '''Indicates specifies whether the control has vertical scroll bars, horizontal scroll bars, both, or neither.
        See :class:`ControlScrollBarType`'''
        raise NotImplementedError()

    def setShowColumnHeads(self, value : bool) -> None:
        '''Indicates whether column headings are displayed.
        :param value: '''
        raise NotImplementedError()

    def setTextColumn(self, value : int) -> None:
        '''Represents the column in a ComboBox or ListBox to display to the user.
        :param value: '''
        raise NotImplementedError()

    def getListStyle(self) -> int:
        '''Gets the visual appearance.
        See :class:`ControlListStyle`'''
        raise NotImplementedError()


class ListColumn:
    '''Represents a column in a Table.'''

    def setTotalsRowLabel(self, value : str) -> None:
        '''Sets the display labels of total row.
        :param value: '''
        raise NotImplementedError()

    def getCustomCalculatedFormula(self, isR1C1 : bool, isLocal : bool) -> str:
        '''Gets the formula of this list column.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :returns: The formula of this list column.'''
        raise NotImplementedError()

    def getRange(self) -> Range:
        '''Gets the range of this list column.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the column.'''
        raise NotImplementedError()

    def setCustomCalculatedFormula(self, formula : str, isR1C1 : bool, isLocal : bool) -> None:
        '''Sets the formula for this list column.
        :param formula: the formula for this list column.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.'''
        raise NotImplementedError()

    def getTotalsRowLabel(self) -> str:
        '''Gets the display labels of total row.'''
        raise NotImplementedError()

    def getCustomTotalsRowFormula(self, isR1C1 : bool, isLocal : bool) -> str:
        '''Gets the formula of totals row of this list column.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :returns: The formula of this list column.'''
        raise NotImplementedError()

    def setDataStyle(self, style : Style) -> None:
        '''Sets the style of the data in this column of the table.
        :param style: '''
        raise NotImplementedError()

    def setFormula(self, value : str) -> None:
        '''Sets the formula of the list column.
        :param value: '''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the column.
        :param value: '''
        raise NotImplementedError()

    def getFormula(self) -> str:
        '''Gets the formula of the list column.'''
        raise NotImplementedError()

    def getTotalsCalculation(self) -> int:
        '''Gets the type of calculation in the Totals row of the list column.
        See :class:`TotalsCalculation`'''
        raise NotImplementedError()

    def getDataStyle(self) -> Style:
        '''Gets the style of the data in this column of the table.'''
        raise NotImplementedError()

    def setTotalsCalculation(self, value : int) -> None:
        '''Sets the type of calculation in the Totals row of the list column.
        See :class:`TotalsCalculation`
        :param value: '''
        raise NotImplementedError()

    def setCustomTotalsRowFormula(self, formula : str, isR1C1 : bool, isLocal : bool) -> None:
        '''Gets the formula of totals row of this list column.
        :param formula: the formula for this list column.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.'''
        raise NotImplementedError()


class ListColumnCollection:
    '''Represents A collection of all the :class:`ListColumn` objects in the specified ListObject object.'''

    @overload
    def get(self, index : int) -> ListColumn:
        '''Gets the ListColumn by the index.
        :param index: The index.
        :returns: the ListColumn object.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> ListColumn:
        '''Gets the ListColumn by the name.
        :param name: The name of the ListColumn
        :returns: The ListColumn object.'''
        raise NotImplementedError()


class ListObject:
    '''Represents a list object on a worksheet.
    The ListObject object is a member of the ListObjects collection.
    The ListObjects collection contains all the list objects on a worksheet.'''

    def getAlternativeDescription(self) -> str:
        '''Gets the alternative description.'''
        raise NotImplementedError()

    def getShowTableStyleColumnStripes(self) -> bool:
        '''Indicates whether column stripe formatting is applied.'''
        raise NotImplementedError()

    def getComment(self) -> str:
        '''Gets the comment of the table.'''
        raise NotImplementedError()

    def setShowTableStyleRowStripes(self, value : bool) -> None:
        '''Indicates whether row stripe formatting is applied.
        :param value: '''
        raise NotImplementedError()

    def getDisplayName(self) -> str:
        '''Gets the display name.'''
        raise NotImplementedError()

    def setShowTableStyleFirstColumn(self, value : bool) -> None:
        '''Indicates whether the first column in the table should have the style applied.
        :param value: '''
        raise NotImplementedError()

    def applyStyleToRange(self) -> None:
        '''Apply the table style to the range.'''
        raise NotImplementedError()

    @overload
    def putCellFormula(self, rowOffset : int, columnOffset : int, formula : str) -> None:
        '''Put the formula to the cell in the table.
        :param rowOffset: The row offset in the table.
        :param columnOffset: The column offset in the table.
        :param formula: The formula of the cell.'''
        raise NotImplementedError()

    @overload
    def putCellFormula(self, rowOffset : int, columnOffset : int, formula : str, isTotalsRowFormula : bool) -> None:
        '''Put the formula to the cell in the table.
        :param rowOffset: The row offset in the table.
        :param columnOffset: The column offset in the table.
        :param formula: The formula of the cell.
        :param isTotalsRowFormula: '''
        raise NotImplementedError()

    def getTableStyleType(self) -> int:
        '''Gets and the built-in table style.
        See :class:`TableStyleType`'''
        raise NotImplementedError()

    def getAutoFilter(self) -> AutoFilter:
        '''Gets auto filter.'''
        raise NotImplementedError()

    def setShowTotals(self, value : bool) -> None:
        '''Sets whether this ListObject show total row.
        :param value: '''
        raise NotImplementedError()

    def getEndColumn(self) -> int:
        '''Gets the end column of the range.'''
        raise NotImplementedError()

    def setShowTableStyleLastColumn(self, value : bool) -> None:
        '''Indicates whether the last column in the table should have the style applied.
        :param value: '''
        raise NotImplementedError()

    def getXmlMap(self) -> XmlMap:
        '''Gets an :meth:`ListObject.getXmlMap()` used for this list.'''
        raise NotImplementedError()

    def getShowTableStyleFirstColumn(self) -> bool:
        '''Indicates whether the first column in the table should have the style applied.'''
        raise NotImplementedError()

    def resize(self, startRow : int, startColumn : int, endRow : int, endColumn : int, hasHeaders : bool) -> None:
        '''Resize the range of the list object.
        :param startRow: The start row index of the new range.
        :param startColumn: The start column index of the new range.
        :param endRow: The end row index of the new range.
        :param endColumn: The end column index of the new range.
        :param hasHeaders: Whether this table has headers.'''
        raise NotImplementedError()

    def getShowHeaderRow(self) -> bool:
        '''Gets whether this ListObject show header row.'''
        raise NotImplementedError()

    def getTableStyleName(self) -> str:
        '''Gets the table style name.'''
        raise NotImplementedError()

    def getAlternativeText(self) -> str:
        '''Gets the alternative text.'''
        raise NotImplementedError()

    @overload
    def putCellValue(self, rowOffset : int, columnOffset : int, value : Object) -> None:
        '''Put the value to the cell.
        :param rowOffset: The row offset in the table.
        :param columnOffset: The column offset in the table.
        :param value: The cell value.'''
        raise NotImplementedError()

    @overload
    def putCellValue(self, rowOffset : int, columnOffset : int, value : Object, isTotalsRowLabel : bool) -> None:
        '''Put the value to the cell.
        :param rowOffset: The row offset in the table.
        :param columnOffset: The column offset in the table.
        :param value: The cell value.
        :param isTotalsRowLabel: '''
        raise NotImplementedError()

    def setShowTableStyleColumnStripes(self, value : bool) -> None:
        '''Indicates whether column stripe formatting is applied.
        :param value: '''
        raise NotImplementedError()

    def setComment(self, value : str) -> None:
        '''Sets the comment of the table.
        :param value: '''
        raise NotImplementedError()

    def setTableStyleType(self, value : int) -> None:
        '''Gets and the built-in table style.
        See :class:`TableStyleType`
        :param value: '''
        raise NotImplementedError()

    def getStartColumn(self) -> int:
        '''Gets the start column of the range.'''
        raise NotImplementedError()

    def getDataRange(self) -> Range:
        '''Gets the data range of the ListObject.'''
        raise NotImplementedError()

    def getShowTableStyleRowStripes(self) -> bool:
        '''Indicates whether row stripe formatting is applied.'''
        raise NotImplementedError()

    def filter(self) -> AutoFilter:
        '''Filter the table.'''
        raise NotImplementedError()

    def getStartRow(self) -> int:
        '''Gets the start row of the range.'''
        raise NotImplementedError()

    def getEndRow(self) -> int:
        '''Gets the end  row of the range.'''
        raise NotImplementedError()

    def setAlternativeText(self, value : str) -> None:
        '''Sets the alternative text.
        :param value: '''
        raise NotImplementedError()

    def getListColumns(self) -> ListColumnCollection:
        '''Gets ListColumns of the ListObject.'''
        raise NotImplementedError()

    def setAlternativeDescription(self, value : str) -> None:
        '''Sets the alternative description.
        :param value: '''
        raise NotImplementedError()

    def getShowTotals(self) -> bool:
        '''Gets whether this ListObject show total row.'''
        raise NotImplementedError()

    def updateColumnName(self) -> None:
        '''Updates all list columns' name from the worksheet.'''
        raise NotImplementedError()

    def getQueryTable(self) -> QueryTable:
        '''Gets the linked QueryTable.'''
        raise NotImplementedError()

    def getShowTableStyleLastColumn(self) -> bool:
        '''Indicates whether the last column in the table should have the style applied.'''
        raise NotImplementedError()

    def setDisplayName(self, value : str) -> None:
        '''Sets the display name.
        :param value: '''
        raise NotImplementedError()

    def setTableStyleName(self, value : str) -> None:
        '''Sets the table style name.
        :param value: '''
        raise NotImplementedError()

    @overload
    def convertToRange(self) -> None:
        '''Convert the table to range.'''
        raise NotImplementedError()

    @overload
    def convertToRange(self, options : TableToRangeOptions) -> None:
        '''Convert the table to range.
        :param options: the options when converting table to range.'''
        raise NotImplementedError()

    def setShowHeaderRow(self, value : bool) -> None:
        '''Sets whether this ListObject show header row.
        :param value: '''
        raise NotImplementedError()

    def getDataSourceType(self) -> int:
        '''Gets the data source type of the table.
        See :class:`TableDataSourceType`'''
        raise NotImplementedError()


class ListObjectCollection:
    '''Represents a collection of :class:`ListObject` objects in the worksheet.'''

    @overload
    def get(self, index : int) -> ListObject:
        '''Gets the ListObject by index.
        :param index: The index.
        :returns: The ListObject'''
        raise NotImplementedError()

    @overload
    def get(self, tableName : str) -> ListObject:
        '''Gets the ListObject by specified name.
        :param tableName: ListObject name.
        :returns: The ListObject'''
        raise NotImplementedError()

    def updateColumnName(self) -> None:
        '''Update all column name of the tables.'''
        raise NotImplementedError()

    @overload
    def add(self, startRow : int, startColumn : int, endRow : int, endColumn : int, hasHeaders : bool) -> int:
        '''Adds a ListObject to the worksheet.
        :param startRow: The start row of the list range.
        :param startColumn: The start row of the list range.
        :param endRow: The start row of the list range.
        :param endColumn: The start row of the list range.
        :param hasHeaders: Whether the range has headers.
        :returns: The index of the new ListObject'''
        raise NotImplementedError()

    @overload
    def add(self, startCell : str, endCell : str, hasHeaders : bool) -> int:
        '''Adds a ListObject to the worksheet.
        :param startCell: The start cell of the list range.
        :param endCell: The end cell of the list range.
        :param hasHeaders: Whether the range has headers.
        :returns: The index of the new ListObject'''
        raise NotImplementedError()


class LoadDataFilterOptions:
    '''Represents the options to filter data when loading workbook from template.'''

    NONE : LoadDataFilterOptions
    '''Load nothing for sheet data'''

    ALL : LoadDataFilterOptions
    '''Load all'''

    CELL_BLANK : LoadDataFilterOptions
    '''Load cells whose value is blank'''

    CELL_STRING : LoadDataFilterOptions
    '''Load cells whose value is string'''

    CELL_NUMERIC : LoadDataFilterOptions
    '''Load cells whose value is numeric(including datetime)'''

    CELL_ERROR : LoadDataFilterOptions
    '''Load cells whose value is error'''

    CELL_BOOL : LoadDataFilterOptions
    '''Load cells whose value is bool'''

    CELL_VALUE : LoadDataFilterOptions
    '''Load cells value(all value types) only'''

    FORMULA : LoadDataFilterOptions
    '''Load cell formulas.'''

    CELL_DATA : LoadDataFilterOptions
    '''Load cells data including values, formulas and formatting'''

    CHART : LoadDataFilterOptions
    '''Load charts'''

    SHAPE : LoadDataFilterOptions
    '''Load shapes'''

    DRAWING : LoadDataFilterOptions
    '''Drawing objects(including Chart, Picture, OleObject and all other drawing objects)'''

    MERGED_AREA : LoadDataFilterOptions
    '''Load merged cells'''

    CONDITIONAL_FORMATTING : LoadDataFilterOptions
    '''Load conditional formatting'''

    DATA_VALIDATION : LoadDataFilterOptions
    '''Load data validations'''

    PIVOT_TABLE : LoadDataFilterOptions
    '''Load pivot tables'''

    TABLE : LoadDataFilterOptions
    '''Load tables'''

    HYPERLINKS : LoadDataFilterOptions
    '''Load hyperlinks'''

    SHEET_SETTINGS : LoadDataFilterOptions
    '''Load settings for worksheet'''

    SHEET_DATA : LoadDataFilterOptions
    '''Load all data of worksheet, such as cells data, settings, objects, ...etc.'''

    BOOK_SETTINGS : LoadDataFilterOptions
    '''Load settings for workbook'''

    SETTINGS : LoadDataFilterOptions
    '''Load settings for workbook and worksheet'''

    XML_MAP : LoadDataFilterOptions
    '''Load XmlMap'''

    STRUCTURE : LoadDataFilterOptions
    '''Load structure of the workbook'''

    DOCUMENT_PROPERTIES : LoadDataFilterOptions
    '''Load document properties'''

    DEFINED_NAMES : LoadDataFilterOptions
    '''Load defined Name objects'''

    VBA : LoadDataFilterOptions
    '''Load VBA projects'''

    STYLE : LoadDataFilterOptions
    '''Load styles for cell formatting'''

    PICTURE : LoadDataFilterOptions
    '''Load pictures'''

    OLE_OBJECT : LoadDataFilterOptions
    '''Load OleObjects'''

    REVISION : LoadDataFilterOptions
    '''Load revision logs'''


class LoadFilter:
    '''Represents the filter that provides options for loading data when loading workbook from template.'''

    def getSheetsInLoadingOrder(self) -> list[int]:
        '''Specifies the sheets(indices) and order to be loaded.
        Default is null, that denotes to load all sheets in the default order in template file.
        If not null and some sheet's index is not in the returned array, then the sheet will not be loaded.'''
        raise NotImplementedError()

    def setLoadDataFilterOptions(self, value : int) -> None:
        '''The filter options to denote what data should be loaded.
        See :class:`LoadDataFilterOptions`
        :param value: '''
        raise NotImplementedError()

    def getLoadDataFilterOptions(self) -> int:
        '''The filter options to denote what data should be loaded.
        See :class:`LoadDataFilterOptions`'''
        raise NotImplementedError()

    def startSheet(self, sheet : Worksheet) -> None:
        '''Prepares filter options before loading given worksheet.
        User's implementation of LoadFilter can change the LoadDataFilterOptions here
        to denote how to load data for this worksheet.
        :param sheet: The worksheet to be loaded.'''
        raise NotImplementedError()


class LoadFormat:
    '''Represents the load file format.'''

    AUTO : LoadFormat
    '''Represents recognizing the format automatically.'''

    CSV : LoadFormat
    '''Comma-Separated Values(CSV) text file.'''

    XLSX : LoadFormat
    '''Represents Office Open XML spreadsheetML workbook or template, with or without macros.'''

    TSV : LoadFormat
    '''Tab-Separated Values(TSV) text file.'''

    TAB_DELIMITED : LoadFormat
    '''Represents a tab delimited text file, same with :attr:`LoadFormat.TSV`.'''

    HTML : LoadFormat
    '''Represents a html file.'''

    M_HTML : LoadFormat
    '''Represents a mhtml file.'''

    ODS : LoadFormat
    '''Open Document Sheet(ODS) file.'''

    EXCEL_97_TO_2003 : LoadFormat
    '''Represents an Excel97-2003 xls file.'''

    SPREADSHEET_ML : LoadFormat
    '''Represents an Excel 2003 xml file.'''

    XLSB : LoadFormat
    '''Represents an xlsb file.'''

    OTS : LoadFormat
    '''Open Document Template Sheet(OTS) file.'''

    NUMBERS : LoadFormat
    '''Represents a numbers file.'''

    FODS : LoadFormat
    '''Represents OpenDocument Flat XML Spreadsheet (.fods) file format.'''

    SXC : LoadFormat
    '''Represents StarOffice Calc Spreadsheet (.sxc) file format.'''

    XML : LoadFormat
    '''Represents a simple xml file.'''

    EPUB : LoadFormat
    '''Reprents an EPUB file.'''

    AZW_3 : LoadFormat
    '''Represents an AZW3 file.'''

    CHM : LoadFormat
    '''Represents a CHM file.'''

    UNKNOWN : LoadFormat
    '''Represents unrecognized format, cannot be loaded.'''

    IMAGE : LoadFormat
    '''Image'''

    JSON : LoadFormat
    '''Json'''


class LoadNumbersTableType:
    '''Indicates type of loading tables when some tables are in a sheet.'''

    ONE_TABLE_PER_SHEET : LoadNumbersTableType
    ''''''

    OVERRIDE_OTHER_TABLES : LoadNumbersTableType
    ''''''

    TILE_TABLES : LoadNumbersTableType
    ''''''


class LoadOptions:
    '''Represents the options of loading the file.'''

    def getPreservePaddingSpacesInFormula(self) -> bool:
        '''Indicates whether preserve those spaces and line breaks that are padded between formula tokens
        while getting and setting formulas.
        Default value is false.'''
        raise NotImplementedError()

    def setStandardFont(self, value : str) -> None:
        ''':deprecated: Use DefaultStyleSettings.FontName property instead.'''
        raise NotImplementedError()

    def getLocale(self) -> Locale:
        '''Gets the Locale used for workbook at the time the file was loaded.'''
        raise NotImplementedError()

    def setMemorySetting(self, value : int) -> None:
        '''Sets the memory usage options.
        See :class:`MemorySetting`
        :param value: '''
        raise NotImplementedError()

    def setPaperSize(self, type : int) -> None:
        '''Sets the default print paper size from default printer's setting.
        :param type: :class:`PaperSizeType`. The default paper size.'''
        raise NotImplementedError()

    def setParsingFormulaOnOpen(self, value : bool) -> None:
        '''Indicates whether parsing the formula when reading the file.
        :param value: '''
        raise NotImplementedError()

    def getAutoFilter(self) -> bool:
        '''Indicates whether auto filtering the data when loading the files.'''
        raise NotImplementedError()

    def getWarningCallback(self) -> IWarningCallback:
        '''Gets warning callback.'''
        raise NotImplementedError()

    def setLocale(self, value : Locale) -> None:
        '''Sets the Locale used for workbook at the time the file was loaded.
        :param value: '''
        raise NotImplementedError()

    def getFontConfigs(self) -> IndividualFontConfigs:
        '''Gets individual font configs.
        Only works for the :class:`Workbook` which uses this :class:`LoadOptions` to load.'''
        raise NotImplementedError()

    def getCheckDataValid(self) -> bool:
        '''Check whether data is valid in the template file.'''
        raise NotImplementedError()

    def setLanguageCode(self, value : int) -> None:
        '''Sets the user interface language of the Workbook version based on CountryCode that has saved the file.
        See :class:`CountryCode`
        :param value: '''
        raise NotImplementedError()

    def getLoadFormat(self) -> int:
        '''Gets the load format.
        See :class:`LoadFormat`'''
        raise NotImplementedError()

    def setKeepUnparsedData(self, value : bool) -> None:
        '''Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.
        :param value: '''
        raise NotImplementedError()

    def getLoadFilter(self) -> LoadFilter:
        '''The filter to denote how to load data.'''
        raise NotImplementedError()

    def setIgnoreNotPrinted(self, value : bool) -> None:
        '''Ignore the data which are not printed if directly printing the file
        :param value: '''
        raise NotImplementedError()

    def getKeepUnparsedData(self) -> bool:
        '''Whether keep the unparsed data in memory for the Workbook when it is loaded from template file. Default is true.'''
        raise NotImplementedError()

    def setWarningCallback(self, value : IWarningCallback) -> None:
        '''Sets warning callback.
        :param value: '''
        raise NotImplementedError()

    def getIgnoreNotPrinted(self) -> bool:
        '''Ignore the data which are not printed if directly printing the file'''
        raise NotImplementedError()

    def setAutoFilter(self, value : bool) -> None:
        '''Indicates whether auto filtering the data when loading the files.
        :param value: '''
        raise NotImplementedError()

    def getRegion(self) -> int:
        '''Gets the system regional settings based on CountryCode at the time the file was loaded.
        See :class:`CountryCode`'''
        raise NotImplementedError()

    def getPassword(self) -> str:
        '''Gets the password of the workbook.'''
        raise NotImplementedError()

    def getMemorySetting(self) -> int:
        '''Gets the memory usage options.
        See :class:`MemorySetting`'''
        raise NotImplementedError()

    def setCheckExcelRestriction(self, value : bool) -> None:
        '''Whether check restriction of excel file when user modify cells related objects.
        For example, excel does not allow inputting string value longer than 32K.
        When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
        If this property is false, we will accept your input string value as the cell's value so that later
        you can output the complete string value for other file formats such as CSV.
        However, if you have set such kind of value that is invalid for excel file format,
        you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
        :param value: '''
        raise NotImplementedError()

    def getDefaultStyleSettings(self) -> DefaultStyleSettings:
        '''Gets the default style settings for initializing styles of the workbook'''
        raise NotImplementedError()

    def setLightCellsDataHandler(self, value : LightCellsDataHandler) -> None:
        '''The data handler for processing cells data when reading template file.
        :param value: '''
        raise NotImplementedError()

    def setIgnoreUselessShapes(self, value : bool) -> None:
        '''Indicates whether ignoring useless shapes.
        :param value: '''
        raise NotImplementedError()

    def setAutoFitterOptions(self, value : AutoFitterOptions) -> None:
        '''Sets the auto fitter options
        :param value: '''
        raise NotImplementedError()

    def setPreservePaddingSpacesInFormula(self, value : bool) -> None:
        '''Indicates whether preserve those spaces and line breaks that are padded between formula tokens
        while getting and setting formulas.
        Default value is false.
        :param value: '''
        raise NotImplementedError()

    def setRegion(self, value : int) -> None:
        '''Sets the system regional settings based on CountryCode at the time the file was loaded.
        See :class:`CountryCode`
        :param value: '''
        raise NotImplementedError()

    def setParsingPivotCachedRecords(self, value : bool) -> None:
        '''Indicates whether parsing pivot cached records when loading the file.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getStandardFont(self) -> str:
        ''':deprecated: Use DefaultStyleSettings.FontName property instead.'''
        raise NotImplementedError()

    def getCheckExcelRestriction(self) -> bool:
        '''Whether check restriction of excel file when user modify cells related objects.
        For example, excel does not allow inputting string value longer than 32K.
        When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
        If this property is false, we will accept your input string value as the cell's value so that later
        you can output the complete string value for other file formats such as CSV.
        However, if you have set such kind of value that is invalid for excel file format,
        you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.'''
        raise NotImplementedError()

    def setCheckDataValid(self, value : bool) -> None:
        '''Check whether data is valid in the template file.
        :param value: '''
        raise NotImplementedError()

    def getLightCellsDataHandler(self) -> LightCellsDataHandler:
        '''The data handler for processing cells data when reading template file.'''
        raise NotImplementedError()

    def setLoadFilter(self, value : LoadFilter) -> None:
        '''The filter to denote how to load data.
        :param value: '''
        raise NotImplementedError()

    def setPassword(self, value : str) -> None:
        '''Sets the password of the workbook.
        :param value: '''
        raise NotImplementedError()

    def setInterruptMonitor(self, value : AbstractInterruptMonitor) -> None:
        '''Sets the interrupt monitor.
        :param value: '''
        raise NotImplementedError()

    def getIgnoreUselessShapes(self) -> bool:
        '''Indicates whether ignoring useless shapes.'''
        raise NotImplementedError()

    def getParsingPivotCachedRecords(self) -> bool:
        '''Indicates whether parsing pivot cached records when loading the file.
        The default value is false.'''
        raise NotImplementedError()

    def getLanguageCode(self) -> int:
        '''Gets the user interface language of the Workbook version based on CountryCode that has saved the file.
        See :class:`CountryCode`'''
        raise NotImplementedError()

    def getInterruptMonitor(self) -> AbstractInterruptMonitor:
        '''Gets the interrupt monitor.'''
        raise NotImplementedError()

    def setStandardFontSize(self, value : int) -> None:
        ''':deprecated: Use DefaultStyleSettings.FontSize property instead.'''
        raise NotImplementedError()

    def getAutoFitterOptions(self) -> AutoFitterOptions:
        '''Gets the auto fitter options'''
        raise NotImplementedError()

    def setFontConfigs(self, value : IndividualFontConfigs) -> None:
        '''Sets individual font configs.
        Only works for the :class:`Workbook` which uses this :class:`LoadOptions` to load.
        :param value: '''
        raise NotImplementedError()

    def getStandardFontSize(self) -> int:
        ''':deprecated: Use DefaultStyleSettings.FontSize property instead.'''
        raise NotImplementedError()

    def getParsingFormulaOnOpen(self) -> bool:
        '''Indicates whether parsing the formula when reading the file.'''
        raise NotImplementedError()


class LookAtType:
    '''Represents look at type.'''

    CONTAINS : LookAtType
    '''Cell value Contains the find object.'''

    START_WITH : LookAtType
    '''Cell value Starts with the find object.'''

    END_WITH : LookAtType
    '''Cell value ends with the find object.'''

    ENTIRE_CONTENT : LookAtType
    '''Cell value is same as the find object.'''


class LookInType:
    '''Represents look in type.'''

    FORMULAS : LookInType
    '''If the cell contains a formula, find object from formula, else find it from the value.'''

    VALUES : LookInType
    '''Only find object from the formatted values.'''

    VALUES_EXCLUDE_FORMULA_CELL : LookInType
    '''Only find object from the values of cells which do not contains formula.'''

    COMMENTS : LookInType
    '''Only find object from the comments.'''

    ONLY_FORMULAS : LookInType
    '''Only find object from formulas.'''

    ORIGINAL_VALUES : LookInType
    '''Only find object from the original values.'''


class MapChartLabelLayout:
    '''Represents the layout of map chart's labels.'''

    BEST_FIT_ONLY : MapChartLabelLayout
    '''Only best fit.'''

    SHOW_ALL : MapChartLabelLayout
    '''Shows all labels.'''

    NONE : MapChartLabelLayout
    '''No labels.'''


class MapChartProjectionType:
    '''Represents projection type of the map chart.'''

    AUTOMATIC : MapChartProjectionType
    '''Automatic'''

    MERCATOR : MapChartProjectionType
    '''Mercator'''

    MILLER : MapChartProjectionType
    '''Miller'''

    ALBERS : MapChartProjectionType
    '''Albers'''


class MapChartRegionType:
    '''Represents the region type of the map chart.'''

    AUTOMATIC : MapChartRegionType
    '''Automatic'''

    DATA_ONLY : MapChartRegionType
    '''Only Data.'''

    COUNTRY_REGION_LIST : MapChartRegionType
    '''Country region list.'''

    WORLD : MapChartRegionType
    '''World.'''


class MarkdownSaveOptions:
    '''Represents the save options for markdown.'''

    def getEncoding(self) -> Encoding:
        '''Gets the default encoding.'''
        raise NotImplementedError()

    def setLightCellsDataProvider(self, value : LightCellsDataProvider) -> None:
        '''The Data provider to provide cells data for saving workbook in light mode.
        :param value: '''
        raise NotImplementedError()

    def getLightCellsDataProvider(self) -> LightCellsDataProvider:
        '''The Data provider to provide cells data for saving workbook in light mode.'''
        raise NotImplementedError()

    def getLineSeparator(self) -> str:
        '''Gets the line separator.'''
        raise NotImplementedError()

    def getFormatStrategy(self) -> int:
        '''Gets the format strategy when exporting the cell value as string.
        See :class:`CellValueFormatStrategy`'''
        raise NotImplementedError()

    def setEncoding(self, value : Encoding) -> None:
        '''Sets the default encoding.
        :param value: '''
        raise NotImplementedError()

    def setLineSeparator(self, value : str) -> None:
        '''Sets the line separator.
        :param value: '''
        raise NotImplementedError()

    def setFormatStrategy(self, value : int) -> None:
        '''Sets the format strategy when exporting the cell value as string.
        See :class:`CellValueFormatStrategy`
        :param value: '''
        raise NotImplementedError()


class Marker:
    '''Represents the marker in a line chart, scatter chart, or radar chart.'''

    def setBackgroundColorSetType(self, value : int) -> None:
        '''Sets the marker background color set type.
        See :class:`FormattingType`
        :param value: '''
        raise NotImplementedError()

    def getMarkerStyle(self) -> int:
        '''Represents the marker style. Applies to line chart, scatter chart, or radar chart.
        See :class:`ChartMarkerType`'''
        raise NotImplementedError()

    def getArea(self) -> Area:
        '''Gets the :class:`Area`.'''
        raise NotImplementedError()

    def setForegroundColorSetType(self, value : int) -> None:
        '''Sets the marker foreground color set type.
        See :class:`FormattingType`
        :param value: '''
        raise NotImplementedError()

    def getMarkerSize(self) -> int:
        '''Represents the marker size in unit of points. Applies to line chart, scatter chart, or radar chart.'''
        raise NotImplementedError()

    def setMarkerSizePx(self, value : int) -> None:
        '''Represents the marker size in unit of pixels. Applies to line chart, scatter chart, or radar chart.
        :param value: '''
        raise NotImplementedError()

    def setForegroundColor(self, value : Color) -> None:
        '''Represents the marker foreground color in a line chart, scatter chart, or radar chart.
        :param value: '''
        raise NotImplementedError()

    def setMarkerSize(self, value : int) -> None:
        '''Represents the marker size in unit of points. Applies to line chart, scatter chart, or radar chart.
        :param value: '''
        raise NotImplementedError()

    def getForegroundColor(self) -> Color:
        '''Represents the marker foreground color in a line chart, scatter chart, or radar chart.'''
        raise NotImplementedError()

    def getBackgroundColorSetType(self) -> int:
        '''Gets the marker background color set type.
        See :class:`FormattingType`'''
        raise NotImplementedError()

    def setBackgroundColor(self, value : Color) -> None:
        '''Represents the marker background color in a line chart, scatter chart, or radar chart.
        :param value: '''
        raise NotImplementedError()

    def setMarkerStyle(self, value : int) -> None:
        '''Represents the marker style. Applies to line chart, scatter chart, or radar chart.
        See :class:`ChartMarkerType`
        :param value: '''
        raise NotImplementedError()

    def getBackgroundColor(self) -> Color:
        '''Represents the marker background color in a line chart, scatter chart, or radar chart.'''
        raise NotImplementedError()

    def getForegroundColorSetType(self) -> int:
        '''Gets the marker foreground color set type.
        See :class:`FormattingType`'''
        raise NotImplementedError()

    def getMarkerSizePx(self) -> int:
        '''Represents the marker size in unit of pixels. Applies to line chart, scatter chart, or radar chart.'''
        raise NotImplementedError()

    def getBorder(self) -> Line:
        '''Gets the :class:`Line`.'''
        raise NotImplementedError()


class MathematicalEquationNode:
    '''This class specifies an equation or mathematical expression. All mathematical text of equations or mathematical expressions are contained by this class.'''

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class MatrixEquationNode:
    '''This class specifies the Matrix equation, consisting of one or more elements laid out in one or more rows and one or more columns.'''

    def isHidePlaceholder(self) -> bool:
        '''This attribute specifies the Hide Placeholders property on a matrix. When this property is on, placeholders do not appear in the matrix.Default, placeholders do appear such that the locations where text can be inserted are made visible.'''
        raise NotImplementedError()

    def getBaseJc(self) -> int:
        '''This attribute specifies the justification of the matrix. Text outside of the matrix can be aligned with the bottom, top, or center of a matrix function. Default, the matrix assumes center justification.
        See :class:`EquationVerticalJustificationType`'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()

    def setBaseJc(self, value : int) -> None:
        '''This attribute specifies the justification of the matrix. Text outside of the matrix can be aligned with the bottom, top, or center of a matrix function. Default, the matrix assumes center justification.
        See :class:`EquationVerticalJustificationType`
        :param value: '''
        raise NotImplementedError()

    def setHidePlaceholder(self, value : bool) -> None:
        '''This attribute specifies the Hide Placeholders property on a matrix. When this property is on, placeholders do not appear in the matrix.Default, placeholders do appear such that the locations where text can be inserted are made visible.
        :param value: '''
        raise NotImplementedError()


class MemoryFontSource:
    '''Represents the single TrueType font file stored in memory.'''

    def getFontData(self) -> list[int]:
        '''Binary font data.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Returns the type of the font source.
        See :class:`FontSourceType`'''
        raise NotImplementedError()


class MemorySetting:
    '''Memory usage options.'''

    NORMAL : MemorySetting
    '''Default option for cells model.'''

    MEMORY_PREFERENCE : MemorySetting
    '''Memory performance preferrable.
    With this option the data will be held in compact format so for common scenarios it may give lower memory cost.
    However, this option also may degrade R/W performance a bit in some special cases.'''


class MergedCellsShrinkType:
    '''Represents the strategy to shrink merged cells for operations such as deleting blank rows/column.'''

    NONE : MergedCellsShrinkType
    '''Leaves the merged cells as it is without any modification.'''

    SHRINK_TO_FIT : MergedCellsShrinkType
    '''Shrinks the merged area if needed, by removing rows from the bottom or columns from the right,
    while ensuring all content remains visible.'''

    KEEP_HEADER_ONLY : MergedCellsShrinkType
    '''Only keeps the header rows/columns of the merged area when the top-left cell of the merged area is not blank.'''


class MergeEmptyTdType:
    '''Represents the merge type for empty TD element when exporting file to html.'''

    DEFAULT : MergeEmptyTdType
    '''Display like MS Excel.'''

    NONE : MergeEmptyTdType
    '''Empty TD elements will not be merged when exporting file to html.
    This will generate a significantly larger html file.'''

    MERGE_FORCELY : MergeEmptyTdType
    '''Merging empty TD element forcedly when exporting file to html.
    The size of html file will be reduced significantly after setting value to true.
    If you want to import the html file to excel or export perfect grid lines when saving file to html,
    please keep the default value.'''


class MetadataOptions:
    '''Represents the options of loading metadata of the file.'''

    def getKeyLength(self) -> int:
        '''The key length.'''
        raise NotImplementedError()

    def getMetadataType(self) -> int:
        '''Gets the type of the metadata which is loading.
        See :class:`MetadataType`'''
        raise NotImplementedError()

    def setPassword(self, value : str) -> None:
        '''Represents Workbook file encryption password.
        :param value: '''
        raise NotImplementedError()

    def setKeyLength(self, value : int) -> None:
        '''The key length.
        :param value: '''
        raise NotImplementedError()

    def getPassword(self) -> str:
        '''Represents Workbook file encryption password.'''
        raise NotImplementedError()


class MetadataType:
    '''Represents the type of metadata.'''

    ENCRYPTION : MetadataType
    '''Encrypts the file.'''

    DECRYPTION : MetadataType
    '''Decrypts the file.'''

    DOCUMENT_PROPERTIES : MetadataType
    '''Load the properties of the file.'''


class Metered:
    '''Provides methods to set metered key.'''

    def getConsumptionQuantity(self) -> int:
        '''Gets consumption file size'''
        raise NotImplementedError()

    def setMeteredKey(self, publicKey : str, privateKey : str) -> None:
        '''Sets metered public and private key.
        If you purchase metered license, when start application, this API should be called, normally, this is enough.
        However, if always fail to upload consumption data and exceed 24 hours, the license will be set to evaluation status,
        to avoid such case, you should regularly check the license status, if it is evaluation status, call this API again.
        :param publicKey: public key
        :param privateKey: private key'''
        raise NotImplementedError()

    def getConsumptionCredit(self) -> int:
        '''Gets consumption credit'''
        raise NotImplementedError()

    def getProductName(self) -> str:
        '''Gets product name'''
        raise NotImplementedError()

    def isMeteredLicensed(self) -> bool:
        '''Check whether metered is licensed'''
        raise NotImplementedError()


class MirrorType:
    '''Represents mirror type of texture fill'''

    NONE : MirrorType
    '''None'''

    HORIZONAL : MirrorType
    '''Horizonal'''

    VERTICAL : MirrorType
    '''Vertical'''

    BOTH : MirrorType
    '''Both'''


class MsoArrowheadLength:
    '''Enumerates the line end width of the shape border line.'''

    SHORT : MsoArrowheadLength
    '''Short line end length'''

    MEDIUM : MsoArrowheadLength
    '''Medium line end length'''

    LONG : MsoArrowheadLength
    '''Long line end length'''


class MsoArrowheadStyle:
    '''Enumerates the line end type of the shape border line.'''

    NONE : MsoArrowheadStyle
    '''No line end type.'''

    ARROW : MsoArrowheadStyle
    '''Arrow line end type.'''

    ARROW_STEALTH : MsoArrowheadStyle
    '''Arrow Stealth line end type.'''

    ARROW_DIAMOND : MsoArrowheadStyle
    '''Arrow Diamond Line end type.'''

    ARROW_OVAL : MsoArrowheadStyle
    '''Arrow Oval line end type.'''

    ARROW_OPEN : MsoArrowheadStyle
    '''Arrow Open line end type.'''


class MsoArrowheadWidth:
    '''Enumerates the line end width of the shape border line.'''

    NARROW : MsoArrowheadWidth
    '''Short line end width.'''

    MEDIUM : MsoArrowheadWidth
    '''Medium line end width.'''

    WIDE : MsoArrowheadWidth
    '''Wide line end width.'''


class MsoDrawingType:
    '''Represents office drawing objects type.'''

    GROUP : MsoDrawingType
    '''Group'''

    LINE : MsoDrawingType
    '''Line'''

    RECTANGLE : MsoDrawingType
    '''Rectangle'''

    OVAL : MsoDrawingType
    '''Oval'''

    ARC : MsoDrawingType
    '''Arc'''

    CHART : MsoDrawingType
    '''Chart'''

    TEXT_BOX : MsoDrawingType
    '''TextBox'''

    BUTTON : MsoDrawingType
    '''Button'''

    PICTURE : MsoDrawingType
    '''Picture'''

    POLYGON : MsoDrawingType
    '''Polygon'''

    CHECK_BOX : MsoDrawingType
    '''CheckBox'''

    RADIO_BUTTON : MsoDrawingType
    '''RadioButton'''

    LABEL : MsoDrawingType
    '''Label'''

    DIALOG_BOX : MsoDrawingType
    '''DialogBox'''

    SPINNER : MsoDrawingType
    '''Spinner'''

    SCROLL_BAR : MsoDrawingType
    '''ScrollBar'''

    LIST_BOX : MsoDrawingType
    '''ListBox'''

    GROUP_BOX : MsoDrawingType
    '''GroupBox'''

    COMBO_BOX : MsoDrawingType
    '''ComboBox'''

    COMMENT : MsoDrawingType
    '''Comment'''

    OLE_OBJECT : MsoDrawingType
    '''OleObject'''

    CELLS_DRAWING : MsoDrawingType
    '''Only for preserving the drawing object in the template file.'''

    UNKNOWN : MsoDrawingType
    '''Only for preserving the drawing object in the xlsx file.'''

    SLICER : MsoDrawingType
    '''Slicer'''

    WEB_EXTENSION : MsoDrawingType
    '''Web extension'''

    SMART_ART : MsoDrawingType
    '''Smart Art'''

    CUSTOM_XML : MsoDrawingType
    '''Custom xml shape ,such as Ink.'''

    TIMELINE : MsoDrawingType
    '''Timeline'''

    MODEL_3_D : MsoDrawingType
    '''3D Model'''


class MsoFillFormat:
    '''Represents fill formatting for a shape.'''

    def setTransparency(self, value : int) -> None:
        '''Returns or sets the degree of transparency of the specified fill as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def getBackColor(self) -> Color:
        '''Gets the file back color.'''
        raise NotImplementedError()

    def setOneColorGradient(self, color : Color, degree : int, style : int, variant : int) -> None:
        '''Sets the specified fill to a one-color gradient.
        :param color: One gradient color.
        :param degree: The gradient degree. Can be a value from 0.0 (dark) through 1.0 (light).
        :param style: :class:`GradientStyleType`. Gradient shading style.
        :param variant: The gradient variant. Can be a value from 1 through 4, corresponding to one of the four variants on the Gradient tab in the Fill Effects dialog box. If style is GradientStyle.FromCenter, the Variant argument can only be 1 or 2.'''
        raise NotImplementedError()

    def setImageData(self, value : list[int]) -> None:
        '''Sets the Texture and Picture fill data.
        :param value: '''
        raise NotImplementedError()

    def getTexture(self) -> int:
        '''Gets the texture fill type.
        See :class:`TextureType`'''
        raise NotImplementedError()

    def setForeColor(self, value : Color) -> None:
        '''Sets the fill fore color.
        :param value: '''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Indicates whether there is fill.'''
        raise NotImplementedError()

    def getImageData(self) -> list[int]:
        '''Gets the Texture and Picture fill data.'''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Returns or sets the degree of transparency of the specified fill as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()

    def getForeColor(self) -> Color:
        '''Gets the fill fore color.'''
        raise NotImplementedError()

    def setBackColor(self, value : Color) -> None:
        '''Sets the file back color.
        :param value: '''
        raise NotImplementedError()

    def setVisible(self, value : bool) -> None:
        '''Indicates whether there is fill.
        :param value: '''
        raise NotImplementedError()


class MsoFillFormatHelper:
    '''Represents fill formatting for a shape.'''

    def getBackColor(self) -> Color:
        '''Gets the file back color.'''
        raise NotImplementedError()

    def setOneColorGradient(self, color : Color, degree : int, style : int, variant : int) -> None:
        '''Sets the specified fill to a one-color gradient.
        :param color: One gradient color.
        :param degree: The gradient degree. Can be a value from 0.0 (dark) through 1.0 (light).
        :param style: :class:`GradientStyleType`. Gradient shading style.
        :param variant: The gradient variant. Can be a value from 1 through 4, corresponding to one of the four variants on the Gradient tab in the Fill Effects dialog box. If style is GradientStyle.FromCenter, the Variant argument can only be 1 or 2.'''
        raise NotImplementedError()

    def setImageData(self, value : list[int]) -> None:
        '''Sets the Texture and Picture fill data.
        :param value: '''
        raise NotImplementedError()

    def getTexture(self) -> int:
        '''Gets the texture fill type.
        See :class:`TextureType`'''
        raise NotImplementedError()

    def getForeColorTransparency(self) -> int:
        '''Returns or sets the degree of fore color of the specified fill as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()

    def setForeColor(self, value : Color) -> None:
        '''Sets the fill fore color.
        :param value: '''
        raise NotImplementedError()

    def setForeColorTransparency(self, value : int) -> None:
        '''Returns or sets the degree of fore color of the specified fill as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Indicates whether there is fill.'''
        raise NotImplementedError()

    def getImageData(self) -> list[int]:
        '''Gets the Texture and Picture fill data.'''
        raise NotImplementedError()

    def getForeColor(self) -> Color:
        '''Gets the fill fore color.'''
        raise NotImplementedError()

    def setBackColor(self, value : Color) -> None:
        '''Sets the file back color.
        :param value: '''
        raise NotImplementedError()

    def setVisible(self, value : bool) -> None:
        '''Indicates whether there is fill.
        :param value: '''
        raise NotImplementedError()


class MsoFormatPicture:
    '''Represents the picture format.'''

    def getLeftCropInch(self) -> int:
        '''Represents the location of the left of the crop rectangle expressed, in unit of inches.'''
        raise NotImplementedError()

    def getRightCrop(self) -> int:
        '''Represents the location of the right of the crop rectangle expressed, expressed as a ratio of the image's width.'''
        raise NotImplementedError()

    def setGray(self, value : bool) -> None:
        '''Indicates whether this picture should display in grayscale.
        :param value: '''
        raise NotImplementedError()

    def getContrast(self) -> int:
        '''Represents the contrast modification for the picture.in unit of percentage.'''
        raise NotImplementedError()

    def setBottomCrop(self, value : int) -> None:
        '''Represents the location of the bottom of the crop rectangle expressed, expressed as a ratio of the image's height.
        :param value: '''
        raise NotImplementedError()

    def setRightCrop(self, value : int) -> None:
        '''Represents the location of the right of the crop rectangle expressed, expressed as a ratio of the image's width.
        :param value: '''
        raise NotImplementedError()

    def getTopCropInch(self) -> int:
        '''Represents the location of the top of the crop rectangle expressed, in unit of inches.'''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()

    def setLeftCropInch(self, value : int) -> None:
        '''Represents the location of the left of the crop rectangle expressed, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def getBrightness(self) -> int:
        '''Represents the brightness modification for the picture in unit of percentage.'''
        raise NotImplementedError()

    def setContrast(self, value : int) -> None:
        '''Represents the contrast modification for the picture.in unit of percentage.
        :param value: '''
        raise NotImplementedError()

    def setTopCrop(self, value : int) -> None:
        '''Represents the location of the top of the crop rectangle expressed, expressed as a ratio of the image's height.
        :param value: '''
        raise NotImplementedError()

    def setTransparency(self, value : int) -> None:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def setBrightness(self, value : int) -> None:
        '''Represents the brightness modification for the picture in unit of percentage.
        :param value: '''
        raise NotImplementedError()

    def getLeftCrop(self) -> int:
        '''Represents the location of the left of the crop rectangle expressed, expressed as a ratio of the image's width.'''
        raise NotImplementedError()

    def getBottomCropInch(self) -> int:
        '''Represents the location of the bottom of the crop rectangle expressed, in unit of inches.'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''
        :param obj: '''
        raise NotImplementedError()

    def setLeftCrop(self, value : int) -> None:
        '''Represents the location of the left of the crop rectangle expressed, expressed as a ratio of the image's width.
        :param value: '''
        raise NotImplementedError()

    def setRightCropInch(self, value : int) -> None:
        '''Represents the location of the right of the crop rectangle expressed, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def setTopCropInch(self, value : int) -> None:
        '''Represents the location of the top of the crop rectangle expressed, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def getTransparentColor(self) -> CellsColor:
        '''Gets the transparent color of the picture.'''
        raise NotImplementedError()

    def hashCode(self) -> int:
        '''Gets the hash code.'''
        raise NotImplementedError()

    def setGamma(self, value : int) -> None:
        '''Represents gamma of the picture.
        :param value: '''
        raise NotImplementedError()

    def getGamma(self) -> int:
        '''Represents gamma of the picture.'''
        raise NotImplementedError()

    def isBiLevel(self) -> bool:
        '''Indicates whether this picture should display in two-color black and white.'''
        raise NotImplementedError()

    def setTransparentColor(self, value : CellsColor) -> None:
        '''Sets the transparent color of the picture.
        :param value: '''
        raise NotImplementedError()

    def isGray(self) -> bool:
        '''Indicates whether this picture should display in grayscale.'''
        raise NotImplementedError()

    def setBottomCropInch(self, value : int) -> None:
        '''Represents the location of the bottom of the crop rectangle expressed, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def getRightCropInch(self) -> int:
        '''Represents the location of the right of the crop rectangle expressed, in unit of inches.'''
        raise NotImplementedError()

    def getTopCrop(self) -> int:
        '''Represents the location of the top of the crop rectangle expressed, expressed as a ratio of the image's height.'''
        raise NotImplementedError()

    def setBiLevel(self, value : bool) -> None:
        '''Indicates whether this picture should display in two-color black and white.
        :param value: '''
        raise NotImplementedError()

    def getBottomCrop(self) -> int:
        '''Represents the location of the bottom of the crop rectangle expressed, expressed as a ratio of the image's height.'''
        raise NotImplementedError()


class MsoLineDashStyle:
    '''Represents style of dash drawing lines.'''

    DASH : MsoLineDashStyle
    '''Represent a dash line.'''

    DASH_DOT : MsoLineDashStyle
    '''Represents a dash-dot line.'''

    DASH_DOT_DOT : MsoLineDashStyle
    '''Represents a dash-dot-dot line.'''

    DASH_LONG_DASH : MsoLineDashStyle
    '''Represents a long dash-short dash line.'''

    DASH_LONG_DASH_DOT : MsoLineDashStyle
    '''Represents a long dash-short dash-dot line.'''

    ROUND_DOT : MsoLineDashStyle
    '''Represents a round-dot line.'''

    SOLID : MsoLineDashStyle
    '''Represent a solid line.'''

    SQUARE_DOT : MsoLineDashStyle
    '''Represents a square-dot line.'''

    CUSTOM : MsoLineDashStyle
    '''Custom dash style.'''


class MsoLineFormat:
    '''Represents line and arrowhead formatting.'''

    def getWeight(self) -> int:
        '''Returns or sets the weight of the line ,in units of pt.'''
        raise NotImplementedError()

    def setTransparency(self, value : int) -> None:
        '''Returns or sets the degree of transparency of the specified fill as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def getBackColor(self) -> Color:
        '''Gets the border line back color.'''
        raise NotImplementedError()

    def setWeight(self, value : int) -> None:
        '''Returns or sets the weight of the line ,in units of pt.
        :param value: '''
        raise NotImplementedError()

    def setDashStyle(self, value : int) -> None:
        '''Sets the dash style for the specified line.
        See :class:`MsoLineDashStyle`
        :param value: '''
        raise NotImplementedError()

    def setForeColor(self, value : Color) -> None:
        '''Sets the border line fore color.
        :param value: '''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Indicates whether the object is visible.'''
        raise NotImplementedError()

    def getDashStyle(self) -> int:
        '''Gets the dash style for the specified line.
        See :class:`MsoLineDashStyle`'''
        raise NotImplementedError()

    def setStyle(self, value : int) -> None:
        '''Returns a Style object that represents the style of the specified range.
        See :class:`MsoLineStyle`
        :param value: '''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Returns or sets the degree of transparency of the specified fill as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()

    def getForeColor(self) -> Color:
        '''Gets the border line fore color.'''
        raise NotImplementedError()

    def getStyle(self) -> int:
        '''Returns a Style object that represents the style of the specified range.
        See :class:`MsoLineStyle`'''
        raise NotImplementedError()

    def setBackColor(self, value : Color) -> None:
        '''Sets the border line back color.
        :param value: '''
        raise NotImplementedError()

    def setVisible(self, value : bool) -> None:
        '''Indicates whether the object is visible.
        :param value: '''
        raise NotImplementedError()


class MsoLineFormatHelper:
    '''Represents line and arrowhead formatting.'''

    def getWeight(self) -> int:
        '''Returns or sets the weight of the line ,in units of pt.'''
        raise NotImplementedError()

    def setTransparency(self, value : int) -> None:
        '''Returns or sets the degree of transparency of the specified fill as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def getBackColor(self) -> Color:
        '''Gets the border line back color.'''
        raise NotImplementedError()

    def setWeight(self, value : int) -> None:
        '''Returns or sets the weight of the line ,in units of pt.
        :param value: '''
        raise NotImplementedError()

    def setDashStyle(self, value : int) -> None:
        '''Sets the dash style for the specified line.
        See :class:`MsoLineDashStyle`
        :param value: '''
        raise NotImplementedError()

    def setForeColor(self, value : Color) -> None:
        '''Sets the border line fore color.
        :param value: '''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Indicates whether the object is visible.'''
        raise NotImplementedError()

    def getDashStyle(self) -> int:
        '''Gets the dash style for the specified line.
        See :class:`MsoLineDashStyle`'''
        raise NotImplementedError()

    def setStyle(self, value : int) -> None:
        '''Returns a Style object that represents the style of the specified range.
        See :class:`MsoLineStyle`
        :param value: '''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Returns or sets the degree of transparency of the specified fill as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()

    def getForeColor(self) -> Color:
        '''Gets the border line fore color.'''
        raise NotImplementedError()

    def getStyle(self) -> int:
        '''Returns a Style object that represents the style of the specified range.
        See :class:`MsoLineStyle`'''
        raise NotImplementedError()

    def setBackColor(self, value : Color) -> None:
        '''Sets the border line back color.
        :param value: '''
        raise NotImplementedError()

    def setVisible(self, value : bool) -> None:
        '''Indicates whether the object is visible.
        :param value: '''
        raise NotImplementedError()


class MsoLineStyle:
    '''Represents style of drawing lines.'''

    SINGLE : MsoLineStyle
    '''Single line (of width lineWidth)'''

    THICK_BETWEEN_THIN : MsoLineStyle
    '''Three lines, thin, thick, thin'''

    THIN_THICK : MsoLineStyle
    '''Double lines, one thin, one thick'''

    THICK_THIN : MsoLineStyle
    '''Double lines, one thick, one thin'''

    THIN_THIN : MsoLineStyle
    '''Double lines of equal width'''


class MsoPresetTextEffect:
    '''Represents preset text effect type of WordArt.'''

    TEXT_EFFECT_1 : MsoPresetTextEffect
    '''TextEffect1'''

    TEXT_EFFECT_2 : MsoPresetTextEffect
    '''TextEffect2'''

    TEXT_EFFECT_3 : MsoPresetTextEffect
    '''TextEffect3'''

    TEXT_EFFECT_4 : MsoPresetTextEffect
    '''TextEffect4'''

    TEXT_EFFECT_5 : MsoPresetTextEffect
    '''TextEffect5'''

    TEXT_EFFECT_6 : MsoPresetTextEffect
    '''TextEffect6'''

    TEXT_EFFECT_7 : MsoPresetTextEffect
    '''TextEffect7'''

    TEXT_EFFECT_8 : MsoPresetTextEffect
    '''TextEffect8'''

    TEXT_EFFECT_9 : MsoPresetTextEffect
    '''TextEffect9'''

    TEXT_EFFECT_10 : MsoPresetTextEffect
    '''TextEffect10'''

    TEXT_EFFECT_11 : MsoPresetTextEffect
    '''TextEffect11'''

    TEXT_EFFECT_12 : MsoPresetTextEffect
    '''TextEffect12'''

    TEXT_EFFECT_13 : MsoPresetTextEffect
    '''TextEffect13'''

    TEXT_EFFECT_14 : MsoPresetTextEffect
    '''TextEffect14'''

    TEXT_EFFECT_15 : MsoPresetTextEffect
    '''TextEffect15'''

    TEXT_EFFECT_16 : MsoPresetTextEffect
    '''TextEffect16'''

    TEXT_EFFECT_17 : MsoPresetTextEffect
    '''TextEffect17'''

    TEXT_EFFECT_18 : MsoPresetTextEffect
    '''TextEffect18'''

    TEXT_EFFECT_19 : MsoPresetTextEffect
    '''TextEffect19'''

    TEXT_EFFECT_20 : MsoPresetTextEffect
    '''TextEffect20'''

    TEXT_EFFECT_21 : MsoPresetTextEffect
    '''TextEffect21'''

    TEXT_EFFECT_22 : MsoPresetTextEffect
    '''TextEffect22'''

    TEXT_EFFECT_23 : MsoPresetTextEffect
    '''TextEffect23'''

    TEXT_EFFECT_24 : MsoPresetTextEffect
    '''TextEffect24'''

    TEXT_EFFECT_25 : MsoPresetTextEffect
    '''TextEffect25'''

    TEXT_EFFECT_26 : MsoPresetTextEffect
    '''TextEffect26'''

    TEXT_EFFECT_27 : MsoPresetTextEffect
    '''TextEffect27'''

    TEXT_EFFECT_28 : MsoPresetTextEffect
    '''TextEffect28'''

    TEXT_EFFECT_29 : MsoPresetTextEffect
    '''TextEffect29'''

    TEXT_EFFECT_30 : MsoPresetTextEffect
    '''TextEffect30'''


class MsoPresetTextEffectShape:
    '''Represents preset text effect shape type of WordArt.'''

    PLAIN_TEXT : MsoPresetTextEffectShape
    '''PlainText'''

    STOP : MsoPresetTextEffectShape
    '''Stop'''

    TRIANGLE_UP : MsoPresetTextEffectShape
    '''TriangleUp'''

    TRIANGLE_DOWN : MsoPresetTextEffectShape
    '''TriangleDown'''

    CHEVRON_UP : MsoPresetTextEffectShape
    '''ChevronUp'''

    CHEVRON_DOWN : MsoPresetTextEffectShape
    '''ChevronDown'''

    RING_INSIDE : MsoPresetTextEffectShape
    '''RingInside'''

    RING_OUTSIDE : MsoPresetTextEffectShape
    '''RingOutside'''

    ARCH_UP_CURVE : MsoPresetTextEffectShape
    '''ArchUpCurve'''

    ARCH_DOWN_CURVE : MsoPresetTextEffectShape
    '''ArchDownCurve'''

    CIRCLE_CURVE : MsoPresetTextEffectShape
    '''CircleCurve'''

    BUTTON_CURVE : MsoPresetTextEffectShape
    '''ButtonCurve'''

    ARCH_UP_POUR : MsoPresetTextEffectShape
    '''ArchUpPour'''

    ARCH_DOWN_POUR : MsoPresetTextEffectShape
    '''ArchDownPour'''

    CIRCLE_POUR : MsoPresetTextEffectShape
    '''CirclePour'''

    BUTTON_POUR : MsoPresetTextEffectShape
    '''ButtonPour'''

    CURVE_UP : MsoPresetTextEffectShape
    '''CurveUp'''

    CURVE_DOWN : MsoPresetTextEffectShape
    '''CurveDown'''

    CAN_UP : MsoPresetTextEffectShape
    '''CanUp'''

    CAN_DOWN : MsoPresetTextEffectShape
    '''CanDown'''

    WAVE_1 : MsoPresetTextEffectShape
    '''Wave1'''

    WAVE_2 : MsoPresetTextEffectShape
    '''Wave2'''

    DOUBLE_WAVE_1 : MsoPresetTextEffectShape
    '''DoubleWave1'''

    DOUBLE_WAVE_2 : MsoPresetTextEffectShape
    '''DoubleWave2'''

    INFLATE : MsoPresetTextEffectShape
    '''Inflate'''

    DEFLATE : MsoPresetTextEffectShape
    '''Deflate'''

    INFLATE_BOTTOM : MsoPresetTextEffectShape
    '''InflateBottom'''

    DEFLATE_BOTTOM : MsoPresetTextEffectShape
    '''DeflateBottom'''

    INFLATE_TOP : MsoPresetTextEffectShape
    '''InflateTop'''

    DEFLATE_TOP : MsoPresetTextEffectShape
    '''DeflateTop'''

    DEFLATE_INFLATE : MsoPresetTextEffectShape
    '''DeflateInflate'''

    DEFLATE_INFLATE_DEFLATE : MsoPresetTextEffectShape
    '''DeflateInflateDeflate'''

    FADE_RIGHT : MsoPresetTextEffectShape
    '''FadeRight'''

    FADE_LEFT : MsoPresetTextEffectShape
    '''FadeLeft'''

    FADE_UP : MsoPresetTextEffectShape
    '''FadeUp'''

    FADE_DOWN : MsoPresetTextEffectShape
    '''FadeDown'''

    SLANT_UP : MsoPresetTextEffectShape
    '''SlantUp'''

    SLANT_DOWN : MsoPresetTextEffectShape
    '''SlantDown'''

    CASCADE_UP : MsoPresetTextEffectShape
    '''CascadeUp'''

    CASCADE_DOWN : MsoPresetTextEffectShape
    '''CascadeDown'''

    MIXED : MsoPresetTextEffectShape
    '''Mixed'''


class MsoTextFrame:
    '''Represents the text frame in a Shape object.'''

    def setAutoMargin(self, value : bool) -> None:
        '''Indicates whether the margin is auto calculated.
        :param value: '''
        raise NotImplementedError()

    def getTopMarginPt(self) -> int:
        '''Returns the top margin in unit of Points'''
        raise NotImplementedError()

    def getLeftMarginPt(self) -> int:
        '''Returns the left margin in unit of Points'''
        raise NotImplementedError()

    def setRightMarginPt(self, value : int) -> None:
        '''Returns the right margin in unit of Points
        :param value: '''
        raise NotImplementedError()

    def setBottomMarginPt(self, value : int) -> None:
        '''Returns the bottom margin in unit of Points
        :param value: '''
        raise NotImplementedError()

    def getRightMarginPt(self) -> int:
        '''Returns the right margin in unit of Points'''
        raise NotImplementedError()

    def setAutoSize(self, value : bool) -> None:
        '''Indicates if size of shape is adjusted automatically according to its content.
        :param value: '''
        raise NotImplementedError()

    def setLeftMarginPt(self, value : int) -> None:
        '''Returns the left margin in unit of Points
        :param value: '''
        raise NotImplementedError()

    def getRotateTextWithShape(self) -> bool:
        '''Indicates whether rotating text with shape.'''
        raise NotImplementedError()

    def getAutoSize(self) -> bool:
        '''Indicates if size of shape is adjusted automatically according to its content.'''
        raise NotImplementedError()

    def setTopMarginPt(self, value : int) -> None:
        '''Returns the top margin in unit of Points
        :param value: '''
        raise NotImplementedError()

    def setRotateTextWithShape(self, value : bool) -> None:
        '''Indicates whether rotating text with shape.
        :param value: '''
        raise NotImplementedError()

    def getBottomMarginPt(self) -> int:
        '''Returns the bottom margin in unit of Points'''
        raise NotImplementedError()

    def isAutoMargin(self) -> bool:
        '''Indicates whether the margin is auto calculated.'''
        raise NotImplementedError()


class MultipleFilterCollection:
    '''Represents the multiple filter collection.'''

    def getMatchBlank(self) -> bool:
        '''Indicates whether to filter by blank.'''
        raise NotImplementedError()

    def get(self, index : int) -> Object:
        '''DateTimeGroupItem or a simple object.
        :param index: '''
        raise NotImplementedError()

    def setMatchBlank(self, value : bool) -> None:
        '''Indicates whether to filter by blank.
        :param value: '''
        raise NotImplementedError()

    def add(self, filter : str) -> None:
        '''Adds string filter.
        :param filter: The filter data.'''
        raise NotImplementedError()


class Name:
    '''Represents a defined name for a range of cells.'''

    def getText(self) -> str:
        '''Gets the name text of the object.'''
        raise NotImplementedError()

    @overload
    def getRanges(self) -> list[Range]:
        '''Gets all ranges referred by this name.'''
        raise NotImplementedError()

    @overload
    def getRanges(self, recalculate : bool) -> list[Range]:
        '''Gets all ranges referred by this name.
        :param recalculate: whether recalculate it if this name has been calculated before this invocation.
        :returns: All ranges.'''
        raise NotImplementedError()

    def setR1C1RefersTo(self, value : str) -> None:
        '''Sets a R1C1 reference of the :class:`Name`.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setRefersTo(self, value : str) -> None:
        '''Returns or sets the formula that the name is defined to refer to, beginning with an equal sign.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setRefersTo(self, refersTo : str, isR1C1 : bool, isLocal : bool) -> None:
        '''Set the reference of this Name.
        :param refersTo: The reference.
        :param isR1C1: Whether the reference is R1C1 format.
        :param isLocal: Whether the reference is locale formatted.'''
        raise NotImplementedError()

    def isReferred(self) -> bool:
        '''Indicates whether this name is referred by other formulas.'''
        raise NotImplementedError()

    def getComment(self) -> str:
        '''Gets the comment of the name.
        Only applies for Excel 2007 or higher versions.'''
        raise NotImplementedError()

    def getFullText(self) -> str:
        '''Gets the name  full text of the object with the scope setting.'''
        raise NotImplementedError()

    def getSheetIndex(self) -> int:
        '''Indicates this name belongs to Workbook or Worksheet.
        0 = Global name, otherwise index to sheet (one-based)'''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Indicates whether the name is visible.'''
        raise NotImplementedError()

    def setSheetIndex(self, value : int) -> None:
        '''Indicates this name belongs to Workbook or Worksheet.
        0 = Global name, otherwise index to sheet (one-based)
        :param value: '''
        raise NotImplementedError()

    def setComment(self, value : str) -> None:
        '''Sets the comment of the name.
        Only applies for Excel 2007 or higher versions.
        :param value: '''
        raise NotImplementedError()

    def toString(self) -> str:
        '''Returns a string represents the current Range object.'''
        raise NotImplementedError()

    def setVisible(self, value : bool) -> None:
        '''Indicates whether the name is visible.
        :param value: '''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''Gets the name text of the object.
        :param value: '''
        raise NotImplementedError()

    def getReferredAreas(self, recalculate : bool) -> list[ReferredArea]:
        '''Gets all references referred by this name.
        :param recalculate: whether recalculate it if this name has been calculated before this invocation.
        :returns: All ranges.'''
        raise NotImplementedError()

    @overload
    def getRange(self) -> Range:
        '''Gets the range if this name refers to a range.'''
        raise NotImplementedError()

    @overload
    def getRange(self, recalculate : bool) -> Range:
        '''Gets the range if this name refers to a range
        :param recalculate: whether recalculate it if this name has been calculated before this invocation.
        :returns: The range.'''
        raise NotImplementedError()

    @overload
    def getRange(self, sheetIndex : int, row : int, column : int) -> Range:
        '''Gets the range if this name refers to a range.
        If the reference of this name is not absolute, the range may be different for different cell.
        :param sheetIndex: The according sheet index.
        :param row: The according row index.
        :param column: The according column index
        :returns: The range.'''
        raise NotImplementedError()

    @overload
    def getRefersTo(self) -> str:
        '''Returns or sets the formula that the name is defined to refer to, beginning with an equal sign.'''
        raise NotImplementedError()

    @overload
    def getRefersTo(self, isR1C1 : bool, isLocal : bool) -> str:
        '''Get the reference of this Name.
        :param isR1C1: Whether the reference needs to be formatted as R1C1.
        :param isLocal: Whether the reference needs to be formatted by locale.'''
        raise NotImplementedError()

    @overload
    def getRefersTo(self, isR1C1 : bool, isLocal : bool, row : int, column : int) -> str:
        '''Get the reference of this Name based on specified cell.
        :param isR1C1: Whether the reference needs to be formatted as R1C1.
        :param isLocal: Whether the reference needs to be formatted by locale.
        :param row: The row index of the cell.
        :param column: The column index of the cell.'''
        raise NotImplementedError()

    def getR1C1RefersTo(self) -> str:
        '''Gets a R1C1 reference of the :class:`Name`.'''
        raise NotImplementedError()


class NameCollection:
    '''Represents a collection of all the :class:`Name` objects in the spreadsheet.'''

    def clear(self) -> None:
        '''Remove all defined names which are not referenced by the formulas and data source.
        If the defined name is referred, we only set Name.ReferTo as null and hide them.'''
        raise NotImplementedError()

    @overload
    def remove(self, names : list[str]) -> None:
        '''Remove an array of name
        :param names: The names' text.'''
        raise NotImplementedError()

    @overload
    def remove(self, text : str) -> None:
        '''Remove the name.
        :param text: The name text.'''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Remove the name at the specific index.
        :param index: index of the Name to be removed.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> Name:
        '''Gets the :class:`Name` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def get(self, text : str) -> Name:
        '''Gets the :class:`Name` element with the specified name.
        :param text: Name text.
        :returns: The element with the specified name.'''
        raise NotImplementedError()

    def sort(self) -> None:
        '''Sorts defined names.'''
        raise NotImplementedError()

    def removeDuplicateNames(self) -> None:
        '''Remove the duplicate defined names'''
        raise NotImplementedError()

    def filter(self, type : int, sheetIndex : int) -> list[Name]:
        '''Gets all defined name by scope.
        :param type: :class:`NameScopeType`. The scope type.
        :param sheetIndex: '''
        raise NotImplementedError()

    def add(self, text : str) -> int:
        '''Defines a new name.
        :param text: The text to use as the name.
        :returns: :class:`Name` object index.'''
        raise NotImplementedError()


class NameScopeType:
    '''Represents the scope type of defined names.'''

    ALL : NameScopeType
    '''All defined names.'''

    WORKBOOK : NameScopeType
    '''The defined names in the workbook.'''

    WORKSHEET : NameScopeType
    '''The defined names in a worksheet or all worksheets.'''


class NaryEquationNode:
    '''This class specifies an n-ary operator equation consisting of an n-ary operator, a base (or operand), and optional upper and lower bounds.'''

    def setNaryGrow(self, value : bool) -> None:
        '''This attribute specifies the growth property of n-ary operators at the document level. When off, n-ary operators such as integrals and summations do not grow to match the size of their operand height. When on, the n-ary operator grows vertically to match its operand height.
        :param value: '''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()

    def getNaryGrow(self) -> bool:
        '''This attribute specifies the growth property of n-ary operators at the document level. When off, n-ary operators such as integrals and summations do not grow to match the size of their operand height. When on, the n-ary operator grows vertically to match its operand height.'''
        raise NotImplementedError()

    def getNaryOperatorType(self) -> int:
        '''an n-ary operator.e.g "?
        See :class:`EquationMathematicalOperatorType`'''
        raise NotImplementedError()

    def setNaryOperator(self, value : str) -> None:
        '''an n-ary operator.e.g "?.
        It is strongly recommended to use attribute NaryOperatorType to set n-ary operator.
        Use this property setting if you cannot find the character you need in a known type.
        :param value: '''
        raise NotImplementedError()

    def setHideSubscript(self, value : bool) -> None:
        '''Whether to display the lower bound
        :param value: '''
        raise NotImplementedError()

    def isHideSubscript(self) -> bool:
        '''Whether to display the lower bound'''
        raise NotImplementedError()

    def setLimitLocation(self, value : int) -> None:
        '''This attribute specifies the location of limits in n-ary operators. Limits can be either centered above and below the n-ary operator, or positioned just to the right of the operator.
        See :class:`EquationLimitLocationType`
        :param value: '''
        raise NotImplementedError()

    def setHideSuperscript(self, value : bool) -> None:
        '''Whether to display the upper bound
        :param value: '''
        raise NotImplementedError()

    def getNaryOperator(self) -> str:
        '''an n-ary operator.e.g "?.
        It is strongly recommended to use attribute NaryOperatorType to set n-ary operator.
        Use this property setting if you cannot find the character you need in a known type.'''
        raise NotImplementedError()

    def setNaryOperatorType(self, value : int) -> None:
        '''an n-ary operator.e.g "?
        See :class:`EquationMathematicalOperatorType`
        :param value: '''
        raise NotImplementedError()

    def getLimitLocation(self) -> int:
        '''This attribute specifies the location of limits in n-ary operators. Limits can be either centered above and below the n-ary operator, or positioned just to the right of the operator.
        See :class:`EquationLimitLocationType`'''
        raise NotImplementedError()

    def isHideSuperscript(self) -> bool:
        '''Whether to display the upper bound'''
        raise NotImplementedError()


class NegativeBarFormat:
    '''Represents the color settings of the data bars for negative values that are defined by a data bar conditional formatting rule.'''

    def getBorderColor(self) -> Color:
        '''Gets a FormatColor object that you can use to specify the border color for negative data bars.'''
        raise NotImplementedError()

    def setColor(self, value : Color) -> None:
        '''Sets a FormatColor object that you can use to specify the fill color for negative data bars.
        :param value: '''
        raise NotImplementedError()

    def setColorType(self, value : int) -> None:
        '''Sets whether to use the same fill color as positive data bars.
        See :class:`DataBarNegativeColorType`
        :param value: '''
        raise NotImplementedError()

    def getBorderColorType(self) -> int:
        '''Gets whether to use the same border color as positive data bars.
        See :class:`DataBarNegativeColorType`'''
        raise NotImplementedError()

    def setBorderColor(self, value : Color) -> None:
        '''Sets a FormatColor object that you can use to specify the border color for negative data bars.
        :param value: '''
        raise NotImplementedError()

    def getColor(self) -> Color:
        '''Gets a FormatColor object that you can use to specify the fill color for negative data bars.'''
        raise NotImplementedError()

    def setBorderColorType(self, value : int) -> None:
        '''Gets whether to use the same border color as positive data bars.
        See :class:`DataBarNegativeColorType`
        :param value: '''
        raise NotImplementedError()

    def getColorType(self) -> int:
        '''Gets whether to use the same fill color as positive data bars.
        See :class:`DataBarNegativeColorType`'''
        raise NotImplementedError()


class NoneBulletValue:
    '''Represents no bullet.'''

    def getType(self) -> int:
        '''Gets the type of the bullet's value.
        See :class:`BulletType`'''
        raise NotImplementedError()


class NoneFill:
    '''Represents no fill.'''


class NumberCategoryType:
    '''Represents category type of cell's number formatting.'''

    GENERAL : NumberCategoryType
    '''General'''

    TEXT : NumberCategoryType
    '''Text'''

    NUMBER : NumberCategoryType
    '''Number'''

    DATE : NumberCategoryType
    '''Date or Date and Time'''

    TIME : NumberCategoryType
    '''Time'''

    FRACTION : NumberCategoryType
    '''Fraction'''

    SCIENTIFIC : NumberCategoryType
    '''Scientific'''


class NumbersLoadOptions:
    '''Represents the options of loading Apple Numbers files.'''

    def getLoadTableType(self) -> int:
        '''Gets the type of loading multiple tables in one worksheet.
        See :class:`LoadNumbersTableType`'''
        raise NotImplementedError()

    def setLoadTableType(self, value : int) -> None:
        '''Sets the type of loading multiple tables in one worksheet.
        See :class:`LoadNumbersTableType`
        :param value: '''
        raise NotImplementedError()


class OdsCellField:
    '''Represents the cell field of ods.'''

    def getColumn(self) -> int:
        '''Gets the column index of the cell.'''
        raise NotImplementedError()

    def setFieldType(self, value : int) -> None:
        '''Sets the type of the field.
        See :class:`OdsCellFieldType`
        :param value: '''
        raise NotImplementedError()

    def getCustomFormat(self) -> str:
        '''Represents the custom format of the field's value.'''
        raise NotImplementedError()

    def setColumn(self, value : int) -> None:
        '''Sets the column index of the cell.
        :param value: '''
        raise NotImplementedError()

    def setRow(self, value : int) -> None:
        '''Sets the row index of the cell.
        :param value: '''
        raise NotImplementedError()

    def setCustomFormat(self, value : str) -> None:
        '''Represents the custom format of the field's value.
        :param value: '''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets the row index of the cell.'''
        raise NotImplementedError()

    def getFieldType(self) -> int:
        '''Gets the type of the field.
        See :class:`OdsCellFieldType`'''
        raise NotImplementedError()


class OdsCellFieldCollection:
    '''Represents the fields of ODS.'''

    def updateFieldsValue(self) -> None:
        '''Update fields value to the cells.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> OdsCellField:
        '''Gets the field by the index.
        :param index: The index.'''
        raise NotImplementedError()

    @overload
    def get(self, row : int, column : int) -> OdsCellField:
        '''Gets the field by row and column index.
        :param row: The row index.
        :param column: The column index.'''
        raise NotImplementedError()

    def add(self, row : int, column : int, fieldType : int, format : str) -> int:
        '''Adds a field.
        :param row: The row index.
        :param column: The column index.
        :param fieldType: :class:`OdsCellFieldType`. The type of the field.
        :param format: The number format of the field.'''
        raise NotImplementedError()


class OdsCellFieldType:
    '''Represents the cell field type of ods.'''

    DATE : OdsCellFieldType
    '''Current date.'''

    SHEET_NAME : OdsCellFieldType
    '''The name of the sheet.'''

    TITLE : OdsCellFieldType
    '''The name of the file.'''


class OdsGeneratorType:
    '''Represents the type of ODS generator.'''

    LIBRE_OFFICE : OdsGeneratorType
    '''Libre Office'''

    OPEN_OFFICE : OdsGeneratorType
    '''Open Office'''


class OdsLoadOptions:
    '''Represents the options of loading ods file.'''

    def setClassicPivotTable(self, value : bool) -> None:
        '''Indicates whether the pivot table is classic.
        :param value: '''
        raise NotImplementedError()

    def setRefreshPivotTables(self, value : bool) -> None:
        '''Indicates whether refresh pivot tables when loading file.
        :param value: '''
        raise NotImplementedError()

    def setApplyExcelDefaultStyleToHyperlink(self, value : bool) -> None:
        '''Indicates whether applying the default style of the Excel to hyperlink.
        :param value: '''
        raise NotImplementedError()

    def getRefreshPivotTables(self) -> bool:
        '''Indicates whether refresh pivot tables when loading file.'''
        raise NotImplementedError()

    def getApplyExcelDefaultStyleToHyperlink(self) -> bool:
        '''Indicates whether applying the default style of the Excel to hyperlink.'''
        raise NotImplementedError()

    def isClassicPivotTable(self) -> bool:
        '''Indicates whether the pivot table is classic.'''
        raise NotImplementedError()


class OdsPageBackground:
    '''Represents the page background of ods.'''

    def setGraphicData(self, value : list[int]) -> None:
        '''Sets the graphic data.
        :param value: '''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets the page background type.
        See :class:`OdsPageBackgroundType`
        :param value: '''
        raise NotImplementedError()

    def getGraphicPositionType(self) -> int:
        '''Gets the background graphic position.
        See :class:`OdsPageBackgroundGraphicPositionType`'''
        raise NotImplementedError()

    def isLink(self) -> bool:
        '''Indicates whether it's a linked graphic.'''
        raise NotImplementedError()

    def setGraphicType(self, value : int) -> None:
        '''Sets the page background graphic type.
        See :class:`OdsPageBackgroundGraphicType`
        :param value: '''
        raise NotImplementedError()

    def setGraphicPositionType(self, value : int) -> None:
        '''Sets the background graphic position.
        See :class:`OdsPageBackgroundGraphicPositionType`
        :param value: '''
        raise NotImplementedError()

    def getGraphicData(self) -> list[int]:
        '''Gets the graphic data.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the page background type.
        See :class:`OdsPageBackgroundType`'''
        raise NotImplementedError()

    def setLinkedGraphic(self, value : str) -> None:
        '''Sets the linked graphic path.
        :param value: '''
        raise NotImplementedError()

    def getGraphicType(self) -> int:
        '''Gets the page background graphic type.
        See :class:`OdsPageBackgroundGraphicType`'''
        raise NotImplementedError()

    def setColor(self, value : Color) -> None:
        '''Sets the color of background.
        :param value: '''
        raise NotImplementedError()

    def getColor(self) -> Color:
        '''Gets the color of background.'''
        raise NotImplementedError()

    def getLinkedGraphic(self) -> str:
        '''Gets the linked graphic path.'''
        raise NotImplementedError()


class OdsPageBackgroundGraphicPositionType:
    '''Represents the position.'''

    TOP_LEFT : OdsPageBackgroundGraphicPositionType
    '''Top left.'''

    TOP_CENTER : OdsPageBackgroundGraphicPositionType
    '''Top center.'''

    TOP_RIGHT : OdsPageBackgroundGraphicPositionType
    '''Top right.'''

    CENTER_LEFT : OdsPageBackgroundGraphicPositionType
    '''Center left.'''

    CENTER_CENTER : OdsPageBackgroundGraphicPositionType
    '''Center.'''

    CENTER_RIGHT : OdsPageBackgroundGraphicPositionType
    '''Center right.'''

    BOTTOM_LEFT : OdsPageBackgroundGraphicPositionType
    '''Bottom left.'''

    BOTTOM_CENTER : OdsPageBackgroundGraphicPositionType
    '''Bottom center.'''

    BOTTOM_RIGHT : OdsPageBackgroundGraphicPositionType
    '''Bottom right.'''


class OdsPageBackgroundGraphicType:
    '''Represents the type of formatting page background with image.'''

    POSITION : OdsPageBackgroundGraphicType
    '''Set the image at specific position.'''

    AREA : OdsPageBackgroundGraphicType
    '''Stretch the image.'''

    TILE : OdsPageBackgroundGraphicType
    '''Repeat and repeat the image.'''


class OdsPageBackgroundType:
    '''Represents the page background type of ods.'''

    NONE : OdsPageBackgroundType
    '''No background.'''

    COLOR : OdsPageBackgroundType
    '''Formats the background with color.'''

    GRAPHIC : OdsPageBackgroundType
    '''Formats the background with image.'''


class OdsSaveOptions:
    '''Represents the options of saving ods file.'''

    def getOdfStrictVersion(self) -> int:
        '''Gets the ODF version.
        See :class:`OpenDocumentFormatVersionType`'''
        raise NotImplementedError()

    def setStrictSchema11(self, value : bool) -> None:
        ''':deprecated: Use OdsSaveOptions.OdfStrictVersion property instead.'''
        raise NotImplementedError()

    def isStrictSchema11(self) -> bool:
        ''':deprecated: Use OdsSaveOptions.OdfStrictVersion property instead.'''
        raise NotImplementedError()

    def getGeneratorType(self) -> int:
        '''Gets the generator of the ods file.
        See :class:`OdsGeneratorType`'''
        raise NotImplementedError()

    def setOdfStrictVersion(self, value : int) -> None:
        '''Sets the ODF version.
        See :class:`OpenDocumentFormatVersionType`
        :param value: '''
        raise NotImplementedError()

    def setGeneratorType(self, value : int) -> None:
        '''Sets the generator of the ods file.
        See :class:`OdsGeneratorType`
        :param value: '''
        raise NotImplementedError()

    def getIgnorePivotTables(self) -> bool:
        '''Indicates whether saving pivot tables.'''
        raise NotImplementedError()

    def setIgnorePivotTables(self, value : bool) -> None:
        '''Indicates whether saving pivot tables.
        :param value: '''
        raise NotImplementedError()


class OLEDBCommandType:
    '''Specifies the OLE DB command type.'''

    NONE : OLEDBCommandType
    '''The command type is not specified.'''

    CUBE_NAME : OLEDBCommandType
    '''Specifies a cube name'''

    SQL_STATEMENT : OLEDBCommandType
    '''Specifies a SQL statement'''

    TABLE_NAME : OLEDBCommandType
    '''Specifies a table name'''

    DEFAULT_INFORMATION : OLEDBCommandType
    '''Specifies that default information has been given, and it is up to the provider how to interpret.'''

    WEB_BASED_LIST : OLEDBCommandType
    '''Specifies a query which is against a web based List Data Provider.'''

    TABLE_COLLECTION : OLEDBCommandType
    '''Specifies the table list.'''


class OleObject:
    '''Represents an OleObject in a worksheet.'''

    def getImageData(self) -> list[int]:
        '''Represents image of ole object as byte array.'''
        raise NotImplementedError()

    def getFileFormatType(self) -> int:
        '''Gets the file type of the embedded ole object data
        See :class:`FileFormatType`'''
        raise NotImplementedError()

    def setDisplayAsIcon(self, value : bool) -> None:
        '''True if the specified object is displayed as an icon
        and the image will not be auto changed.
        :param value: '''
        raise NotImplementedError()

    def setNativeSourceFullName(self, sourceFullName : str) -> None:
        '''Sets the ole native source full file name with path.
        :param sourceFullName: the ole native source full file name'''
        raise NotImplementedError()

    def getAutoLoad(self) -> bool:
        '''Specifies whether the host application for the embedded object shall be called to load
        the object data automatically when the parent workbook is opened.'''
        raise NotImplementedError()

    def getFullObjectBin(self) -> list[int]:
        '''Gets the full embedded ole object binary data in the template file.'''
        raise NotImplementedError()

    def isAutoSize(self) -> bool:
        '''True indicates that the size of the ole object will be auto changed as the size of snapshot of the embedded content
        when the ole object is activated.'''
        raise NotImplementedError()

    def getImageType(self) -> int:
        '''Gets the image format of the ole object.
        See :meth:`ImageOrPrintOptions.getImageType()`'''
        raise NotImplementedError()

    def setImageSourceFullName(self, value : str) -> None:
        '''Sets the path and name of the source file for the linked image.
        :param value: '''
        raise NotImplementedError()

    def isLink(self) -> bool:
        '''Returns true if the OleObject links to the file.'''
        raise NotImplementedError()

    def setAutoLoad(self, value : bool) -> None:
        '''Specifies whether the host application for the embedded object shall be called to load
        the object data automatically when the parent workbook is opened.
        :param value: '''
        raise NotImplementedError()

    def setAutoUpdate(self, value : bool) -> None:
        '''Specifies whether the link to the OleObject is automatically updated or not.
        :param value: '''
        raise NotImplementedError()

    def getSourceFullName(self) -> str:
        ''':deprecated: Use OleObject.ObjectSourceFullName property instead.'''
        raise NotImplementedError()

    def setImageData(self, value : list[int]) -> None:
        '''Represents image of ole object as byte array.
        :param value: '''
        raise NotImplementedError()

    def getObjectData(self) -> list[int]:
        '''Represents embedded ole object data as byte array.'''
        raise NotImplementedError()

    def setLink(self, value : bool) -> None:
        '''Returns true if the OleObject links to the file.
        :param value: '''
        raise NotImplementedError()

    def setAutoSize(self, value : bool) -> None:
        '''True indicates that the size of the ole object will be auto changed as the size of snapshot of the embedded content
        when the ole object is activated.
        :param value: '''
        raise NotImplementedError()

    def setFileFormatType(self, value : int) -> None:
        '''Sets the file type of the embedded ole object data
        See :class:`FileFormatType`
        :param value: '''
        raise NotImplementedError()

    def setProgID(self, value : str) -> None:
        '''Sets the ProgID of the OLE object.
        :param value: '''
        raise NotImplementedError()

    def setObjectData(self, value : list[int]) -> None:
        '''Represents embedded ole object data as byte array.
        :param value: '''
        raise NotImplementedError()

    def getObjectSourceFullName(self) -> str:
        '''Returns the source full name of the source file for the linked OLE object.'''
        raise NotImplementedError()

    def setClassIdentifier(self, value : list[int]) -> None:
        '''Sets the class identifier of the embedded object.
        It means which application opens the embedded file.
        :param value: '''
        raise NotImplementedError()

    def getAutoUpdate(self) -> bool:
        '''Specifies whether the link to the OleObject is automatically updated or not.'''
        raise NotImplementedError()

    def setLabel(self, value : str) -> None:
        '''Sets the display label of the linked ole object.
        :param value: '''
        raise NotImplementedError()

    def getLabel(self) -> str:
        '''Gets the display label of the linked ole object.'''
        raise NotImplementedError()

    @overload
    def setEmbeddedObject(self, linkToFile : bool, objectData : list[int], sourceFileName : str, displayAsIcon : bool, label : str) -> None:
        '''Sets embedded object data.
        :param linkToFile: Indicates whether the object links to the file. If true, the parameter objectData is ignored.
        :param objectData: The embedded object data.
        :param sourceFileName: The file name.
        :param displayAsIcon: Indicates whether diplaying object as an icon.
        :param label: The icon label. Only works when displayAsIcon as true.'''
        raise NotImplementedError()

    @overload
    def setEmbeddedObject(self, linkToFile : bool, objectData : list[int], sourceFileName : str, displayAsIcon : bool, label : str, updateIcon : bool) -> None:
        '''Sets embedded object data.
        :param linkToFile: Indicates whether the object links to the file. If true, the parameter objectData is ignored.
        :param objectData: The embedded object data.
        :param sourceFileName: The file name.
        :param displayAsIcon: Indicates whether diplaying object as an icon.
        :param label: The icon label. Only works when displayAsIcon as true.
        :param updateIcon: Indicates whether automatically updating icon.'''
        raise NotImplementedError()

    def getClassIdentifier(self) -> list[int]:
        '''Gets the class identifier of the embedded object.
        It means which application opens the embedded file.'''
        raise NotImplementedError()

    def getProgID(self) -> str:
        '''Gets the ProgID of the OLE object.'''
        raise NotImplementedError()

    def getDisplayAsIcon(self) -> bool:
        '''True if the specified object is displayed as an icon
        and the image will not be auto changed.'''
        raise NotImplementedError()

    def setSourceFullName(self, value : str) -> None:
        ''':deprecated: Use OleObject.ObjectSourceFullName property instead.'''
        raise NotImplementedError()

    def setObjectSourceFullName(self, value : str) -> None:
        '''Returns the source full name of the source file for the linked OLE object.
        :param value: '''
        raise NotImplementedError()

    def getImageSourceFullName(self) -> str:
        '''Gets the path and name of the source file for the linked image.'''
        raise NotImplementedError()


class OleObjectCollection:
    '''Represents embedded OLE objects.'''

    def clear(self) -> None:
        '''Remove all embedded OLE objects.'''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Removes the element at the specified index.
        :param index: The specified index.'''
        raise NotImplementedError()

    def get(self, index : int) -> OleObject:
        '''Gets the :class:`OleObject` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def add(self, upperLeftRow : int, upperLeftColumn : int, height : int, width : int, imageData : list[int]) -> int:
        '''Adds an OleObject to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param height: Height of oleObject, in unit of pixel.
        :param width: Width of oleObject, in unit of pixel.
        :param imageData: Image of ole object as byte array.
        :returns: :class:`OleObject` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, upperLeftRow : int, upperLeftColumn : int, height : int, width : int, imageData : list[int], linkedFile : str) -> int:
        '''Adds a linked OleObject to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param height: Height of oleObject, in unit of pixel.
        :param width: Width of oleObject, in unit of pixel.
        :param imageData: Image of ole object as byte array.
        :param linkedFile: 
        :returns: :class:`OleObject` object index.'''
        raise NotImplementedError()


class OoxmlCompliance:
    '''Allows to specify which OOXML specification will be used when saving in the Xlsx format.'''

    ECMA_376_2006 : OoxmlCompliance
    '''ECMA-376 1st Edition, 2006.'''

    ISO_29500_2008_STRICT : OoxmlCompliance
    '''ISO/IEC 29500:2008 Strict compliance level.'''


class OoxmlCompressionType:
    '''The Ooxml compression type'''

    LEVEL_1 : OoxmlCompressionType
    '''The fastest but least effective compression.'''

    LEVEL_2 : OoxmlCompressionType
    '''A little slower, but better, than level 1.'''

    LEVEL_3 : OoxmlCompressionType
    '''A little slower, but better, than level 2.'''

    LEVEL_4 : OoxmlCompressionType
    '''A little slower, but better, than level 3.'''

    LEVEL_5 : OoxmlCompressionType
    '''A little slower than level 4, but with better compression.'''

    LEVEL_6 : OoxmlCompressionType
    '''A good balance of speed and compression efficiency.'''

    LEVEL_7 : OoxmlCompressionType
    '''Pretty good compression!'''

    LEVEL_8 : OoxmlCompressionType
    '''Better compression than Level7!'''

    LEVEL_9 : OoxmlCompressionType
    '''The "best" compression, where best means greatest reduction in size of the input data stream.
    This is also the slowest compression.'''


class OoxmlSaveOptions:
    '''Represents the options of saving office open xml file.'''

    def setEmbedOoxmlAsOleObject(self, value : bool) -> None:
        '''Indicates whether embedding Ooxml files of OleObject as ole object.
        :param value: '''
        raise NotImplementedError()

    def setExportCellName(self, value : bool) -> None:
        '''Indicates if export cell name to Excel2007 .xlsx (.xlsm, .xltx, .xltm) file.
        If the output file may be accessed by SQL Server DTS, this value must be true.
        Setting the value to false will highly increase the performance and reduce the file size when creating large file.
        Default value is true.
        :param value: '''
        raise NotImplementedError()

    def setLightCellsDataProvider(self, value : LightCellsDataProvider) -> None:
        '''The data provider for saving workbook in light mode.
        :param value: '''
        raise NotImplementedError()

    def setUpdateZoom(self, value : bool) -> None:
        '''Indicates whether update scaling factor before saving the file
        if the PageSetup.FitToPagesWide and PageSetup.FitToPagesTall properties control how the worksheet is scaled.
        :param value: '''
        raise NotImplementedError()

    def setEnableZip64(self, value : bool) -> None:
        '''Always use ZIP64 extensions when writing zip archives, even when unnecessary.
        :param value: '''
        raise NotImplementedError()

    def getUpdateZoom(self) -> bool:
        '''Indicates whether update scaling factor before saving the file
        if the PageSetup.FitToPagesWide and PageSetup.FitToPagesTall properties control how the worksheet is scaled.'''
        raise NotImplementedError()

    def getCompressionType(self) -> int:
        '''Gets the compression type for ooxml file.
        See :class:`OoxmlCompressionType`'''
        raise NotImplementedError()

    def getExportCellName(self) -> bool:
        '''Indicates if export cell name to Excel2007 .xlsx (.xlsm, .xltx, .xltm) file.
        If the output file may be accessed by SQL Server DTS, this value must be true.
        Setting the value to false will highly increase the performance and reduce the file size when creating large file.
        Default value is true.'''
        raise NotImplementedError()

    def setCompressionType(self, value : int) -> None:
        '''Sets the compression type for ooxml file.
        See :class:`OoxmlCompressionType`
        :param value: '''
        raise NotImplementedError()

    def getLightCellsDataProvider(self) -> LightCellsDataProvider:
        '''The data provider for saving workbook in light mode.'''
        raise NotImplementedError()

    def getEnableZip64(self) -> bool:
        '''Always use ZIP64 extensions when writing zip archives, even when unnecessary.'''
        raise NotImplementedError()

    def getEmbedOoxmlAsOleObject(self) -> bool:
        '''Indicates whether embedding Ooxml files of OleObject as ole object.'''
        raise NotImplementedError()


class OpenDocumentFormatVersionType:
    '''Open Document Format version type.'''

    NONE : OpenDocumentFormatVersionType
    '''None strict.'''

    ODF_11 : OpenDocumentFormatVersionType
    '''ODF Version 1.1'''

    ODF_12 : OpenDocumentFormatVersionType
    '''ODF Version 1.2'''

    ODF_13 : OpenDocumentFormatVersionType
    '''ODF Version 1.3'''


class OperatorType:
    '''Represents the operator type of conditional format and data validation.'''

    BETWEEN : OperatorType
    '''Represents Between operator of conditional format and data validation.'''

    EQUAL : OperatorType
    '''Represents Equal operator of conditional format and data validation.'''

    GREATER_THAN : OperatorType
    '''Represents GreaterThan operator of conditional format and data validation.'''

    GREATER_OR_EQUAL : OperatorType
    '''Represents GreaterOrEqual operator of conditional format and data validation.'''

    LESS_THAN : OperatorType
    '''Represents LessThan operator of conditional format and data validation.'''

    LESS_OR_EQUAL : OperatorType
    '''Represents LessOrEqual operator of conditional format and data validation.'''

    NONE : OperatorType
    '''Represents no comparison.'''

    NOT_BETWEEN : OperatorType
    '''Represents NotBetween operator of conditional format and data validation.'''

    NOT_EQUAL : OperatorType
    '''Represents NotEqual operator of conditional format and data validation.'''


class Outline:
    '''Represents an outline on a worksheet.'''

    def setSummaryColumnRight(self, value : bool) -> None:
        '''Indicates if the summary column will be positioned to the right of the detail columns in the outline.
        :param value: '''
        raise NotImplementedError()

    def getSummaryColumnRight(self) -> bool:
        '''Indicates if the summary column will be positioned to the right of the detail columns in the outline.'''
        raise NotImplementedError()

    def getSummaryRowBelow(self) -> bool:
        '''Indicates if the summary row will be positioned below the detail rows in the outline.'''
        raise NotImplementedError()

    def setSummaryRowBelow(self, value : bool) -> None:
        '''Indicates if the summary row will be positioned below the detail rows in the outline.
        :param value: '''
        raise NotImplementedError()


class Oval:
    '''Represents the oval shape.'''


class PageEndSavingArgs:
    '''Info for a page ends saving process.'''

    def setHasMorePages(self, value : bool) -> None:
        '''Sets a value indicating whether having more pages to be output.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def hasMorePages(self) -> bool:
        '''Gets a value indicating whether having more pages to be output.
        The default value is true.'''
        raise NotImplementedError()


class PageLayoutAlignmentType:
    '''Enumerates page layout alignment types.'''

    BOTTOM : PageLayoutAlignmentType
    '''Represents bottom page layout alignment.'''

    CENTER : PageLayoutAlignmentType
    '''Represents center page layout alignment.'''

    LEFT : PageLayoutAlignmentType
    '''Represents left page layout alignment.'''

    RIGHT : PageLayoutAlignmentType
    '''Represents right page layout alignment.'''

    TOP : PageLayoutAlignmentType
    '''Represents top page layout alignment.'''


class PageOrientationType:
    '''Represents print orientation constants.'''

    LANDSCAPE : PageOrientationType
    '''Landscape orientation'''

    PORTRAIT : PageOrientationType
    '''Portrait orientation'''


class PageSavingArgs:
    '''Info for a page saving process.'''

    def getPageCount(self) -> int:
        '''Total page count.'''
        raise NotImplementedError()

    def getPageIndex(self) -> int:
        '''Current page index, zero based.'''
        raise NotImplementedError()


class PageSetup:
    '''Encapsulates the object that represents the page setup description.
    The PageSetup object contains all page setup options.'''

    def getFirstPageNumber(self) -> int:
        '''Represents the first page number that will be used when this sheet is printed.'''
        raise NotImplementedError()

    def setPicture(self, isFirst : bool, isEven : bool, isHeader : bool, section : int, imageData : list[int]) -> Picture:
        '''Sets an image in the header/footer of a worksheet.
        :param isFirst: Indicates whether setting the picture of first page header/footer.
        :param isEven: Indicates whether setting the picture of even page header/footer.
        :param isHeader: Indicates whether setting the picture of header/footer.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.
        :param imageData: Image data.
        :returns: Returns :class:`Picture` object.'''
        raise NotImplementedError()

    def setRightMargin(self, value : int) -> None:
        '''Represents the size of the right margin, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def setEvenFooter(self, section : int, footerScript : str) -> None:
        '''Sets a script formatting the even page footer of an Excel file.
        Only effect in Excel 2007 when IsHFDiffOddEven is true.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.
        :param footerScript: Footer format script.'''
        raise NotImplementedError()

    def setPrintCopies(self, value : int) -> None:
        '''Sets number of copies to print.
        :param value: '''
        raise NotImplementedError()

    def setPrintHeadings(self, value : bool) -> None:
        '''Represents if row and column headings are printed with this page.
        :param value: '''
        raise NotImplementedError()

    def setPrintTitleColumns(self, value : str) -> None:
        '''Represents the columns that contain the cells to be repeated on the left side of each page.
        :param value: '''
        raise NotImplementedError()

    def isPercentScale(self) -> bool:
        '''If this property is False, the FitToPagesWide and FitToPagesTall properties control how the worksheet is scaled.'''
        raise NotImplementedError()

    def setHeaderMarginInch(self, value : int) -> None:
        '''Represents the distance from the top of the page to the header, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def getOrder(self) -> int:
        '''Represents the order that Microsoft Excel uses to number pages when printing a large worksheet.
        See :class:`PrintOrderType`'''
        raise NotImplementedError()

    def getPaperWidth(self) -> int:
        '''Gets the width of the paper in unit of inches, considered page orientation.'''
        raise NotImplementedError()

    def getRightMargin(self) -> int:
        '''Represents the size of the right margin, in unit of centimeters.'''
        raise NotImplementedError()

    def getHeaderMarginInch(self) -> int:
        '''Represents the distance from the top of the page to the header, in unit of inches.'''
        raise NotImplementedError()

    def getPrintHeadings(self) -> bool:
        '''Represents if row and column headings are printed with this page.'''
        raise NotImplementedError()

    def getEvenFooter(self, section : int) -> str:
        '''Gets a script formatting the even footer of an Excel file.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.'''
        raise NotImplementedError()

    def getPrintCopies(self) -> int:
        '''Gets number of copies to print.'''
        raise NotImplementedError()

    def setFooterMargin(self, value : int) -> None:
        '''Represents the distance from the bottom of the page to the footer, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def customPaperSize(self, width : int, height : int) -> None:
        '''Sets the custom paper size, in unit of inches.
        :param width: The width of the paper.
        :param height: The height of the paper.'''
        raise NotImplementedError()

    def getPrintTitleColumns(self) -> str:
        '''Represents the columns that contain the cells to be repeated on the left side of each page.'''
        raise NotImplementedError()

    def setPrintArea(self, value : str) -> None:
        '''Represents the range to be printed.
        :param value: '''
        raise NotImplementedError()

    def setFirstPageFooter(self, section : int, footerScript : str) -> None:
        '''Sets a script formatting the first page footer of an Excel file.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.
        :param footerScript: Footer format script.'''
        raise NotImplementedError()

    def setOrientation(self, value : int) -> None:
        '''Represents page print orientation.
        See :class:`PageOrientationType`
        :param value: '''
        raise NotImplementedError()

    def getBottomMargin(self) -> int:
        '''Represents the size of the bottom margin, in unit of centimeters.'''
        raise NotImplementedError()

    def copy(self, source : PageSetup, copyOptions : CopyOptions) -> None:
        '''Copies the setting of the page setup.
        :param source: The source.
        :param copyOptions: The copy options.'''
        raise NotImplementedError()

    def getPrintArea(self) -> str:
        '''Represents the range to be printed.'''
        raise NotImplementedError()

    def getHeader(self, section : int) -> str:
        '''Gets a script formatting the header of an Excel file.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.'''
        raise NotImplementedError()

    def setHeaderPicture(self, section : int, headerPicture : list[int]) -> Picture:
        '''Sets an image in the header of a worksheet.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.
        :param headerPicture: Image data.
        :returns: Returns :class:`Picture` object.'''
        raise NotImplementedError()

    def setBottomMargin(self, value : int) -> None:
        '''Represents the size of the bottom margin, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def isAutomaticPaperSize(self) -> bool:
        '''Indicates whether the paper size is automatic.'''
        raise NotImplementedError()

    def isHFDiffOddEven(self) -> bool:
        '''True means that the header/footer of the odd pages is different with odd pages.'''
        raise NotImplementedError()

    def getLeftMarginInch(self) -> int:
        '''Represents the size of the left margin, in unit of inches.'''
        raise NotImplementedError()

    def setPaperSize(self, value : int) -> None:
        '''Represents the size of the paper.
        See :class:`PaperSizeType`
        :param value: '''
        raise NotImplementedError()

    def getFirstPageFooter(self, section : int) -> str:
        '''Gets a script formatting the first page footer of an Excel file.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.'''
        raise NotImplementedError()

    def getOrientation(self) -> int:
        '''Represents page print orientation.
        See :class:`PageOrientationType`'''
        raise NotImplementedError()

    def setEvenHeader(self, section : int, headerScript : str) -> None:
        '''Sets a script formatting the even page header of an Excel file.
        Only effect in Excel 2007 when IsHFDiffOddEven is true.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.
        :param headerScript: Header format script.'''
        raise NotImplementedError()

    def getPaperSize(self) -> int:
        '''Represents the size of the paper.
        See :class:`PaperSizeType`'''
        raise NotImplementedError()

    def clearHeaderFooter(self) -> None:
        '''Clears header and footer setting.'''
        raise NotImplementedError()

    def setLeftMarginInch(self, value : int) -> None:
        '''Represents the size of the left margin, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def getCenterHorizontally(self) -> bool:
        '''Represent if the sheet is printed centered horizontally.'''
        raise NotImplementedError()

    def getPrintTitleRows(self) -> str:
        '''Represents the rows that contain the cells to be repeated at the top of each page.'''
        raise NotImplementedError()

    def isHFScaleWithDoc(self) -> bool:
        '''Indicates whether header and footer are scaled with document scaling.
        Only applies for Excel 2007.'''
        raise NotImplementedError()

    def getPrintGridlines(self) -> bool:
        '''Represents if cell gridlines are printed on the page.'''
        raise NotImplementedError()

    def setFitToPages(self, wide : int, tall : int) -> None:
        '''Sets the number of pages the worksheet will be scaled to when it's printed.
        :param wide: Pages wide.
        :param tall: Pages tall.'''
        raise NotImplementedError()

    def setPrinterSettings(self, value : list[int]) -> None:
        '''Sets the settings of the default printer.
        :param value: '''
        raise NotImplementedError()

    def getFitToPagesTall(self) -> int:
        '''Represents  the number of pages tall the worksheet will be scaled to when it's printed.
        The default value is 1.'''
        raise NotImplementedError()

    def getEvenHeader(self, section : int) -> str:
        '''Gets a script formatting the even header of an Excel file.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.'''
        raise NotImplementedError()

    def setPrintTitleRows(self, value : str) -> None:
        '''Represents the rows that contain the cells to be repeated at the top of each page.
        :param value: '''
        raise NotImplementedError()

    def setRightMarginInch(self, value : int) -> None:
        '''Represents the size of the right margin, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def setPrintErrors(self, value : int) -> None:
        '''Specifies the type of print error displayed.
        See :class:`PrintErrorsType`
        :param value: '''
        raise NotImplementedError()

    def setFooter(self, section : int, footerScript : str) -> None:
        '''Sets a script formatting the footer of an Excel file.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.
        :param footerScript: Footer format script.'''
        raise NotImplementedError()

    def setFirstPageHeader(self, section : int, headerScript : str) -> None:
        '''Sets a script formatting the first page header of an Excel file.
        Only effect in Excel 2007 when IsHFDiffFirst is true.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.
        :param headerScript: Header format script.'''
        raise NotImplementedError()

    def getPrintQuality(self) -> int:
        '''Represents the print quality.'''
        raise NotImplementedError()

    def getPrinterSettings(self) -> list[int]:
        '''Gets the settings of the default printer.'''
        raise NotImplementedError()

    def getCommands(self, headerFooterScript : str) -> list[HeaderFooterCommand]:
        '''Gets all commands of header or footer.
        :param headerFooterScript: The header/footer script
        :returns: Returns all commands of header or footer.'''
        raise NotImplementedError()

    def getHeaderMargin(self) -> int:
        '''Represents the distance from the top of the page to the header, in unit of centimeters.'''
        raise NotImplementedError()

    def setPrintGridlines(self, value : bool) -> None:
        '''Represents if cell gridlines are printed on the page.
        :param value: '''
        raise NotImplementedError()

    def setPrintDraft(self, value : bool) -> None:
        '''Represents if the sheet will be printed without graphics.
        :param value: '''
        raise NotImplementedError()

    def setHFScaleWithDoc(self, value : bool) -> None:
        '''Indicates whether header and footer are scaled with document scaling.
        Only applies for Excel 2007.
        :param value: '''
        raise NotImplementedError()

    def isHFDiffFirst(self) -> bool:
        '''True means that the header/footer of the first page is different with other pages.'''
        raise NotImplementedError()

    def getFitToPagesWide(self) -> int:
        '''Represents the number of pages wide the worksheet will be scaled to when it's printed.
        The default value is 1.'''
        raise NotImplementedError()

    def getPrintErrors(self) -> int:
        '''Specifies the type of print error displayed.
        See :class:`PrintErrorsType`'''
        raise NotImplementedError()

    def setFooterMarginInch(self, value : int) -> None:
        '''Represents the distance from the bottom of the page to the footer, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def getRightMarginInch(self) -> int:
        '''Represents the size of the right margin, in unit of inches.'''
        raise NotImplementedError()

    @overload
    def getPicture(self, isHeader : bool, section : int) -> Picture:
        '''Gets the :class:`Picture` object of the header / footer.
        :param isHeader: Indicates whether it is in the header or footer.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.
        :returns: Returns :class:`Picture` object. Returns null if there is no picture.'''
        raise NotImplementedError()

    @overload
    def getPicture(self, isFirst : bool, isEven : bool, isHeader : bool, section : int) -> Picture:
        '''Gets the :class:`Picture` object of the header / footer.
        :param isFirst: Indicates whether getting the picture of first page header/footer.
        :param isEven: Indicates whether getting the picture of even page header/footer.
        :param isHeader: Indicates whether getting the picture of header/footer.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.
        :returns: Returns :class:`Picture` object.'''
        raise NotImplementedError()

    def setFitToPagesTall(self, value : int) -> None:
        '''Represents  the number of pages tall the worksheet will be scaled to when it's printed.
        The default value is 1.
        :param value: '''
        raise NotImplementedError()

    def getFirstPageHeader(self, section : int) -> str:
        '''Gets a script formatting the first page header of an Excel file.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.'''
        raise NotImplementedError()

    def setZoom(self, value : int) -> None:
        '''Represents the scaling factor in percent. It should be between 10 and 400.
        :param value: '''
        raise NotImplementedError()

    def isHFAlignMargins(self) -> bool:
        '''Indicates whether header and footer margins are aligned with the page margins.
        If this property is true, the left header and footer will be aligned with the left margin,
        and the right header and footer will be aligned with the right margin.
        This option is enabled by default.'''
        raise NotImplementedError()

    def setHeaderMargin(self, value : int) -> None:
        '''Represents the distance from the top of the page to the header, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def setOrder(self, value : int) -> None:
        '''Represents the order that Microsoft Excel uses to number pages when printing a large worksheet.
        See :class:`PrintOrderType`
        :param value: '''
        raise NotImplementedError()

    def getPaperHeight(self) -> int:
        '''Gets the height of the paper in unit of inches , considered page orientation.'''
        raise NotImplementedError()

    def getFooterMarginInch(self) -> int:
        '''Represents the distance from the bottom of the page to the footer, in unit of inches.'''
        raise NotImplementedError()

    def setAutoFirstPageNumber(self, value : bool) -> None:
        '''Indicates whether the first the page number is automatically assigned.
        :param value: '''
        raise NotImplementedError()

    def getPrintDraft(self) -> bool:
        '''Represents if the sheet will be printed without graphics.'''
        raise NotImplementedError()

    def setBlackAndWhite(self, value : bool) -> None:
        '''Represents if elements of the document will be printed in black and white.
        :param value: '''
        raise NotImplementedError()

    def setPrintQuality(self, value : int) -> None:
        '''Represents the print quality.
        :param value: '''
        raise NotImplementedError()

    def setCenterVertically(self, value : bool) -> None:
        '''Represent if the sheet is printed centered vertically.
        :param value: '''
        raise NotImplementedError()

    def setLeftMargin(self, value : int) -> None:
        '''Represents the size of the left margin, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def setTopMargin(self, value : int) -> None:
        '''Represents the size of the top margin, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def getODSPageBackground(self) -> OdsPageBackground:
        '''Gets the background of ODS.'''
        raise NotImplementedError()

    def setHFAlignMargins(self, value : bool) -> None:
        '''Indicates whether header and footer margins are aligned with the page margins.
        If this property is true, the left header and footer will be aligned with the left margin,
        and the right header and footer will be aligned with the right margin.
        This option is enabled by default.
        :param value: '''
        raise NotImplementedError()

    def setBottomMarginInch(self, value : int) -> None:
        '''Represents the size of the bottom margin, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def getZoom(self) -> int:
        '''Represents the scaling factor in percent. It should be between 10 and 400.'''
        raise NotImplementedError()

    def setFitToPagesWide(self, value : int) -> None:
        '''Represents the number of pages wide the worksheet will be scaled to when it's printed.
        The default value is 1.
        :param value: '''
        raise NotImplementedError()

    def getCenterVertically(self) -> bool:
        '''Represent if the sheet is printed centered vertically.'''
        raise NotImplementedError()

    def getBlackAndWhite(self) -> bool:
        '''Represents if elements of the document will be printed in black and white.'''
        raise NotImplementedError()

    def isAutoFirstPageNumber(self) -> bool:
        '''Indicates whether the first the page number is automatically assigned.'''
        raise NotImplementedError()

    def getBottomMarginInch(self) -> int:
        '''Represents the size of the bottom margin, in unit of inches.'''
        raise NotImplementedError()

    def setFirstPageNumber(self, value : int) -> None:
        '''Represents the first page number that will be used when this sheet is printed.
        :param value: '''
        raise NotImplementedError()

    def getLeftMargin(self) -> int:
        '''Represents the size of the left margin, in unit of centimeters.'''
        raise NotImplementedError()

    def setHeader(self, section : int, headerScript : str) -> None:
        '''Sets a script formatting the header of an Excel file.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.
        :param headerScript: Header format script.'''
        raise NotImplementedError()

    def getPrintComments(self) -> int:
        '''Represents the way comments are printed with the sheet.
        See :class:`PrintCommentsType`'''
        raise NotImplementedError()

    def getTopMarginInch(self) -> int:
        '''Represents the size of the top margin, in unit of inches.'''
        raise NotImplementedError()

    def setPrintComments(self, value : int) -> None:
        '''Represents the way comments are printed with the sheet.
        See :class:`PrintCommentsType`
        :param value: '''
        raise NotImplementedError()

    def setTopMarginInch(self, value : int) -> None:
        '''Represents the size of the top margin, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def setCenterHorizontally(self, value : bool) -> None:
        '''Represent if the sheet is printed centered horizontally.
        :param value: '''
        raise NotImplementedError()

    def setHFDiffFirst(self, value : bool) -> None:
        '''True means that the header/footer of the first page is different with other pages.
        :param value: '''
        raise NotImplementedError()

    def setFooterPicture(self, section : int, footerPicture : list[int]) -> Picture:
        '''Sets an image in the footer of a worksheet.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.
        :param footerPicture: Image data.
        :returns: Returns :class:`Picture` object.'''
        raise NotImplementedError()

    def getTopMargin(self) -> int:
        '''Represents the size of the top margin, in unit of centimeters.'''
        raise NotImplementedError()

    def getFooter(self, section : int) -> str:
        '''Gets a script formatting the footer of an Excel file.
        :param section: 0: Left Section, 1: Center Section, 2: Right Section.'''
        raise NotImplementedError()

    def setHFDiffOddEven(self, value : bool) -> None:
        '''True means that the header/footer of the odd pages is different with odd pages.
        :param value: '''
        raise NotImplementedError()

    def setPercentScale(self, value : bool) -> None:
        '''If this property is False, the FitToPagesWide and FitToPagesTall properties control how the worksheet is scaled.
        :param value: '''
        raise NotImplementedError()

    def getFooterMargin(self) -> int:
        '''Represents the distance from the bottom of the page to the footer, in unit of centimeters.'''
        raise NotImplementedError()


class PageStartSavingArgs:
    '''Info for a page starts saving process.'''

    def isToOutput(self) -> bool:
        '''Gets a value indicating whether the page should be output.
        The default value is true.'''
        raise NotImplementedError()

    def setToOutput(self, value : bool) -> None:
        '''Sets a value indicating whether the page should be output.
        The default value is true.
        :param value: '''
        raise NotImplementedError()


class PaginatedSaveOptions:
    '''Represents the options for pagination.'''

    def setDrawObjectEventHandler(self, value : DrawObjectEventHandler) -> None:
        '''Implements this interface to get DrawObject and Bound when rendering.
        :param value: '''
        raise NotImplementedError()

    def getOutputBlankPageWhenNothingToPrint(self) -> bool:
        '''Indicates whether to output a blank page when there is nothing to print.'''
        raise NotImplementedError()

    def getDefaultEditLanguage(self) -> int:
        '''Gets default edit language.
        See :class:`DefaultEditLanguage`'''
        raise NotImplementedError()

    def setCheckFontCompatibility(self, value : bool) -> None:
        '''Indicates whether to check font compatibility for every character in text.
        :param value: '''
        raise NotImplementedError()

    def setEmfRenderSetting(self, value : int) -> None:
        '''Setting for rendering Emf metafile.
        See :class:`EmfRenderSetting`
        :param value: '''
        raise NotImplementedError()

    def getCheckWorkbookDefaultFont(self) -> bool:
        '''When characters in the Excel are Unicode and not be set with correct font in cell style,
        They may appear as block in pdf,image.
        Set this to true to try to use workbook's default font to show these characters first.'''
        raise NotImplementedError()

    def getPageIndex(self) -> int:
        '''Gets the 0-based index of the first page to save.'''
        raise NotImplementedError()

    def setOnePagePerSheet(self, value : bool) -> None:
        '''If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
        The paper size of pagesetup will be invalid, and the other settings of pagesetup
        will still take effect.
        :param value: '''
        raise NotImplementedError()

    def getGridlineType(self) -> int:
        '''Gets gridline type.
        See :class:`GridlineType`'''
        raise NotImplementedError()

    def getAllColumnsInOnePagePerSheet(self) -> bool:
        '''If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
        The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
        will still take effect.'''
        raise NotImplementedError()

    def setTextCrossType(self, value : int) -> None:
        '''Sets displaying text type when the text width is larger than cell width.
        See :class:`TextCrossType`
        :param value: '''
        raise NotImplementedError()

    def setPageSavingCallback(self, value : IPageSavingCallback) -> None:
        '''Control/Indicate progress of page saving process.
        :param value: '''
        raise NotImplementedError()

    def getDefaultFont(self) -> str:
        '''When characters in the Excel are Unicode and not be set with correct font in cell style,
        They may appear as block in pdf,image.
        Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
        If this property is not set, Aspose.Cells will use system default font to show these unicode characters.'''
        raise NotImplementedError()

    def getEmfRenderSetting(self) -> int:
        '''Setting for rendering Emf metafile.
        See :class:`EmfRenderSetting`'''
        raise NotImplementedError()

    def setPrintingPageType(self, value : int) -> None:
        '''Indicates which pages will not be printed.
        See :class:`PrintingPageType`
        :param value: '''
        raise NotImplementedError()

    def getPageCount(self) -> int:
        '''Gets the number of pages to save.'''
        raise NotImplementedError()

    def getDrawObjectEventHandler(self) -> DrawObjectEventHandler:
        '''Implements this interface to get DrawObject and Bound when rendering.'''
        raise NotImplementedError()

    def getPrintingPageType(self) -> int:
        '''Indicates which pages will not be printed.
        See :class:`PrintingPageType`'''
        raise NotImplementedError()

    def isFontSubstitutionCharGranularity(self) -> bool:
        '''Indicates whether to only substitute the font of character when the cell font is not compatibility for it.'''
        raise NotImplementedError()

    def getCheckFontCompatibility(self) -> bool:
        '''Indicates whether to check font compatibility for every character in text.'''
        raise NotImplementedError()

    def getSheetSet(self) -> SheetSet:
        '''Gets the sheets to render. Default is all visible sheets in the workbook: :meth:`com.aspose.cells.SheetSet.getVisible()`.
        The following code only renders active sheet to pdf.'''
        raise NotImplementedError()

    def setGridlineType(self, value : int) -> None:
        '''Sets gridline type.
        See :class:`GridlineType`
        :param value: '''
        raise NotImplementedError()

    def setCheckWorkbookDefaultFont(self, value : bool) -> None:
        '''When characters in the Excel are Unicode and not be set with correct font in cell style,
        They may appear as block in pdf,image.
        Set this to true to try to use workbook's default font to show these characters first.
        :param value: '''
        raise NotImplementedError()

    def getPageSavingCallback(self) -> IPageSavingCallback:
        '''Control/Indicate progress of page saving process.'''
        raise NotImplementedError()

    def setPageIndex(self, value : int) -> None:
        '''Sets the 0-based index of the first page to save.
        :param value: '''
        raise NotImplementedError()

    def setAllColumnsInOnePagePerSheet(self, value : bool) -> None:
        '''If AllColumnsInOnePagePerSheet is true , all column content of one sheet will output to only one page in result.
        The width of paper size of pagesetup will be ignored, and the other settings of pagesetup
        will still take effect.
        :param value: '''
        raise NotImplementedError()

    def getTextCrossType(self) -> int:
        '''Gets displaying text type when the text width is larger than cell width.
        See :class:`TextCrossType`'''
        raise NotImplementedError()

    def setSheetSet(self, value : SheetSet) -> None:
        '''Sets the sheets to render. Default is all visible sheets in the workbook: :meth:`com.aspose.cells.SheetSet.getVisible()`.
        :param value: '''
        raise NotImplementedError()

    def setIgnoreError(self, value : bool) -> None:
        '''Indicates if you need to hide the error while rendering.
        The error can be error in shape, image, chart rendering, etc.
        :param value: '''
        raise NotImplementedError()

    def setPageCount(self, value : int) -> None:
        '''Sets the number of pages to save.
        :param value: '''
        raise NotImplementedError()

    def setDefaultEditLanguage(self, value : int) -> None:
        '''Sets default edit language.
        See :class:`DefaultEditLanguage`
        :param value: '''
        raise NotImplementedError()

    def getOnePagePerSheet(self) -> bool:
        '''If OnePagePerSheet is true , all content of one sheet will output to only one page in result.
        The paper size of pagesetup will be invalid, and the other settings of pagesetup
        will still take effect.'''
        raise NotImplementedError()

    def setFontSubstitutionCharGranularity(self, value : bool) -> None:
        '''Indicates whether to only substitute the font of character when the cell font is not compatibility for it.
        :param value: '''
        raise NotImplementedError()

    def setDefaultFont(self, value : str) -> None:
        '''When characters in the Excel are Unicode and not be set with correct font in cell style,
        They may appear as block in pdf,image.
        Set the DefaultFont such as MingLiu or MS Gothic to show these characters.
        If this property is not set, Aspose.Cells will use system default font to show these unicode characters.
        :param value: '''
        raise NotImplementedError()

    def getIgnoreError(self) -> bool:
        '''Indicates if you need to hide the error while rendering.
        The error can be error in shape, image, chart rendering, etc.'''
        raise NotImplementedError()

    def setOutputBlankPageWhenNothingToPrint(self, value : bool) -> None:
        '''Indicates whether to output a blank page when there is nothing to print.
        :param value: '''
        raise NotImplementedError()


class PaneCollection:
    '''Represents all Pane objects shown in the specified window.'''

    def getFirstVisibleRowOfBottomPane(self) -> int:
        '''Gets the first visible row of the bottom pane.'''
        raise NotImplementedError()

    def setFirstVisibleColumnOfRightPane(self, value : int) -> None:
        '''Sets the first visible column of the right pane.
        :param value: '''
        raise NotImplementedError()

    def setFirstVisibleRowOfBottomPane(self, value : int) -> None:
        '''Sets the first visible row of the bottom pane.
        :param value: '''
        raise NotImplementedError()

    def getAcitvePaneType(self) -> int:
        '''Gets the active pane.
        See :class:`RectangleAlignmentType`'''
        raise NotImplementedError()

    def getFirstVisibleColumnOfRightPane(self) -> int:
        '''Gets the first visible column of the right pane.'''
        raise NotImplementedError()

    def setAcitvePaneType(self, value : int) -> None:
        '''Sets the active pane.
        See :class:`RectangleAlignmentType`
        :param value: '''
        raise NotImplementedError()


class PaneStateType:
    '''Represents state of the sheet's pane.'''

    FROZEN : PaneStateType
    '''Panes are frozen, but were not before being frozen.'''

    FROZEN_SPLIT : PaneStateType
    '''Panes are frozen and were split before being frozen.'''

    SPLIT : PaneStateType
    '''Panes are split, but not frozen.'''

    NORMAL : PaneStateType
    '''Panes are not frozen and not split.'''


class PaperSizeType:
    '''Represents paper size constants.'''

    PAPER_LETTER : PaperSizeType
    '''Letter (8-1/2 in. x 11 in.)'''

    PAPER_LETTER_SMALL : PaperSizeType
    '''Letter Small (8-1/2 in. x 11 in.)'''

    PAPER_TABLOID : PaperSizeType
    '''Tabloid (11 in. x 17 in.)'''

    PAPER_LEDGER : PaperSizeType
    '''Ledger (17 in. x 11 in.)'''

    PAPER_LEGAL : PaperSizeType
    '''Legal (8-1/2 in. x 14 in.)'''

    PAPER_STATEMENT : PaperSizeType
    '''Statement (5-1/2 in. x 8-1/2 in.)'''

    PAPER_EXECUTIVE : PaperSizeType
    '''Executive (7-1/4 in. x 10-1/2 in.)'''

    PAPER_A_3 : PaperSizeType
    '''A3 (297 mm x 420 mm)'''

    PAPER_A_4 : PaperSizeType
    '''A4 (210 mm x 297 mm)'''

    PAPER_A_4_SMALL : PaperSizeType
    '''A4 Small (210 mm x 297 mm)'''

    PAPER_A_5 : PaperSizeType
    '''A5 (148 mm x 210 mm)'''

    PAPER_B_4 : PaperSizeType
    '''JIS B4 (257 mm x 364 mm)'''

    PAPER_B_5 : PaperSizeType
    '''JIS B5 (182 mm x 257 mm)'''

    PAPER_FOLIO : PaperSizeType
    '''Folio (8-1/2 in. x 13 in.)'''

    PAPER_QUARTO : PaperSizeType
    '''Quarto (215 mm x 275 mm)'''

    PAPER_10_X_14 : PaperSizeType
    '''10 in. x 14 in.'''

    PAPER_11_X_17 : PaperSizeType
    '''11 in. x 17 in.'''

    PAPER_NOTE : PaperSizeType
    '''Note (8-1/2 in. x 11 in.)'''

    PAPER_ENVELOPE_9 : PaperSizeType
    '''Envelope #9 (3-7/8 in. x 8-7/8 in.)'''

    PAPER_ENVELOPE_10 : PaperSizeType
    '''Envelope #10 (4-1/8 in. x 9-1/2 in.)'''

    PAPER_ENVELOPE_11 : PaperSizeType
    '''Envelope #11 (4-1/2 in. x 10-3/8 in.)'''

    PAPER_ENVELOPE_12 : PaperSizeType
    '''Envelope #12 (4-1/2 in. x 11 in.)'''

    PAPER_ENVELOPE_14 : PaperSizeType
    '''Envelope #14 (5 in. x 11-1/2 in.)'''

    PAPER_C_SHEET : PaperSizeType
    '''C size sheet'''

    PAPER_D_SHEET : PaperSizeType
    '''D size sheet'''

    PAPER_E_SHEET : PaperSizeType
    '''E size sheet'''

    PAPER_ENVELOPE_DL : PaperSizeType
    '''Envelope DL (110 mm x 220 mm)'''

    PAPER_ENVELOPE_C_5 : PaperSizeType
    '''Envelope C5 (162 mm x 229 mm)'''

    PAPER_ENVELOPE_C_3 : PaperSizeType
    '''Envelope C3 (324 mm x 458 mm)'''

    PAPER_ENVELOPE_C_4 : PaperSizeType
    '''Envelope C4 (229 mm x 324 mm)'''

    PAPER_ENVELOPE_C_6 : PaperSizeType
    '''Envelope C6 (114 mm x 162 mm)'''

    PAPER_ENVELOPE_C_65 : PaperSizeType
    '''Envelope C65 (114 mm x 229 mm)'''

    PAPER_ENVELOPE_B_4 : PaperSizeType
    '''Envelope B4 (250 mm x 353 mm)'''

    PAPER_ENVELOPE_B_5 : PaperSizeType
    '''Envelope B5 (176 mm x 250 mm)'''

    PAPER_ENVELOPE_B_6 : PaperSizeType
    '''Envelope B6 (176 mm x 125 mm)'''

    PAPER_ENVELOPE_ITALY : PaperSizeType
    '''Envelope Italy (110 mm x 230 mm)'''

    PAPER_ENVELOPE_MONARCH : PaperSizeType
    '''Envelope Monarch (3-7/8 in. x 7-1/2 in.)'''

    PAPER_ENVELOPE_PERSONAL : PaperSizeType
    '''Envelope (3-5/8 in. x 6-1/2 in.)'''

    PAPER_FANFOLD_US : PaperSizeType
    '''U.S. Standard Fanfold (14-7/8 in. x 11 in.)'''

    PAPER_FANFOLD_STD_GERMAN : PaperSizeType
    '''German Standard Fanfold (8-1/2 in. x 12 in.)'''

    PAPER_FANFOLD_LEGAL_GERMAN : PaperSizeType
    '''German Legal Fanfold (8-1/2 in. x 13 in.)'''

    PAPER_ISOB_4 : PaperSizeType
    '''B4 (ISO) 250 x 353 mm'''

    PAPER_JAPANESE_POSTCARD : PaperSizeType
    '''Japanese Postcard (100mm  148mm)'''

    PAPER_9_X_11 : PaperSizeType
    '''9?  11?'''

    PAPER_10_X_11 : PaperSizeType
    '''10?  11?'''

    PAPER_15_X_11 : PaperSizeType
    '''15?  11?'''

    PAPER_ENVELOPE_INVITE : PaperSizeType
    '''Envelope Invite(220mm  220mm)'''

    PAPER_LETTER_EXTRA : PaperSizeType
    '''US Letter Extra 9 \275 x 12 in'''

    PAPER_LEGAL_EXTRA : PaperSizeType
    '''US Legal Extra 9 \275 x 15 in'''

    PAPER_TABLOID_EXTRA : PaperSizeType
    '''US Tabloid Extra 11.69 x 18 in'''

    PAPER_A_4_EXTRA : PaperSizeType
    '''A4 Extra 9.27 x 12.69 in'''

    PAPER_LETTER_TRANSVERSE : PaperSizeType
    '''Letter Transverse 8 \275 x 11 in'''

    PAPER_A_4_TRANSVERSE : PaperSizeType
    '''A4 Transverse 210 x 297 mm'''

    PAPER_LETTER_EXTRA_TRANSVERSE : PaperSizeType
    '''Letter Extra Transverse 9\275 x 12 in'''

    PAPER_SUPER_A : PaperSizeType
    '''SuperA/SuperA/A4 227 x 356 mm'''

    PAPER_SUPER_B : PaperSizeType
    '''SuperB/SuperB/A3 305 x 487 mm'''

    PAPER_LETTER_PLUS : PaperSizeType
    '''US Letter Plus 8.5 x 12.69 in'''

    PAPER_A_4_PLUS : PaperSizeType
    '''A4 Plus 210 x 330 mm'''

    PAPER_A_5_TRANSVERSE : PaperSizeType
    '''A5 Transverse 148 x 210 mm'''

    PAPER_JISB_5_TRANSVERSE : PaperSizeType
    '''B5 (JIS) Transverse 182 x 257 mm'''

    PAPER_A_3_EXTRA : PaperSizeType
    '''A3 Extra 322 x 445 mm'''

    PAPER_A_5_EXTRA : PaperSizeType
    '''A5 Extra 174 x 235 mm'''

    PAPER_ISOB_5_EXTRA : PaperSizeType
    '''B5 (ISO) Extra 201 x 276 mm'''

    PAPER_A_2 : PaperSizeType
    '''A2 420 x 594 mm'''

    PAPER_A_3_TRANSVERSE : PaperSizeType
    '''A3 Transverse 297 x 420 mm'''

    PAPER_A_3_EXTRA_TRANSVERSE : PaperSizeType
    '''A3 Extra Transverse 322 x 445 mm'''

    PAPER_JAPANESE_DOUBLE_POSTCARD : PaperSizeType
    '''Japanese Double Postcard 200 x 148 mm'''

    PAPER_A_6 : PaperSizeType
    '''A6 105 x 148 mm'''

    PAPER_JAPANESE_ENVELOPE_KAKU_2 : PaperSizeType
    '''Japanese Envelope Kaku #2'''

    PAPER_JAPANESE_ENVELOPE_KAKU_3 : PaperSizeType
    '''Japanese Envelope Kaku #3'''

    PAPER_JAPANESE_ENVELOPE_CHOU_3 : PaperSizeType
    '''Japanese Envelope Chou #3'''

    PAPER_JAPANESE_ENVELOPE_CHOU_4 : PaperSizeType
    '''Japanese Envelope Chou #4'''

    PAPER_LETTER_ROTATED : PaperSizeType
    '''11in  8.5in'''

    PAPER_A_3_ROTATED : PaperSizeType
    '''420mm  297mm'''

    PAPER_A_4_ROTATED : PaperSizeType
    '''297mm  210mm'''

    PAPER_A_5_ROTATED : PaperSizeType
    '''210mm  148mm'''

    PAPER_JISB_4_ROTATED : PaperSizeType
    '''B4 (JIS) Rotated 364 x 257 mm'''

    PAPER_JISB_5_ROTATED : PaperSizeType
    '''B5 (JIS) Rotated 257 x 182 mm'''

    PAPER_JAPANESE_POSTCARD_ROTATED : PaperSizeType
    '''Japanese Postcard Rotated 148 x 100 mm'''

    PAPER_JAPANESE_DOUBLE_POSTCARD_ROTATED : PaperSizeType
    '''Double Japanese Postcard Rotated 148 x 200 mm'''

    PAPER_A_6_ROTATED : PaperSizeType
    '''A6 Rotated 148 x 105 mm'''

    PAPER_JAPANESE_ENVELOPE_KAKU_2_ROTATED : PaperSizeType
    '''Japanese Envelope Kaku #2 Rotated'''

    PAPER_JAPANESE_ENVELOPE_KAKU_3_ROTATED : PaperSizeType
    '''Japanese Envelope Kaku #3 Rotated'''

    PAPER_JAPANESE_ENVELOPE_CHOU_3_ROTATED : PaperSizeType
    '''Japanese Envelope Chou #3 Rotated'''

    PAPER_JAPANESE_ENVELOPE_CHOU_4_ROTATED : PaperSizeType
    '''Japanese Envelope Chou #4 Rotated'''

    PAPER_JISB_6 : PaperSizeType
    '''B6 (JIS) 128 x 182 mm'''

    PAPER_JISB_6_ROTATED : PaperSizeType
    '''B6 (JIS) Rotated 182 x 128 mm'''

    PAPER_12_X_11 : PaperSizeType
    '''12 x 11 in'''

    PAPER_JAPANESE_ENVELOPE_YOU_4 : PaperSizeType
    '''Japanese Envelope You #4'''

    PAPER_JAPANESE_ENVELOPE_YOU_4_ROTATED : PaperSizeType
    '''Japanese Envelope You #4 Rotated'''

    PAPER_PRC_16_K : PaperSizeType
    '''PRC 16K 146 x 215 mm'''

    PAPER_PRC_32_K : PaperSizeType
    '''PRC 32K 97 x 151 mm'''

    PAPER_PRC_BIG_32_K : PaperSizeType
    '''PRC 32K(Big) 97 x 151 mm'''

    PAPER_PRC_ENVELOPE_1 : PaperSizeType
    '''PRC Envelope #1 102 x 165 mm'''

    PAPER_PRC_ENVELOPE_2 : PaperSizeType
    '''PRC Envelope #2 102 x 176 mm'''

    PAPER_PRC_ENVELOPE_3 : PaperSizeType
    '''PRC Envelope #3 125 x 176 mm'''

    PAPER_PRC_ENVELOPE_4 : PaperSizeType
    '''PRC Envelope #4 110 x 208 mm'''

    PAPER_PRC_ENVELOPE_5 : PaperSizeType
    '''PRC Envelope #5 110 x 220 mm'''

    PAPER_PRC_ENVELOPE_6 : PaperSizeType
    '''PRC Envelope #6 120 x 230 mm'''

    PAPER_PRC_ENVELOPE_7 : PaperSizeType
    '''PRC Envelope #7 160 x 230 mm'''

    PAPER_PRC_ENVELOPE_8 : PaperSizeType
    '''PRC Envelope #8 120 x 309 mm'''

    PAPER_PRC_ENVELOPE_9 : PaperSizeType
    '''PRC Envelope #9 229 x 324 mm'''

    PAPER_PRC_ENVELOPE_10 : PaperSizeType
    '''PRC Envelope #10 324 x 458 mm'''

    PAPER_PRC_16_K_ROTATED : PaperSizeType
    '''PRC 16K Rotated'''

    PAPER_PRC_32_K_ROTATED : PaperSizeType
    '''PRC 32K Rotated'''

    PAPER_PRC_BIG_32_K_ROTATED : PaperSizeType
    '''PRC 32K(Big) Rotated'''

    PAPER_PRC_ENVELOPE_1_ROTATED : PaperSizeType
    '''PRC Envelope #1 Rotated 165 x 102 mm'''

    PAPER_PRC_ENVELOPE_2_ROTATED : PaperSizeType
    '''PRC Envelope #2 Rotated 176 x 102 mm'''

    PAPER_PRC_ENVELOPE_3_ROTATED : PaperSizeType
    '''PRC Envelope #3 Rotated 176 x 125 mm'''

    PAPER_PRC_ENVELOPE_4_ROTATED : PaperSizeType
    '''PRC Envelope #4 Rotated 208 x 110 mm'''

    PAPER_PRC_ENVELOPE_5_ROTATED : PaperSizeType
    '''PRC Envelope #5 Rotated 220 x 110 mm'''

    PAPER_PRC_ENVELOPE_6_ROTATED : PaperSizeType
    '''PRC Envelope #6 Rotated 230 x 120 mm'''

    PAPER_PRC_ENVELOPE_7_ROTATED : PaperSizeType
    '''PRC Envelope #7 Rotated 230 x 160 mm'''

    PAPER_PRC_ENVELOPE_8_ROTATED : PaperSizeType
    '''PRC Envelope #8 Rotated 309 x 120 mm'''

    PAPER_PRC_ENVELOPE_9_ROTATED : PaperSizeType
    '''PRC Envelope #9 Rotated 324 x 229 mm'''

    PAPER_PRC_ENVELOPE_10_ROTATED : PaperSizeType
    '''PRC Envelope #10 Rotated 458 x 324 mm'''

    PAPER_B_3 : PaperSizeType
    '''usual B3(13.9 x 19.7 in)'''

    PAPER_BUSINESS_CARD : PaperSizeType
    '''Business Card(90mm x 55 mm)'''

    PAPER_THERMAL : PaperSizeType
    '''Thermal(3 x 11 in)'''

    CUSTOM : PaperSizeType
    '''Represents the custom paper size.'''


class ParameterType:
    '''Represents all parameters' type or return value type of function.'''

    REFERENCE : ParameterType
    ''''''

    VALUE : ParameterType
    ''''''

    ARRAY : ParameterType
    ''''''


class PasteOperationType:
    '''Represents operation type when pasting range.'''

    NONE : PasteOperationType
    '''No operation.'''

    ADD : PasteOperationType
    '''Add'''

    SUBTRACT : PasteOperationType
    '''Subtract'''

    MULTIPLY : PasteOperationType
    '''Multiply'''

    DIVIDE : PasteOperationType
    '''Divide'''


class PasteOptions:
    '''Represents the paste special options.'''

    def getSkipBlanks(self) -> bool:
        '''Indicates whether skips blank cells.'''
        raise NotImplementedError()

    def getTranspose(self) -> bool:
        '''True to transpose rows and columns when the range is pasted. The default value is False.'''
        raise NotImplementedError()

    def setPasteType(self, value : int) -> None:
        '''The paste special type.
        See :class:`PasteType`
        :param value: '''
        raise NotImplementedError()

    def setSkipBlanks(self, value : bool) -> None:
        '''Indicates whether skips blank cells.
        :param value: '''
        raise NotImplementedError()

    def getOnlyVisibleCells(self) -> bool:
        '''True means only copying visible cells.'''
        raise NotImplementedError()

    def setOperationType(self, value : int) -> None:
        '''Sets the operation type when pasting range.
        See :class:`PasteOperationType`
        :param value: '''
        raise NotImplementedError()

    def getPasteType(self) -> int:
        '''The paste special type.
        See :class:`PasteType`'''
        raise NotImplementedError()

    def setTranspose(self, value : bool) -> None:
        '''True to transpose rows and columns when the range is pasted. The default value is False.
        :param value: '''
        raise NotImplementedError()

    def getOperationType(self) -> int:
        '''Gets the operation type when pasting range.
        See :class:`PasteOperationType`'''
        raise NotImplementedError()

    def setIgnoreLinksToOriginalFile(self, value : bool) -> None:
        '''Ingore links to the original file.
        :param value: '''
        raise NotImplementedError()

    def getIgnoreLinksToOriginalFile(self) -> bool:
        '''Ingore links to the original file.'''
        raise NotImplementedError()

    def setOnlyVisibleCells(self, value : bool) -> None:
        '''True means only copying visible cells.
        :param value: '''
        raise NotImplementedError()


class PasteType:
    '''Represents the paste special type.'''

    ALL : PasteType
    '''Copies all data of the range.'''

    DEFAULT : PasteType
    '''It works as "All" behavior of MS Excel.'''

    ALL_EXCEPT_BORDERS : PasteType
    '''Copies all data of the range without the range.'''

    DEFAULT_EXCEPT_BORDERS : PasteType
    '''It works as "All except borders" behavior of MS Excel.'''

    COLUMN_WIDTHS : PasteType
    '''Only copies the widths of the range.'''

    ROW_HEIGHTS : PasteType
    '''Only copies the heights of the range.'''

    COMMENTS : PasteType
    ''''''

    FORMATS : PasteType
    ''''''

    FORMULAS : PasteType
    ''''''

    FORMULAS_AND_NUMBER_FORMATS : PasteType
    ''''''

    VALIDATION : PasteType
    ''''''

    VALUES : PasteType
    ''''''

    VALUES_AND_FORMATS : PasteType
    ''''''

    VALUES_AND_NUMBER_FORMATS : PasteType
    ''''''


class PatternFill:
    '''Encapsulates the object that represents pattern fill format'''

    def getBackTransparency(self) -> int:
        '''Gets the transparency of background color.'''
        raise NotImplementedError()

    def setBackgroundCellsColor(self, value : CellsColor) -> None:
        '''Sets the foreground :class:`CellsColor` object.
        :param value: '''
        raise NotImplementedError()

    def setForegroundColor(self, value : Color) -> None:
        '''Sets the foreground :class:`Color`.
        :param value: '''
        raise NotImplementedError()

    def setBackTransparency(self, value : int) -> None:
        '''Sets the transparency of background color.
        :param value: '''
        raise NotImplementedError()

    def getBackgroundCellsColor(self) -> CellsColor:
        '''Gets the foreground :class:`CellsColor` object.'''
        raise NotImplementedError()

    def getForeTransparency(self) -> int:
        '''Gets the transparency of foreground color.'''
        raise NotImplementedError()

    def getForegroundColor(self) -> Color:
        '''Gets the foreground :class:`Color`.'''
        raise NotImplementedError()

    def setPattern(self, value : int) -> None:
        '''Sets the fill pattern type
        See :class:`FillPattern`
        :param value: '''
        raise NotImplementedError()

    def setBackgroundColor(self, value : Color) -> None:
        '''Sets the background :class:`Color` of the :class:`Area`.
        :param value: '''
        raise NotImplementedError()

    def getPattern(self) -> int:
        '''Gets the fill pattern type
        See :class:`FillPattern`'''
        raise NotImplementedError()

    def getBackgroundColor(self) -> Color:
        '''Gets the background :class:`Color` of the :class:`Area`.'''
        raise NotImplementedError()

    def setForegroundCellsColor(self, value : CellsColor) -> None:
        '''Sets the foreground :class:`CellsColor` object.
        :param value: '''
        raise NotImplementedError()

    def getForegroundCellsColor(self) -> CellsColor:
        '''Gets the foreground :class:`CellsColor` object.'''
        raise NotImplementedError()

    def setForeTransparency(self, value : int) -> None:
        '''Sets the transparency of foreground color.
        :param value: '''
        raise NotImplementedError()


class PclSaveOptions:
    '''Represents the options for saving Pcl file.'''

    def addPrinterFont(self, fontFullName : str, fontPclName : str) -> None:
        '''Adds information about font that is already added to the printer by manufacturer.
        :param fontFullName: Full name of the font (e.g. "Times New Roman Bold Italic") used in the source file.
        :param fontPclName: Name of the font that will be used in the output Pcl document.'''
        raise NotImplementedError()


class PdfBookmarkEntry:
    '''PdfBookmarkEntry is an entry in pdf bookmark.
    if Text property of current instance is null or "",
    current instance will be hidden and children will be inserted on current level.'''

    def isOpen(self) -> bool:
        '''When this property is true, the bookmarkentry will expand, otherwise it will collapse.'''
        raise NotImplementedError()

    def setCollapse(self, value : bool) -> None:
        '''When this property is true, the bookmarkentry will collapse, otherwise it will expand.
        :param value: '''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''Title of a bookmark.
        :param value: '''
        raise NotImplementedError()

    def setDestination(self, value : Cell) -> None:
        '''The cell to which the bookmark link.
        :param value: '''
        raise NotImplementedError()

    def isCollapse(self) -> bool:
        '''When this property is true, the bookmarkentry will collapse, otherwise it will expand.'''
        raise NotImplementedError()

    def getDestinationName(self) -> str:
        '''Gets name of destination.'''
        raise NotImplementedError()

    def setDestinationName(self, value : str) -> None:
        '''Sets name of destination.
        :param value: '''
        raise NotImplementedError()

    def setSubEntry(self, value : list) -> None:
        '''SubEntry of a bookmark.
        :param value: '''
        raise NotImplementedError()

    def getSubEntry(self) -> list:
        '''SubEntry of a bookmark.'''
        raise NotImplementedError()

    def getDestination(self) -> Cell:
        '''The cell to which the bookmark link.'''
        raise NotImplementedError()

    def getText(self) -> str:
        '''Title of a bookmark.'''
        raise NotImplementedError()

    def setOpen(self, value : bool) -> None:
        '''When this property is true, the bookmarkentry will expand, otherwise it will collapse.
        :param value: '''
        raise NotImplementedError()


class PdfCompliance:
    '''Allowing user to set PDF conversion's Compatibility'''

    NONE : PdfCompliance
    '''Pdf format compatible with PDF 1.4'''

    PDF_14 : PdfCompliance
    '''Pdf format compatible with PDF 1.4'''

    PDF_15 : PdfCompliance
    '''Pdf format compatible with PDF 1.5'''

    PDF_16 : PdfCompliance
    '''Pdf format compatible with PDF 1.6'''

    PDF_17 : PdfCompliance
    '''Pdf format compatible with PDF 1.7'''

    PDF_A_1_B : PdfCompliance
    '''Pdf format compatible with PDF/A-1b(ISO 19005-1)'''

    PDF_A_1_A : PdfCompliance
    '''Pdf format compatible with PDF/A-1a(ISO 19005-1)'''

    PDF_A_2_B : PdfCompliance
    '''Pdf format compatible with PDF/A-2b(ISO 19005-2)'''

    PDF_A_2_U : PdfCompliance
    '''Pdf format compatible with PDF/A-2u(ISO 19005-2)'''

    PDF_A_2_A : PdfCompliance
    '''Pdf format compatible with PDF/A-2a(ISO 19005-2)'''

    PDF_A_3_B : PdfCompliance
    '''Pdf format compatible with PDF/A-3b(ISO 19005-3)'''

    PDF_A_3_U : PdfCompliance
    '''Pdf format compatible with PDF/A-3u(ISO 19005-3)'''

    PDF_A_3_A : PdfCompliance
    '''Pdf format compatible with PDF/A-3a(ISO 19005-3)'''


class PdfCompressionCore:
    '''Specifies a type of compression applied to all content in the PDF file except images.'''

    NONE : PdfCompressionCore
    '''None'''

    RLE : PdfCompressionCore
    '''Rle'''

    LZW : PdfCompressionCore
    '''Lzw'''

    FLATE : PdfCompressionCore
    '''Flate'''


class PdfCustomPropertiesExport:
    '''Specifies the way :class:`CustomDocumentPropertyCollection` are exported to PDF file.'''

    NONE : PdfCustomPropertiesExport
    '''No custom properties are exported.'''

    STANDARD : PdfCustomPropertiesExport
    '''Custom properties are exported as entries in Info dictionary.'''


class PdfFontEncoding:
    '''Represents pdf embedded font encoding.'''

    IDENTITY : PdfFontEncoding
    '''Represents use Identity-H encoding for all embedded fonts in pdf.'''

    ANSI_PREFER : PdfFontEncoding
    '''Represents prefer to use WinAnsiEncoding for TrueType fonts with characters 32-127,
    otherwise, Identity-H encoding will be used for embedded fonts in pdf.'''


class PdfOptimizationType:
    '''Specifies a type of optimization.'''

    STANDARD : PdfOptimizationType
    '''High print quality'''

    MINIMUM_SIZE : PdfOptimizationType
    '''File size is more important than print quality'''


class PdfSaveOptions:
    '''Represents the options for saving pdf file.'''

    def setWatermark(self, value : RenderingWatermark) -> None:
        '''Sets watermark to output.
        :param value: '''
        raise NotImplementedError()

    def getCalculateFormula(self) -> bool:
        '''Indicates whether to calculate formulas before saving pdf file.'''
        raise NotImplementedError()

    def setCreatedTime(self, value : DateTime) -> None:
        '''Sets the time of generating the pdf document.
        :param value: '''
        raise NotImplementedError()

    def setImageResample(self, desiredPPI : int, jpegQuality : int) -> None:
        '''Sets desired PPI(pixels per inch) of resample images and jpeg quality.
        All images will be converted to JPEG with the specified quality setting,
        and images that are greater than the specified PPI (pixels per inch) will be resampled.
        The following code sets desired PPI as 96 and jpeg quality as 80 for images in the output pdf.
        :param desiredPPI: Desired pixels per inch. 220 high quality. 150 screen quality. 96 email quality.
        :param jpegQuality: 0 - 100% JPEG quality.'''
        raise NotImplementedError()

    def getPdfCompression(self) -> int:
        '''Indicate the compression algorithm
        See :class:`PdfCompressionCore`'''
        raise NotImplementedError()

    def setProducer(self, value : str) -> None:
        '''Sets producer of generated pdf document.
        :param value: '''
        raise NotImplementedError()

    def setPdfCompression(self, value : int) -> None:
        '''Indicate the compression algorithm
        See :class:`PdfCompressionCore`
        :param value: '''
        raise NotImplementedError()

    def setCalculateFormula(self, value : bool) -> None:
        '''Indicates whether to calculate formulas before saving pdf file.
        :param value: '''
        raise NotImplementedError()

    def getCompliance(self) -> int:
        '''Gets the PDF standards compliance level for output documents.
        See :class:`PdfCompliance`'''
        raise NotImplementedError()

    def getImageType(self) -> ImageFormat:
        ''':deprecated: Chart and Shape are always rendered as vector elements(e.g. point, line) for rendering quality.'''
        raise NotImplementedError()

    def getDisplayDocTitle(self) -> bool:
        '''Indicates whether the window's title bar should display the document title.'''
        raise NotImplementedError()

    def setCustomPropertiesExport(self, value : int) -> None:
        '''Sets a value determining the way :class:`CustomDocumentPropertyCollection` are exported to PDF file. Default value is None.
        See :class:`PdfCustomPropertiesExport`
        :param value: '''
        raise NotImplementedError()

    def getBookmark(self) -> PdfBookmarkEntry:
        '''Gets the :class:`PdfBookmarkEntry` object.'''
        raise NotImplementedError()

    def setEmbedStandardWindowsFonts(self, value : bool) -> None:
        '''True to embed true type fonts.
        Affects only ASCII characters 32-127.
        Fonts for character codes greater than 127 are always embedded.
        Fonts are always embedded for PDF/A-1a, PDF/A-1b standard.
        Default is true.
        :param value: '''
        raise NotImplementedError()

    def setCompliance(self, value : int) -> None:
        '''Sets the PDF standards compliance level for output documents.
        See :class:`PdfCompliance`
        :param value: '''
        raise NotImplementedError()

    def setFontEncoding(self, value : int) -> None:
        '''Sets embedded font encoding in pdf.
        See :class:`PdfFontEncoding`
        :param value: '''
        raise NotImplementedError()

    def setBookmark(self, value : PdfBookmarkEntry) -> None:
        '''Sets the :class:`PdfBookmarkEntry` object.
        :param value: '''
        raise NotImplementedError()

    def getCreatedTime(self) -> DateTime:
        '''Gets the time of generating the pdf document.'''
        raise NotImplementedError()

    def getWatermark(self) -> RenderingWatermark:
        '''Gets watermark to output.
        The following code sets watermark in the output pdf.'''
        raise NotImplementedError()

    def setSecurityOptions(self, value : PdfSecurityOptions) -> None:
        '''Set this options, when security is need in xls2pdf result.
        :param value: '''
        raise NotImplementedError()

    def getCustomPropertiesExport(self) -> int:
        '''Gets a value determining the way :class:`CustomDocumentPropertyCollection` are exported to PDF file. Default value is None.
        See :class:`PdfCustomPropertiesExport`'''
        raise NotImplementedError()

    def setOptimizationType(self, value : int) -> None:
        '''Sets pdf optimization type.
        See :class:`PdfOptimizationType`
        :param value: '''
        raise NotImplementedError()

    def getExportDocumentStructure(self) -> bool:
        '''Indicates whether to export document structure.'''
        raise NotImplementedError()

    def getSecurityOptions(self) -> PdfSecurityOptions:
        '''Set this options, when security is need in xls2pdf result.
        The following code sets hight resolution print permisson for the output pdf.'''
        raise NotImplementedError()

    def setDisplayDocTitle(self, value : bool) -> None:
        '''Indicates whether the window's title bar should display the document title.
        :param value: '''
        raise NotImplementedError()

    def getEmbedAttachments(self) -> bool:
        '''Indicates whether to embed attachment for Ole objects in Excel.'''
        raise NotImplementedError()

    def getFontEncoding(self) -> int:
        '''Gets embedded font encoding in pdf.
        See :class:`PdfFontEncoding`'''
        raise NotImplementedError()

    def setImageType(self, value : ImageFormat) -> None:
        ''':deprecated: Chart and Shape are always rendered as vector elements(e.g. point, line) for rendering quality.'''
        raise NotImplementedError()

    def setEmbedAttachments(self, value : bool) -> None:
        '''Indicates whether to embed attachment for Ole objects in Excel.
        :param value: '''
        raise NotImplementedError()

    def setExportDocumentStructure(self, value : bool) -> None:
        '''Indicates whether to export document structure.
        :param value: '''
        raise NotImplementedError()

    def getEmbedStandardWindowsFonts(self) -> bool:
        '''True to embed true type fonts.
        Affects only ASCII characters 32-127.
        Fonts for character codes greater than 127 are always embedded.
        Fonts are always embedded for PDF/A-1a, PDF/A-1b standard.
        Default is true.'''
        raise NotImplementedError()

    def getOptimizationType(self) -> int:
        '''Gets pdf optimization type.
        See :class:`PdfOptimizationType`'''
        raise NotImplementedError()

    def getProducer(self) -> str:
        '''Gets producer of generated pdf document.'''
        raise NotImplementedError()


class PdfSecurityOptions:
    '''Options for encrypting and access permissions for a PDF document.
    PDF/A does not allow security setting.'''

    def setOwnerPassword(self, value : str) -> None:
        '''Sets the owner password for the encrypted PDF document.
        :param value: '''
        raise NotImplementedError()

    def getFillFormsPermission(self) -> bool:
        '''Indicates whether to allow to fill in existing interactive form fields (including signature fields),
        even if :meth:`PdfSecurityOptions.getModifyDocumentPermission()` is clear.'''
        raise NotImplementedError()

    def setExtractContentPermissionObsolete(self, value : bool) -> None:
        ''':deprecated: Use ExtractContentPermission property instead.'''
        raise NotImplementedError()

    def setAssembleDocumentPermission(self, value : bool) -> None:
        '''Indicates whether to allow to assemble the document (insert, rotate, or delete pages and create bookmarks or thumbnail images),
        even if :meth:`PdfSecurityOptions.getModifyDocumentPermission()` is clear.
        :param value: '''
        raise NotImplementedError()

    def setModifyDocumentPermission(self, value : bool) -> None:
        '''Indicates whether to allow to modify the contents of the document by operations other than those controlled
        by :meth:`PdfSecurityOptions.getAnnotationsPermission()`, :meth:`PdfSecurityOptions.getFillFormsPermission()` and :meth:`PdfSecurityOptions.getAssembleDocumentPermission()`.
        :param value: '''
        raise NotImplementedError()

    def setExtractContentPermission(self, value : bool) -> None:
        '''Indicates whether to allow to copy or otherwise extract text and graphics from the document
        by operations other than that controlled by :meth:`PdfSecurityOptions.getAccessibilityExtractContent()`.
        :param value: '''
        raise NotImplementedError()

    def getAccessibilityExtractContent(self) -> bool:
        '''Indicates whether to allow to extract text and graphics (in support of accessibility to users with disabilities or for other purposes).'''
        raise NotImplementedError()

    def setAccessibilityExtractContent(self, value : bool) -> None:
        '''Indicates whether to allow to extract text and graphics (in support of accessibility to users with disabilities or for other purposes).
        :param value: '''
        raise NotImplementedError()

    def getModifyDocumentPermission(self) -> bool:
        '''Indicates whether to allow to modify the contents of the document by operations other than those controlled
        by :meth:`PdfSecurityOptions.getAnnotationsPermission()`, :meth:`PdfSecurityOptions.getFillFormsPermission()` and :meth:`PdfSecurityOptions.getAssembleDocumentPermission()`.'''
        raise NotImplementedError()

    def setFillFormsPermission(self, value : bool) -> None:
        '''Indicates whether to allow to fill in existing interactive form fields (including signature fields),
        even if :meth:`PdfSecurityOptions.getModifyDocumentPermission()` is clear.
        :param value: '''
        raise NotImplementedError()

    def setPrintPermission(self, value : bool) -> None:
        '''Indicates whether to allow to print the document.
        :param value: '''
        raise NotImplementedError()

    def getPrintPermission(self) -> bool:
        '''Indicates whether to allow to print the document.'''
        raise NotImplementedError()

    def getAnnotationsPermission(self) -> bool:
        '''Indicates whether to allow to add or modify text annotations, fill in interactive form fields.'''
        raise NotImplementedError()

    def getFullQualityPrintPermission(self) -> bool:
        '''Indicates whether to allow to print the document to a representation from
        which a faithful digital copy of the PDF content could be generated.'''
        raise NotImplementedError()

    def setAnnotationsPermission(self, value : bool) -> None:
        '''Indicates whether to allow to add or modify text annotations, fill in interactive form fields.
        :param value: '''
        raise NotImplementedError()

    def getAssembleDocumentPermission(self) -> bool:
        '''Indicates whether to allow to assemble the document (insert, rotate, or delete pages and create bookmarks or thumbnail images),
        even if :meth:`PdfSecurityOptions.getModifyDocumentPermission()` is clear.'''
        raise NotImplementedError()

    def getUserPassword(self) -> str:
        '''Gets the user password required for opening the encrypted PDF document.'''
        raise NotImplementedError()

    def getExtractContentPermissionObsolete(self) -> bool:
        ''':deprecated: Use ExtractContentPermission property instead.'''
        raise NotImplementedError()

    def getOwnerPassword(self) -> str:
        '''Gets the owner password for the encrypted PDF document.'''
        raise NotImplementedError()

    def getExtractContentPermission(self) -> bool:
        '''Indicates whether to allow to copy or otherwise extract text and graphics from the document
        by operations other than that controlled by :meth:`PdfSecurityOptions.getAccessibilityExtractContent()`.'''
        raise NotImplementedError()

    def setUserPassword(self, value : str) -> None:
        '''Sets the user password required for opening the encrypted PDF document.
        :param value: '''
        raise NotImplementedError()

    def setFullQualityPrintPermission(self, value : bool) -> None:
        '''Indicates whether to allow to print the document to a representation from
        which a faithful digital copy of the PDF content could be generated.
        :param value: '''
        raise NotImplementedError()


class PicFormatOption:
    '''Represents picture format option'''

    def setType(self, value : int) -> None:
        '''Sets the picture fill type.
        See :class:`FillPictureType`
        :param value: '''
        raise NotImplementedError()

    def getLeft(self) -> int:
        '''Gets the left offset for stretching picture.'''
        raise NotImplementedError()

    def setRight(self, value : int) -> None:
        '''Sets the right offset for stretching picture.
        :param value: '''
        raise NotImplementedError()

    def getTop(self) -> int:
        '''Gets the top offset for stretching picture.'''
        raise NotImplementedError()

    def getRight(self) -> int:
        '''Gets the right offset for stretching picture.'''
        raise NotImplementedError()

    def getBottom(self) -> int:
        '''Gets the bottom offset for stretching picture.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the picture fill type.
        See :class:`FillPictureType`'''
        raise NotImplementedError()

    def setLeft(self, value : int) -> None:
        '''Sets the left offset for stretching picture.
        :param value: '''
        raise NotImplementedError()

    def setScale(self, value : int) -> None:
        '''Sets how many the picture stack and scale with.
        :param value: '''
        raise NotImplementedError()

    def setBottom(self, value : int) -> None:
        '''Sets the bottom offset for stretching picture.
        :param value: '''
        raise NotImplementedError()

    def getScale(self) -> int:
        '''Gets how many the picture stack and scale with.'''
        raise NotImplementedError()

    def setTop(self, value : int) -> None:
        '''Sets the top offset for stretching picture.
        :param value: '''
        raise NotImplementedError()


class Picture:
    '''Encapsulates the object that represents a single picture in a spreadsheet.'''

    def setBorderWeight(self, value : int) -> None:
        '''Sets the weight of the border line of a picture in units of pt.
        :param value: '''
        raise NotImplementedError()

    def getOriginalHeightCM(self) -> int:
        '''Gets the original height of picture, in unit of centimeters.'''
        raise NotImplementedError()

    def isDynamicDataExchange(self) -> bool:
        '''Gets whether dynamic data exchange'''
        raise NotImplementedError()

    def setFormula(self, value : str) -> None:
        '''Sets the data of the formula.
        :param value: '''
        raise NotImplementedError()

    def setDisplayAsIcon(self, value : bool) -> None:
        '''True if the specified object is displayed as an icon
        and the image will not be auto changed.
        :param value: '''
        raise NotImplementedError()

    def getSignatureLine(self) -> SignatureLine:
        '''Gets the signature line'''
        raise NotImplementedError()

    def placeInCell(self) -> None:
        '''Place this picture in the cell'''
        raise NotImplementedError()

    def setData(self, value : list[int]) -> None:
        '''Gets the data of the picture.
        :param value: '''
        raise NotImplementedError()

    def getOriginalHeight(self) -> int:
        '''Gets the original height of the picture.'''
        raise NotImplementedError()

    def isAutoSize(self) -> bool:
        '''True indicates that the size of the ole object will be auto changed as the size of snapshot of the embedded content
        when the ole object is activated.'''
        raise NotImplementedError()

    def getImageType(self) -> int:
        '''Gets the image format of the picture.
        See :meth:`ImageOrPrintOptions.getImageType()`'''
        raise NotImplementedError()

    def getBorderWeight(self) -> int:
        '''Gets the weight of the border line of a picture in units of pt.'''
        raise NotImplementedError()

    def isLink(self) -> bool:
        '''Returns true if the picture is linked to a file.'''
        raise NotImplementedError()

    def setBorderLineColor(self, value : Color) -> None:
        '''Represents the :class:`Color` of the border line of a picture.
        :param value: '''
        raise NotImplementedError()

    def setSignatureLine(self, value : SignatureLine) -> None:
        '''Sets the signature line
        :param value: '''
        raise NotImplementedError()

    def getSourceFullName(self) -> str:
        '''Gets the path and name of the source file for the linked image.'''
        raise NotImplementedError()

    def getData(self) -> list[int]:
        '''Gets the data of the picture.'''
        raise NotImplementedError()

    def getBorderLineColor(self) -> Color:
        '''Represents the :class:`Color` of the border line of a picture.'''
        raise NotImplementedError()

    def setDynamicDataExchange(self, value : bool) -> None:
        '''Sets whether dynamic data exchange
        :param value: '''
        raise NotImplementedError()

    def getOriginalHeightInch(self) -> int:
        '''Gets the original height of picture, in unit of inches.'''
        raise NotImplementedError()

    def getOriginalWidthCM(self) -> int:
        '''Gets the original width of picture, in unit of centimeters.'''
        raise NotImplementedError()

    def setLink(self, value : bool) -> None:
        '''Returns true if the picture is linked to a file.
        :param value: '''
        raise NotImplementedError()

    def setAutoSize(self, value : bool) -> None:
        '''True indicates that the size of the ole object will be auto changed as the size of snapshot of the embedded content
        when the ole object is activated.
        :param value: '''
        raise NotImplementedError()

    def move(self, upperLeftRow : int, upperLeftColumn : int) -> None:
        '''Moves the picture to a specified location.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.'''
        raise NotImplementedError()

    def getOriginalWidthInch(self) -> int:
        '''Gets the original width of picture, in unit of inches.'''
        raise NotImplementedError()

    def copy(self, source : Picture, options : CopyOptions) -> None:
        '''Copy the picture.
        :param source: The source picture.
        :param options: The copy options.'''
        raise NotImplementedError()

    def isSameSetting(self, obj : Object) -> bool:
        '''Returns whether the shape is same.
        :param obj: '''
        raise NotImplementedError()

    def getFormula(self) -> str:
        '''Gets the data of the formula.'''
        raise NotImplementedError()

    def getOriginalWidth(self) -> int:
        '''Gets the original width of the picture.'''
        raise NotImplementedError()

    def getDisplayAsIcon(self) -> bool:
        '''True if the specified object is displayed as an icon
        and the image will not be auto changed.'''
        raise NotImplementedError()

    def setSourceFullName(self, value : str) -> None:
        '''Sets the path and name of the source file for the linked image.
        :param value: '''
        raise NotImplementedError()


class PictureBulletValue:
    '''Represents the value of the image bullet.'''

    def setImageData(self, value : list[int]) -> None:
        '''Sets image data of the bullet.
        :param value: '''
        raise NotImplementedError()

    def getImageData(self) -> list[int]:
        '''Gets image data of the bullet.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the bullet's value.
        See :class:`BulletType`'''
        raise NotImplementedError()


class PictureCollection:
    '''Encapsulates a collection of :class:`Picture` objects.'''

    def clear(self) -> None:
        '''Clear all pictures.'''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Remove shapes at the specific index
        :param index: '''
        raise NotImplementedError()

    def get(self, index : int) -> Picture:
        '''Gets the :class:`Picture` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def add(self, upperLeftRow : int, upperLeftColumn : int, lowerRightRow : int, lowerRightColumn : int, stream : InputStream) -> int:
        '''Adds a picture to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param lowerRightRow: Lower right row index
        :param lowerRightColumn: Lower right column index
        :param stream: Stream object which contains the image data.
        :returns: :class:`Picture` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, upperLeftRow : int, upperLeftColumn : int, lowerRightRow : int, lowerRightColumn : int, fileName : str) -> int:
        '''Adds a picture to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param lowerRightRow: Lower right row index
        :param lowerRightColumn: Lower right column index
        :param fileName: Image filename.
        :returns: :class:`Picture` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, upperLeftRow : int, upperLeftColumn : int, stream : InputStream) -> int:
        '''Adds a picture to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param stream: Stream object which contains the image data.
        :returns: :class:`Picture` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, upperLeftRow : int, upperLeftColumn : int, fileName : str) -> int:
        '''Adds a picture to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param fileName: Image filename.
        :returns: :class:`Picture` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, upperLeftRow : int, upperLeftColumn : int, stream : InputStream, widthScale : int, heightScale : int) -> int:
        '''Adds a picture to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param stream: Stream object which contains the image data.
        :param widthScale: Scale of image width, a percentage.
        :param heightScale: Scale of image height, a percentage.
        :returns: :class:`Picture` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, upperLeftRow : int, upperLeftColumn : int, fileName : str, widthScale : int, heightScale : int) -> int:
        '''Adds a picture to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param fileName: Image filename.
        :param widthScale: Scale of image width, a percentage.
        :param heightScale: Scale of image height, a percentage.
        :returns: :class:`Picture` object index.'''
        raise NotImplementedError()


class PivotArea:
    '''Presents the selected area of the PivotTable.'''

    def setColumnGrandIncluded(self, value : bool) -> None:
        '''Indicates whether the column grand total is included.
        :param value: '''
        raise NotImplementedError()

    def getFilters(self) -> PivotAreaFilterCollection:
        '''Gets all filters for this PivotArea.'''
        raise NotImplementedError()

    def isRowGrandIncluded(self) -> bool:
        '''Indicates whether the row grand total is included.'''
        raise NotImplementedError()

    def setAxisType(self, value : int) -> None:
        '''Sets the region of the PivotTable to which this rule applies.
        See :class:`PivotFieldType`
        :param value: '''
        raise NotImplementedError()

    def getOnlyLabel(self) -> bool:
        '''Indicates whether only the data labels for an item selection are selected.'''
        raise NotImplementedError()

    def getAxisType(self) -> int:
        '''Gets the region of the PivotTable to which this rule applies.
        See :class:`PivotFieldType`'''
        raise NotImplementedError()

    def setOnlyData(self, value : bool) -> None:
        '''Indicates whether only the data values (in the data area of the view) for an item
        selection are selected and does not include the item labels.
        :param value: '''
        raise NotImplementedError()

    def isOutline(self) -> bool:
        '''Indicates whether the rule refers to an area that is in outline mode.'''
        raise NotImplementedError()

    def setRowGrandIncluded(self, value : bool) -> None:
        '''Indicates whether the row grand total is included.
        :param value: '''
        raise NotImplementedError()

    def setOnlyLabel(self, value : bool) -> None:
        '''Indicates whether only the data labels for an item selection are selected.
        :param value: '''
        raise NotImplementedError()

    def setOutline(self, value : bool) -> None:
        '''Indicates whether the rule refers to an area that is in outline mode.
        :param value: '''
        raise NotImplementedError()

    def getOnlyData(self) -> bool:
        '''Indicates whether only the data values (in the data area of the view) for an item
        selection are selected and does not include the item labels.'''
        raise NotImplementedError()

    def setRuleType(self, value : int) -> None:
        '''Sets the type of selection rule.
        See :class:`PivotAreaType`
        :param value: '''
        raise NotImplementedError()

    def select(self, axisType : int, fieldPosition : int, selectionType : int) -> None:
        '''Select the area with filters.
        :param axisType: :class:`PivotFieldType`. The region of the PivotTable to which this rule applies.
        :param fieldPosition: Position of the field within the axis to which this rule applies.
        :param selectionType: :class:`PivotTableSelectionType`. Specifies what can be selected in a PivotTable during a structured selection.'''
        raise NotImplementedError()

    def getRuleType(self) -> int:
        '''Gets the type of selection rule.
        See :class:`PivotAreaType`'''
        raise NotImplementedError()

    def isColumnGrandIncluded(self) -> bool:
        '''Indicates whether the column grand total is included.'''
        raise NotImplementedError()


class PivotAreaFilter:
    '''Represents the filter of :class:`PivotArea` for :class:`PivotTable`.'''

    def getSelected(self) -> bool:
        '''Indicates whether this field has selection.
        Only works when the PivotTable is in Outline view.'''
        raise NotImplementedError()

    def isSubtotalSet(self, subtotalType : int) -> bool:
        '''Gets which subtotal is set for this filter.
        :param subtotalType: :class:`PivotFieldSubtotalType`. The subtotal function type.'''
        raise NotImplementedError()

    def setSubtotals(self, subtotalType : int, shown : bool) -> None:
        '''Subtotal for the filter.
        :param subtotalType: :class:`PivotFieldSubtotalType`. The subtotal function.
        :param shown: Indicates if showing this subtotal data.'''
        raise NotImplementedError()

    def setSelected(self, value : bool) -> None:
        '''Indicates whether this field has selection.
        Only works when the PivotTable is in Outline view.
        :param value: '''
        raise NotImplementedError()


class PivotAreaFilterCollection:
    '''Represents the list of filters for :class:`PivotArea`'''

    def get(self, index : int) -> PivotAreaFilter:
        '''Gets filter from the list by the index.
        :param index: The Index'''
        raise NotImplementedError()


class PivotAreaType:
    '''Indicates the type of rule being used to describe an area or aspect of the PivotTable.'''

    NONE : PivotAreaType
    '''No Pivot area.'''

    NORMAL : PivotAreaType
    '''Represents a header or item.'''

    DATA : PivotAreaType
    '''Represents something in the data area.'''

    ALL : PivotAreaType
    '''Represents the whole PivotTable.'''

    ORIGIN : PivotAreaType
    '''Represents the blank cells at the top-left of the PivotTable (top-right for RTL sheets).'''

    BUTTON : PivotAreaType
    '''Represents a field button.'''

    TOP_RIGHT : PivotAreaType
    '''Represents the blank cells at the top-right of the PivotTable (top-left for RTL sheets).'''


class PivotConditionFormatRuleType:
    '''Represents PivotTable condition formatting rule type.'''

    NONE : PivotConditionFormatRuleType
    '''Indicates that Top N conditional formatting is not evaluated'''

    ALL : PivotConditionFormatRuleType
    '''Indicates that Top N conditional formatting is
    evaluated across the entire scope range.'''

    ROW : PivotConditionFormatRuleType
    '''Indicates that Top N conditional formatting is evaluated for each row.'''

    COLUMN : PivotConditionFormatRuleType
    '''Indicates that Top N conditional formatting is
    evaluated for each column.'''


class PivotConditionFormatScopeType:
    '''Represents PivotTable condition formatting scope type.'''

    DATA : PivotConditionFormatScopeType
    '''Indicates that conditional formatting is applied to the selected data fields.'''

    FIELD : PivotConditionFormatScopeType
    '''Indicates that conditional formatting is applied to the selected PivotTable field intersections.'''

    SELECTION : PivotConditionFormatScopeType
    '''Indicates that conditional formatting is applied to the selected cells.'''


class PivotDateTimeRangeGroupSettings:
    '''Represents the field grouped by date time range.'''

    def getEnd(self) -> DateTime:
        '''Gets the end date time of the group.'''
        raise NotImplementedError()

    def isGroupedBy(self, type : int) -> bool:
        '''Check whether the field is grouped by the type.
        :param type: :class:`PivotGroupByType`. The group type'''
        raise NotImplementedError()

    def getGroupByTypes(self) -> list[int]:
        '''Gets the types of grouping by date time.
        See :class:`PivotGroupByType`'''
        raise NotImplementedError()

    def getStart(self) -> DateTime:
        '''Gets the start date time of the group.'''
        raise NotImplementedError()

    def getInterval(self) -> int:
        '''Gets the internal of the group.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the data time group type.
        See :class:`PivotFieldGroupType`'''
        raise NotImplementedError()


class PivotDiscreteGroupSettings:
    '''Rrepsents the discrete group of pivot field'''

    def getItems(self) -> list[CustomPiovtFieldGroupItem]:
        '''Gets the discrete items.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the group type.
        See :class:`PivotFieldGroupType`'''
        raise NotImplementedError()


class PivotField:
    '''Represents a field in a PivotTable report.'''

    def isHiddenItem(self, index : int) -> bool:
        '''Gets whether the specific PivotItem is hidden.
        :param index: The index of the pivotItem in the pivotField.
        :returns: whether the specific PivotItem is hidden'''
        raise NotImplementedError()

    @overload
    def sortBy(self, sortType : int, fieldSortedBy : int) -> None:
        '''Sorts this pivot field.
        :param sortType: :class:`SortOrder`. The type of sorting this field.
        :param fieldSortedBy: The index of pivot field sorted by.'''
        raise NotImplementedError()

    @overload
    def sortBy(self, sortType : int, fieldSortedBy : int, dataType : int, cellName : str) -> None:
        '''Sorts this pivot field.
        :param sortType: :class:`SortOrder`. The type of sorting this field.
        :param fieldSortedBy: The index of pivot field sorted by.
        :param dataType: :class:`PivotLineType`. The type of data sorted by.
        :param cellName: Sort by values in the row or column'''
        raise NotImplementedError()

    def getPivotFilterByType(self, type : int) -> PivotFilter:
        '''Gets the pivot filter of the pivot field by type
        :param type: '''
        raise NotImplementedError()

    def setRepeatItemLabels(self, value : bool) -> None:
        '''Indicates whether repeating labels of the field in the region.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def setAutoSortField(self, value : int) -> None:
        '''Represents the index of field which is auto sorted.
        -1 means PivotField itself,others means the position of the data fields.
        :param value: '''
        raise NotImplementedError()

    def filterByDate(self, type : int, dateTime1 : DateTime, dateTime2 : DateTime) -> PivotFilter:
        '''Filters by date setting of row or column pivot field.
        :param type: :class:`PivotFilterType`. The type of filtering data.
        :param dateTime1: The date label of filter condition
        :param dateTime2: The upper-bound date label of between filter condition'''
        raise NotImplementedError()

    def setAutoShow(self, value : bool) -> None:
        '''Indicates whether the specified PivotTable field is automatically shown,only valid for excel 2003.
        :param value: '''
        raise NotImplementedError()

    def getNumberFormat(self) -> str:
        '''Represents the custom display format of numbers and dates.'''
        raise NotImplementedError()

    def getAutoSortField(self) -> int:
        '''Represents the index of field which is auto sorted.
        -1 means PivotField itself,others means the position of the data fields.'''
        raise NotImplementedError()

    def setBaseItemPosition(self, value : int) -> None:
        ''':deprecated: Use PivotField.ShowValuesSetting.BaseItemPositionType property instead.'''
        raise NotImplementedError()

    def filterByLabel(self, type : int, label1 : str, label2 : str) -> PivotFilter:
        '''Filters by captions of row or column pivot field.
        :param type: :class:`PivotFilterType`. The type of filtering data.
        :param label1: The label of filter condition
        :param label2: The upper-bound label of between filter condition'''
        raise NotImplementedError()

    def setBaseIndex(self, value : int) -> None:
        '''Represents the PivotField index in the base PivotFields.
        :param value: '''
        raise NotImplementedError()

    def getCalculatedFieldFormula(self) -> str:
        ''':deprecated: Use PivotField.GetFormula() method instead.'''
        raise NotImplementedError()

    def getFilters(self) -> list[PivotFilter]:
        '''Gets all pivot filters of this pivot field.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Represents the name of PivotField.
        :param value: '''
        raise NotImplementedError()

    def getPivotFilters(self) -> list:
        ''':deprecated: Use PivotField.GetFilters() instead.'''
        raise NotImplementedError()

    def setNumber(self, value : int) -> None:
        '''Represents the built-in display format of numbers and dates.
        :param value: '''
        raise NotImplementedError()

    def getBaseIndex(self) -> int:
        '''Represents the PivotField index in the base PivotFields.'''
        raise NotImplementedError()

    def setCurrentPageItem(self, value : int) -> None:
        '''Represents the current page item showing for the page field (valid only for page fields).
        :param value: '''
        raise NotImplementedError()

    def setDataDisplayFormat(self, value : int) -> None:
        ''':deprecated: Use PivotField.ShowValuesSetting.CalculationType property instead.'''
        raise NotImplementedError()

    def getPivotItems(self) -> PivotItemCollection:
        '''Gets the pivot items of the pivot field'''
        raise NotImplementedError()

    def getPosition(self) -> int:
        '''Represents the index of :class:`PivotField` in the region.'''
        raise NotImplementedError()

    def setNumberFormat(self, value : str) -> None:
        '''Represents the custom display format of numbers and dates.
        :param value: '''
        raise NotImplementedError()

    def getNonAutoSortDefault(self) -> bool:
        '''Indicates whether a sort operation that will be applied to this pivot field is an autosort operation or a simple data sort.'''
        raise NotImplementedError()

    def isAutoShow(self) -> bool:
        '''Indicates whether the specified PivotTable field is automatically shown,only valid for excel 2003.'''
        raise NotImplementedError()

    def setIncludeNewItemsInFilter(self, value : bool) -> None:
        '''Indicates whether including new items to the field in manual filter.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getBaseItemPosition(self) -> int:
        ''':deprecated: Use PivotField.ShowValuesSetting.BaseItemPositionType property instead.'''
        raise NotImplementedError()

    def setAutoSubtotals(self, value : bool) -> None:
        '''Indicates whether the specified field shows automatic subtotals. Default is true.
        :param value: '''
        raise NotImplementedError()

    def isMultipleItemSelectionAllowed(self) -> bool:
        '''indicates whether the field can have multiple items
        selected in the page field
        The default value is false.'''
        raise NotImplementedError()

    def getCurrentPageItem(self) -> int:
        '''Represents the current page item showing for the page field (valid only for page fields).'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Represents the name of PivotField.'''
        raise NotImplementedError()

    def getDataDisplayFormat(self) -> int:
        ''':deprecated: Use PivotField.ShowValuesSetting.CalculationType property instead.'''
        raise NotImplementedError()

    def filterByValue(self, valueFieldIndex : int, type : int, value1 : int, value2 : int) -> PivotFilter:
        '''Filters by values of data pivot field.
        :param valueFieldIndex: The index of value field in the value region.
        :param type: :class:`PivotFilterType`. The type of filtering data.
        :param value1: The value of filter condition
        :param value2: The upper-bound value of between filter condition'''
        raise NotImplementedError()

    def getItemCount(self) -> int:
        '''Gets the count of the base items in this pivot field.'''
        raise NotImplementedError()

    def getFormula(self) -> str:
        '''Gets formula of the calculated field .'''
        raise NotImplementedError()

    def getDragToData(self) -> bool:
        '''Indicates whether the specified field can be dragged to the data position.
        The default value is true.'''
        raise NotImplementedError()

    def setAutoSort(self, value : bool) -> None:
        '''Indicates whether the specified PivotTable field is automatically sorted.
        :param value: '''
        raise NotImplementedError()

    def setDragToData(self, value : bool) -> None:
        '''Indicates whether the specified field can be dragged to the data position.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def getDragToColumn(self) -> bool:
        '''Indicates whether the specified field can be dragged to the column position.
        The default value is true.'''
        raise NotImplementedError()

    def hideItemDetail(self, index : int, isHiddenDetail : bool) -> None:
        '''Sets whether the specific PivotItem in a pivot field is hidden detail.
        :param index: the index of the pivotItem in the pivotField.
        :param isHiddenDetail: whether the specific PivotItem is hidden'''
        raise NotImplementedError()

    def setDragToRow(self, value : bool) -> None:
        '''Indicates whether the specified field can be dragged to the row position.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def initPivotItems(self) -> None:
        '''Init the pivot items of the pivot field'''
        raise NotImplementedError()

    def setDragToColumn(self, value : bool) -> None:
        '''Indicates whether the specified field can be dragged to the column position.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def isRepeatItemLabels(self) -> bool:
        '''Indicates whether repeating labels of the field in the region.
        The default value is false.'''
        raise NotImplementedError()

    def setShowSubtotalAtTop(self, value : bool) -> None:
        '''when ShowInOutlineForm is true, then display subtotals at the top of the list of items instead of at the bottom
        :param value: '''
        raise NotImplementedError()

    def getBaseItemIndex(self) -> int:
        ''':deprecated: Use PivotField.ShowValuesSetting.BaseItemIndex property instead.'''
        raise NotImplementedError()

    def isInsertPageBreaksBetweenItems(self) -> bool:
        '''Indicates whether inserting page breaks after each item.
        The default value is false.'''
        raise NotImplementedError()

    def setShowCompact(self, value : bool) -> None:
        '''Indicates whether display labels from the next field in the same column on the Pivot Table view
        :param value: '''
        raise NotImplementedError()

    def setAscendShow(self, value : bool) -> None:
        '''Indicates whether the specified PivotTable field is autoshown ascending.
        :param value: '''
        raise NotImplementedError()

    def getInsertBlankRow(self) -> bool:
        '''Indicates whether inserting blank line after each item.'''
        raise NotImplementedError()

    def setBaseItemIndex(self, value : int) -> None:
        ''':deprecated: Use PivotField.ShowValuesSetting.BaseItemIndex property instead.'''
        raise NotImplementedError()

    def setDisplayName(self, value : str) -> None:
        '''Represents the PivotField display name.
        :param value: '''
        raise NotImplementedError()

    def getAutoShowCount(self) -> int:
        '''Represent the number of top or bottom items
        that are automatically shown in the specified PivotTable field.'''
        raise NotImplementedError()

    def getRange(self) -> SxRng:
        ''':deprecated: Use PivotField.GroupSettings property instead.'''
        raise NotImplementedError()

    def setAutoShowCount(self, value : int) -> None:
        '''Represent the number of top or bottom items
        that are automatically shown in the specified PivotTable field.
        :param value: '''
        raise NotImplementedError()

    def getDragToRow(self) -> bool:
        '''Indicates whether the specified field can be dragged to the row position.
        The default value is true.'''
        raise NotImplementedError()

    def showValuesAs(self, displayFormat : int, baseField : int, baseItemPositionType : int, baseItem : int) -> None:
        '''Shows values of data field as different display format when the ShowDataAs calculation is in use.
        :param displayFormat: :class:`PivotFieldDataDisplayFormat`. The data display format type.
        :param baseField: The index to the field which ShowDataAs calculation bases on.
        :param baseItemPositionType: :class:`PivotItemPositionType`.
        :param baseItem: The index to the base item which ShowDataAs calculation bases on.'''
        raise NotImplementedError()

    def isAscendShow(self) -> bool:
        '''Indicates whether the specified PivotTable field is autoshown ascending.'''
        raise NotImplementedError()

    def setInsertBlankRow(self, value : bool) -> None:
        '''Indicates whether inserting blank line after each item.
        :param value: '''
        raise NotImplementedError()

    def getNumber(self) -> int:
        '''Represents the built-in display format of numbers and dates.'''
        raise NotImplementedError()

    def isAutoSort(self) -> bool:
        '''Indicates whether the specified PivotTable field is automatically sorted.'''
        raise NotImplementedError()

    def getGroupSettings(self) -> PivotFieldGroupSettings:
        '''Gets the group settings of the pivot field.'''
        raise NotImplementedError()

    def getShowCompact(self) -> bool:
        '''Indicates whether display labels from the next field in the same column on the Pivot Table view'''
        raise NotImplementedError()

    def isCalculatedField(self) -> bool:
        '''Indicates whether the specified PivotTable field is calculated field.'''
        raise NotImplementedError()

    def setFunction(self, value : int) -> None:
        '''Represents the function used to summarize the PivotTable data field.
        See :class:`ConsolidationFunction`
        :param value: '''
        raise NotImplementedError()

    @overload
    def hideItem(self, index : int, isHidden : bool) -> None:
        '''Sets whether the specific PivotItem in a data field is hidden.
        :param index: the index of the pivotItem in the pivotField.
        :param isHidden: whether the specific PivotItem is hidden'''
        raise NotImplementedError()

    @overload
    def hideItem(self, itemValue : str, isHidden : bool) -> None:
        '''Sets whether the specific PivotItem in a data field is hidden.
        :param itemValue: the value of the pivotItem in the pivotField.
        :param isHidden: whether the specific PivotItem is hidden'''
        raise NotImplementedError()

    def getShowSubtotalAtTop(self) -> bool:
        '''when ShowInOutlineForm is true, then display subtotals at the top of the list of items instead of at the bottom'''
        raise NotImplementedError()

    @overload
    def groupBy(self, interval : int, newField : bool) -> None:
        '''Automatically group the field with internal
        :param interval: The internal of group.
        :param newField: Indicates whether adding a new field to the pivottable.'''
        raise NotImplementedError()

    @overload
    def groupBy(self, start : DateTime, end : DateTime, groups : list[int], interval : int, firstAsNewField : bool) -> bool:
        '''Group the file by the date group types.
        :param start: The start datetime
        :param end: The end of datetime
        :param groups: :class:`PivotGroupByType`. Group types
        :param interval: The interval
        :param firstAsNewField: Indicates whether adding a new field to the pivottable.
        :returns: False means this field could not be grouped by date time.'''
        raise NotImplementedError()

    @overload
    def groupBy(self, start : int, end : int, interval : int, newField : bool) -> bool:
        '''Group the file by number.
        :param start: The start value
        :param end: The end of value
        :param interval: The interval
        :param newField: Indicates whether adding a new field to the pivottable
        :returns: False means this field could not be grouped by date time.'''
        raise NotImplementedError()

    @overload
    def groupBy(self, customGroupItems : list[CustomPiovtFieldGroupItem], newField : bool) -> bool:
        '''Custom group the field.
        :param customGroupItems: The custom group items.
        :param newField: Indicates whether adding a new field to the pivottable
        :returns: False means this field could not be grouped by date time.'''
        raise NotImplementedError()

    def isHiddenItemDetail(self, index : int) -> bool:
        '''Gets whether hidding the detail of  the specific PivotItem..
        :param index: The index of the pivotItem in the pivotField.
        :returns: whether the specific PivotItem is hidden detail'''
        raise NotImplementedError()

    def setMultipleItemSelectionAllowed(self, value : bool) -> None:
        '''indicates whether the field can have multiple items
        selected in the page field
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def setNonAutoSortDefault(self, value : bool) -> None:
        '''Indicates whether a sort operation that will be applied to this pivot field is an autosort operation or a simple data sort.
        :param value: '''
        raise NotImplementedError()

    def getDisplayName(self) -> str:
        '''Represents the PivotField display name.'''
        raise NotImplementedError()

    def getOriginalItems(self) -> list[str]:
        '''Get the original base items;'''
        raise NotImplementedError()

    def filterTop10(self, valueFieldIndex : int, type : int, isTop : bool, itemCount : int) -> PivotFilter:
        '''Filters by values of data pivot field.
        :param valueFieldIndex: The index of data field in the data region.
        :param type: :class:`PivotFilterType`. The type of filtering data. Only can be Count,Sum and Percent.
        :param isTop: Indicates whether filter from top or bottom
        :param itemCount: The item count'''
        raise NotImplementedError()

    def isAutoSubtotals(self) -> bool:
        '''Indicates whether the specified field shows automatic subtotals. Default is true.'''
        raise NotImplementedError()

    def getSortSetting(self) -> PivotFieldSortSetting:
        '''Gets all settings of auto sorting'''
        raise NotImplementedError()

    def getShowValuesSetting(self) -> PivotShowValuesSetting:
        '''Gets the settings of showing values as when the ShowDataAs calculation is in use.'''
        raise NotImplementedError()

    def addCalculatedItem(self, name : str, formula : str) -> None:
        '''Add a calculated formula item to the pivot field.
        :param name: The item's name.
        :param formula: The formula of pivot item.'''
        raise NotImplementedError()

    def getAutoShowField(self) -> int:
        '''Represents auto show field index. -1 means PivotField itself.
        It should be the index of the data fields.'''
        raise NotImplementedError()

    def clearFilter(self) -> None:
        '''Clears filter setting on this pivot field.'''
        raise NotImplementedError()

    def getBaseFieldIndex(self) -> int:
        ''':deprecated: Use PivotField.ShowValuesSetting.BaseFieldIndex property instead.'''
        raise NotImplementedError()

    def setAutoShowField(self, value : int) -> None:
        '''Represents auto show field index. -1 means PivotField itself.
        It should be the index of the data fields.
        :param value: '''
        raise NotImplementedError()

    def getShowAllItems(self) -> bool:
        '''Indicates whether all items displays in the PivotTable report,
        even if they don't contain summary data.
        show items with no data
        The default value is false.'''
        raise NotImplementedError()

    def isIncludeNewItemsInFilter(self) -> bool:
        '''Indicates whether including new items to the field in manual filter.
        The default value is false.'''
        raise NotImplementedError()

    def getDragToPage(self) -> bool:
        '''Indicates whether the specified field can be dragged to the page position.
        The default value is true.'''
        raise NotImplementedError()

    def setDragToPage(self, value : bool) -> None:
        '''Indicates whether the specified field can be dragged to the page position.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def setAscendSort(self, value : bool) -> None:
        '''Indicates whether the specified PivotTable field is autosorted ascending.
        :param value: '''
        raise NotImplementedError()

    def setInsertPageBreaksBetweenItems(self, value : bool) -> None:
        '''Indicates whether inserting page breaks after each item.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getDragToHide(self) -> bool:
        '''Indicates whether the specified field can be dragged to the hide position.
        The default value is true.'''
        raise NotImplementedError()

    def ungroup(self) -> None:
        '''Ungroup the pivot field.'''
        raise NotImplementedError()

    def setSubtotals(self, subtotalType : int, shown : bool) -> None:
        '''Sets whether the specified field shows that subtotals.
        :param subtotalType: :class:`PivotFieldSubtotalType`. subtotals type.
        :param shown: whether the specified field shows that subtotals.'''
        raise NotImplementedError()

    def setDragToHide(self, value : bool) -> None:
        '''Indicates whether the specified field can be dragged to the hide position.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def getSubtotals(self, subtotalType : int) -> bool:
        '''Indicates whether showing specified subtotal.
        :param subtotalType: :class:`PivotFieldSubtotalType`. subtotal type.
        :returns: Returns whether showing specified subtotal.'''
        raise NotImplementedError()

    def hideDetail(self, isHiddenDetail : bool) -> None:
        '''Sets whether the PivotItems in a pivot field is hidden detail.That is collapse/expand this field.
        :param isHiddenDetail: Whether hide the detail of the pivot field.'''
        raise NotImplementedError()

    def getFunction(self) -> int:
        '''Represents the function used to summarize the PivotTable data field.
        See :class:`ConsolidationFunction`'''
        raise NotImplementedError()

    def isAscendSort(self) -> bool:
        '''Indicates whether the specified PivotTable field is autosorted ascending.'''
        raise NotImplementedError()

    def getRegionType(self) -> int:
        '''Specifies the region of the PivotTable that this field is displayed.
        See :class:`PivotFieldType`'''
        raise NotImplementedError()

    def setShowInOutlineForm(self, value : bool) -> None:
        '''Indicates whether layout this field in outline form on the Pivot Table view
        :param value: '''
        raise NotImplementedError()

    def isValueFields(self) -> bool:
        '''Indicates whether this field represents values fields.'''
        raise NotImplementedError()

    def setShowAllItems(self, value : bool) -> None:
        '''Indicates whether all items displays in the PivotTable report,
        even if they don't contain summary data.
        show items with no data
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def getShowInOutlineForm(self) -> bool:
        '''Indicates whether layout this field in outline form on the Pivot Table view'''
        raise NotImplementedError()

    def setBaseFieldIndex(self, value : int) -> None:
        ''':deprecated: Use PivotField.ShowValuesSetting.BaseFieldIndex property instead.'''
        raise NotImplementedError()

    def getItems(self) -> list[str]:
        '''Get all labels of pivot items in this field.'''
        raise NotImplementedError()


class PivotFieldCollection:
    '''Represents a collection of all the PivotField objects
    in the PivotTable's specific PivotFields type.'''

    def clear(self) -> None:
        '''clear all fields of PivotFieldCollection'''
        raise NotImplementedError()

    def move(self, currPos : int, destPos : int) -> None:
        '''Moves the PivotField from current position to destination position
        :param currPos: Current position of PivotField based on zero
        :param destPos: Destination position of PivotField based on zero'''
        raise NotImplementedError()

    def getCount(self) -> int:
        '''Gets the count of the pivotFields.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> PivotField:
        '''Gets the PivotField Object at the specific index.
        :param index: '''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> PivotField:
        '''Gets the PivotField Object of the specific name.
        :param name: '''
        raise NotImplementedError()

    def addByBaseIndex(self, baseFieldIndex : int) -> int:
        '''Adds a PivotField Object to the specific type PivotFields.
        :param baseFieldIndex: field index in the base PivotFields.
        :returns: the index of the PivotField Object in this PivotFields.'''
        raise NotImplementedError()

    def iterator(self) -> Iterator:
        '''Gets an enumerator over the elements in this collection in proper sequence.'''
        raise NotImplementedError()

    def add(self, pivotField : PivotField) -> int:
        '''Adds a PivotField Object to the specific type PivotFields.
        :param pivotField: a PivotField Object.
        :returns: the index of the PivotField Object in this PivotFields.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the PivotFields type.
        See :class:`PivotFieldType`'''
        raise NotImplementedError()


class PivotFieldDataDisplayFormat:
    '''Represents data display format in the PivotTable data field.'''

    NORMAL : PivotFieldDataDisplayFormat
    '''Represents normal display format.'''

    DIFFERENCE_FROM : PivotFieldDataDisplayFormat
    '''Represents difference from display format.'''

    PERCENTAGE_OF : PivotFieldDataDisplayFormat
    '''Represents percentage of display format.'''

    PERCENTAGE_DIFFERENCE_FROM : PivotFieldDataDisplayFormat
    '''Represents percentage difference from  display format.'''

    RUNNING_TOTAL_IN : PivotFieldDataDisplayFormat
    '''Represents running total in display format.'''

    PERCENTAGE_OF_ROW : PivotFieldDataDisplayFormat
    '''Represents percentage of row display format.'''

    PERCENTAGE_OF_COLUMN : PivotFieldDataDisplayFormat
    '''Represents percentage of column display format.'''

    PERCENTAGE_OF_TOTAL : PivotFieldDataDisplayFormat
    '''Represents percentage of total display format.'''

    INDEX : PivotFieldDataDisplayFormat
    '''Represents index display format.'''

    PERCENTAGE_OF_PARENT_ROW_TOTAL : PivotFieldDataDisplayFormat
    '''Represents percentage of parent row total display format.'''

    PERCENTAGE_OF_PARENT_COLUMN_TOTAL : PivotFieldDataDisplayFormat
    '''Represents percentage of parent column total display format.'''

    PERCENTAGE_OF_PARENT_TOTAL : PivotFieldDataDisplayFormat
    '''Represents percentage of parent total display format.'''

    PERCENTAGE_OF_RUNNING_TOTAL_IN : PivotFieldDataDisplayFormat
    '''Represents percentage of running total in display format.'''

    RANK_SMALLEST_TO_LARGEST : PivotFieldDataDisplayFormat
    '''Represents smallest to largest display format.'''

    RANK_LARGEST_TO_SMALLEST : PivotFieldDataDisplayFormat
    '''Represents largest to smallest display format.'''


class PivotFieldGroupSettings:
    '''Represents the group setting of pivot field.'''

    def getType(self) -> int:
        '''Gets the group type of pivot field.
        See :class:`PivotFieldGroupType`'''
        raise NotImplementedError()


class PivotFieldGroupType:
    '''Represents the group type of pivot field.'''

    NONE : PivotFieldGroupType
    '''No group'''

    DATE_TIME_RANGE : PivotFieldGroupType
    '''Grouped by DateTime range.'''

    NUMBERIC_RANGE : PivotFieldGroupType
    '''Grouped by numberic range.'''

    DISCRETE : PivotFieldGroupType
    '''Grouped by discrete points.'''


class PivotFieldSortSetting:
    '''Represents the setting of sorting pivot fields.'''

    def getCell(self) -> str:
        '''Sorts by the values in which row or column.'''
        raise NotImplementedError()

    def isSimpleSort(self) -> bool:
        '''Indicates whether a simple data sort operation will be applied.'''
        raise NotImplementedError()

    def isSortByLabels(self) -> bool:
        '''Indicates whether sorting the field by itself or data field.'''
        raise NotImplementedError()

    def getSortType(self) -> int:
        '''Represents the :class:`SortOrder`.
        See :class:`SortOrder`'''
        raise NotImplementedError()

    def getLineTypeSortedBy(self) -> int:
        '''The pivot line type sorted by.
        See :class:`PivotLineType`'''
        raise NotImplementedError()

    def getFieldIndex(self) -> int:
        '''Represents the index of the field sorted by.
        -1 means sorting the PivotField by the labels,others means sorting by the data field.'''
        raise NotImplementedError()


class PivotFieldSubtotalType:
    '''Summary description for PivotFieldSubtotalType.'''

    NONE : PivotFieldSubtotalType
    '''Represents None subtotal type.'''

    AUTOMATIC : PivotFieldSubtotalType
    '''Represents Automatic subtotal type.'''

    SUM : PivotFieldSubtotalType
    '''Represents Sum subtotal type.'''

    COUNT : PivotFieldSubtotalType
    '''Represents Count subtotal type.'''

    AVERAGE : PivotFieldSubtotalType
    '''Represents Average subtotal type.'''

    MAX : PivotFieldSubtotalType
    '''Represents Max subtotal type.'''

    MIN : PivotFieldSubtotalType
    '''Represents Min subtotal type.'''

    PRODUCT : PivotFieldSubtotalType
    '''Represents Product subtotal type.'''

    COUNT_NUMS : PivotFieldSubtotalType
    '''Represents Count Nums subtotal type.'''

    STDEV : PivotFieldSubtotalType
    '''Represents Stdev subtotal type.'''

    STDEVP : PivotFieldSubtotalType
    '''Represents Stdevp subtotal type.'''

    VAR : PivotFieldSubtotalType
    '''Represents Var subtotal type.'''

    VARP : PivotFieldSubtotalType
    '''Represents Varp subtotal type.'''


class PivotFieldType:
    '''Represents PivotTable field type.'''

    UNDEFINED : PivotFieldType
    '''Presents base pivot field type.'''

    ROW : PivotFieldType
    '''Presents row pivot field type.'''

    COLUMN : PivotFieldType
    '''Presents column pivot field type.'''

    PAGE : PivotFieldType
    '''Presents page pivot field type.'''

    DATA : PivotFieldType
    '''Presents data pivot field type.'''


class PivotFilter:
    '''Represents a PivotFilter in PivotFilter Collection.'''

    def getFilterCategory(self) -> int:
        '''Gets the category of this filter.
        See :class:`FilterCategory`'''
        raise NotImplementedError()

    def getNumberValues(self) -> list[int]:
        '''Gets values of the number filter.'''
        raise NotImplementedError()

    def getMemberPropertyFieldIndex(self) -> int:
        '''Gets the member property field index of the pivot filter.'''
        raise NotImplementedError()

    def setMeasureFldIndex(self, value : int) -> None:
        ''':deprecated: Use PivotFilter.ValueFieldIndex property.'''
        raise NotImplementedError()

    def setValue2(self, value : str) -> None:
        '''Gets the string value2 of the label pivot filter.
        :param value: '''
        raise NotImplementedError()

    def setValue1(self, value : str) -> None:
        '''Gets the string value1 of the label pivot filter.
        :param value: '''
        raise NotImplementedError()

    def getFieldIndex(self) -> int:
        '''Gets the index of source field which this pivot filter is applied to.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Gets the name of the pivot filter.
        :param value: '''
        raise NotImplementedError()

    def setEvaluationOrder(self, value : int) -> None:
        '''Gets the Evaluation Order of the pivot filter.
        :param value: '''
        raise NotImplementedError()

    def setUseWholeDay(self, value : bool) -> None:
        '''Indicates whether uses whole days in its filtering criteria.
        :param value: '''
        raise NotImplementedError()

    def getEvaluationOrder(self) -> int:
        '''Gets the Evaluation Order of the pivot filter.'''
        raise NotImplementedError()

    def getValue2(self) -> str:
        '''Gets the string value2 of the label pivot filter.'''
        raise NotImplementedError()

    def getValue1(self) -> str:
        '''Gets the string value1 of the label pivot filter.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the pivot filter.'''
        raise NotImplementedError()

    def getFilterType(self) -> int:
        '''Gets the autofilter type of the pivot filter.
        See :class:`PivotFilterType`'''
        raise NotImplementedError()

    def getValueFieldIndex(self) -> int:
        '''Gets the index of value field in the value region.'''
        raise NotImplementedError()

    def getDateTimeValues(self) -> list[DateTime]:
        '''Gets values of the number filter.'''
        raise NotImplementedError()

    def getUseWholeDay(self) -> bool:
        '''Indicates whether uses whole days in its filtering criteria.'''
        raise NotImplementedError()

    def getMeasureFldIndex(self) -> int:
        ''':deprecated: Use PivotFilter.ValueFieldIndex property.'''
        raise NotImplementedError()

    def getLabels(self) -> list[str]:
        '''Gets labels of the caption filter.'''
        raise NotImplementedError()

    def getMeasureCubeFieldIndex(self) -> int:
        '''Specifies the index of the measure cube field.
        this property is used only by filters in OLAP pivots and specifies on which measure a value filter should apply.'''
        raise NotImplementedError()

    def setMemberPropertyFieldIndex(self, value : int) -> None:
        '''Gets the member property field index of the pivot filter.
        :param value: '''
        raise NotImplementedError()

    def setValueFieldIndex(self, value : int) -> None:
        '''Gets the index of value field in the value region.
        :param value: '''
        raise NotImplementedError()

    def getAutoFilter(self) -> AutoFilter:
        ''':deprecated: Use FilterLabel, FilterValue,FilterDate or FilterTop10 method.'''
        raise NotImplementedError()

    def getTop10Value(self) -> Top10Filter:
        '''Gets top 10 setting of the filter.'''
        raise NotImplementedError()


class PivotFilterCollection:
    '''Represents a collection of all the PivotFilter objects'''

    def clearFilter(self, fieldIndex : int) -> None:
        '''Clear PivotFilter from the specific PivotField
        :param fieldIndex: the PivotField index'''
        raise NotImplementedError()

    def addTop10Filter(self, baseFieldIndex : int, valueFieldIndex : int, type : int, isTop : bool, itemCount : int) -> PivotFilter:
        '''Filters by values of data pivot field.
        :param baseFieldIndex: The index of field in the source.
        :param valueFieldIndex: The index of data field in the data region.
        :param type: :class:`PivotFilterType`. The type of filtering data. Only can be Count,Sum and Percent.
        :param isTop: Indicates whether filter from top or bottom
        :param itemCount: The item count'''
        raise NotImplementedError()

    def addLabelFilter(self, baseFieldIndex : int, type : int, label1 : str, label2 : str) -> PivotFilter:
        '''Filters by captions of row or column pivot field.
        :param baseFieldIndex: The index of field in the source.
        :param type: :class:`PivotFilterType`. The type of filtering data.
        :param label1: The label of filter condition
        :param label2: The upper-bound label of between filter condition'''
        raise NotImplementedError()

    def addValueFilter(self, baseFieldIndex : int, valueFieldIndex : int, type : int, value1 : int, value2 : int) -> PivotFilter:
        '''Filters by values of data pivot field.
        :param baseFieldIndex: The index of field in the source.
        :param valueFieldIndex: The index of value field in the value region.
        :param type: :class:`PivotFilterType`. The type of filtering data.
        :param value1: The value of filter condition
        :param value2: The upper-bound value of between filter condition'''
        raise NotImplementedError()

    def get(self, index : int) -> PivotFilter:
        '''Gets the pivotfilter object at the specific index.
        :param index: '''
        raise NotImplementedError()

    def addDateFilter(self, baseFieldIndex : int, type : int, dateTime1 : DateTime, dateTime2 : DateTime) -> PivotFilter:
        '''Filters by date setting of row or column pivot field.
        :param baseFieldIndex: The index of field in the source.
        :param type: :class:`PivotFilterType`. The type of filtering data.
        :param dateTime1: The date label of filter condition
        :param dateTime2: The upper-bound date label of between filter condition'''
        raise NotImplementedError()

    def add(self, fieldIndex : int, type : int) -> int:
        ''':deprecated: Use PivotFilterCollection.AddValueFilter(),AddTop10Filter(),AddLabelFilter() and AddDateFilter() methods,instead.'''
        raise NotImplementedError()


class PivotFilterType:
    '''Represents PivotTable Filter type.'''

    CAPTION_BEGINS_WITH : PivotFilterType
    '''Indicates the "begins with" filter for field captions.'''

    CAPTION_BETWEEN : PivotFilterType
    '''Indicates the "is between" filter for field captions.'''

    CAPTION_CONTAINS : PivotFilterType
    '''Indicates the "contains" filter for field captions.'''

    CAPTION_ENDS_WITH : PivotFilterType
    '''Indicates the "ends with" filter for field captions.'''

    CAPTION_EQUAL : PivotFilterType
    '''Indicates the "equal" filter for field captions.'''

    CAPTION_GREATER_THAN : PivotFilterType
    '''Indicates the "is greater than" filter for field captions.'''

    CAPTION_GREATER_THAN_OR_EQUAL : PivotFilterType
    '''Indicates the "is greater than or equal to" filter for field captions.'''

    CAPTION_LESS_THAN : PivotFilterType
    '''Indicates the "is less than" filter for field captions.'''

    CAPTION_LESS_THAN_OR_EQUAL : PivotFilterType
    '''Indicates the "is less than or equal to" filter for field captions.'''

    CAPTION_NOT_BEGINS_WITH : PivotFilterType
    '''Indicates the "does not begin with" filter for field captions.'''

    CAPTION_NOT_BETWEEN : PivotFilterType
    '''Indicates the "is not between" filter for field captions.'''

    CAPTION_NOT_CONTAINS : PivotFilterType
    '''Indicates the "does not contain" filter for field captions.'''

    CAPTION_NOT_ENDS_WITH : PivotFilterType
    '''Indicates the "does not end with" filter for field captions.'''

    CAPTION_NOT_EQUAL : PivotFilterType
    '''Indicates the "not equal" filter for field captions.'''

    COUNT : PivotFilterType
    '''Indicates the "count" filter.'''

    DATE_BETWEEN : PivotFilterType
    '''Indicates the "between" filter for date values.'''

    DATE_EQUAL : PivotFilterType
    '''Indicates the "equals" filter for date values.'''

    DATE_NEWER_THAN : PivotFilterType
    '''Indicates the "after" filter for date values.'''

    DATE_AFTER : PivotFilterType
    '''Indicates the "after" filter for date values.'''

    DATE_NEWER_THAN_OR_EQUAL : PivotFilterType
    '''Indicates the "after or equal to" filter for date values.'''

    DATE_AFTER_OR_EQUAL : PivotFilterType
    '''Indicates the "after or equal to" filter for date values.'''

    DATE_NOT_BETWEEN : PivotFilterType
    '''Indicates the "not between" filter for date values.'''

    DATE_NOT_EQUAL : PivotFilterType
    '''Indicates the "does not equal" filter for date values.'''

    DATE_OLDER_THAN : PivotFilterType
    '''Indicates the "before" filter for date values.'''

    DATE_BEFORE : PivotFilterType
    '''Indicates the "before" filter for date values.'''

    DATE_OLDER_THAN_OR_EQUAL : PivotFilterType
    '''Indicates the "before or equal to" filter for date values.'''

    DATE_BEFORE_OR_EQUAL : PivotFilterType
    '''Indicates the "before or equal to" filter for date values.'''

    LAST_MONTH : PivotFilterType
    '''Indicates the "last month" filter for date values.'''

    LAST_QUARTER : PivotFilterType
    '''Indicates the "last quarter" filter for date values.'''

    LAST_WEEK : PivotFilterType
    '''Indicates the "last week" filter for date values.'''

    LAST_YEAR : PivotFilterType
    '''Indicates the "last year" filter for date values.'''

    M_1 : PivotFilterType
    '''Indicates the "January" filter for date values.'''

    JANUARY : PivotFilterType
    '''Indicates the "January" filter for date values.'''

    M_2 : PivotFilterType
    '''Indicates the "February" filter for date values.'''

    FEBRUARY : PivotFilterType
    '''Indicates the "February" filter for date values.'''

    M_3 : PivotFilterType
    '''Indicates the "March" filter for date values.'''

    MARCH : PivotFilterType
    '''Indicates the "March" filter for date values.'''

    M_4 : PivotFilterType
    '''Indicates the "April" filter for date values.'''

    APRIL : PivotFilterType
    '''Indicates the "April" filter for date values.'''

    M_5 : PivotFilterType
    '''Indicates the "May" filter for date values.'''

    MAY : PivotFilterType
    '''Indicates the "May" filter for date values.'''

    M_6 : PivotFilterType
    '''Indicates the "June" filter for date values.'''

    JUNE : PivotFilterType
    '''Indicates the "June" filter for date values.'''

    M_7 : PivotFilterType
    '''Indicates the "July" filter for date values.'''

    JULY : PivotFilterType
    '''Indicates the "July" filter for date values.'''

    M_8 : PivotFilterType
    '''Indicates the "August" filter for date values.'''

    AUGUST : PivotFilterType
    '''Indicates the "August" filter for date values.'''

    M_9 : PivotFilterType
    '''Indicates the "September" filter for date values.'''

    SEPTEMBER : PivotFilterType
    '''Indicates the "September" filter for date values.'''

    M_10 : PivotFilterType
    '''Indicates the "October" filter for date values.'''

    OCTOBER : PivotFilterType
    '''Indicates the "October" filter for date values.'''

    M_11 : PivotFilterType
    '''Indicates the "November" filter for date values.'''

    NOVEMBER : PivotFilterType
    '''Indicates the "November" filter for date values.'''

    M_12 : PivotFilterType
    '''Indicates the "December" filter for date values.'''

    DECEMBER : PivotFilterType
    '''Indicates the "December" filter for date values.'''

    NEXT_MONTH : PivotFilterType
    '''Indicates the "next month" filter for date values.'''

    NEXT_QUARTER : PivotFilterType
    '''Indicates the "next quarter" for date values.'''

    NEXT_WEEK : PivotFilterType
    '''Indicates the "next week" for date values.'''

    NEXT_YEAR : PivotFilterType
    '''Indicates the "next year" filter for date values.'''

    PERCENT : PivotFilterType
    '''Indicates the "percent" filter for numeric values.'''

    Q_1 : PivotFilterType
    '''Indicates the "first quarter" filter for date values.'''

    QUARTER_1 : PivotFilterType
    '''Indicates the "first quarter" filter for date values.'''

    Q_2 : PivotFilterType
    '''Indicates the "second quarter" filter for date values.'''

    QUARTER_2 : PivotFilterType
    '''Indicates the "second quarter" filter for date values.'''

    Q_3 : PivotFilterType
    '''Indicates the "third quarter" filter for date values.'''

    QUARTER_3 : PivotFilterType
    '''Indicates the "third quarter" filter for date values.'''

    Q_4 : PivotFilterType
    '''Indicates the "fourth quarter" filter for date values.'''

    QUARTER_4 : PivotFilterType
    '''Indicates the "fourth quarter" filter for date values.'''

    SUM : PivotFilterType
    '''Indicates the "sum" filter for numeric values.'''

    THIS_MONTH : PivotFilterType
    '''Indicates the "this month" filter for date values.'''

    THIS_QUARTER : PivotFilterType
    '''Indicates the "this quarter" filter for date values.'''

    THIS_WEEK : PivotFilterType
    '''Indicates the "this week" filter for date values.'''

    THIS_YEAR : PivotFilterType
    '''Indicate the "this year" filter for date values.'''

    TODAY : PivotFilterType
    '''Indicates the "today" filter for date values.'''

    TOMORROW : PivotFilterType
    '''Indicates the "tomorrow" filter for date values.'''

    UNKNOWN : PivotFilterType
    '''Indicates the PivotTable filter is unknown to the application.'''

    VALUE_BETWEEN : PivotFilterType
    '''Indicates the "Value between" filter for text and numeric values.'''

    VALUE_EQUAL : PivotFilterType
    '''Indicates the "value equal" filter for text and numeric values.'''

    VALUE_GREATER_THAN : PivotFilterType
    '''Indicates the "value greater than" filter for text and numeric values.'''

    VALUE_GREATER_THAN_OR_EQUAL : PivotFilterType
    '''Indicates the "value greater than or equal to" filter for text and numeric values.'''

    VALUE_LESS_THAN : PivotFilterType
    '''Indicates the "value less than" filter for text and numeric values.'''

    VALUE_LESS_THAN_OR_EQUAL : PivotFilterType
    '''Indicates the "value less than or equal to" filter for text and numeric values.'''

    VALUE_NOT_BETWEEN : PivotFilterType
    '''Indicates the "value not between" filter for text and numeric values.'''

    VALUE_NOT_EQUAL : PivotFilterType
    '''Indicates the "value not equal" filter for text and numeric values.'''

    YEAR_TO_DATE : PivotFilterType
    '''Indicates the "year-to-date" filter for date values.'''

    YESTERDAY : PivotFilterType
    '''Indicates the "yesterday" filter for date values.'''

    NONE : PivotFilterType
    '''No filter.'''


class PivotFormatCondition:
    '''Represents a PivotTable Format Condition in PivotFormatCondition Collection.'''

    def setConditionalAreas(self) -> None:
        '''Sets conditional areas of PivotFormatCondition object.'''
        raise NotImplementedError()

    def getScopeType(self) -> int:
        '''Gets scope type for the pivot table condition format .
        See :class:`PivotConditionFormatScopeType`'''
        raise NotImplementedError()

    @overload
    def addColumnAreaCondition(self, fieldName : str) -> None:
        '''Adds PivotTable conditional format limit in the column fields.
        :param fieldName: The name of PivotField.'''
        raise NotImplementedError()

    @overload
    def addColumnAreaCondition(self, columnField : PivotField) -> None:
        '''Adds PivotTable conditional format limit in the column fields.
        :param columnField: The PivotField in the column fields.'''
        raise NotImplementedError()

    def getFormatConditions(self) -> FormatConditionCollection:
        '''Get formatconditions for the pivot table condition format .'''
        raise NotImplementedError()

    @overload
    def addDataAreaCondition(self, fieldName : str) -> None:
        '''Adds PivotTable conditional format limit in the data fields.
        :param fieldName: The name of PivotField.'''
        raise NotImplementedError()

    @overload
    def addDataAreaCondition(self, dataField : PivotField) -> None:
        '''Adds PivotTable conditional format limit in the data fields.
        :param dataField: The PivotField in the data fields.'''
        raise NotImplementedError()

    def setRuleType(self, value : int) -> None:
        '''Sets rule type for the pivot table condition format .
        See :class:`PivotConditionFormatRuleType`
        :param value: '''
        raise NotImplementedError()

    def getRuleType(self) -> int:
        '''Gets rule type for the pivot table condition format .
        See :class:`PivotConditionFormatRuleType`'''
        raise NotImplementedError()

    def setScopeType(self, value : int) -> None:
        '''Sets scope type for the pivot table condition format .
        See :class:`PivotConditionFormatScopeType`
        :param value: '''
        raise NotImplementedError()

    @overload
    def addRowAreaCondition(self, fieldName : str) -> None:
        '''Adds PivotTable conditional format limit in the row fields.
        :param fieldName: The name of PivotField.'''
        raise NotImplementedError()

    @overload
    def addRowAreaCondition(self, rowField : PivotField) -> None:
        '''Adds PivotTable conditional format limit in the row fields.
        :param rowField: The PivotField in the row fields.'''
        raise NotImplementedError()


class PivotFormatConditionCollection:
    '''Represents PivotTable Format Conditions.'''

    def get(self, index : int) -> PivotFormatCondition:
        '''Gets the pivot FormatCondition object at the specific index.
        :param index: '''
        raise NotImplementedError()

    def add(self) -> int:
        '''Adds a pivot FormatCondition to the collection.'''
        raise NotImplementedError()


class PivotGlobalizationSettings:
    '''Represents the globalization settings for pivot tables.'''

    def getTextOfProtectedName(self, protectedName : str) -> str:
        '''Gets the text for specified protected name.
        :param protectedName: The protected name in PivotTable.
        :returns: The local prorected names of PivotTable.'''
        raise NotImplementedError()

    def getTextOfYears(self) -> str:
        '''Gets the local text of "Years".'''
        raise NotImplementedError()

    def getTextOfEmptyData(self) -> str:
        '''Gets the text of "(blank)" label in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfHours(self) -> str:
        '''Gets the local text of "Hours".'''
        raise NotImplementedError()

    def getShortTextOf12Months(self) -> list[str]:
        '''Gets all short formatted string of 12 months.'''
        raise NotImplementedError()

    def getTextOfMonths(self) -> str:
        '''Gets the local text of "Months".'''
        raise NotImplementedError()

    def getTextOfProtection(self) -> str:
        ''':deprecated: Use PivotGlobalizationSettings.GetTextOfProtectedName(string) method instead.'''
        raise NotImplementedError()

    def getTextOfQuarters(self) -> str:
        '''Get the local text of "Quarters".'''
        raise NotImplementedError()

    def getTextOfTotal(self) -> str:
        '''Gets the text of "Total" label in the PivotTable.
        You need to override this method when the PivotTable contains two or more PivotFields in the data area.'''
        raise NotImplementedError()

    def getTextOfSubTotal(self, subTotalType : int) -> str:
        '''Gets the text of :class:`PivotFieldSubtotalType` type in the PivotTable.
        :param subTotalType: :class:`PivotFieldSubtotalType`. The :class:`PivotFieldSubtotalType`
        :returns: The text of given type'''
        raise NotImplementedError()

    def getTextOfRowLabels(self) -> str:
        '''Gets the text of "Row Labels" label in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfColumnLabels(self) -> str:
        '''Gets the text of "Column Labels" label in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfDataFieldHeader(self) -> str:
        '''Gets the the text of the value area field header in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfSeconds(self) -> str:
        '''Gets the local text of "Seconds"'''
        raise NotImplementedError()

    def getTextOfDays(self) -> str:
        '''Gets the local text of "Days".'''
        raise NotImplementedError()

    def getTextOf4Quaters(self) -> list[str]:
        '''Gets the local text of 4 Quaters.'''
        raise NotImplementedError()

    def getTextOfGrandTotal(self) -> str:
        '''Gets the text of "Grand Total" label in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfAll(self) -> str:
        '''Gets the text of "(All)" label in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfMultipleItems(self) -> str:
        '''Gets the text of "(Multiple Items)" label in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfMinutes(self) -> str:
        '''Gets the local text of "Minutes".'''
        raise NotImplementedError()

    def getTextOfRange(self) -> str:
        '''Gets the local text of "Range"'''
        raise NotImplementedError()


class PivotGroupByType:
    '''Represents group by type.'''

    RANGE_OF_VALUES : PivotGroupByType
    '''Group by numbers.'''

    NUMBERS : PivotGroupByType
    '''Group by numbers.'''

    SECONDS : PivotGroupByType
    '''Presents Seconds groupby type.'''

    MINUTES : PivotGroupByType
    '''Presents Minutes groupby type.'''

    HOURS : PivotGroupByType
    '''Presents Hours groupby type.'''

    DAYS : PivotGroupByType
    '''Presents Days groupby type.'''

    MONTHS : PivotGroupByType
    '''Presents Months groupby type.'''

    QUARTERS : PivotGroupByType
    '''Presents Quarters groupby type.'''

    YEARS : PivotGroupByType
    '''Presents Years groupby type.'''


class PivotItem:
    '''Represents a item in a PivotField report.'''

    def isFormula(self) -> bool:
        ''':deprecated: Use PivotItem.IsCalculatedItem property instead.'''
        raise NotImplementedError()

    def setDetailHidden(self, value : bool) -> None:
        '''Sets whether the detail of this pivot item is hidden.
        :param value: '''
        raise NotImplementedError()

    def getValue(self) -> Object:
        '''Gets the value of the pivot item'''
        raise NotImplementedError()

    def setPosition(self, value : int) -> None:
        '''Specifying the position index in all the PivotItems,not the PivotItems under the same parent node.
        :param value: '''
        raise NotImplementedError()

    def setFormula(self, value : bool) -> None:
        ''':deprecated: Use PivotItem.IsCalculatedItem property instead.'''
        raise NotImplementedError()

    def isCalculatedItem(self) -> bool:
        '''Indicates whether this pivot item is a calculated formula item.'''
        raise NotImplementedError()

    def isHidden(self) -> bool:
        '''Gets whether the pivot item is hidden.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Gets the name of the pivot item.
        :param value: '''
        raise NotImplementedError()

    def isHideDetail(self) -> bool:
        ''':deprecated: Use PivotItem.IsDetailHidden property instead.'''
        raise NotImplementedError()

    def getDoubleValue(self) -> int:
        '''Gets the double value of the pivot item
        If the value is null or not number ,it will return 0'''
        raise NotImplementedError()

    def getPositionInSameParentNode(self) -> int:
        '''Specifying the position index in the PivotItems under the same parent node.'''
        raise NotImplementedError()

    def setHidden(self, value : bool) -> None:
        '''Sets whether the pivot item is hidden.
        :param value: '''
        raise NotImplementedError()

    def getDateTimeValue(self) -> DateTime:
        '''Gets the date time value of the pivot item
        If the value is null ,it will return DateTime.MinValue'''
        raise NotImplementedError()

    def hide(self, value : bool) -> None:
        ''':deprecated: Use Aspose.Cells.Pivot.PivotField.HideItem method instead.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the pivot item.'''
        raise NotImplementedError()

    def setPositionInSameParentNode(self, value : int) -> None:
        '''Specifying the position index in the PivotItems under the same parent node.
        :param value: '''
        raise NotImplementedError()

    def move(self, count : int, isSameParent : bool) -> None:
        '''Moves the item up or down
        :param count: 
        :param isSameParent: '''
        raise NotImplementedError()

    def setHideDetail(self, value : bool) -> None:
        ''':deprecated: Use PivotItem.IsDetailHidden property instead.'''
        raise NotImplementedError()

    def isMissing(self) -> bool:
        '''Indicates whether the item is removed from the data source.'''
        raise NotImplementedError()

    def getFormula(self) -> str:
        '''Gets the formula of this calculated item.
        Only works when this item is calculated item.'''
        raise NotImplementedError()

    def isDetailHidden(self) -> bool:
        '''Gets whether the detail of this pivot item is hidden.'''
        raise NotImplementedError()

    def setIndex(self, value : int) -> None:
        '''Gets the index of the pivot item in cache field.
        :param value: '''
        raise NotImplementedError()

    def getIndex(self) -> int:
        '''Gets the index of the pivot item in cache field.'''
        raise NotImplementedError()

    def getStringValue(self) -> str:
        '''Gets the string value of the pivot item
        If the value is null, it will return ""'''
        raise NotImplementedError()

    def getPosition(self) -> int:
        '''Specifying the position index in all the PivotItems,not the PivotItems under the same parent node.'''
        raise NotImplementedError()


class PivotItemCollection:
    '''Represents all the :class:`PivotItem` objects in the PivotField.'''

    def getCount(self) -> int:
        '''Gets the count of the pivot items.'''
        raise NotImplementedError()

    def swapItem(self, index1 : int, index2 : int) -> None:
        '''Directly swap two items.
        :param index1: 
        :param index2: '''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> PivotItem:
        '''Gets the PivotItem Object at the specific index.
        :param index: '''
        raise NotImplementedError()

    @overload
    def get(self, itemValue : str) -> PivotItem:
        '''Gets the :class:`PivotItem` by the specific name.
        :param itemValue: '''
        raise NotImplementedError()

    def changeitemsOrder(self, sourceIndex : int, destIndex : int) -> None:
        ''':deprecated: Use PivotItemCollection.SwapItem() method instead.'''
        raise NotImplementedError()

    def iterator(self) -> Iterator:
        '''Gets an enumerator over the elements in this collection in proper sequence.'''
        raise NotImplementedError()


class PivotItemPosition:
    '''Represents base item Next/Previous/All position in the base field .'''

    PREVIOUS : PivotItemPosition
    '''Represents the previous pivot item in the PivotField.'''

    NEXT : PivotItemPosition
    '''Represents the next pivot item in the PivotField.'''

    CUSTOM : PivotItemPosition
    '''Shows values as the different format based the index of pivot item in the PivotField.'''


class PivotItemPositionType:
    '''Represents the position type of the pivot base item in the base field when the ShowDataAs calculation is in use.'''

    PREVIOUS : PivotItemPositionType
    '''Represents the previous pivot item in the PivotField.'''

    NEXT : PivotItemPositionType
    '''Represents the next pivot item in the PivotField.'''

    CUSTOM : PivotItemPositionType
    '''Shows values as the different format based the index of pivot item in the PivotField.'''


class PivotLineType:
    '''Specifies the type of the PivotLine.'''

    REGULAR : PivotLineType
    '''Regular PivotLine with pivot items.'''

    SUBTOTAL : PivotLineType
    '''Subtotal line.'''

    GRAND_TOTAL : PivotLineType
    '''Grand Total line.'''

    BLANK : PivotLineType
    '''Blank line after each group.'''


class PivotMissingItemLimitType:
    '''Represents number of items to retain per field.'''

    AUTOMATIC : PivotMissingItemLimitType
    '''The default number of unique items per PivotField allowed.'''

    MAX : PivotMissingItemLimitType
    '''The maximum number of unique items per PivotField allowed (>32,500).'''

    NONE : PivotMissingItemLimitType
    '''No unique items per PivotField allowed.'''


class PivotNumbericRangeGroupSettings:
    '''Represents the numberic range group of the pivot field.'''

    def getEnd(self) -> int:
        '''Gets the end number of the group.'''
        raise NotImplementedError()

    def getStart(self) -> int:
        '''Gets the start number of the group.'''
        raise NotImplementedError()

    def getInterval(self) -> int:
        '''Gets the interval of the group.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the group type.
        See :class:`PivotFieldGroupType`'''
        raise NotImplementedError()


class PivotOptions:
    '''Represents a complex type that specifies the pivot controls that appear on the chart'''

    def getDropZoneCategories(self) -> bool:
        '''Specifies whether a control for each PivotTable field on the PivotTable row axis
        of the source PivotTable appears on the chart when dropZonesVisible is set to true.'''
        raise NotImplementedError()

    def getDropZoneData(self) -> bool:
        '''Specifies whether a control for each PivotTable field on the PivotTable data axis
        of the source PivotTable appears on the chart when dropZonesVisible is set to true.'''
        raise NotImplementedError()

    def setDropZoneSeries(self, value : bool) -> None:
        '''Specifies whether a control for each PivotTable field on the PivotTable column axis
        of the source PivotTable appears on the chart when dropZonesVisible is set to true.
        :param value: '''
        raise NotImplementedError()

    def setDropZoneData(self, value : bool) -> None:
        '''Specifies whether a control for each PivotTable field on the PivotTable data axis
        of the source PivotTable appears on the chart when dropZonesVisible is set to true.
        :param value: '''
        raise NotImplementedError()

    def setDropZonesVisible(self, value : bool) -> None:
        '''Specifies whether any pivot controls can appear on the pivot chart.
        :param value: '''
        raise NotImplementedError()

    def getDropZoneFilter(self) -> bool:
        '''Specifies whether a control for each PivotTable field on the PivotTable page axis
        of the source PivotTable appears on the chart when dropZonesVisible is set to true.'''
        raise NotImplementedError()

    def setDropZoneCategories(self, value : bool) -> None:
        '''Specifies whether a control for each PivotTable field on the PivotTable row axis
        of the source PivotTable appears on the chart when dropZonesVisible is set to true.
        :param value: '''
        raise NotImplementedError()

    def getDropZonesVisible(self) -> bool:
        '''Specifies whether any pivot controls can appear on the pivot chart.'''
        raise NotImplementedError()

    def setDropZoneFilter(self, value : bool) -> None:
        '''Specifies whether a control for each PivotTable field on the PivotTable page axis
        of the source PivotTable appears on the chart when dropZonesVisible is set to true.
        :param value: '''
        raise NotImplementedError()

    def getDropZoneSeries(self) -> bool:
        '''Specifies whether a control for each PivotTable field on the PivotTable column axis
        of the source PivotTable appears on the chart when dropZonesVisible is set to true.'''
        raise NotImplementedError()


class PivotPageFields:
    '''Represents the pivot page field items
    if the pivot table data source is consolidation ranges.
    It only can contain up to 4 fields.'''

    def addIdentify(self, rangeIndex : int, pageItemIndex : list[int]) -> None:
        '''Sets which item label in each page field to use to identify the data range.
        The pageItemIndex.Length must be equal to PageFieldCount, so please add the page field first.
        :param rangeIndex: The consolidation data range index.
        :param pageItemIndex: The page item index in the each page field.'''
        raise NotImplementedError()

    def getPageFieldCount(self) -> int:
        '''Gets the number of page fields.'''
        raise NotImplementedError()

    def addPageField(self, pageItems : list[str]) -> None:
        '''Adds a page field.
        :param pageItems: Page field item label'''
        raise NotImplementedError()


class PivotRefreshState:
    '''The state for refreshing pivot tables.'''

    SUCCESS : PivotRefreshState
    '''Successfully refreshed'''

    UNSUPPORTED_EXTERNAL_DATA_SOURCE : PivotRefreshState
    '''Refresh failed because the data source is external.'''


class PivotShowValuesSetting:
    '''Represents the settings about showing values as when the ShowDataAs calculation is in use.'''

    def setBaseItemPositionType(self, value : int) -> None:
        '''Represents type of the base pivot item in the base field when the ShowDataAs calculation is in use.
        Valid only for data fields.
        Because PivotItemPosition.Custom is only for read,if you need to set PivotItemPosition.Custom,
        please set PivotField.BaseItemIndex attribute.
        See :class:`PivotItemPositionType`
        :param value: '''
        raise NotImplementedError()

    def setBaseItemIndex(self, value : int) -> None:
        '''Represents the custom index of the pivot item in the base field when the ShowDataAs calculation is in use.
        Valid only for data fields.
        :param value: '''
        raise NotImplementedError()

    def getBaseItemPositionType(self) -> int:
        '''Represents type of the base pivot item in the base field when the ShowDataAs calculation is in use.
        Valid only for data fields.
        Because PivotItemPosition.Custom is only for read,if you need to set PivotItemPosition.Custom,
        please set PivotField.BaseItemIndex attribute.
        See :class:`PivotItemPositionType`'''
        raise NotImplementedError()

    def setBaseFieldIndex(self, value : int) -> None:
        '''Represents the base field for a ShowDataAs calculation when the ShowDataAs calculation is in use.
        :param value: '''
        raise NotImplementedError()

    def getBaseFieldIndex(self) -> int:
        '''Represents the base field for a ShowDataAs calculation when the ShowDataAs calculation is in use.'''
        raise NotImplementedError()

    def getCalculationType(self) -> int:
        '''Represents how to show values of a data field in the pivot report.
        See :class:`PivotFieldDataDisplayFormat`'''
        raise NotImplementedError()

    def setCalculationType(self, value : int) -> None:
        '''Represents how to show values of a data field in the pivot report.
        See :class:`PivotFieldDataDisplayFormat`
        :param value: '''
        raise NotImplementedError()

    def getBaseItemIndex(self) -> int:
        '''Represents the custom index of the pivot item in the base field when the ShowDataAs calculation is in use.
        Valid only for data fields.'''
        raise NotImplementedError()


class PivotTable:
    '''Summary description for PivotTable.'''

    def setDisplayErrorString(self, value : bool) -> None:
        '''Indicates whether the PivotTable report displays a custom string in cells that contain errors.
        :param value: '''
        raise NotImplementedError()

    def getEnableFieldDialog(self) -> bool:
        '''Indicates whether the PivotTable Field dialog box is available
        when the user double-clicks the PivotTable field.'''
        raise NotImplementedError()

    def showDetail(self, rowOffset : int, columnOffset : int, newSheet : bool, destRow : int, destColumn : int) -> None:
        '''Show the detail of one item in the data region to a new Table.
        :param rowOffset: Offset to the first data row in the data region.
        :param columnOffset: Offset to the first data column in the data region.
        :param newSheet: Show the detail to a new worksheet.
        :param destRow: The target row.
        :param destColumn: The target column.'''
        raise NotImplementedError()

    @overload
    def setUngroup(self, baseFieldIndex : int) -> None:
        ''':deprecated: Use PivotField.Ungroup() method instead.'''
        raise NotImplementedError()

    @overload
    def setUngroup(self, pivotField : PivotField) -> None:
        ''':deprecated: Use PivotField.Ungroup() method instead.'''
        raise NotImplementedError()

    def isMultipleFieldFilters(self) -> bool:
        '''Specifies a boolean value that indicates whether the fields of a PivotTable can have multiple filters set on them.'''
        raise NotImplementedError()

    def getEnableDataValueEditing(self) -> bool:
        '''Specifies a boolean value that indicates whether the user is allowed to edit the cells in the data area of the pivottable.
        Enable cell editing in the values area'''
        raise NotImplementedError()

    def clearData(self) -> None:
        '''Clear PivotTable's data and formatting'''
        raise NotImplementedError()

    def setRowHeaderCaption(self, value : str) -> None:
        '''Gets the Row Header Caption of the PivotTable.
        :param value: '''
        raise NotImplementedError()

    def setAltTextTitle(self, value : str) -> None:
        '''Sets the title of the alter text.
        :param value: '''
        raise NotImplementedError()

    def setAutoFormatType(self, value : int) -> None:
        '''Sets the auto format type of PivotTable.
        See :class:`PivotTableAutoFormatType`
        :param value: '''
        raise NotImplementedError()

    @overload
    def format(self, pivotArea : PivotArea, style : Style) -> None:
        '''Formats selected area of the PivotTable.
        :param pivotArea: 
        :param style: '''
        raise NotImplementedError()

    @overload
    def format(self, row : int, column : int, style : Style) -> None:
        '''Format the cell in the pivottable area
        :param row: Row Index of the cell
        :param column: Column index of the cell
        :param style: Style which is to format the cell'''
        raise NotImplementedError()

    def setIndent(self, value : int) -> None:
        '''Specifies the indentation increment for compact axis and can be used to set the Report Layout to Compact Form.
        :param value: '''
        raise NotImplementedError()

    def setRefreshDataFlag(self, value : bool) -> None:
        '''Indicates whether Refreshing Data or not.
        :param value: '''
        raise NotImplementedError()

    def getCustomListSort(self) -> bool:
        '''Indicates whether consider built-in custom list when sort data'''
        raise NotImplementedError()

    def getShowRowHeaderCaption(self) -> bool:
        '''Indicates whether row header caption is shown in the PivotTable report
        Indicates whether Display field captions and filter drop downs'''
        raise NotImplementedError()

    def getNullString(self) -> str:
        '''Gets the string displayed in cells that contain null values
        when the DisplayNullString property is true.The default value is an empty string.'''
        raise NotImplementedError()

    @overload
    def refreshData(self) -> int:
        '''Refreshes pivottable's data and setting from it's data source.'''
        raise NotImplementedError()

    @overload
    def refreshData(self, option : PivotTableRefreshOption) -> int:
        '''Refreshes pivottable's data and setting from it's data source with options.
        :param option: The options for refreshing data source of pivot table.'''
        raise NotImplementedError()

    def setShowPivotStyleColumnStripes(self, value : bool) -> None:
        '''Indicates whether stripe formatting is applied for column.
        :param value: '''
        raise NotImplementedError()

    def setEnableDataValueEditing(self, value : bool) -> None:
        '''Specifies a boolean value that indicates whether the user is allowed to edit the cells in the data area of the pivottable.
        Enable cell editing in the values area
        :param value: '''
        raise NotImplementedError()

    def setMergeLabels(self, value : bool) -> None:
        '''True if the specified PivotTable report's outer-row item, column item, subtotal, and grand total labels use merged cells.
        :param value: '''
        raise NotImplementedError()

    def getShowPivotStyleRowStripes(self) -> bool:
        '''Indicates whether row stripe formatting is applied.'''
        raise NotImplementedError()

    def showReportFilterPage(self, pageField : PivotField) -> None:
        '''Show all the report filter pages according to PivotField, the PivotField must be located in the PageFields.
        :param pageField: The PivotField object'''
        raise NotImplementedError()

    def setPrintDrill(self, value : bool) -> None:
        '''Specifies a boolean value that indicates whether drill indicators should be printed.
        print expand/collapse buttons when displayed on pivottable.
        :param value: '''
        raise NotImplementedError()

    def getIndent(self) -> int:
        '''Specifies the indentation increment for compact axis and can be used to set the Report Layout to Compact Form.'''
        raise NotImplementedError()

    def getSaveData(self) -> bool:
        '''Indicates whether data for the PivotTable report is saved with the workbook.'''
        raise NotImplementedError()

    def setItemPrintTitles(self, value : bool) -> None:
        ''':deprecated: Use PivotTable.RepeatItemsOnEachPrintedPage property instead.'''
        raise NotImplementedError()

    def showInCompactForm(self) -> None:
        '''Layouts the PivotTable in compact form.'''
        raise NotImplementedError()

    def getManualUpdate(self) -> bool:
        '''Indicates whether the PivotTable report is recalculated only at the user's request.'''
        raise NotImplementedError()

    def setSaveData(self, value : bool) -> None:
        '''Indicates whether data for the PivotTable report is saved with the workbook.
        :param value: '''
        raise NotImplementedError()

    def setPrintTitles(self, value : bool) -> None:
        '''Indicates whether the print titles for the worksheet are set based
        on the PivotTable report. The default value is false.
        :param value: '''
        raise NotImplementedError()

    def isExcel2003Compatible(self) -> bool:
        '''Specifies whether the PivotTable is compatible for Excel2003 when refreshing PivotTable,
        if true, a string must be less than or equal to 255 characters, so if the string is greater than 255 characters,
        it will be truncated. if false, a string will not have the aforementioned restriction.
        The default value is true.'''
        raise NotImplementedError()

    def setMissingItemsLimit(self, value : int) -> None:
        '''Specifies a boolean value that indicates whether the fields of a PivotTable can have multiple filters set on them.
        See :class:`PivotMissingItemLimitType`
        :param value: '''
        raise NotImplementedError()

    def getSubtotalHiddenPageItems(self) -> bool:
        '''Indicates whether hidden page field items in the PivotTable report
        are included in row and column subtotals, block totals, and grand totals.
        The default value is False.'''
        raise NotImplementedError()

    def fields(self, fieldType : int) -> PivotFieldCollection:
        ''':deprecated: Use PivotField.GetFields() method instead.'''
        raise NotImplementedError()

    def setPageFieldWrapCount(self, value : int) -> None:
        '''Gets the number of page fields in each column or row in the PivotTable report.
        :param value: '''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Gets the name of the PivotTable
        :param value: '''
        raise NotImplementedError()

    def getShowValuesRow(self) -> bool:
        '''Indicates whether showing values row.'''
        raise NotImplementedError()

    @overload
    def setManualGroupField(self, baseFieldIndex : int, startVal : int, endVal : int, groupByList : list, intervalNum : int) -> None:
        ''':deprecated: Use PivotField.GroupBy() method instead.'''
        raise NotImplementedError()

    @overload
    def setManualGroupField(self, pivotField : PivotField, startVal : int, endVal : int, groupByList : list, intervalNum : int) -> None:
        ''':deprecated: Use PivotField.GroupBy() method instead.'''
        raise NotImplementedError()

    @overload
    def setManualGroupField(self, baseFieldIndex : int, startVal : DateTime, endVal : DateTime, groupByList : list, intervalNum : int) -> None:
        ''':deprecated: Use PivotField.GroupBy() method instead.'''
        raise NotImplementedError()

    @overload
    def setManualGroupField(self, pivotField : PivotField, startVal : DateTime, endVal : DateTime, groupByList : list, intervalNum : int) -> None:
        ''':deprecated: Use PivotField.GroupBy() method instead.'''
        raise NotImplementedError()

    def getPivotTableStyleType(self) -> int:
        '''Gets the built-in pivot table style.
        See :class:`PivotTableStyleType`'''
        raise NotImplementedError()

    def getShowPivotStyleRowHeader(self) -> bool:
        '''Indicates whether the row header in the pivot table should have the style applied.'''
        raise NotImplementedError()

    def setHasBlankRows(self, value : bool) -> None:
        '''Indicates whether to add blank rows.
        This property only applies for the PivotTable auto format types which needs to add blank rows.
        :param value: '''
        raise NotImplementedError()

    def setSubtotalHiddenPageItems(self, value : bool) -> None:
        '''Indicates whether hidden page field items in the PivotTable report
        are included in row and column subtotals, block totals, and grand totals.
        The default value is False.
        :param value: '''
        raise NotImplementedError()

    def showReportFilterPageByName(self, fieldName : str) -> None:
        '''Show all the report filter pages according to PivotField's name, the PivotField must be located in the PageFields.
        :param fieldName: The name of PivotField'''
        raise NotImplementedError()

    def setManualUpdate(self, value : bool) -> None:
        '''Indicates whether the PivotTable report is recalculated only at the user's request.
        :param value: '''
        raise NotImplementedError()

    def setEnableFieldList(self, value : bool) -> None:
        '''Gets whether enable the field list for the PivotTable.
        :param value: '''
        raise NotImplementedError()

    def getTableRange2(self) -> CellArea:
        '''Returns a CellArea object that represents the range containing the entire PivotTable report,
        includes page fields. Read-only.'''
        raise NotImplementedError()

    def getTableRange1(self) -> CellArea:
        '''Returns a CellArea object that represents the range containing the entire PivotTable report,
        but doesn't include page fields. Read-only.'''
        raise NotImplementedError()

    def getFields(self, fieldType : int) -> PivotFieldCollection:
        '''Gets the specific pivot field list by the region.
        :param fieldType: :class:`PivotFieldType`. the region type.
        :returns: the specific pivot field collection'''
        raise NotImplementedError()

    def setShowPivotStyleRowHeader(self, value : bool) -> None:
        '''Indicates whether the row header in the pivot table should have the style applied.
        :param value: '''
        raise NotImplementedError()

    def setCustomListSort(self, value : bool) -> None:
        '''Indicates whether consider built-in custom list when sort data
        :param value: '''
        raise NotImplementedError()

    def setDataSource(self, value : list[str]) -> None:
        '''Sets the data source of the pivot table.
        :param value: '''
        raise NotImplementedError()

    def getPivotFormatConditions(self) -> PivotFormatConditionCollection:
        '''Gets the Format Conditions of the pivot table.'''
        raise NotImplementedError()

    def getPivotFilters(self) -> PivotFilterCollection:
        '''Returns a list of pivot filters.'''
        raise NotImplementedError()

    @overload
    def move(self, row : int, column : int) -> None:
        '''Moves the PivotTable to a different location in the worksheet.
        :param row: row index.
        :param column: column index.'''
        raise NotImplementedError()

    @overload
    def move(self, destCellName : str) -> None:
        '''Moves the PivotTable to a different location in the worksheet.
        :param destCellName: the dest cell name.'''
        raise NotImplementedError()

    def getDataFieldHeaderName(self) -> str:
        '''Gets the name of the value area field header in the PivotTable.'''
        raise NotImplementedError()

    def calculateRange(self) -> None:
        '''Calculates pivottable's range.'''
        raise NotImplementedError()

    def getTag(self) -> str:
        '''Gets a string saved with the PivotTable report.'''
        raise NotImplementedError()

    def getShowDataTips(self) -> bool:
        '''Specifies a boolean value that indicates whether tooltips should be displayed for PivotTable data cells.'''
        raise NotImplementedError()

    def getAutofitColumnWidthOnUpdate(self) -> bool:
        '''Indicates whether autofitting column width on update'''
        raise NotImplementedError()

    def getHorizontalBreaks(self) -> list:
        '''get pivot table row index list of horizontal pagebreaks'''
        raise NotImplementedError()

    def setExcel2003Compatible(self, value : bool) -> None:
        '''Specifies whether the PivotTable is compatible for Excel2003 when refreshing PivotTable,
        if true, a string must be less than or equal to 255 characters, so if the string is greater than 255 characters,
        it will be truncated. if false, a string will not have the aforementioned restriction.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def setShowValuesRow(self, value : bool) -> None:
        '''Indicates whether showing values row.
        :param value: '''
        raise NotImplementedError()

    def getShowPivotStyleColumnHeader(self) -> bool:
        '''Indicates whether the column header in the pivot table should have the style applied.'''
        raise NotImplementedError()

    @overload
    def calculateData(self) -> None:
        '''Calculates pivottable's data to cells.'''
        raise NotImplementedError()

    @overload
    def calculateData(self, option : PivotTableCalculateOption) -> None:
        '''Calculating pivot tables with options
        :param option: '''
        raise NotImplementedError()

    def isAutoFormat(self) -> bool:
        '''Indicates whether the PivotTable report is automatically formatted.
        Checkbox "autoformat table " which is in pivottable option for Excel 2003'''
        raise NotImplementedError()

    def getRefreshedByWho(self) -> str:
        '''Gets the name of the last user who refreshed this PivotTable'''
        raise NotImplementedError()

    def setEnableFieldDialog(self, value : bool) -> None:
        '''Indicates whether the PivotTable Field dialog box is available
        when the user double-clicks the PivotTable field.
        :param value: '''
        raise NotImplementedError()

    def getPivotTableStyleName(self) -> str:
        '''Gets the pivottable style name.'''
        raise NotImplementedError()

    def getDataFields(self) -> PivotFieldCollection:
        '''Gets a PivotField object that represents all the data fields in a PivotTable.
        Read-only.It would be init only when there are two or more data fields in the DataPiovtFiels.
        It only use to add DataPivotField to the PivotTable row/column area . Default is in row area.'''
        raise NotImplementedError()

    def getChildren(self) -> list[PivotTable]:
        '''Gets the Children Pivot Tables which use this PivotTable data as data source.'''
        raise NotImplementedError()

    def getShowPivotStyleColumnStripes(self) -> bool:
        '''Indicates whether stripe formatting is applied for column.'''
        raise NotImplementedError()

    def getEnableWizard(self) -> bool:
        '''Indicates whether the PivotTable Wizard is available.'''
        raise NotImplementedError()

    def setShowDataTips(self, value : bool) -> None:
        '''Specifies a boolean value that indicates whether tooltips should be displayed for PivotTable data cells.
        :param value: '''
        raise NotImplementedError()

    def getPivotFormats(self) -> PivotTableFormatCollection:
        '''Gets the collection of formats applied to PivotTable.'''
        raise NotImplementedError()

    def setTag(self, value : str) -> None:
        '''Gets a string saved with the PivotTable report.
        :param value: '''
        raise NotImplementedError()

    @overload
    def addCalculatedField(self, name : str, formula : str, dragToDataArea : bool) -> None:
        '''Adds a calculated field to pivot field.
        :param name: The name of the calculated field
        :param formula: The formula of the calculated field.
        :param dragToDataArea: True,drag this field to data area immediately'''
        raise NotImplementedError()

    @overload
    def addCalculatedField(self, name : str, formula : str) -> None:
        '''Adds a calculated field to pivot field and drag it to data area.
        :param name: The name of the calculated field
        :param formula: The formula of the calculated field.'''
        raise NotImplementedError()

    def getErrorString(self) -> str:
        '''Gets the string displayed in cells that contain errors
        when the DisplayErrorString property is true.The default value is an empty string.'''
        raise NotImplementedError()

    def getDisplayImmediateItems(self) -> bool:
        '''Indicates whether items in the row and column areas are visible
        when the data area of the PivotTable is empty. The default value is true.'''
        raise NotImplementedError()

    def getExternalConnectionDataSource(self) -> ExternalConnection:
        ''':deprecated: Use pivotTable.GetSourceDataConnections() method instead.'''
        raise NotImplementedError()

    def copyStyle(self, pivotTable : PivotTable) -> None:
        '''Copies named style from another pivot table.
        :param pivotTable: Source pivot table.'''
        raise NotImplementedError()

    def getGrandTotalName(self) -> str:
        '''Returns the text string label that is displayed in the grand total column or row heading.
        The default value is the string "Grand Total".'''
        raise NotImplementedError()

    def changeDataSource(self, source : list[str]) -> None:
        '''Set pivottable's source data.
        Sheet1!$A$1:$C$3
        :param source: '''
        raise NotImplementedError()

    def getSource(self) -> list[str]:
        '''Get pivottable's source data.'''
        raise NotImplementedError()

    def getColumnHeaderCaption(self) -> str:
        '''Gets the Column Header Caption of the PivotTable.'''
        raise NotImplementedError()

    def setEnableWizard(self, value : bool) -> None:
        '''Indicates whether the PivotTable Wizard is available.
        :param value: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the PivotTable'''
        raise NotImplementedError()

    def setShowEmptyCol(self, value : bool) -> None:
        '''Specifies a boolean value that indicates whether to include empty columns in the table
        :param value: '''
        raise NotImplementedError()

    def hasBlankRows(self) -> bool:
        '''Indicates whether to add blank rows.
        This property only applies for the PivotTable auto format types which needs to add blank rows.'''
        raise NotImplementedError()

    def getEnableDrilldown(self) -> bool:
        '''Gets whether drilldown is enabled.'''
        raise NotImplementedError()

    def getDisplayNullString(self) -> bool:
        '''Indicates whether the PivotTable report displays a custom string if the value is null.'''
        raise NotImplementedError()

    def getShowEmptyCol(self) -> bool:
        '''Specifies a boolean value that indicates whether to include empty columns in the table'''
        raise NotImplementedError()

    def getFieldListSortAscending(self) -> bool:
        '''Indicates whether fields in the PivotTable are sorted in non-default order in the field list.'''
        raise NotImplementedError()

    def getShowMemberPropertyTips(self) -> bool:
        '''Specifies a boolean value that indicates whether member property information should be omitted from PivotTable tooltips.'''
        raise NotImplementedError()

    def setFieldListSortAscending(self, value : bool) -> None:
        '''Indicates whether fields in the PivotTable are sorted in non-default order in the field list.
        :param value: '''
        raise NotImplementedError()

    def setShowDrill(self, value : bool) -> None:
        '''Sets whether showing expand/collapse buttons.
        :param value: '''
        raise NotImplementedError()

    def getDataField(self) -> PivotField:
        '''Gets a :class:`PivotField` object that represents all the data fields in a PivotTable.
        Read-only.
        It would only be created when there are two or more data fields in the Data region.
        Defaultly it is in row region. You can drag it to the row/column region with PivotTable.AddFieldToArea() method .'''
        raise NotImplementedError()

    def getPrintDrill(self) -> bool:
        '''Specifies a boolean value that indicates whether drill indicators should be printed.
        print expand/collapse buttons when displayed on pivottable.'''
        raise NotImplementedError()

    def getRowFields(self) -> PivotFieldCollection:
        '''Returns a PivotFields object that are currently shown as row fields.'''
        raise NotImplementedError()

    def getPageFields(self) -> PivotFieldCollection:
        '''Returns a PivotFields object that are currently shown as page fields.'''
        raise NotImplementedError()

    def getDataSource(self) -> list[str]:
        '''Gets the data source of the pivot table.'''
        raise NotImplementedError()

    def dispose(self) -> None:
        '''Performs application-defined tasks associated with freeing, releasing, or
        resetting unmanaged resources.'''
        raise NotImplementedError()

    def setShowPivotStyleLastColumn(self, value : bool) -> None:
        '''Indicates whether the column formatting is applied.
        :param value: '''
        raise NotImplementedError()

    def setErrorString(self, value : str) -> None:
        '''Gets the string displayed in cells that contain errors
        when the DisplayErrorString property is true.The default value is an empty string.
        :param value: '''
        raise NotImplementedError()

    def getRepeatItemsOnEachPrintedPage(self) -> bool:
        '''Indicates whether pivot item captions on the row area are repeated on each printed page for pivot fields in tabular form.'''
        raise NotImplementedError()

    def showInOutlineForm(self) -> None:
        '''Layouts the PivotTable in outline form.'''
        raise NotImplementedError()

    def setShowMemberPropertyTips(self, value : bool) -> None:
        '''Specifies a boolean value that indicates whether member property information should be omitted from PivotTable tooltips.
        :param value: '''
        raise NotImplementedError()

    def setGrandTotalName(self, value : str) -> None:
        '''Returns the text string label that is displayed in the grand total column or row heading.
        The default value is the string "Grand Total".
        :param value: '''
        raise NotImplementedError()

    def getColumnFields(self) -> PivotFieldCollection:
        '''Returns a PivotFields object that are currently shown as column fields.'''
        raise NotImplementedError()

    def getRefreshDate(self) -> DateTime:
        '''Gets the last date time when the PivotTable was refreshed.'''
        raise NotImplementedError()

    def getPreserveFormatting(self) -> bool:
        '''Indicates whether formatting is preserved when the PivotTable is refreshed or recalculated.'''
        raise NotImplementedError()

    def setMultipleFieldFilters(self, value : bool) -> None:
        '''Specifies a boolean value that indicates whether the fields of a PivotTable can have multiple filters set on them.
        :param value: '''
        raise NotImplementedError()

    def getColumnGrand(self) -> bool:
        '''Indicates whether the PivotTable report shows grand totals for columns.'''
        raise NotImplementedError()

    def getPageFieldOrder(self) -> int:
        '''Gets the order in which page fields are added to the PivotTable report's layout.
        See :class:`PrintOrderType`'''
        raise NotImplementedError()

    def setNullString(self, value : str) -> None:
        '''Gets the string displayed in cells that contain null values
        when the DisplayNullString property is true.The default value is an empty string.
        :param value: '''
        raise NotImplementedError()

    def isGridDropZones(self) -> bool:
        '''Indicates whether the PivotTable report displays classic pivottable layout.
        (enables dragging fields in the grid)'''
        raise NotImplementedError()

    def setRepeatItemsOnEachPrintedPage(self, value : bool) -> None:
        '''Indicates whether pivot item captions on the row area are repeated on each printed page for pivot fields in tabular form.
        :param value: '''
        raise NotImplementedError()

    def getRefreshDataFlag(self) -> bool:
        '''Indicates whether Refreshing Data or not.'''
        raise NotImplementedError()

    def getShowDrill(self) -> bool:
        '''Gets whether showing expand/collapse buttons.'''
        raise NotImplementedError()

    def setSelected(self, value : bool) -> None:
        '''Indicates whether this PivotTable is selected.
        :param value: '''
        raise NotImplementedError()

    def getSourceType(self) -> int:
        '''Gets the data source type of the pivot table.
        See :class:`PivotTableSourceType`'''
        raise NotImplementedError()

    def setRowGrand(self, value : bool) -> None:
        '''Indicates whether the PivotTable report shows grand totals for rows.
        :param value: '''
        raise NotImplementedError()

    def getShowPivotStyleLastColumn(self) -> bool:
        '''Indicates whether the column formatting is applied.'''
        raise NotImplementedError()

    @overload
    def removeField(self, fieldType : int, fieldName : str) -> None:
        '''Removes a field from specific field area
        :param fieldType: :class:`PivotFieldType`. The fields area type.
        :param fieldName: The name in the base fields.'''
        raise NotImplementedError()

    @overload
    def removeField(self, fieldType : int, baseFieldIndex : int) -> None:
        '''Removes a field from specific field area
        :param fieldType: :class:`PivotFieldType`. The fields area type.
        :param baseFieldIndex: The field index in the base fields.'''
        raise NotImplementedError()

    @overload
    def removeField(self, fieldType : int, pivotField : PivotField) -> None:
        '''Remove field from specific field area
        :param fieldType: :class:`PivotFieldType`. the fields area type.
        :param pivotField: the field in the base fields.'''
        raise NotImplementedError()

    def setRefreshDataOnOpeningFile(self, value : bool) -> None:
        '''Indicates whether Refresh Data when Opening File.
        :param value: '''
        raise NotImplementedError()

    def setDisplayNullString(self, value : bool) -> None:
        '''Indicates whether the PivotTable report displays a custom string if the value is null.
        :param value: '''
        raise NotImplementedError()

    def setEnableDrilldown(self, value : bool) -> None:
        '''Gets whether drilldown is enabled.
        :param value: '''
        raise NotImplementedError()

    def setShowRowHeaderCaption(self, value : bool) -> None:
        '''Indicates whether row header caption is shown in the PivotTable report
        Indicates whether Display field captions and filter drop downs
        :param value: '''
        raise NotImplementedError()

    def setPivotTableStyleType(self, value : int) -> None:
        '''Sets the built-in pivot table style.
        See :class:`PivotTableStyleType`
        :param value: '''
        raise NotImplementedError()

    def setDataFieldHeaderName(self, value : str) -> None:
        '''Sets the name of the value area field header in the PivotTable.
        :param value: '''
        raise NotImplementedError()

    def getAltTextDescription(self) -> str:
        '''Gets the description of the alt text.'''
        raise NotImplementedError()

    def getRowGrand(self) -> bool:
        '''Indicates whether the PivotTable report shows grand totals for rows.'''
        raise NotImplementedError()

    @overload
    def addFieldToArea(self, fieldType : int, fieldName : str) -> int:
        '''Adds the field to the specific area.
        :param fieldType: :class:`PivotFieldType`. The fields area type.
        :param fieldName: The name in the base fields.
        :returns: The field position in the specific fields.If there is no field named as it, return -1.'''
        raise NotImplementedError()

    @overload
    def addFieldToArea(self, fieldType : int, baseFieldIndex : int) -> int:
        '''Adds the field to the specific area.
        :param fieldType: :class:`PivotFieldType`. The fields area type.
        :param baseFieldIndex: The field index in the base fields.
        :returns: The field position in the specific fields.'''
        raise NotImplementedError()

    @overload
    def addFieldToArea(self, fieldType : int, pivotField : PivotField) -> int:
        '''Adds the field to the specific area.
        :param fieldType: :class:`PivotFieldType`. the fields area type.
        :param pivotField: the field in the base fields.
        :returns: the field position in the specific fields.'''
        raise NotImplementedError()

    def getItemPrintTitles(self) -> bool:
        ''':deprecated: Use PivotTable.RepeatItemsOnEachPrintedPage property instead.'''
        raise NotImplementedError()

    def showInTabularForm(self) -> None:
        '''Layouts the PivotTable in tabular form.'''
        raise NotImplementedError()

    def getBaseFields(self) -> PivotFieldCollection:
        '''Returns all base pivot fields in the PivotTable.'''
        raise NotImplementedError()

    def setDisplayImmediateItems(self, value : bool) -> None:
        '''Indicates whether items in the row and column areas are visible
        when the data area of the PivotTable is empty. The default value is true.
        :param value: '''
        raise NotImplementedError()

    def setShowEmptyRow(self, value : bool) -> None:
        '''Specifies a boolean value that indicates whether to include empty rows in the table.
        :param value: '''
        raise NotImplementedError()

    def getDisplayErrorString(self) -> bool:
        '''Indicates whether the PivotTable report displays a custom string in cells that contain errors.'''
        raise NotImplementedError()

    def getDataBodyRange(self) -> CellArea:
        '''Returns a :class:`CellArea` object that represents the range that contains the data area
        in the list between the header row and the insert row. Read-only.'''
        raise NotImplementedError()

    def showReportFilterPageByIndex(self, posIndex : int) -> None:
        '''Show all the report filter pages according to the position index in the PageFields
        :param posIndex: The position index in the PageFields'''
        raise NotImplementedError()

    def getShowEmptyRow(self) -> bool:
        '''Specifies a boolean value that indicates whether to include empty rows in the table.'''
        raise NotImplementedError()

    def getColumnRange(self) -> CellArea:
        '''Returns a CellArea object that represents the range
        that contains the column area in the PivotTable report. Read-only.'''
        raise NotImplementedError()

    def getCellByDisplayName(self, displayName : str) -> Cell:
        '''Gets the :class:`Cell` object by the display name of PivotField.
        :param displayName: the DisplayName of PivotField
        :returns: the Cell object'''
        raise NotImplementedError()

    def getAutoFormatType(self) -> int:
        '''Gets the auto format type of PivotTable.
        See :class:`PivotTableAutoFormatType`'''
        raise NotImplementedError()

    def formatAll(self, style : Style) -> None:
        '''Format all the cell in the pivottable area
        :param style: Style which is to format'''
        raise NotImplementedError()

    def setColumnGrand(self, value : bool) -> None:
        '''Indicates whether the PivotTable report shows grand totals for columns.
        :param value: '''
        raise NotImplementedError()

    def setAutoFormat(self, value : bool) -> None:
        '''Indicates whether the PivotTable report is automatically formatted.
        Checkbox "autoformat table " which is in pivottable option for Excel 2003
        :param value: '''
        raise NotImplementedError()

    def setPreserveFormatting(self, value : bool) -> None:
        '''Indicates whether formatting is preserved when the PivotTable is refreshed or recalculated.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setAutoGroupField(self, baseFieldIndex : int) -> None:
        ''':deprecated: Use PivotField.GroupBy() method instead.'''
        raise NotImplementedError()

    @overload
    def setAutoGroupField(self, pivotField : PivotField) -> None:
        ''':deprecated: Use PivotField.GroupBy() method instead.'''
        raise NotImplementedError()

    def isSelected(self) -> bool:
        '''Indicates whether this PivotTable is selected.'''
        raise NotImplementedError()

    def setPageFieldOrder(self, value : int) -> None:
        '''Sets the order in which page fields are added to the PivotTable report's layout.
        See :class:`PrintOrderType`
        :param value: '''
        raise NotImplementedError()

    def getEnableFieldList(self) -> bool:
        '''Gets whether enable the field list for the PivotTable.'''
        raise NotImplementedError()

    def getRefreshDataOnOpeningFile(self) -> bool:
        '''Indicates whether Refresh Data when Opening File.'''
        raise NotImplementedError()

    def getRowHeaderCaption(self) -> str:
        '''Gets the Row Header Caption of the PivotTable.'''
        raise NotImplementedError()

    def getNamesOfSourceDataConnections(self) -> list[str]:
        '''Gets the name of external source data connections.'''
        raise NotImplementedError()

    def getMissingItemsLimit(self) -> int:
        '''Specifies a boolean value that indicates whether the fields of a PivotTable can have multiple filters set on them.
        See :class:`PivotMissingItemLimitType`'''
        raise NotImplementedError()

    def formatRow(self, row : int, style : Style) -> None:
        '''Format the row data in the pivottable area
        :param row: Row Index of the Row object
        :param style: Style which is to format'''
        raise NotImplementedError()

    def setAutofitColumnWidthOnUpdate(self, value : bool) -> None:
        '''Indicates whether autofitting column width on update
        :param value: '''
        raise NotImplementedError()

    def setPivotTableStyleName(self, value : str) -> None:
        '''Sets the pivottable style name.
        :param value: '''
        raise NotImplementedError()

    def setColumnHeaderCaption(self, value : str) -> None:
        '''Gets the Column Header Caption of the PivotTable.
        :param value: '''
        raise NotImplementedError()

    def setGridDropZones(self, value : bool) -> None:
        '''Indicates whether the PivotTable report displays classic pivottable layout.
        (enables dragging fields in the grid)
        :param value: '''
        raise NotImplementedError()

    def getMergeLabels(self) -> bool:
        '''True if the specified PivotTable report's outer-row item, column item, subtotal, and grand total labels use merged cells.'''
        raise NotImplementedError()

    def setShowPivotStyleColumnHeader(self, value : bool) -> None:
        '''Indicates whether the column header in the pivot table should have the style applied.
        :param value: '''
        raise NotImplementedError()

    def getRowRange(self) -> CellArea:
        '''Returns a CellArea object that represents the range
        that contains the row area in the PivotTable report. Read-only.'''
        raise NotImplementedError()

    def getAltTextTitle(self) -> str:
        '''Gets the title of the alter text.'''
        raise NotImplementedError()

    def setAltTextDescription(self, value : str) -> None:
        '''Gets the description of the alt text.
        :param value: '''
        raise NotImplementedError()

    def getSourceDataConnections(self) -> list[ExternalConnection]:
        '''Gets the external connection data sources.'''
        raise NotImplementedError()

    def setShowPivotStyleRowStripes(self, value : bool) -> None:
        '''Indicates whether row stripe formatting is applied.
        :param value: '''
        raise NotImplementedError()

    def getPageFieldWrapCount(self) -> int:
        '''Gets the number of page fields in each column or row in the PivotTable report.'''
        raise NotImplementedError()

    def getPrintTitles(self) -> bool:
        '''Indicates whether the print titles for the worksheet are set based
        on the PivotTable report. The default value is false.'''
        raise NotImplementedError()


class PivotTableAutoFormatType:
    '''Represents PivotTable auto format type.'''

    NONE : PivotTableAutoFormatType
    '''Represents None format type.'''

    CLASSIC : PivotTableAutoFormatType
    '''Represents Classic auto format type.'''

    REPORT_1 : PivotTableAutoFormatType
    '''Represents Report1 format type.'''

    REPORT_2 : PivotTableAutoFormatType
    '''Represents Report2 format type.'''

    REPORT_3 : PivotTableAutoFormatType
    '''Represents Report3 format type.'''

    REPORT_4 : PivotTableAutoFormatType
    '''Represents Report4 format type.'''

    REPORT_5 : PivotTableAutoFormatType
    '''Represents Report5 format type.'''

    REPORT_6 : PivotTableAutoFormatType
    '''Represents Report6 format type.'''

    REPORT_7 : PivotTableAutoFormatType
    '''Represents Report7 format type.'''

    REPORT_8 : PivotTableAutoFormatType
    '''Represents Report8 format type.'''

    REPORT_9 : PivotTableAutoFormatType
    '''Represents Report9 format type.'''

    REPORT_10 : PivotTableAutoFormatType
    '''Represents Report10 format type.'''

    TABLE_1 : PivotTableAutoFormatType
    '''Represents Table1 format type.'''

    TABLE_2 : PivotTableAutoFormatType
    '''Represents Table2 format type.'''

    TABLE_3 : PivotTableAutoFormatType
    '''Represents Table3 format type.'''

    TABLE_4 : PivotTableAutoFormatType
    '''Represents Table4 format type.'''

    TABLE_5 : PivotTableAutoFormatType
    '''Represents Table5 format type.'''

    TABLE_6 : PivotTableAutoFormatType
    '''Represents Table6 format type.'''

    TABLE_7 : PivotTableAutoFormatType
    '''Represents Table7 format type.'''

    TABLE_8 : PivotTableAutoFormatType
    '''Represents Table8 format type.'''

    TABLE_9 : PivotTableAutoFormatType
    '''Represents Table9 format type.'''

    TABLE_10 : PivotTableAutoFormatType
    '''Represents Table10 format type.'''


class PivotTableCalculateOption:
    '''Rerepsents the options of calcuating the pivot table.'''

    def setRefreshData(self, value : bool) -> None:
        '''Indicates whether refreshing data source of the pivottable.
        :param value: '''
        raise NotImplementedError()

    def getRefreshCharts(self) -> bool:
        '''Indicates whether refreshing charts are based on this pivot table.'''
        raise NotImplementedError()

    def getReserveMissingPivotItemType(self) -> int:
        '''Represents how to reserve missing pivot items.
        See :class:`ReserveMissingPivotItemType`'''
        raise NotImplementedError()

    def setRefreshCharts(self, value : bool) -> None:
        '''Indicates whether refreshing charts are based on this pivot table.
        :param value: '''
        raise NotImplementedError()

    def getRefreshData(self) -> bool:
        '''Indicates whether refreshing data source of the pivottable.'''
        raise NotImplementedError()

    def setReserveMissingPivotItemType(self, value : int) -> None:
        '''Represents how to reserve missing pivot items.
        See :class:`ReserveMissingPivotItemType`
        :param value: '''
        raise NotImplementedError()


class PivotTableCollection:
    '''Represents the collection of all the PivotTable objects on the specified worksheet.'''

    @overload
    def remove(self, pivotTable : PivotTable) -> None:
        '''Deletes the specified PivotTable and delete the PivotTable data
        :param pivotTable: PivotTable object'''
        raise NotImplementedError()

    @overload
    def remove(self, pivotTable : PivotTable, keepData : bool) -> None:
        '''Deletes the specified PivotTable
        :param pivotTable: PivotTable object
        :param keepData: Whether to keep the PivotTable data'''
        raise NotImplementedError()

    def clear(self) -> None:
        '''Clear all pivot tables.'''
        raise NotImplementedError()

    @overload
    def removeAt(self, index : int) -> None:
        '''Deletes the PivotTable at the specified index and delete the PivotTable data
        :param index: the position index in PivotTable collection'''
        raise NotImplementedError()

    @overload
    def removeAt(self, index : int, keepData : bool) -> None:
        '''Deletes the PivotTable at the specified index
        :param index: the position index in PivotTable collection
        :param keepData: Whether to keep the PivotTable data'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> PivotTable:
        '''Gets the PivotTable report by index.
        :param index: '''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> PivotTable:
        '''Gets the PivotTable report by pivottable's name.
        :param name: '''
        raise NotImplementedError()

    @overload
    def get(self, row : int, column : int) -> PivotTable:
        '''Gets the PivotTable report by pivottable's position.
        :param row: 
        :param column: '''
        raise NotImplementedError()

    @overload
    def add(self, sourceData : str, destCellName : str, tableName : str) -> int:
        '''Adds a new PivotTable.
        :param sourceData: The data for the new PivotTable cache.
        :param destCellName: The cell in the upper-left corner of the PivotTable report's destination range.
        :param tableName: The name of the new PivotTable report.
        :returns: The new added cache index.'''
        raise NotImplementedError()

    @overload
    def add(self, sourceData : str, destCellName : str, tableName : str, useSameSource : bool) -> int:
        '''Adds a new PivotTable.
        :param sourceData: The data for the new PivotTable cache.
        :param destCellName: The cell in the upper-left corner of the PivotTable report's destination range.
        :param tableName: The name of the new PivotTable report.
        :param useSameSource: Indicates whether using same data source when another existing pivot table has used this data source.
        :returns: The new added cache index.'''
        raise NotImplementedError()

    @overload
    def add(self, sourceData : str, row : int, column : int, tableName : str) -> int:
        '''Adds a new PivotTable.
        :param sourceData: The data cell range for the new PivotTable.Example : Sheet1!A1:C8
        :param row: Row index of the cell in the upper-left corner of the PivotTable report's destination range.
        :param column: Column index of the cell in the upper-left corner of the PivotTable report's destination range.
        :param tableName: The name of the new PivotTable report.
        :returns: The new added cache index.'''
        raise NotImplementedError()

    @overload
    def add(self, sourceData : str, row : int, column : int, tableName : str, useSameSource : bool) -> int:
        '''Adds a new PivotTable.
        :param sourceData: The data cell range for the new PivotTable.Example : Sheet1!A1:C8
        :param row: Row index of the cell in the upper-left corner of the PivotTable report's destination range.
        :param column: Column index of the cell in the upper-left corner of the PivotTable report's destination range.
        :param tableName: The name of the new PivotTable report.
        :param useSameSource: Indicates whether using same data source when another existing pivot table has used this data source.
        :returns: The new added cache index.'''
        raise NotImplementedError()

    @overload
    def add(self, sourceData : str, row : int, column : int, tableName : str, useSameSource : bool, isXlsClassic : bool) -> int:
        '''Adds a new PivotTable.
        :param sourceData: The data cell range for the new PivotTable.Example : Sheet1!A1:C8
        :param row: Row index of the cell in the upper-left corner of the PivotTable report's destination range.
        :param column: Column index of the cell in the upper-left corner of the PivotTable report's destination range.
        :param tableName: The name of the new PivotTable report.
        :param useSameSource: Indicates whether using same data source when another existing pivot table has used this data source.
        :param isXlsClassic: 
        :returns: The new added cache index.'''
        raise NotImplementedError()

    @overload
    def add(self, sourceData : str, cell : str, tableName : str, useSameSource : bool, isXlsClassic : bool) -> int:
        '''Adds a new PivotTable.
        :param sourceData: The data cell range for the new PivotTable.Example : Sheet1!A1:C8
        :param cell: The cell in the upper-left corner of the PivotTable report's destination range.
        :param tableName: The name of the new PivotTable report.
        :param useSameSource: Indicates whether using same data source when another existing pivot table has used this data source.
        :param isXlsClassic: 
        :returns: The new added cache index.'''
        raise NotImplementedError()

    @overload
    def add(self, pivotTable : PivotTable, destCellName : str, tableName : str) -> int:
        '''Adds a new PivotTable based on another PivotTable.
        :param pivotTable: The source pivotTable.
        :param destCellName: The cell in the upper-left corner of the PivotTable report's destination range.
        :param tableName: The name of the new PivotTable report.
        :returns: The new added PivotTable index.'''
        raise NotImplementedError()

    @overload
    def add(self, pivotTable : PivotTable, row : int, column : int, tableName : str) -> int:
        '''Adds a new PivotTable based on another PivotTable.
        :param pivotTable: The source pivotTable.
        :param row: Row index of the cell in the upper-left corner of the PivotTable report's destination range.
        :param column: Column index of the cell in the upper-left corner of the PivotTable report's destination range.
        :param tableName: The name of the new PivotTable report.
        :returns: The new added PivotTable index.'''
        raise NotImplementedError()

    @overload
    def add(self, sourceData : list[str], isAutoPage : bool, pageFields : PivotPageFields, destCellName : str, tableName : str) -> int:
        '''Adds a new PivotTable Object to the collection with multiple consolidation ranges as data source.
        :param sourceData: The multiple consolidation ranges,such as {"Sheet1!A1:C8","Sheet2!A1:B8"}
        :param isAutoPage: Whether auto create a single page field.
        :param pageFields: The pivot page field items.
        :param destCellName: destCellName The name of the new PivotTable report.
        :param tableName: the name of the new PivotTable report.
        :returns: The new added PivotTable index.'''
        raise NotImplementedError()

    @overload
    def add(self, sourceData : list[str], isAutoPage : bool, pageFields : PivotPageFields, row : int, column : int, tableName : str) -> int:
        '''Adds a new PivotTable Object to the collection with multiple consolidation ranges as data source.
        :param sourceData: The multiple consolidation ranges,such as {"Sheet1!A1:C8","Sheet2!A1:B8"}
        :param isAutoPage: Whether auto create a single page field.
        :param pageFields: The pivot page field items.
        :param row: Row index of the cell in the upper-left corner of the PivotTable report's destination range.
        :param column: Column index of the cell in the upper-left corner of the PivotTable report's destination range.
        :param tableName: The name of the new PivotTable report.
        :returns: The new added PivotTable index.'''
        raise NotImplementedError()

    def dispose(self) -> None:
        '''Performs application-defined tasks associated with freeing, releasing, or
        resetting unmanaged resources.'''
        raise NotImplementedError()


class PivotTableFormat:
    '''Represents the format defined in the PivotTable.'''

    def getStyle(self) -> Style:
        '''Gets the formatted style.'''
        raise NotImplementedError()

    def getPivotArea(self) -> PivotArea:
        '''Gets the pivot area.'''
        raise NotImplementedError()

    def setStyle(self, style : Style) -> None:
        '''Sets the style of the pivot area.
        :param style: '''
        raise NotImplementedError()


class PivotTableFormatCollection:
    '''Represents the collection of formats applied to PivotTable.'''

    def get(self, index : int) -> PivotTableFormat:
        '''Gets the format by the index.
        :param index: The index.'''
        raise NotImplementedError()

    def formatArea(self, axisType : int, fieldPosition : int, subtotalType : int, selectionType : int, isGrandRow : bool, isGrandColumn : bool, style : Style) -> PivotTableFormat:
        '''Formats selected area.
        :param axisType: :class:`PivotFieldType`. The region of the PivotTable to which this rule applies.
        :param fieldPosition: Position of the field within the axis to which this rule applies.
        :param subtotalType: :class:`PivotFieldSubtotalType`. The subtotal filter type of the pivot field
        :param selectionType: :class:`PivotTableSelectionType`. Indicates how to select data.
        :param isGrandRow: Indicates whether selecting grand total rows.
        :param isGrandColumn: Indicates whether selecting grand total columns.
        :param style: The style which appies to the area of the pivot table.'''
        raise NotImplementedError()

    def add(self) -> int:
        '''Add a :class:`PivotTableFormat`.'''
        raise NotImplementedError()


class PivotTableRefreshOption:
    '''Represents the options of refreshing data source of the pivot table.'''

    def getReserveMissingPivotItemType(self) -> int:
        '''Represents how to reserve missing pivot items.
        See :class:`ReserveMissingPivotItemType`'''
        raise NotImplementedError()

    def setReserveMissingPivotItemType(self, value : int) -> None:
        '''Represents how to reserve missing pivot items.
        See :class:`ReserveMissingPivotItemType`
        :param value: '''
        raise NotImplementedError()


class PivotTableSelectionType:
    '''Specifies what can be selected in a PivotTable during a structured selection.
    These constants can be combined to select multiple types.'''

    DATA_AND_LABEL : PivotTableSelectionType
    '''Data and labels'''

    DATA_ONLY : PivotTableSelectionType
    '''Only selects data'''

    LABEL_ONLY : PivotTableSelectionType
    '''Only selects labels'''


class PivotTableSourceType:
    '''Represents data source type of the pivot table.'''

    SHEET : PivotTableSourceType
    '''Specifies that the source data is a range.'''

    EXTERNAL : PivotTableSourceType
    '''Specifies that external source data is used.'''

    CONSOLIDATION : PivotTableSourceType
    '''Specifies that multiple consolidation ranges are used as the source data.'''

    SCENARIO : PivotTableSourceType
    '''The source data is populated from a temporary internal structure.'''

    UNKNOWN : PivotTableSourceType
    '''Unknown data source.'''


class PivotTableStyleType:
    '''Represents the pivot table style type.'''

    NONE : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_1 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_2 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_3 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_4 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_5 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_6 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_7 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_8 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_9 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_10 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_11 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_12 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_13 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_14 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_15 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_16 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_17 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_18 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_19 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_20 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_21 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_22 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_23 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_24 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_25 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_26 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_27 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_LIGHT_28 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_1 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_2 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_3 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_4 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_5 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_6 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_7 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_8 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_9 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_10 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_11 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_12 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_13 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_14 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_15 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_16 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_17 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_18 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_19 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_20 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_21 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_22 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_23 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_24 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_25 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_26 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_27 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_MEDIUM_28 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_1 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_2 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_3 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_4 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_5 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_6 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_7 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_8 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_9 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_10 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_11 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_12 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_13 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_14 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_15 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_16 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_17 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_18 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_19 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_20 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_21 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_22 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_23 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_24 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_25 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_26 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_27 : PivotTableStyleType
    ''''''

    PIVOT_TABLE_STYLE_DARK_28 : PivotTableStyleType
    ''''''

    CUSTOM : PivotTableStyleType
    ''''''


class PlacementType:
    '''Represents the way the drawing object is attached to the cells below it.'''

    FREE_FLOATING : PlacementType
    '''Don't move or size with cells.'''

    MOVE : PlacementType
    '''Move but don't size with cells.'''

    MOVE_AND_SIZE : PlacementType
    '''Move and size with cells.'''


class PlotArea:
    '''Encapsulates the object that represents the plot area in a chart.'''

    def setWidth(self, value : int) -> None:
        '''Sets the width of plot-area bounding box in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def setInnerWidth(self, value : int) -> None:
        '''Sets the width  of plot area in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Gets the width of plot-area bounding box in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def setAutomaticSize(self, value : bool) -> None:
        '''Indicates whether the plot area is automatic sized.
        :param value: '''
        raise NotImplementedError()

    def isAutomaticSize(self) -> bool:
        '''Indicates whether the plot area is automatic sized.'''
        raise NotImplementedError()

    def setHeight(self, value : int) -> None:
        '''Sets the height of plot-area bounding box in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def setInnerHeight(self, value : int) -> None:
        '''Sets the height of plot area in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Gets the height of plot-area bounding box in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def setInnerY(self, value : int) -> None:
        '''Gets or gets the x coordinate of the upper top corner of plot area in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def setY(self, value : int) -> None:
        '''Gets or gets the y coordinate of the upper top corner  of plot-area bounding box in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def setInnerX(self, value : int) -> None:
        '''Gets or gets the x coordinate of the upper top corner of plot area in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def setX(self, value : int) -> None:
        '''Gets or gets the x coordinate of the upper left corner of plot-area bounding box in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def getInnerY(self) -> int:
        '''Gets or gets the x coordinate of the upper top corner of plot area in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def getY(self) -> int:
        '''Gets or gets the y coordinate of the upper top corner  of plot-area bounding box in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def getInnerX(self) -> int:
        '''Gets or gets the x coordinate of the upper top corner of plot area in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def getX(self) -> int:
        '''Gets or gets the x coordinate of the upper left corner of plot-area bounding box in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def setPositionAuto(self) -> None:
        '''Set position of the plot area to automatic'''
        raise NotImplementedError()

    def getInnerHeight(self) -> int:
        '''Gets the height of plot area in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def getInnerWidth(self) -> int:
        '''Gets the width  of plot area in units of 1/4000 of the chart area.'''
        raise NotImplementedError()


class PlotDataByType:
    '''Represents the type of data plot by row or column.'''

    ROW : PlotDataByType
    '''By row.'''

    COLUMN : PlotDataByType
    '''By column.'''


class PlotEmptyCellsType:
    '''Represents all plot empty cells type of a chart.'''

    NOT_PLOTTED : PlotEmptyCellsType
    '''Not plotted(leave gap)'''

    ZERO : PlotEmptyCellsType
    '''Zero'''

    INTERPOLATED : PlotEmptyCellsType
    '''Interpolated'''


class PowerQueryFormula:
    '''Represents the definition of power query formula.'''

    def getPowerQueryFormulaItems(self) -> PowerQueryFormulaItemCollection:
        '''Gets all items of power query formula.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the power query formula.'''
        raise NotImplementedError()

    def getFormulaDefinition(self) -> str:
        '''Gets the definition of the power query formula.'''
        raise NotImplementedError()

    def getGroupName(self) -> str:
        '''Gets the name of group which contains this power query formula.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the power query formula.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of this power query formula.
        See :class:`PowerQueryFormulaType`'''
        raise NotImplementedError()


class PowerQueryFormulaCollection:
    '''Represents all power query formulas in the mashup data.'''

    @overload
    def get(self, index : int) -> PowerQueryFormula:
        '''Gets :class:`PowerQueryFormula` by the index in the list.
        :param index: The index.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> PowerQueryFormula:
        '''Gets :class:`PowerQueryFormula` by the name of the power query formula.
        :param name: The name of the item.'''
        raise NotImplementedError()


class PowerQueryFormulaFunction:
    '''Represents the function of power query.'''

    def setF(self, value : str) -> None:
        '''Sets the definition of function.
        :param value: '''
        raise NotImplementedError()

    def getF(self) -> str:
        '''Gets the definition of function.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of power query formula.
        See :class:`PowerQueryFormulaType`'''
        raise NotImplementedError()


class PowerQueryFormulaItem:
    '''Represents the item of the power query formula.'''

    def getValue(self) -> str:
        '''Gets the value of the item.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the item.'''
        raise NotImplementedError()

    def setValue(self, value : str) -> None:
        '''Gets the value of the item.
        :param value: '''
        raise NotImplementedError()


class PowerQueryFormulaItemCollection:
    '''Represents all item of the power query formula.'''

    @overload
    def get(self, index : int) -> PowerQueryFormulaItem:
        '''Gets :class:`PowerQueryFormulaItem` by the index in the list.
        :param index: The index.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> PowerQueryFormulaItem:
        '''Gets :class:`PowerQueryFormulaItem` by the name of the item.
        :param name: The name of the item.'''
        raise NotImplementedError()


class PowerQueryFormulaParameter:
    '''Represents the parameter of power query formula.'''

    def getParameterDefinition(self) -> str:
        ''':deprecated: Use PowerQueryFormulaParameter.FormulaDefinition property, instead.'''
        raise NotImplementedError()

    def getValue(self) -> str:
        '''Gets the value of parameter.'''
        raise NotImplementedError()

    def getFormulaDefinition(self) -> str:
        '''Gets the definition of the parameter.'''
        raise NotImplementedError()

    def setValue(self, value : str) -> None:
        '''Gets the value of parameter.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of power query formula.
        See :class:`PowerQueryFormulaType`'''
        raise NotImplementedError()


class PowerQueryFormulaParameterCollection:
    '''Represents the parameters of power query formula.'''

    @overload
    def get(self, index : int) -> PowerQueryFormulaParameter:
        '''Gets :class:`PowerQueryFormulaParameter` by the index in the list.
        :param index: The index.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> PowerQueryFormulaParameter:
        '''Gets :class:`PowerQueryFormulaParameter` by the name of the item.
        :param name: The name of the item.'''
        raise NotImplementedError()


class PowerQueryFormulaType:
    '''Represents the type of power query formula.'''

    FORMULA : PowerQueryFormulaType
    '''Formula power query formula.'''

    FUNCTION : PowerQueryFormulaType
    '''Function power query formula.'''

    PARAMETER : PowerQueryFormulaType
    '''Parameter power query formula.'''


class PptxSaveOptions:
    '''Represents the pptx save options.'''

    def setIgnoreHiddenRows(self, value : bool) -> None:
        '''Inidicates whether ignoring hidden rows when converting Excel to PowerPoint.
        :param value: '''
        raise NotImplementedError()

    def setExportViewType(self, value : int) -> None:
        '''Sets the display type when exporting to PowerPoint.
        The default exporting type is working as printing.
        See :class:`SlideViewType`
        :param value: '''
        raise NotImplementedError()

    def getExportViewType(self) -> int:
        '''Gets the display type when exporting to PowerPoint.
        The default exporting type is working as printing.
        See :class:`SlideViewType`'''
        raise NotImplementedError()

    def setAdjustFontSizeForRowType(self, value : int) -> None:
        '''Represents what type of line needs to be adjusted size of font if height of row is small.
        See :class:`AdjustFontSizeForRowType`
        :param value: '''
        raise NotImplementedError()

    def getAdjustFontSizeForRowType(self) -> int:
        '''Represents what type of line needs to be adjusted size of font if height of row is small.
        See :class:`AdjustFontSizeForRowType`'''
        raise NotImplementedError()

    def getIgnoreHiddenRows(self) -> bool:
        '''Inidicates whether ignoring hidden rows when converting Excel to PowerPoint.'''
        raise NotImplementedError()


class PresetCameraType:
    '''Represent different algorithmic methods for setting all camera properties, including position.'''

    ISOMETRIC_BOTTOM_DOWN : PresetCameraType
    ''''''

    ISOMETRIC_BOTTOM_UP : PresetCameraType
    ''''''

    ISOMETRIC_LEFT_DOWN : PresetCameraType
    ''''''

    ISOMETRIC_LEFT_UP : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_1_LEFT : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_1_RIGHT : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_1_TOP : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_2_LEFT : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_2_RIGHT : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_2_TOP : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_3_BOTTOM : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_3_LEFT : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_3_RIGHT : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_4_BOTTOM : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_4_LEFT : PresetCameraType
    ''''''

    ISOMETRIC_OFF_AXIS_4_RIGHT : PresetCameraType
    ''''''

    ISOMETRIC_RIGHT_DOWN : PresetCameraType
    ''''''

    ISOMETRIC_RIGHT_UP : PresetCameraType
    ''''''

    ISOMETRIC_TOP_DOWN : PresetCameraType
    ''''''

    ISOMETRIC_TOP_UP : PresetCameraType
    ''''''

    LEGACY_OBLIQUE_BOTTOM : PresetCameraType
    ''''''

    LEGACY_OBLIQUE_BOTTOM_LEFT : PresetCameraType
    ''''''

    LEGACY_OBLIQUE_BOTTOM_RIGHT : PresetCameraType
    ''''''

    LEGACY_OBLIQUE_FRONT : PresetCameraType
    ''''''

    LEGACY_OBLIQUE_LEFT : PresetCameraType
    ''''''

    LEGACY_OBLIQUE_RIGHT : PresetCameraType
    ''''''

    LEGACY_OBLIQUE_TOP : PresetCameraType
    ''''''

    LEGACY_OBLIQUE_TOP_LEFT : PresetCameraType
    ''''''

    LEGACY_OBLIQUE_TOP_RIGHT : PresetCameraType
    ''''''

    LEGACY_PERSPECTIVE_BOTTOM : PresetCameraType
    ''''''

    LEGACY_PERSPECTIVE_BOTTOM_LEFT : PresetCameraType
    ''''''

    LEGACY_PERSPECTIVE_BOTTOM_RIGHT : PresetCameraType
    ''''''

    LEGACY_PERSPECTIVE_FRONT : PresetCameraType
    ''''''

    LEGACY_PERSPECTIVE_LEFT : PresetCameraType
    ''''''

    LEGACY_PERSPECTIVE_RIGHT : PresetCameraType
    ''''''

    LEGACY_PERSPECTIVE_TOP : PresetCameraType
    ''''''

    LEGACY_PERSPECTIVE_TOP_LEFT : PresetCameraType
    ''''''

    LEGACY_PERSPECTIVE_TOP_RIGHT : PresetCameraType
    ''''''

    OBLIQUE_BOTTOM : PresetCameraType
    ''''''

    OBLIQUE_BOTTOM_LEFT : PresetCameraType
    ''''''

    OBLIQUE_BOTTOM_RIGHT : PresetCameraType
    ''''''

    OBLIQUE_LEFT : PresetCameraType
    ''''''

    OBLIQUE_RIGHT : PresetCameraType
    ''''''

    OBLIQUE_TOP : PresetCameraType
    ''''''

    OBLIQUE_TOP_LEFT : PresetCameraType
    ''''''

    OBLIQUE_TOP_RIGHT : PresetCameraType
    ''''''

    ORTHOGRAPHIC_FRONT : PresetCameraType
    ''''''

    PERSPECTIVE_ABOVE : PresetCameraType
    ''''''

    PERSPECTIVE_ABOVE_LEFT_FACING : PresetCameraType
    ''''''

    PERSPECTIVE_ABOVE_RIGHT_FACING : PresetCameraType
    ''''''

    PERSPECTIVE_BELOW : PresetCameraType
    ''''''

    PERSPECTIVE_CONTRASTING_LEFT_FACING : PresetCameraType
    ''''''

    PERSPECTIVE_CONTRASTING_RIGHT_FACING : PresetCameraType
    ''''''

    PERSPECTIVE_FRONT : PresetCameraType
    ''''''

    PERSPECTIVE_HEROIC_EXTREME_LEFT_FACING : PresetCameraType
    ''''''

    PERSPECTIVE_HEROIC_EXTREME_RIGHT_FACING : PresetCameraType
    ''''''

    PERSPECTIVE_HEROIC_LEFT_FACING : PresetCameraType
    ''''''

    PERSPECTIVE_HEROIC_RIGHT_FACING : PresetCameraType
    ''''''

    PERSPECTIVE_LEFT : PresetCameraType
    ''''''

    PERSPECTIVE_RELAXED : PresetCameraType
    ''''''

    PERSPECTIVE_RELAXED_MODERATELY : PresetCameraType
    ''''''

    PERSPECTIVE_RIGHT : PresetCameraType
    ''''''


class PresetMaterialType:
    '''Describes surface appearance of a shape.'''

    CLEAR : PresetMaterialType
    '''Clear'''

    DARK_EDGE : PresetMaterialType
    '''Dark edge'''

    FLAT : PresetMaterialType
    '''Flat'''

    LEGACY_MATTE : PresetMaterialType
    '''Legacy matte'''

    LEGACY_METAL : PresetMaterialType
    '''Legacy metal'''

    LEGACY_PLASTIC : PresetMaterialType
    '''Legacy plastic'''

    LEGACY_WIREFRAME : PresetMaterialType
    '''Legacy wireframe'''

    MATTE : PresetMaterialType
    '''Matte'''

    METAL : PresetMaterialType
    '''Metal'''

    PLASTIC : PresetMaterialType
    '''Plastic'''

    POWDER : PresetMaterialType
    '''Powder'''

    SOFT_EDGE : PresetMaterialType
    '''Soft edge'''

    SOFT_METAL : PresetMaterialType
    '''Soft metal'''

    TRANSLUCENT_POWDER : PresetMaterialType
    '''Translucent powder'''

    WARM_MATTE : PresetMaterialType
    '''Warm matte'''


class PresetShadowType:
    '''Represents preset shadow type.'''

    NO_SHADOW : PresetShadowType
    '''No shadow.'''

    CUSTOM : PresetShadowType
    '''Custom shadow.'''

    OFFSET_DIAGONAL_BOTTOM_RIGHT : PresetShadowType
    '''Outer shadow offset diagonal bottom right.'''

    OFFSET_BOTTOM : PresetShadowType
    '''Outer shadow offset bottom.'''

    OFFSET_DIAGONAL_BOTTOM_LEFT : PresetShadowType
    '''Outer shadow offset diagonal bottom left.'''

    OFFSET_RIGHT : PresetShadowType
    '''Outer shadow offset right.'''

    OFFSET_CENTER : PresetShadowType
    '''Outer shadow offset center.'''

    OFFSET_LEFT : PresetShadowType
    '''Outer shadow offset left.'''

    OFFSET_DIAGONAL_TOP_RIGHT : PresetShadowType
    '''Outer shadow offset diagonal top right.'''

    OFFSET_TOP : PresetShadowType
    '''Outer shadow offset top.'''

    OFFSET_DIAGONAL_TOP_LEFT : PresetShadowType
    '''Outer shadow offset diagonal top left.'''

    INSIDE_DIAGONAL_TOP_LEFT : PresetShadowType
    '''Inner shadow inside diagonal top Left.'''

    INSIDE_TOP : PresetShadowType
    '''Inner shadow inside top.'''

    INSIDE_DIAGONAL_TOP_RIGHT : PresetShadowType
    '''Inner shadow inside diagonal top right.'''

    INSIDE_LEFT : PresetShadowType
    '''Inner shadow inside left.'''

    INSIDE_CENTER : PresetShadowType
    '''Inner shadow inside center.'''

    INSIDE_RIGHT : PresetShadowType
    '''Inner shadow inside right.'''

    INSIDE_DIAGONAL_BOTTOM_LEFT : PresetShadowType
    '''Inner shadow inside diagonal bottom left.'''

    INSIDE_BOTTOM : PresetShadowType
    '''Inner shadow inside bottom.'''

    INSIDE_DIAGONAL_BOTTOM_RIGHT : PresetShadowType
    '''Inner shadow inside diagonal bottom right.'''

    PERSPECTIVE_DIAGONAL_UPPER_LEFT : PresetShadowType
    '''Outer shadow perspective diagonal upper left.'''

    PERSPECTIVE_DIAGONAL_UPPER_RIGHT : PresetShadowType
    '''Outer shadow perspective diagonal upper right.'''

    BELOW : PresetShadowType
    '''Outer shadow below.'''

    PERSPECTIVE_DIAGONAL_LOWER_LEFT : PresetShadowType
    '''Outer shadow perspective diagonal lower left.'''

    PERSPECTIVE_DIAGONAL_LOWER_RIGHT : PresetShadowType
    '''Outer shadow perspective diagonal lower right.'''


class PresetThemeGradientType:
    '''Represents the preset theme gradient type.'''

    LIGHT_GRADIENT : PresetThemeGradientType
    '''Light gradient'''

    TOP_SPOTLIGHT : PresetThemeGradientType
    '''Top spotlight'''

    MEDIUM_GRADIENT : PresetThemeGradientType
    '''Medium gradient'''

    BOTTOM_SPOTLIGHT : PresetThemeGradientType
    '''Bottom spotlight'''

    RADIAL_GRADIENT : PresetThemeGradientType
    '''Radial gradient'''


class PresetWordArtStyle:
    '''Represents the preset WordArt styles.'''

    WORD_ART_STYLE_1 : PresetWordArtStyle
    '''Fill - Black, Text 1, Shadow'''

    WORD_ART_STYLE_2 : PresetWordArtStyle
    '''Fill - Blue, Accent 1, Shadow'''

    WORD_ART_STYLE_3 : PresetWordArtStyle
    '''Fill - Orange, Accent 2, Outline - Accent 2'''

    WORD_ART_STYLE_4 : PresetWordArtStyle
    '''Fill - White, Outline - Accent 1, Shadow'''

    WORD_ART_STYLE_5 : PresetWordArtStyle
    '''Fill - Gold, Accent 4, Soft Bevel'''

    WORD_ART_STYLE_6 : PresetWordArtStyle
    '''Gradient Fill - Gray'''

    WORD_ART_STYLE_7 : PresetWordArtStyle
    '''Gradient Fill - Blue, Accent 1, Reflection'''

    WORD_ART_STYLE_8 : PresetWordArtStyle
    '''Gradient Fill - Gold, Accent 4, Outline - Accent 4'''

    WORD_ART_STYLE_9 : PresetWordArtStyle
    '''Fill - White, Outline - Accent 1, Glow - Accent 1'''

    WORD_ART_STYLE_10 : PresetWordArtStyle
    '''Fill - Gray-50%, Accent 3, Sharp Bevel'''

    WORD_ART_STYLE_11 : PresetWordArtStyle
    '''Fill - Black, Text 1, Outline - Background 1, Hard Shadow - Background 1'''

    WORD_ART_STYLE_12 : PresetWordArtStyle
    '''Fill - Black, Text 1, Outline - Background 1, Hard Shadow - Accent 1'''

    WORD_ART_STYLE_13 : PresetWordArtStyle
    '''Fill - Blue, Accent 1, Outline - Background 1, Hard Shadow - Accent 1'''

    WORD_ART_STYLE_14 : PresetWordArtStyle
    '''Fill - White, Outline - Accent 2, Hard Shadow - Accent 2'''

    WORD_ART_STYLE_15 : PresetWordArtStyle
    '''Fill - Gray-25%, Background 2, Inner Shadow'''

    WORD_ART_STYLE_16 : PresetWordArtStyle
    '''Pattern Fill - White, Text 2, Dark Upward Diagonal, Shadow'''

    WORD_ART_STYLE_17 : PresetWordArtStyle
    '''Pattern Fill - Gray-50%, Accent 3, Narrow Horizontal, Inner Shadow'''

    WORD_ART_STYLE_18 : PresetWordArtStyle
    '''Fill - Blue, Accent 1, 50%, Hard Shadow - Accent 1'''

    WORD_ART_STYLE_19 : PresetWordArtStyle
    '''Pattern Fill - Blue, Accent 1, Light Downward Diagonal, Outline - Accent 1'''

    WORD_ART_STYLE_20 : PresetWordArtStyle
    '''Pattern Fill - Blue-Gray, Text 2, Dark Upward Diagonal, Hard Shadow - Text 2'''


class PrintCommentsType:
    '''Represents the way comments are printed with the sheet.'''

    PRINT_IN_PLACE : PrintCommentsType
    '''Represents to print comments as displayed on sheet.'''

    PRINT_NO_COMMENTS : PrintCommentsType
    '''Represents not to print comments.'''

    PRINT_SHEET_END : PrintCommentsType
    '''Represents to print comments at end of sheet.'''

    PRINT_WITH_THREADED_COMMENTS : PrintCommentsType
    '''Represents to print comments as displayed on sheet include threaded comments.'''


class PrintErrorsType:
    '''Represents print errors constants.'''

    PRINT_ERRORS_BLANK : PrintErrorsType
    '''Represents not to print errors.'''

    PRINT_ERRORS_DASH : PrintErrorsType
    '''Represents to print errors as "--".'''

    PRINT_ERRORS_DISPLAYED : PrintErrorsType
    '''Represents to print errors as displayed.'''

    PRINT_ERRORS_NA : PrintErrorsType
    '''Represents to print errors as "#N/A".'''


class PrintingPageType:
    '''Indicates which pages will not be printed.'''

    DEFAULT : PrintingPageType
    '''Prints all pages.'''

    IGNORE_BLANK : PrintingPageType
    '''Don't print the pages which the cells are blank.'''

    IGNORE_STYLE : PrintingPageType
    '''Don't print the pages which cells only contain styles.'''


class PrintOrderType:
    '''Represent print order constants.'''

    DOWN_THEN_OVER : PrintOrderType
    '''Down, then over'''

    OVER_THEN_DOWN : PrintOrderType
    '''Over, then down'''


class PrintSizeType:
    '''Represents the printed chart size.'''

    FULL : PrintSizeType
    '''Use full page.'''

    FIT : PrintSizeType
    '''Scale to fit page.'''

    CUSTOM : PrintSizeType
    '''Custom.'''


class PropertyType:
    '''Specifies data type of a document property.'''

    BOOLEAN : PropertyType
    '''The property is a boolean value.'''

    DATE_TIME : PropertyType
    '''The property is a date time value.'''

    DOUBLE : PropertyType
    '''The property is a floating number.'''

    NUMBER : PropertyType
    '''The property is an integer number.'''

    STRING : PropertyType
    '''The property is a string value.'''

    BLOB : PropertyType
    '''The property is a byte array.'''


class ProtectedRange:
    '''A specified range to be allowed to edit when the sheet protection is ON.'''

    def addArea(self, startRow : int, startColumn : int, endRow : int, endColumn : int) -> None:
        '''Adds a referred area to this
        :param startRow: The start row.
        :param startColumn: The start column.
        :param endRow: The end row.
        :param endColumn: The end column.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the Range title. This is used as a descriptor, not as a named range definition.'''
        raise NotImplementedError()

    def setPassword(self, value : str) -> None:
        '''Represents the password to protect the range.
        :param value: '''
        raise NotImplementedError()

    def getPassword(self) -> str:
        '''Represents the password to protect the range.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Gets the Range title. This is used as a descriptor, not as a named range definition.
        :param value: '''
        raise NotImplementedError()

    def getAreas(self) -> list[CellArea]:
        '''Gets all referred areas.'''
        raise NotImplementedError()

    def setSecurityDescriptor(self, value : str) -> None:
        '''The security descriptor defines user accounts who may edit this range without providing a password to access the range.
        :param value: '''
        raise NotImplementedError()

    def getCellArea(self) -> CellArea:
        '''Gets the :class:`CellArea` object represents the cell area to be protected.'''
        raise NotImplementedError()

    def isProtectedWithPassword(self) -> bool:
        '''Indicates whether the worksheets is protected with password.'''
        raise NotImplementedError()

    def getSecurityDescriptor(self) -> str:
        '''The security descriptor defines user accounts who may edit this range without providing a password to access the range.'''
        raise NotImplementedError()


class ProtectedRangeCollection:
    '''Encapsulates a collection of :class:`ProtectedRange` objects.'''

    def get(self, index : int) -> ProtectedRange:
        '''Gets the :class:`ProtectedRange` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    def add(self, name : str, startRow : int, startColumn : int, endRow : int, endColumn : int) -> int:
        '''Adds a :class:`ProtectedRange` item to the collection.
        :param name: Range title. This is used as a descriptor, not as a named range definition.
        :param startRow: Start row index of the range.
        :param startColumn: Start column index of the range.
        :param endRow: End row index of the range.
        :param endColumn: End column index of the range.
        :returns: object index.'''
        raise NotImplementedError()


class Protection:
    '''Represents the various types of protection options available for a worksheet.'''

    def isInsertingHyperlinksAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowInsertingHyperlink property instead.'''
        raise NotImplementedError()

    def getAllowUsingPivotTable(self) -> bool:
        '''Represents if the user is allowed to manipulate pivot tables on a protected worksheet.'''
        raise NotImplementedError()

    def setAllowEditingContent(self, value : bool) -> None:
        '''Represents if the user is allowed to edit contents of locked cells on a protected worksheet.
        :param value: '''
        raise NotImplementedError()

    def getPasswordHash(self) -> int:
        '''Gets the hash of current password.'''
        raise NotImplementedError()

    def getAllowInsertingColumn(self) -> bool:
        '''Represents if the insertion of columns is allowed on a protected worksheet'''
        raise NotImplementedError()

    def setAllowFormattingColumn(self, value : bool) -> None:
        '''Represents if the formatting of columns is allowed on a protected worksheet
        :param value: '''
        raise NotImplementedError()

    def setAllowEditingObject(self, value : bool) -> None:
        '''Represents if the user is allowed to manipulate drawing objects on a protected worksheet.
        :param value: '''
        raise NotImplementedError()

    def isSelectingUnlockedCellsAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowSelectingUnlockedCell property instead.'''
        raise NotImplementedError()

    def setAllowUsingPivotTable(self, value : bool) -> None:
        '''Represents if the user is allowed to manipulate pivot tables on a protected worksheet.
        :param value: '''
        raise NotImplementedError()

    def setAllowDeletingColumn(self, value : bool) -> None:
        '''Represents if the deletion of columns is allowed on a protected worksheet.
        :param value: '''
        raise NotImplementedError()

    def setAllowInsertingColumn(self, value : bool) -> None:
        '''Represents if the insertion of columns is allowed on a protected worksheet
        :param value: '''
        raise NotImplementedError()

    def isProtectedWithPassword(self) -> bool:
        '''Indicates whether the worksheets is protected with password.'''
        raise NotImplementedError()

    def getAllowEditingScenario(self) -> bool:
        '''Represents if the user is allowed to edit scenarios on a protected worksheet.'''
        raise NotImplementedError()

    def getAllowFormattingColumn(self) -> bool:
        '''Represents if the formatting of columns is allowed on a protected worksheet'''
        raise NotImplementedError()

    def isFilteringAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowFiltering property instead.'''
        raise NotImplementedError()

    def setSelectingUnlockedCellsAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowSelectingUnlockedCell property instead.'''
        raise NotImplementedError()

    def getAllowEditingContent(self) -> bool:
        '''Represents if the user is allowed to edit contents of locked cells on a protected worksheet.'''
        raise NotImplementedError()

    def setAllowEditingScenario(self, value : bool) -> None:
        '''Represents if the user is allowed to edit scenarios on a protected worksheet.
        :param value: '''
        raise NotImplementedError()

    def setAllowSorting(self, value : bool) -> None:
        '''Represents if the sorting option is allowed on a protected worksheet.
        :param value: '''
        raise NotImplementedError()

    def setEditingContentsAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowEditingContent property instead.'''
        raise NotImplementedError()

    def isDeletingColumnsAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowDeletingColumn property instead.'''
        raise NotImplementedError()

    def setAllowFormattingCell(self, value : bool) -> None:
        '''Represents if the formatting of cells is allowed on a protected worksheet.
        :param value: '''
        raise NotImplementedError()

    def setAllowFiltering(self, value : bool) -> None:
        '''Represents if the user is allowed to make use of an AutoFilter that was created before the sheet was protected.
        :param value: '''
        raise NotImplementedError()

    def getAllowSelectingLockedCell(self) -> bool:
        '''Represents if the user is allowed to select locked cells on a protected worksheet.'''
        raise NotImplementedError()

    def setEditingObjectsAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowEditingObject property instead.'''
        raise NotImplementedError()

    def getAllowDeletingColumn(self) -> bool:
        '''Represents if the deletion of columns is allowed on a protected worksheet.'''
        raise NotImplementedError()

    def setInsertingHyperlinksAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowInsertingHyperlink property instead.'''
        raise NotImplementedError()

    def setAllowFormattingRow(self, value : bool) -> None:
        '''Represents if the formatting of rows is allowed on a protected worksheet
        :param value: '''
        raise NotImplementedError()

    def setAllowInsertingHyperlink(self, value : bool) -> None:
        '''Represents if the insertion of hyperlinks is allowed on a protected worksheet
        :param value: '''
        raise NotImplementedError()

    def isDeletingRowsAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowDeletingRow property instead.'''
        raise NotImplementedError()

    def setFormattingRowsAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowFormattingRow property instead.'''
        raise NotImplementedError()

    def getPassword(self) -> str:
        '''Represents the password to protect the worksheet.'''
        raise NotImplementedError()

    def setEditingScenariosAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowEditingScenario property instead.'''
        raise NotImplementedError()

    def isSortingAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowSorting property instead.'''
        raise NotImplementedError()

    def getAllowEditingObject(self) -> bool:
        '''Represents if the user is allowed to manipulate drawing objects on a protected worksheet.'''
        raise NotImplementedError()

    def setFormattingCellsAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowFormattingCell property instead.'''
        raise NotImplementedError()

    def setAllowDeletingRow(self, value : bool) -> None:
        '''Represents if the deletion of rows is allowed on a protected worksheet.
        :param value: '''
        raise NotImplementedError()

    def getAllowFormattingCell(self) -> bool:
        '''Represents if the formatting of cells is allowed on a protected worksheet.'''
        raise NotImplementedError()

    def getAllowDeletingRow(self) -> bool:
        '''Represents if the deletion of rows is allowed on a protected worksheet.'''
        raise NotImplementedError()

    def setDeletingRowsAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowDeletingRow property instead.'''
        raise NotImplementedError()

    def isSelectingLockedCellsAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowSelectingLockedCell property instead.'''
        raise NotImplementedError()

    def isEditingObjectsAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowEditingObject property instead.'''
        raise NotImplementedError()

    def setUsingPivotTablesAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowUsingPivotTable property instead.'''
        raise NotImplementedError()

    def setAllowInsertingRow(self, value : bool) -> None:
        '''Represents if the insertion of rows is allowed on a protected worksheet
        :param value: '''
        raise NotImplementedError()

    def setInsertingColumnsAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowInsertingColumn property instead.'''
        raise NotImplementedError()

    def setFilteringAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowFiltering property instead.'''
        raise NotImplementedError()

    def isEditingContentsAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowEditingContent property instead.'''
        raise NotImplementedError()

    def setSelectingLockedCellsAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowSelectingLockedCell property instead.'''
        raise NotImplementedError()

    def isFormattingRowsAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowFormattingRow property instead.'''
        raise NotImplementedError()

    def setPassword(self, value : str) -> None:
        '''Represents the password to protect the worksheet.
        :param value: '''
        raise NotImplementedError()

    def isEditingScenariosAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowEditingScenario property instead.'''
        raise NotImplementedError()

    def setAllowSelectingLockedCell(self, value : bool) -> None:
        '''Represents if the user is allowed to select locked cells on a protected worksheet.
        :param value: '''
        raise NotImplementedError()

    def isInsertingRowsAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowInsertingRow property instead.'''
        raise NotImplementedError()

    def getAllowSelectingUnlockedCell(self) -> bool:
        '''Represents if the user is allowed to select unlocked cells on a protected worksheet.'''
        raise NotImplementedError()

    def isFormattingCellsAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowFormattingCell property instead.'''
        raise NotImplementedError()

    def getAllowFormattingRow(self) -> bool:
        '''Represents if the formatting of rows is allowed on a protected worksheet'''
        raise NotImplementedError()

    def getAllowFiltering(self) -> bool:
        '''Represents if the user is allowed to make use of an AutoFilter that was created before the sheet was protected.'''
        raise NotImplementedError()

    def isUsingPivotTablesAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowUsingPivotTable property instead.'''
        raise NotImplementedError()

    def getAllowInsertingHyperlink(self) -> bool:
        '''Represents if the insertion of hyperlinks is allowed on a protected worksheet'''
        raise NotImplementedError()

    def setSortingAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowSorting property instead.'''
        raise NotImplementedError()

    def setAllowSelectingUnlockedCell(self, value : bool) -> None:
        '''Represents if the user is allowed to select unlocked cells on a protected worksheet.
        :param value: '''
        raise NotImplementedError()

    def isFormattingColumnsAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowFormattingColumn property instead.'''
        raise NotImplementedError()

    def setFormattingColumnsAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowFormattingColumn property instead.'''
        raise NotImplementedError()

    def copy(self, source : Protection) -> None:
        '''Copy protection info.
        :param source: '''
        raise NotImplementedError()

    def getAllowSorting(self) -> bool:
        '''Represents if the sorting option is allowed on a protected worksheet.'''
        raise NotImplementedError()

    def setInsertingRowsAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowInsertingRow property instead.'''
        raise NotImplementedError()

    def setDeletingColumnsAllowed(self, value : bool) -> None:
        ''':deprecated: Use Protection.AllowDeletingColumn property instead.'''
        raise NotImplementedError()

    def isInsertingColumnsAllowed(self) -> bool:
        ''':deprecated: Use Protection.AllowInsertingColumn property instead.'''
        raise NotImplementedError()

    def getAllowInsertingRow(self) -> bool:
        '''Represents if the insertion of rows is allowed on a protected worksheet'''
        raise NotImplementedError()

    def verifyPassword(self, password : str) -> bool:
        '''Verifies password.
        :param password: The password.'''
        raise NotImplementedError()


class ProtectionType:
    '''Represents workbook/worksheet protection type.'''

    ALL : ProtectionType
    '''Represents to protect all.'''

    CONTENTS : ProtectionType
    '''Represents to protect contents, used in Worksheet protection.'''

    OBJECTS : ProtectionType
    '''Represents to protect objects, used in Worksheet protection.'''

    SCENARIOS : ProtectionType
    '''Represents to protect scenarios, used in Worksheet protection.'''

    STRUCTURE : ProtectionType
    '''Represents to protect structure, used in Workbook protection.'''

    WINDOWS : ProtectionType
    '''Represents to protect window, used in Workbook protection.'''

    NONE : ProtectionType
    '''Represents no protection. Only for Reading property.'''


class QuartileCalculationType:
    '''Represents quartile calculation methods.'''

    EXCLUSIVE : QuartileCalculationType
    '''The quartile calculation includes the median when splitting the dataset into quartiles.'''

    INCLUSIVE : QuartileCalculationType
    '''The quartile calculation excludes the median when splitting the dataset into quartiles.'''


class QueryTable:
    '''Represents QueryTable information.'''

    def getPreserveFormatting(self) -> bool:
        '''Returns or sets the PreserveFormatting of the object.'''
        raise NotImplementedError()

    def getResultRange(self) -> Range:
        '''Gets the range of the result.'''
        raise NotImplementedError()

    def getAdjustColumnWidth(self) -> bool:
        '''Returns or sets the AdjustColumnWidth of the object.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of querytable.'''
        raise NotImplementedError()

    def getConnectionId(self) -> int:
        '''Gets the connection id of the query table.'''
        raise NotImplementedError()

    def setPreserveFormatting(self, value : bool) -> None:
        '''Returns or sets the PreserveFormatting of the object.
        :param value: '''
        raise NotImplementedError()

    def getExternalConnection(self) -> ExternalConnection:
        '''Gets the relate external connection.'''
        raise NotImplementedError()

    def setAdjustColumnWidth(self, value : bool) -> None:
        '''Returns or sets the AdjustColumnWidth of the object.
        :param value: '''
        raise NotImplementedError()


class QueryTableCollection:
    '''A collection of :class:`QueryTableCollection` objects that represent QueryTable collection information.'''

    def get(self, index : int) -> QueryTable:
        '''Gets the querytable by the specific index.
        :param index: The index.
        :returns: The querytable'''
        raise NotImplementedError()


class RadicalEquationNode:
    '''This class specifies the radical equation, consisting of an optional degree deg(EquationNodeType.Degree) and a base.'''

    def setDegHide(self, value : bool) -> None:
        '''Whether to hide the degree of radicals.
        :param value: '''
        raise NotImplementedError()

    def isDegHide(self) -> bool:
        '''Whether to hide the degree of radicals.'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class RadioButton:
    '''Represents a radio button.'''

    def setShadow(self, value : bool) -> None:
        '''Indicates whether the combobox has 3-D shading.
        :param value: '''
        raise NotImplementedError()

    def setChecked(self, value : bool) -> None:
        '''Indicates if the radiobutton is checked or not.
        :param value: '''
        raise NotImplementedError()

    def getShadow(self) -> bool:
        '''Indicates whether the combobox has 3-D shading.'''
        raise NotImplementedError()

    def getOptionIndex(self) -> int:
        '''Gets the option index (one-based) in all the radio buttons of the GroupBox which contains this radio button.'''
        raise NotImplementedError()

    def getGroupBox(self) -> GroupBox:
        '''Gets the GroupBox that contains this RadioButton.'''
        raise NotImplementedError()

    def isChecked(self) -> bool:
        '''Indicates if the radiobutton is checked or not.'''
        raise NotImplementedError()


class RadioButtonActiveXControl:
    '''Represents a RadioButton ActiveX control.'''

    def setAlignment(self, value : int) -> None:
        '''Sets the position of the Caption relative to the control.
        See :class:`ControlCaptionAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def setGroupName(self, value : str) -> None:
        '''Sets the group's name.
        :param value: '''
        raise NotImplementedError()

    def setWordWrapped(self, value : bool) -> None:
        '''Indicates whether the contents of the control automatically wrap at the end of a line.
        :param value: '''
        raise NotImplementedError()

    def isWordWrapped(self) -> bool:
        '''Indicates whether the contents of the control automatically wrap at the end of a line.'''
        raise NotImplementedError()

    def getAlignment(self) -> int:
        '''Gets the position of the Caption relative to the control.
        See :class:`ControlCaptionAlignmentType`'''
        raise NotImplementedError()

    def getGroupName(self) -> str:
        '''Gets the group's name.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()


class Range:
    '''Encapsulates the object that represents a range of cells within a spreadsheet.'''

    def getTop(self) -> int:
        '''Gets the distance, in points, from the top edge of row 1 to the top edge of the range.'''
        raise NotImplementedError()

    def moveTo(self, destRow : int, destColumn : int) -> None:
        '''Move the current range to the dest range.
        :param destRow: The start row of the dest range.
        :param destColumn: The start column of the dest range.'''
        raise NotImplementedError()

    def getRowCount(self) -> int:
        '''Gets the count of rows in the range.'''
        raise NotImplementedError()

    def setInsideBorders(self, borderEdge : int, lineStyle : int, borderColor : CellsColor) -> None:
        '''Set inside borders of the range.
        :param borderEdge: :class:`BorderType`. Inside borde type, only can be :attr:`BorderType.VERTICAL` and :attr:`BorderType.HORIZONTAL`.
        :param lineStyle: :class:`CellBorderType`. The border style.
        :param borderColor: The color of the border.'''
        raise NotImplementedError()

    def toString(self) -> str:
        '''Returns a string represents the current Range object.'''
        raise NotImplementedError()

    def copyValue(self, range : Range) -> None:
        '''Copies cell value from a source range.
        :param range: Source :class:`Range` object.'''
        raise NotImplementedError()

    def getFirstRow(self) -> int:
        '''Gets the index of the first row of the range.'''
        raise NotImplementedError()

    def getRowHeight(self) -> int:
        '''Sets or gets the height of rows in this range'''
        raise NotImplementedError()

    def toJson(self, options : JsonSaveOptions) -> str:
        '''Convert the range to JSON value.
        :param options: The options of converting'''
        raise NotImplementedError()

    def getCurrentRegion(self) -> Range:
        '''Returns a Range object that represents the current region.
        The current region is a range bounded by any combination of blank rows and blank columns.'''
        raise NotImplementedError()

    def copyStyle(self, range : Range) -> None:
        '''Copies style settings from a source range.
        :param range: Source :class:`Range` object.'''
        raise NotImplementedError()

    def addHyperlink(self, address : str, textToDisplay : str, screenTip : str) -> Hyperlink:
        '''Adds a hyperlink to a specified cell or a range of cells.
        :param address: Address of the hyperlink.
        :param textToDisplay: The text to be displayed for the specified hyperlink.
        :param screenTip: The screenTip text for the specified hyperlink.
        :returns: :class:`Hyperlink` object.'''
        raise NotImplementedError()

    def getAddress(self) -> str:
        '''Gets address of the range.'''
        raise NotImplementedError()

    def getWorksheet(self) -> Worksheet:
        '''Gets the :meth:`Range.getWorksheet()`object which contains this range.'''
        raise NotImplementedError()

    def getHyperlinks(self) -> list[Hyperlink]:
        '''Gets all hyperlink in the range.'''
        raise NotImplementedError()

    def getOffset(self, rowOffset : int, columnOffset : int) -> Range:
        '''Gets :class:`Range` range by offset.
        :param rowOffset: Row offset in this range, zero based.
        :param columnOffset: Column offset in this range, zero based.'''
        raise NotImplementedError()

    def unionRang(self, range : Range) -> list[Range]:
        ''':deprecated: Use Range.UnionRanges() instead.'''
        raise NotImplementedError()

    def iterator(self) -> Iterator:
        '''Gets the enumerator for cells in this Range.'''
        raise NotImplementedError()

    def transpose(self) -> None:
        '''Transpose (rotate) data from rows to columns or vice versa.'''
        raise NotImplementedError()

    def getEntireColumn(self) -> Range:
        '''Gets a Range object that represents the entire column (or columns) that contains the specified range.'''
        raise NotImplementedError()

    def toImage(self, options : ImageOrPrintOptions) -> list[int]:
        '''Converts the range to image.
        :param options: The options for converting this range to image'''
        raise NotImplementedError()

    def putValue(self, stringValue : str, isConverted : bool, setStyle : bool) -> None:
        '''Puts a value into the range, if appropriate the value will be converted to other data type and cell's number format will be reset.
        :param stringValue: Input value
        :param isConverted: True: converted to other data type if appropriate.
        :param setStyle: True: set the number format to cell's style when converting to other data type'''
        raise NotImplementedError()

    def getEntireRow(self) -> Range:
        '''Gets a Range object that represents the entire row (or rows) that contains the specified range.'''
        raise NotImplementedError()

    def setColumnWidth(self, value : int) -> None:
        '''Sets or gets the column width of this range
        :param value: '''
        raise NotImplementedError()

    def unionRanges(self, ranges : list[Range]) -> UnionRange:
        '''Returns the union result of two ranges.
        :param ranges: The range
        :returns: The union of two ranges.'''
        raise NotImplementedError()

    def copyData(self, range : Range) -> None:
        '''Copies cell data (including formulas) from a source range.
        :param range: Source :class:`Range` object.'''
        raise NotImplementedError()

    def getColumnCount(self) -> int:
        '''Gets the count of columns in the range.'''
        raise NotImplementedError()

    def intersect(self, range : Range) -> Range:
        '''Returns a :class:`Range` object that represents the rectangular intersection of two ranges.
        :param range: The intersecting range.
        :returns: Returns a :class:`Range` object'''
        raise NotImplementedError()

    @overload
    def autoFill(self, target : Range) -> None:
        '''Automaticall fill the target range.
        :param target: the target range.'''
        raise NotImplementedError()

    @overload
    def autoFill(self, target : Range, autoFillType : int) -> None:
        '''Automaticall fill the target range.
        :param target: The targed range.
        :param autoFillType: :class:`AutoFillType`. The auto fill type.'''
        raise NotImplementedError()

    def unMerge(self) -> None:
        '''Unmerges merged cells of this range.'''
        raise NotImplementedError()

    def union(self, range : Range) -> list:
        ''':deprecated: Use Range.UnionRanges() instead.'''
        raise NotImplementedError()

    def getCellOrNull(self, rowOffset : int, columnOffset : int) -> Cell:
        '''Gets :class:`Cell` object or null in this range.
        :param rowOffset: Row offset in this range, zero based.
        :param columnOffset: Column offset in this range, zero based.
        :returns: :class:`Cell` object.'''
        raise NotImplementedError()

    def setRowHeight(self, value : int) -> None:
        '''Sets or gets the height of rows in this range
        :param value: '''
        raise NotImplementedError()

    def getLeft(self) -> int:
        '''Gets the distance, in points, from the left edge of column A to the left edge of the range.'''
        raise NotImplementedError()

    def isBlank(self) -> bool:
        '''Indicates whether the range contains values.'''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Gets the width of a range in points.'''
        raise NotImplementedError()

    def isIntersect(self, range : Range) -> bool:
        '''Indicates whether the range is intersect.
        :param range: The range.
        :returns: Whether the range is intersect.'''
        raise NotImplementedError()

    def setValue(self, value : Object) -> None:
        '''Sets the value of the range.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setStyle(self, style : Style, explicitFlag : bool) -> None:
        '''Apply the cell style.
        :param style: The cell style.
        :param explicitFlag: True, only overwriting formatting which is explicitly set.'''
        raise NotImplementedError()

    @overload
    def setStyle(self, style : Style) -> None:
        '''Sets the style of the range.
        :param style: The Style object.'''
        raise NotImplementedError()

    def getValue(self) -> Object:
        '''Gets the value of the range.'''
        raise NotImplementedError()

    def getColumnWidth(self) -> int:
        '''Sets or gets the column width of this range'''
        raise NotImplementedError()

    @overload
    def setOutlineBorders(self, borderStyle : int, borderColor : CellsColor) -> None:
        '''Sets the outline borders around a range of cells with same border style and color.
        :param borderStyle: :class:`CellBorderType`. Border style.
        :param borderColor: Border color.'''
        raise NotImplementedError()

    @overload
    def setOutlineBorders(self, borderStyle : int, borderColor : Color) -> None:
        '''Sets the outline borders around a range of cells with same border style and color.
        :param borderStyle: :class:`CellBorderType`. Border style.
        :param borderColor: Border color.'''
        raise NotImplementedError()

    @overload
    def setOutlineBorders(self, borderStyles : list[int], borderColors : list[Color]) -> None:
        '''Sets out line borders around a range of cells.
        :param borderStyles: :class:`CellBorderType`. Border styles.
        :param borderColors: Border colors.'''
        raise NotImplementedError()

    @overload
    def setOutlineBorder(self, borderEdge : int, borderStyle : int, borderColor : CellsColor) -> None:
        '''Sets outline border around a range of cells.
        :param borderEdge: :class:`BorderType`. Border edge.
        :param borderStyle: :class:`CellBorderType`. Border style.
        :param borderColor: Border color.'''
        raise NotImplementedError()

    @overload
    def setOutlineBorder(self, borderEdge : int, borderStyle : int, borderColor : Color) -> None:
        '''Sets outline border around a range of cells.
        :param borderEdge: :class:`BorderType`. Border edge.
        :param borderStyle: :class:`CellBorderType`. Border style.
        :param borderColor: Border color.'''
        raise NotImplementedError()

    def merge(self) -> None:
        '''Combines a range of cells into a single cell.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the range.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the range.
        :param value: '''
        raise NotImplementedError()

    def get(self, rowOffset : int, columnOffset : int) -> Cell:
        '''Gets :class:`Cell` object in this range.
        :param rowOffset: Row offset in this range, zero based.
        :param columnOffset: Column offset in this range, zero based.
        :returns: :class:`Cell` object.'''
        raise NotImplementedError()

    def toHtml(self, saveOptions : HtmlSaveOptions) -> list[int]:
        '''Convert the range to html .
        :param saveOptions: Options for coverting range to html.'''
        raise NotImplementedError()

    def getFirstColumn(self) -> int:
        '''Gets the index of the first column of the range.'''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Gets the width of a range in points.'''
        raise NotImplementedError()

    def getRefersTo(self) -> str:
        '''Gets the range's refers to.'''
        raise NotImplementedError()

    def applyStyle(self, style : Style, flag : StyleFlag) -> None:
        '''Applies formats for a whole range.
        :param style: The style object which will be applied.
        :param flag: Flags which indicates applied formatting properties.'''
        raise NotImplementedError()

    @overload
    def copy(self, range : Range, options : PasteOptions) -> None:
        '''Copying the range with paste special options.
        :param range: The source range.
        :param options: The paste special options.'''
        raise NotImplementedError()

    @overload
    def copy(self, range : Range) -> None:
        '''Copies data (including formulas), formatting, drawing objects etc. from a source range.
        :param range: Source :class:`Range` object.'''
        raise NotImplementedError()


class RangeCollection:
    '''Encapsulates a collection of :class:`Range` objects.'''

    def get(self, index : int) -> Range:
        '''Gets the :class:`Range` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    def add(self, range : Range) -> int:
        '''Adds a :class:`Range` item to the collection.
        :param range: Range object'''
        raise NotImplementedError()


class ReConnectionMethodType:
    '''Specifies what the spreadsheet application should do when a connection fails.'''

    REQUIRED : ReConnectionMethodType
    '''On refresh use the existing connection information and if it ends up being invalid
    then get updated connection information, if available from the external connection file.'''

    ALWAYS : ReConnectionMethodType
    '''On every refresh get updated connection information from the external connection file,
    if available, and use that instead of the existing connection information.
    In this case the data refresh will fail if the external connection file is unavailable.'''

    NEVER : ReConnectionMethodType
    '''Never get updated connection information from the external connection file
    even if it is available and even if the existing connection information is invalid'''


class RectangleAlignmentType:
    '''Represents how to position two rectangles relative to each other.'''

    BOTTOM : RectangleAlignmentType
    '''Bottom'''

    BOTTOM_LEFT : RectangleAlignmentType
    '''BottomLeft'''

    BOTTOM_RIGHT : RectangleAlignmentType
    '''BottomRight'''

    CENTER : RectangleAlignmentType
    '''Center'''

    LEFT : RectangleAlignmentType
    '''Left'''

    RIGHT : RectangleAlignmentType
    '''Right'''

    TOP : RectangleAlignmentType
    '''Top'''

    TOP_LEFT : RectangleAlignmentType
    '''TopLeft'''

    TOP_RIGHT : RectangleAlignmentType
    '''TopRight'''


class RectangleShape:
    '''Represents the rectangle shape.'''


class ReferredArea:
    '''Represents a referred area by the formula.'''

    def toString(self) -> str:
        '''Returns the reference address of this area.
        Generally it is the address of the reference which may be used in formula, such as "Sheet1!A1:C3".'''
        raise NotImplementedError()

    def getEndColumn(self) -> int:
        '''The end column of the area.'''
        raise NotImplementedError()

    def isExternalLink(self) -> bool:
        '''Indicates whether this is an external link.'''
        raise NotImplementedError()

    def getExternalFileName(self) -> str:
        '''Get the external file name if this is an external reference.'''
        raise NotImplementedError()

    def getStartRow(self) -> int:
        '''The start row of the area.'''
        raise NotImplementedError()

    @overload
    def getValue(self, rowOffset : int, colOffset : int) -> Object:
        '''Gets cell value with given offset from the top-left of this area.
        :param rowOffset: row offset from the start row of this area
        :param colOffset: column offset from the start row of this area
        :returns: "#REF!" if this area is invalid; "#N/A" if given offset out of this area; Otherwise return the cell value at given position.'''
        raise NotImplementedError()

    @overload
    def getValue(self, rowOffset : int, colOffset : int, calculateFormulas : bool) -> Object:
        '''Gets cell value with given offset from the top-left of this area.
        :param rowOffset: row offset from the start row of this area
        :param colOffset: column offset from the start row of this area
        :param calculateFormulas: Whether calculate it recursively if the specified reference is formula
        :returns: "#REF!" if this area is invalid; "#N/A" if given offset out of this area; Otherwise return the cell value at given position.'''
        raise NotImplementedError()

    @overload
    def getValues(self) -> Object:
        '''Gets cell values in this area.'''
        raise NotImplementedError()

    @overload
    def getValues(self, calculateFormulas : bool) -> Object:
        '''Gets cell values in this area.
        :param calculateFormulas: In this range, if there are some formulas that have not been calculated,
        :returns: If this area is invalid, "#REF!" will be returned; If this area is one single cell, then return the cell value object; Otherwise return one 2D array for all values in this area.'''
        raise NotImplementedError()

    def getStartColumn(self) -> int:
        '''The start column of the area.'''
        raise NotImplementedError()

    def isEntireColumn(self) -> bool:
        '''Indicates whether this area contains all rows(entire column).'''
        raise NotImplementedError()

    def isArea(self) -> bool:
        '''Indicates whether this is an area.'''
        raise NotImplementedError()

    def getSheetName(self) -> str:
        '''Indicates which sheet this reference is in.'''
        raise NotImplementedError()

    def isEntireRow(self) -> bool:
        '''Indicates whether this area contains all columns(entire row).'''
        raise NotImplementedError()

    def getEndRow(self) -> int:
        '''The end row of the area.'''
        raise NotImplementedError()


class ReferredAreaCollection:
    '''Represents all referred cells and areas.'''

    def get(self, index : int) -> ReferredArea:
        '''
        :param index: '''
        raise NotImplementedError()


class ReflectionEffect:
    '''This class specifies a reflection effect.'''

    def setDirection(self, value : int) -> None:
        '''Sets the direction of the alpha gradient ramp relative to the shape itself.
        :param value: '''
        raise NotImplementedError()

    def setTransparency(self, value : int) -> None:
        '''Sets the degree of the starting reflection transparency as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def getRotWithShape(self) -> bool:
        '''Gets if the reflection should rotate with the shape.'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets the preset reflection effect.
        See :class:`ReflectionEffectType`
        :param value: '''
        raise NotImplementedError()

    def getBlur(self) -> int:
        '''Gets the blur radius,in unit of points.'''
        raise NotImplementedError()

    def setRotWithShape(self, value : bool) -> None:
        '''Sets if the reflection should rotate with the shape.
        :param value: '''
        raise NotImplementedError()

    def getDirection(self) -> int:
        '''Gets the direction of the alpha gradient ramp relative to the shape itself.'''
        raise NotImplementedError()

    def setDistance(self, value : int) -> None:
        '''Sets how far to distance the shadow,in unit of points.
        :param value: '''
        raise NotImplementedError()

    def setSize(self, value : int) -> None:
        '''Sets the end position (along the alpha gradient ramp) of the end alpha value,in unit of percentage
        :param value: '''
        raise NotImplementedError()

    def getDistance(self) -> int:
        '''Gets how far to distance the shadow,in unit of points.'''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Gets the degree of the starting reflection transparency as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the preset reflection effect.
        See :class:`ReflectionEffectType`'''
        raise NotImplementedError()

    def getFadeDirection(self) -> int:
        '''Gets the direction to offset the reflection.'''
        raise NotImplementedError()

    def setBlur(self, value : int) -> None:
        '''Sets the blur radius,in unit of points.
        :param value: '''
        raise NotImplementedError()

    def setFadeDirection(self, value : int) -> None:
        '''Sets the direction to offset the reflection.
        :param value: '''
        raise NotImplementedError()

    def getSize(self) -> int:
        '''Gets the end position (along the alpha gradient ramp) of the end alpha value,in unit of percentage'''
        raise NotImplementedError()


class ReflectionEffectType:
    '''Represents the effect type of reflection.'''

    NONE : ReflectionEffectType
    '''No reflection effect.'''

    CUSTOM : ReflectionEffectType
    '''Custom reflection effect.'''

    TIGHT_REFLECTION_TOUCHING : ReflectionEffectType
    '''Tight reflection, touching.'''

    HALF_REFLECTION_TOUCHING : ReflectionEffectType
    '''Half reflection, touching.'''

    FULL_REFLECTION_TOUCHING : ReflectionEffectType
    '''Full reflection, touching.'''

    TIGHT_REFLECTION_4_PT_OFFSET : ReflectionEffectType
    '''Tight reflection, 4 pt offset.'''

    HALF_REFLECTION_4_PT_OFFSET : ReflectionEffectType
    '''Half reflection, 4 pt offset.'''

    FULL_REFLECTION_4_PT_OFFSET : ReflectionEffectType
    '''Full reflection, 4 pt offset.'''

    TIGHT_REFLECTION_8_PT_OFFSET : ReflectionEffectType
    '''Tight reflection, 8 pt offset.'''

    HALF_REFLECTION_8_PT_OFFSET : ReflectionEffectType
    '''Half reflection, 8 pt offset.'''

    FULL_REFLECTION_8_PT_OFFSET : ReflectionEffectType
    '''Full reflection, 8 pt offset.'''


class RenameStrategy:
    '''Strategy option for duplicate names of columns.'''

    EXCEPTION : RenameStrategy
    '''Throws exception.'''

    DIGIT : RenameStrategy
    '''Named with digit. Duplicated names will become ...1, ...2, etc.'''

    LETTER : RenameStrategy
    '''Named with letter.. Duplicated names will become ...A, ...B, etc.'''


class RenderingFont:
    '''Font for rendering.'''

    def getItalic(self) -> bool:
        '''Gets italic for the font.'''
        raise NotImplementedError()

    def setItalic(self, value : bool) -> None:
        '''Sets italic for the font.
        :param value: '''
        raise NotImplementedError()

    def setColor(self, value : Color) -> None:
        '''Sets color for the font.
        :param value: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets name of the font.'''
        raise NotImplementedError()

    def getColor(self) -> Color:
        '''Gets color for the font.'''
        raise NotImplementedError()

    def getBold(self) -> bool:
        '''Gets bold for the font.'''
        raise NotImplementedError()

    def getSize(self) -> float:
        '''Gets size of the font in points.'''
        raise NotImplementedError()

    def setBold(self, value : bool) -> None:
        '''Sets bold for the font.
        :param value: '''
        raise NotImplementedError()


class RenderingWatermark:
    '''Watermark for rendering.'''

    def getImage(self) -> list[int]:
        '''Gets image of the watermark.'''
        raise NotImplementedError()

    def getOffsetY(self) -> float:
        '''Gets offset value to :meth:`RenderingWatermark.getVAlignment()`'''
        raise NotImplementedError()

    def getText(self) -> str:
        '''Gets text of the watermark.'''
        raise NotImplementedError()

    def getOffsetX(self) -> float:
        '''Gets offset value to :meth:`RenderingWatermark.getHAlignment()`'''
        raise NotImplementedError()

    def getFont(self) -> RenderingFont:
        '''Gets font of the watermark.'''
        raise NotImplementedError()

    def setVAlignment(self, value : int) -> None:
        '''Sets vertical alignment of the watermark to the page.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def setBackground(self, value : bool) -> None:
        '''Indicates whether the watermark is placed behind page contents.
        :param value: '''
        raise NotImplementedError()

    def getScaleToPagePercent(self) -> int:
        '''Gets scale relative to target page in percent.'''
        raise NotImplementedError()

    def isBackground(self) -> bool:
        '''Indicates whether the watermark is placed behind page contents.'''
        raise NotImplementedError()

    def setScaleToPagePercent(self, value : int) -> None:
        '''Sets scale relative to target page in percent.
        :param value: '''
        raise NotImplementedError()

    def getOpacity(self) -> float:
        '''Gets opacity of the watermark in range [0, 1].'''
        raise NotImplementedError()

    def setOffsetY(self, value : float) -> None:
        '''Sets offset value to :meth:`RenderingWatermark.getVAlignment()`
        :param value: '''
        raise NotImplementedError()

    def setOffsetX(self, value : float) -> None:
        '''Sets offset value to :meth:`RenderingWatermark.getHAlignment()`
        :param value: '''
        raise NotImplementedError()

    def getVAlignment(self) -> int:
        '''Gets vertical alignment of the watermark to the page.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def getRotation(self) -> float:
        '''Gets roation of the watermark in degrees.'''
        raise NotImplementedError()

    def getHAlignment(self) -> int:
        '''Gets horizontal alignment of the watermark to the page.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def setOpacity(self, value : float) -> None:
        '''Sets opacity of the watermark in range [0, 1].
        :param value: '''
        raise NotImplementedError()

    def setRotation(self, value : float) -> None:
        '''Sets roation of the watermark in degrees.
        :param value: '''
        raise NotImplementedError()

    def setHAlignment(self, value : int) -> None:
        '''Sets horizontal alignment of the watermark to the page.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()


class ReplaceOptions:
    '''Represent the replace options.'''

    def setRegexKey(self, value : bool) -> None:
        '''Indicates whether the searched key is regex. If true then the searched key will be taken as regex.
        :param value: '''
        raise NotImplementedError()

    def setStyleFlags(self, value : list[StyleFlag]) -> None:
        '''Sets flags of applying font settings.
        :param value: '''
        raise NotImplementedError()

    def getRegexKey(self) -> bool:
        '''Indicates whether the searched key is regex. If true then the searched key will be taken as regex.'''
        raise NotImplementedError()

    def setCaseSensitive(self, value : bool) -> None:
        '''Indicates if the searched string is case sensitive.
        :param value: '''
        raise NotImplementedError()

    def getCaseSensitive(self) -> bool:
        '''Indicates if the searched string is case sensitive.'''
        raise NotImplementedError()

    def getFontSettings(self) -> list[FontSetting]:
        '''The rich formatted settings for the replaced text.'''
        raise NotImplementedError()

    def getStyleFlags(self) -> list[StyleFlag]:
        '''Gets flags of applying font settings.'''
        raise NotImplementedError()

    def setMatchEntireCellContents(self, value : bool) -> None:
        '''Indicates whether to match entire cells contents
        :param value: '''
        raise NotImplementedError()

    def setFontSettings(self, value : list[FontSetting]) -> None:
        '''The rich formatted settings for the replaced text.
        :param value: '''
        raise NotImplementedError()

    def getMatchEntireCellContents(self) -> bool:
        '''Indicates whether to match entire cells contents'''
        raise NotImplementedError()


class ReserveMissingPivotItemType:
    '''Represents how to keep the missing pivot items.'''

    DEFAULT : ReserveMissingPivotItemType
    '''Removes old missint pivot items and reserves visible items which the current data source does not contain as missing items.'''

    ALL : ReserveMissingPivotItemType
    '''Reserves all missing items.'''

    NONE : ReserveMissingPivotItemType
    '''Removes all missing pivot items.'''


class ResourceLoadingType:
    '''Represents how to loading the linked resource.'''

    DEFAULT : ResourceLoadingType
    '''Loads this resource as usual.'''

    SKIP : ResourceLoadingType
    '''Skips loading of this resource.'''

    USER_PROVIDED : ResourceLoadingType
    '''Use stream provided by user'''


class Revision:
    '''Represents the revision.'''

    def getId(self) -> int:
        '''Gets the number of this revision.'''
        raise NotImplementedError()

    def getWorksheet(self) -> Worksheet:
        '''Gets the worksheet.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents the type of revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()


class RevisionActionType:
    '''Represents the type of revision action.'''

    ADD : RevisionActionType
    '''Add revision.'''

    DELETE : RevisionActionType
    '''Delete revision.'''

    DELETE_COLUMN : RevisionActionType
    '''Column delete revision.'''

    DELETE_ROW : RevisionActionType
    '''Row delete revision.'''

    INSERT_COLUMN : RevisionActionType
    '''Column insert revision.'''

    INSERT_ROW : RevisionActionType
    '''Row insert revision.'''


class RevisionAutoFormat:
    '''represents a revision record of information about a formatting change.'''

    def getCellArea(self) -> CellArea:
        '''Gets the location where the formatting was applied.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()


class RevisionCellChange:
    '''Represents the revision that changing cells.'''

    def isOldFormatted(self) -> bool:
        '''Indicates whether this cell is old formatted.'''
        raise NotImplementedError()

    def getOldFormula(self) -> str:
        '''Gets the old formula.'''
        raise NotImplementedError()

    def getNewFormula(self) -> str:
        '''Gets the old formula.'''
        raise NotImplementedError()

    def getOldValue(self) -> Object:
        '''Gets old value of the cell.'''
        raise NotImplementedError()

    def getNewValue(self) -> Object:
        '''Gets new value of the cell.'''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets the row index of the cell.'''
        raise NotImplementedError()

    def getCellName(self) -> str:
        '''Gets the name of the cell.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents the type of revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()

    def getOldStyle(self) -> Style:
        '''Gets the old style of the cell.'''
        raise NotImplementedError()

    def isNewFormatted(self) -> bool:
        '''Indicates whether this cell is new formatted.'''
        raise NotImplementedError()

    def getNewStyle(self) -> Style:
        '''Gets the new style of the cell.'''
        raise NotImplementedError()

    def getColumn(self) -> int:
        '''Gets the column index of the cell.'''
        raise NotImplementedError()


class RevisionCellComment:
    '''Represents a revision record of a cell comment change.'''

    def isOldComment(self) -> bool:
        '''Indicates whether it's an  old comment.'''
        raise NotImplementedError()

    def setCellName(self, value : str) -> None:
        '''Gets the name of the cell.
        :param value: '''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets the row index of the which contains a comment.'''
        raise NotImplementedError()

    def getCellName(self) -> str:
        '''Gets the name of the cell.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()

    def getOldLength(self) -> int:
        '''Gets Length of the comment text added in this revision.'''
        raise NotImplementedError()

    def getActionType(self) -> int:
        '''Gets the action type of the revision.
        See :class:`RevisionActionType`'''
        raise NotImplementedError()

    def getNewLength(self) -> int:
        '''Gets Length of the comment before this revision was made.'''
        raise NotImplementedError()

    def getColumn(self) -> int:
        '''Gets the column index of the which contains a comment.'''
        raise NotImplementedError()


class RevisionCellMove:
    '''Represents a revision record on a cell(s) that moved.'''

    def getSourceArea(self) -> CellArea:
        '''Gets the source area.'''
        raise NotImplementedError()

    def getSourceWorksheet(self) -> Worksheet:
        '''Gets the source worksheet.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents the type of revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()

    def getDestinationArea(self) -> CellArea:
        '''Gets the destination area.'''
        raise NotImplementedError()


class RevisionCollection:
    '''Represents all revision logs.'''

    def get(self, index : int) -> Revision:
        '''Gets :class:`Revision` by the index.
        :param index: '''
        raise NotImplementedError()


class RevisionCustomView:
    '''Represents a revision record of adding or removing a custom view to the workbook'''

    def getGuid(self) -> java.util.UUID:
        '''Gets the globally unique identifier of the custom view.'''
        raise NotImplementedError()

    def getActionType(self) -> int:
        '''Gets the type of action.
        See :class:`RevisionActionType`'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()


class RevisionDefinedName:
    '''Represents a revision record of a defined name change.'''

    def getNewFormula(self) -> str:
        '''Gets the formula.'''
        raise NotImplementedError()

    def getText(self) -> str:
        '''Gets the text of the defined name.'''
        raise NotImplementedError()

    def getOldFormula(self) -> str:
        '''Gets the old formula.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents the type of revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()


class RevisionFormat:
    '''Represents a revision record of information about a formatting change.'''

    def getStyle(self) -> Style:
        '''Gets the applied style.'''
        raise NotImplementedError()

    def getAreas(self) -> list[CellArea]:
        '''The range to which this formatting was applied.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()


class RevisionHeader:
    '''Represents a list of specific changes that have taken place for this workbook.'''

    def setSavedTime(self, value : DateTime) -> None:
        '''Sets rhe date and time when this set of revisions was saved.
        :param value: '''
        raise NotImplementedError()

    def getUserName(self) -> str:
        '''Gets the name of the user making the revision.'''
        raise NotImplementedError()

    def getSavedTime(self) -> DateTime:
        '''Gets rhe date and time when this set of revisions was saved.'''
        raise NotImplementedError()

    def setUserName(self, value : str) -> None:
        '''Sets the name of the user making the revision.
        :param value: '''
        raise NotImplementedError()


class RevisionInsertDelete:
    '''Represents a revision record of a row/column insert/delete action.'''

    def getRevisions(self) -> RevisionCollection:
        '''Gets revision list by this operation.'''
        raise NotImplementedError()

    def getCellArea(self) -> CellArea:
        '''Gets the inserting/deleting range.'''
        raise NotImplementedError()

    def getActionType(self) -> int:
        '''Gets the action type of this revision.
        See :class:`RevisionActionType`'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents the type of revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()


class RevisionInsertSheet:
    '''Represents a revision record of a sheet that was inserted.'''

    def getName(self) -> str:
        '''Gets the name of the worksheet.'''
        raise NotImplementedError()

    def getActionType(self) -> int:
        '''Gets the action type of the revision.
        See :class:`RevisionActionType`'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()

    def getSheetPosition(self) -> int:
        '''Gets the zero based position of the new sheet in the sheet tab bar.'''
        raise NotImplementedError()


class RevisionLog:
    '''Represents the revision log.'''

    def getMetadataTable(self) -> RevisionHeader:
        '''Gets table that contains metadata about a list of specific changes that have taken place
        for this workbook.'''
        raise NotImplementedError()

    def getRevisions(self) -> RevisionCollection:
        '''Gets all revisions in this log.'''
        raise NotImplementedError()


class RevisionLogCollection:
    '''Represents all revision logs.'''

    def get(self, index : int) -> RevisionLog:
        '''Gets :class:`RevisionLog` by index.
        :param index: The index.
        :returns: Returns :class:`RevisionLog` object.'''
        raise NotImplementedError()

    def highlightChanges(self, options : HighlightChangesOptions) -> None:
        '''Highlights changes of shared workbook.
        :param options: Set the options for filtering which changes should be tracked.'''
        raise NotImplementedError()

    def setDaysPreservingHistory(self, value : int) -> None:
        '''Sets the number of days the spreadsheet application will keep the change history for this workbook.
        :param value: '''
        raise NotImplementedError()

    def getDaysPreservingHistory(self) -> int:
        '''Gets the number of days the spreadsheet application will keep the change history for this workbook.'''
        raise NotImplementedError()


class RevisionMergeConflict:
    '''Represents a revision record which indicates that there was a merge conflict.'''

    def getType(self) -> int:
        '''Gets the type of revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()


class RevisionQueryTable:
    '''Represents a revision of a query table field change.'''

    def getFieldId(self) -> int:
        '''Gets ID of the specific query table field that was removed.'''
        raise NotImplementedError()

    def getCellArea(self) -> CellArea:
        '''Gets the location of the affected query table.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents the type of the revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()


class RevisionRenameSheet:
    '''Represents a revision of renaming sheet.'''

    def getNewName(self) -> str:
        '''Gets the new name of the worksheet.'''
        raise NotImplementedError()

    def getOldName(self) -> str:
        '''Gets the old name of the worksheet.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents the type of the revision.
        See :class:`RevisionType`'''
        raise NotImplementedError()


class RevisionType:
    '''Represents the revision type.'''

    CUSTOM_VIEW : RevisionType
    '''Custom view.'''

    DEFINED_NAME : RevisionType
    '''Defined name.'''

    CHANGE_CELLS : RevisionType
    '''Cells change.'''

    AUTO_FORMAT : RevisionType
    '''Auto format.'''

    MERGE_CONFLICT : RevisionType
    '''Merge conflict.'''

    COMMENT : RevisionType
    '''Comment.'''

    FORMAT : RevisionType
    '''Format.'''

    INSERT_SHEET : RevisionType
    '''Insert worksheet.'''

    MOVE_CELLS : RevisionType
    '''Move cells.'''

    UNDO : RevisionType
    '''Undo.'''

    QUERY_TABLE : RevisionType
    '''Query table.'''

    INSERT_DELETE : RevisionType
    '''Inserting or deleting.'''

    RENAME_SHEET : RevisionType
    '''Rename worksheet.'''

    UNKNOWN : RevisionType
    '''Unknown.'''


class Row:
    '''Represents a single row in a worksheet.'''

    def isCollapsed(self) -> bool:
        '''whether the row is collapsed'''
        raise NotImplementedError()

    def getCellByIndex(self, index : int) -> Cell:
        '''Get the cell by specific index in the cells collection of this row.
        :param index: The index(position) of the cell in the cells collection of this row.
        :returns: The Cell object at given position.'''
        raise NotImplementedError()

    def getGroupLevel(self) -> int:
        '''Gets the group level of the row.'''
        raise NotImplementedError()

    def getLastDataCell(self) -> Cell:
        '''Gets the last non-blank cell in the row.'''
        raise NotImplementedError()

    def hasCustomStyle(self) -> bool:
        '''Indicates whether this row has custom style settings(different from the default one inherited from workbook).'''
        raise NotImplementedError()

    def copySettings(self, source : Row, checkStyle : bool) -> None:
        '''Copy settings of row, such as style, height, visibility, ...etc.
        :param source: the source row whose settings will be copied to this one
        :param checkStyle: whether check and gather style.'''
        raise NotImplementedError()

    def setStyle(self, style : Style) -> None:
        '''Sets the style of this row.
        :param style: the style to be used as the default style for cells in this row.'''
        raise NotImplementedError()

    def getStyle(self) -> Style:
        '''Gets the style of this row.'''
        raise NotImplementedError()

    def isHidden(self) -> bool:
        '''Indicates whether the row is hidden.'''
        raise NotImplementedError()

    def setHeightMatched(self, value : bool) -> None:
        '''Indicates whether the row height matches current default font setting of the workbook.
        True of this property also denotes the row height is "automatic" without custom height value set by user.
        :param value: '''
        raise NotImplementedError()

    def setHeight(self, value : int) -> None:
        '''Sets the row height in unit of Points.
        :param value: '''
        raise NotImplementedError()

    def setGroupLevel(self, value : int) -> None:
        '''Gets the group level of the row.
        :param value: '''
        raise NotImplementedError()

    def getFirstDataCell(self) -> Cell:
        '''Gets the first non-blank cell in the row.'''
        raise NotImplementedError()

    def getFirstCell(self) -> Cell:
        '''Gets the first cell object in the row.'''
        raise NotImplementedError()

    def setHidden(self, value : bool) -> None:
        '''Indicates whether the row is hidden.
        :param value: '''
        raise NotImplementedError()

    @overload
    def equals(self, obj : Object) -> bool:
        '''Checks whether this object refers to the same row with another.
        :param obj: another object
        :returns: true if two objects refers to the same row.'''
        raise NotImplementedError()

    @overload
    def equals(self, row : Row) -> bool:
        '''Checks whether this object refers to the same row with another row object.
        :param row: another row object
        :returns: true if two row objects refers to the same row.'''
        raise NotImplementedError()

    def getCellOrNull(self, column : int) -> Cell:
        '''Gets the cell or null in the specific index.
        :param column: The column index
        :returns: Returns the cell object if the cell exists. Or returns null if the cell object does not exist.'''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Gets the row height in unit of Points.'''
        raise NotImplementedError()

    def isBlank(self) -> bool:
        '''Indicates whether the row contains any data'''
        raise NotImplementedError()

    @overload
    def iterator(self) -> Iterator:
        '''Gets the cells enumerator'''
        raise NotImplementedError()

    @overload
    def iterator(self, reversed : bool, sync : bool) -> Iterator:
        '''Gets an enumerator that iterates cells through this row.
        :param reversed: whether enumerate cells in reversed order
        :param sync: whether the returned enumerator should check the modification of cells in this row
        :returns: The cell enumerator'''
        raise NotImplementedError()

    def getLastCell(self) -> Cell:
        '''Gets the last cell object in the row.'''
        raise NotImplementedError()

    def isHeightMatched(self) -> bool:
        '''Indicates whether the row height matches current default font setting of the workbook.
        True of this property also denotes the row height is "automatic" without custom height value set by user.'''
        raise NotImplementedError()

    def getIndex(self) -> int:
        '''Gets the index of this row.'''
        raise NotImplementedError()

    def get(self, column : int) -> Cell:
        '''Gets the cell.
        :param column: The column index'''
        raise NotImplementedError()

    def applyStyle(self, style : Style, flag : StyleFlag) -> None:
        '''Applies formats for a whole row.
        :param style: The style object which will be applied.
        :param flag: Flags which indicates applied formatting properties.'''
        raise NotImplementedError()

    def setCollapsed(self, value : bool) -> None:
        '''whether the row is collapsed
        :param value: '''
        raise NotImplementedError()


class RowCollection:
    '''Collects the :class:`Row` objects that represent the individual rows in a worksheet.'''

    def clear(self) -> None:
        '''Clear all rows and cells.'''
        raise NotImplementedError()

    def getRowByIndex(self, index : int) -> Row:
        '''Gets the row object by the position in the list.
        :param index: The position.
        :returns: The Row object at given position.'''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Remove the row item at the specified index(position) in this collection.
        :param index: zero-based index(position, not :meth:`Row.getIndex()`) of the existing row item in this collection.'''
        raise NotImplementedError()

    def getCount(self) -> int:
        '''Gets the number of rows in this collection.'''
        raise NotImplementedError()

    def get(self, rowIndex : int) -> Row:
        '''Gets a :class:`Row` object by given row index. The Row object of given row index will be instantiated if it does not exist before.
        :param rowIndex: '''
        raise NotImplementedError()

    @overload
    def iterator(self) -> Iterator:
        '''Gets an enumerator that iterates rows through this collection'''
        raise NotImplementedError()

    @overload
    def iterator(self, reversed : bool, sync : bool) -> Iterator:
        '''Gets an enumerator that iterates rows through this collection
        :param reversed: whether enumerate rows in reversed order
        :param sync: whether the returned enumerator should check the modification of row collection
        :returns: The row enumerator'''
        raise NotImplementedError()



class SaveFormat:
    '''Represents the format in which the workbook is saved.'''

    CSV : SaveFormat
    '''Comma-Separated Values(CSV) text file.'''

    XLSX : SaveFormat
    '''Represents an xlsx file.'''

    XLSM : SaveFormat
    '''Represents an xlsm file which enable macros.'''

    XLTX : SaveFormat
    '''Represents an xltx file.'''

    XLTM : SaveFormat
    '''Represents an xltm file which enable macros.'''

    XLAM : SaveFormat
    '''Represents an xltm file which enable addin macros.'''

    TSV : SaveFormat
    '''Tab-Separated Values(TSV) text file.'''

    TAB_DELIMITED : SaveFormat
    '''Represents a tab delimited text file, same with :attr:`LoadFormat.TSV`.'''

    HTML : SaveFormat
    '''Represents a html file.'''

    M_HTML : SaveFormat
    '''Represents a mhtml file.'''

    ODS : SaveFormat
    '''Open Document Sheet(ODS) file.'''

    EXCEL_97_TO_2003 : SaveFormat
    '''Represents an Excel97-2003 xls file.'''

    SPREADSHEET_ML : SaveFormat
    '''Represents an Excel 2003 xml file.'''

    XLSB : SaveFormat
    '''Represents an xlsb file.'''

    AUTO : SaveFormat
    '''If saving the file to the disk,the file format accords to the extension of the file name.
    If saving the file to the stream, the file format is xlsx.'''

    UNKNOWN : SaveFormat
    '''Represents unrecognized format, cannot be saved.'''

    PDF : SaveFormat
    '''Represents a Pdf file.'''

    XPS : SaveFormat
    '''XPS (XML Paper Specification) format.'''

    TIFF : SaveFormat
    '''Represents a TIFF file.'''

    SVG : SaveFormat
    '''SVG file.'''

    DIF : SaveFormat
    '''Data Interchange Format.'''

    OTS : SaveFormat
    '''Open Document Template Sheet(OTS) file.'''

    XLT : SaveFormat
    '''Excel 97-2003 template file.'''

    XML : SaveFormat
    '''Represents a simple xml file.'''

    NUMBERS : SaveFormat
    '''Represents a numbers file.'''

    MARKDOWN : SaveFormat
    '''Represents markdown document.'''

    FODS : SaveFormat
    '''Represents OpenDocument Flat XML Spreadsheet (.fods) file format.'''

    SXC : SaveFormat
    '''Represents StarOffice Calc Spreadsheet (.sxc) file format.'''

    PPTX : SaveFormat
    '''Represents .pptx file.'''

    DOCX : SaveFormat
    '''Represents .docx file.'''

    EMF : SaveFormat
    '''Windows Enhanced Metafile.'''

    JPG : SaveFormat
    '''JPEG JFIF.'''

    PNG : SaveFormat
    '''Portable Network Graphics.'''

    BMP : SaveFormat
    '''Windows Bitmap'''

    GIF : SaveFormat
    '''Gif'''

    JSON : SaveFormat
    '''Json'''

    SQL_SCRIPT : SaveFormat
    '''Sql'''

    X_HTML : SaveFormat
    '''Rrepesents XHtml file.'''

    EPUB : SaveFormat
    '''Represents Epub file.'''

    AZW_3 : SaveFormat
    '''Represents Azw3 file.'''

    PCL : SaveFormat
    '''PCL (Printer Command Language)'''


class SaveOptions:
    '''Represents all save options'''

    def setCreateDirectory(self, value : bool) -> None:
        '''If true and the directory does not exist, the directory will be automatically created before saving the file.
        :param value: '''
        raise NotImplementedError()

    def getSaveFormat(self) -> int:
        '''Gets the save file format.
        See :class:`SaveFormat`'''
        raise NotImplementedError()

    def getMergeAreas(self) -> bool:
        '''Indicates whether merge the areas of conditional formatting and validation before saving the file.'''
        raise NotImplementedError()

    def setCheckExcelRestriction(self, value : bool) -> None:
        '''Whether check restriction of excel file when user modify cells related objects.
        For example, excel does not allow inputting string value longer than 32K.
        When you input a value longer than 32K, it will be truncated.
        :param value: '''
        raise NotImplementedError()

    def getClearData(self) -> bool:
        '''Make the workbook empty after saving the file.'''
        raise NotImplementedError()

    def setSortNames(self, value : bool) -> None:
        '''Indicates whether sorting defined names before saving file.
        :param value: '''
        raise NotImplementedError()

    def setMergeAreas(self, value : bool) -> None:
        '''Indicates whether merge the areas of conditional formatting and validation before saving the file.
        :param value: '''
        raise NotImplementedError()

    def getUpdateSmartArt(self) -> bool:
        '''Indicates whether updating smart art setting.
        The default value is false.'''
        raise NotImplementedError()

    def setValidateMergedAreas(self, value : bool) -> None:
        '''Indicates whether validate merged cells before saving the file.
        :param value: '''
        raise NotImplementedError()

    def getSortExternalNames(self) -> bool:
        '''Indicates whether sorting external defined names before saving file.'''
        raise NotImplementedError()

    def getCheckExcelRestriction(self) -> bool:
        '''Whether check restriction of excel file when user modify cells related objects.
        For example, excel does not allow inputting string value longer than 32K.
        When you input a value longer than 32K, it will be truncated.'''
        raise NotImplementedError()

    def setEncryptDocumentProperties(self, value : bool) -> None:
        '''Indicates whether encrypt document properties when saving as .xls file.
        The default value is true.
        :param value: '''
        raise NotImplementedError()

    def getEncryptDocumentProperties(self) -> bool:
        '''Indicates whether encrypt document properties when saving as .xls file.
        The default value is true.'''
        raise NotImplementedError()

    def getValidateMergedAreas(self) -> bool:
        '''Indicates whether validate merged cells before saving the file.'''
        raise NotImplementedError()

    def setRefreshChartCache(self, value : bool) -> None:
        '''Indicates whether refreshing chart cache data
        :param value: '''
        raise NotImplementedError()

    def getCachedFileFolder(self) -> str:
        '''The cached file folder is used to store some large data.'''
        raise NotImplementedError()

    def getWarningCallback(self) -> IWarningCallback:
        '''Gets warning callback.'''
        raise NotImplementedError()

    def setSortExternalNames(self, value : bool) -> None:
        '''Indicates whether sorting external defined names before saving file.
        :param value: '''
        raise NotImplementedError()

    def setClearData(self, value : bool) -> None:
        '''Make the workbook empty after saving the file.
        :param value: '''
        raise NotImplementedError()

    def getCreateDirectory(self) -> bool:
        '''If true and the directory does not exist, the directory will be automatically created before saving the file.'''
        raise NotImplementedError()

    def getSortNames(self) -> bool:
        '''Indicates whether sorting defined names before saving file.'''
        raise NotImplementedError()

    def getRefreshChartCache(self) -> bool:
        '''Indicates whether refreshing chart cache data'''
        raise NotImplementedError()

    def setCachedFileFolder(self, value : str) -> None:
        '''The cached file folder is used to store some large data.
        :param value: '''
        raise NotImplementedError()

    def setUpdateSmartArt(self, value : bool) -> None:
        '''Indicates whether updating smart art setting.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def setWarningCallback(self, value : IWarningCallback) -> None:
        '''Sets warning callback.
        :param value: '''
        raise NotImplementedError()


class Scenario:
    '''Represents an individual scenario.'''

    def isLocked(self) -> bool:
        '''Indicates whether scenario is locked for editing when the sheet is protected.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of scenario.'''
        raise NotImplementedError()

    def isHidden(self) -> bool:
        '''Indicates whether scenario is hidden.'''
        raise NotImplementedError()

    def setComment(self, value : str) -> None:
        '''Sets the comment of scenario.
        :param value: '''
        raise NotImplementedError()

    def setLocked(self, value : bool) -> None:
        '''Indicates whether scenario is locked for editing when the sheet is protected.
        :param value: '''
        raise NotImplementedError()

    def getComment(self) -> str:
        '''Gets the comment of scenario.'''
        raise NotImplementedError()

    def setHidden(self, value : bool) -> None:
        '''Indicates whether scenario is hidden.
        :param value: '''
        raise NotImplementedError()

    def getUser(self) -> str:
        '''Gets name of user who last changed the scenario.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of scenario.
        :param value: '''
        raise NotImplementedError()

    def getInputCells(self) -> ScenarioInputCellCollection:
        '''Gets the input cells of scenario.'''
        raise NotImplementedError()


class ScenarioCollection:
    '''Represents the list of scenarios.'''

    def getActiveIndex(self) -> int:
        '''Gets which scenario is selected.'''
        raise NotImplementedError()

    def get(self, index : int) -> Scenario:
        '''Gets the :class:`Scenario` object by the index.
        :param index: The specific index in the list.'''
        raise NotImplementedError()

    def setLastSelected(self, value : int) -> None:
        '''Indicates which scenario was last selected by the user to be run/shown.
        :param value: '''
        raise NotImplementedError()

    def getLastSelected(self) -> int:
        '''Indicates which scenario was last selected by the user to be run/shown.'''
        raise NotImplementedError()

    def setActiveIndex(self, value : int) -> None:
        '''Sets which scenario is selected.
        :param value: '''
        raise NotImplementedError()

    def add(self, name : str) -> int:
        '''Adds a scenario.
        :param name: The name of scenario.
        :returns: The index in the list of scenarios.'''
        raise NotImplementedError()


class ScenarioInputCell:
    '''Represents input cell for the scenario.'''

    def setDeleted(self, value : bool) -> None:
        '''Indicates whether input cell is deleted.
        :param value: '''
        raise NotImplementedError()

    def getValue(self) -> str:
        '''Gets value of the input cell.'''
        raise NotImplementedError()

    def getColumn(self) -> int:
        '''Gets the column index of the input cell.'''
        raise NotImplementedError()

    def isDeleted(self) -> bool:
        '''Indicates whether input cell is deleted.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the input cell address.'''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets the row index of the input cell.'''
        raise NotImplementedError()

    def setValue(self, value : str) -> None:
        '''Sets value of the input cell.
        :param value: '''
        raise NotImplementedError()


class ScenarioInputCellCollection:
    '''Represents the list of the scenario's input cells.'''

    def get(self, index : int) -> ScenarioInputCell:
        '''Gets :class:`ScenarioInputCell` by index in the list.
        :param index: The specific index in the list
        :returns: The :class:`ScenarioInputCell` object'''
        raise NotImplementedError()

    def add(self, row : int, column : int, value : str) -> int:
        '''Adds an input cell.
        :param row: The row index of input cell.
        :param column: The column index of input cell.
        :param value: The value of input cell.'''
        raise NotImplementedError()


class ScrollBar:
    '''Represents a scroll bar object.'''

    def getMax(self) -> int:
        '''Gets the maximum value of a scroll bar or spinner range.'''
        raise NotImplementedError()

    def getShadow(self) -> bool:
        '''Indicates whether the shape has 3-D shading.'''
        raise NotImplementedError()

    def setIncrementalChange(self, value : int) -> None:
        '''Sets the amount that the scroll bar or spinner is incremented a line scroll.
        :param value: '''
        raise NotImplementedError()

    def getCurrentValue(self) -> int:
        '''Gets the current value.'''
        raise NotImplementedError()

    def getIncrementalChange(self) -> int:
        '''Gets the amount that the scroll bar or spinner is incremented a line scroll.'''
        raise NotImplementedError()

    def setShadow(self, value : bool) -> None:
        '''Indicates whether the shape has 3-D shading.
        :param value: '''
        raise NotImplementedError()

    def setMin(self, value : int) -> None:
        '''Sets the minimum value of a scroll bar or spinner range.
        :param value: '''
        raise NotImplementedError()

    def getPageChange(self) -> int:
        '''Gets page change'''
        raise NotImplementedError()

    def setCurrentValue(self, value : int) -> None:
        '''Sets the current value.
        :param value: '''
        raise NotImplementedError()

    def isHorizontal(self) -> bool:
        '''Indicates whether this is a horizontal scroll bar.'''
        raise NotImplementedError()

    def setHorizontal(self, value : bool) -> None:
        '''Indicates whether this is a horizontal scroll bar.
        :param value: '''
        raise NotImplementedError()

    def setPageChange(self, value : int) -> None:
        '''Sets page change
        :param value: '''
        raise NotImplementedError()

    def setMax(self, value : int) -> None:
        '''Sets the maximum value of a scroll bar or spinner range.
        :param value: '''
        raise NotImplementedError()

    def getMin(self) -> int:
        '''Gets the minimum value of a scroll bar or spinner range.'''
        raise NotImplementedError()


class ScrollBarActiveXControl:
    '''Represents the ScrollBar control.'''

    def getLargeChange(self) -> int:
        '''Gets the amount by which the Position property changes'''
        raise NotImplementedError()

    def setLargeChange(self, value : int) -> None:
        '''Sets the amount by which the Position property changes
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()


class SelectionType:
    '''The selection type of list box.'''

    SINGLE : SelectionType
    '''Sigle selection type.'''

    MULTI : SelectionType
    '''Multiple selection type.'''

    EXTEND : SelectionType
    '''Extend selection type.'''


class Series:
    '''Encapsulates the object that represents a single data series in a chart.'''

    def getBubbleSizeRepresents(self) -> int:
        ''':deprecated: Use Aspose.Cells.Charts.Series.SizeRepresents property instead.'''
        raise NotImplementedError()

    def setSplitValue(self, value : int) -> None:
        '''Returns or sets a value that shall be used to determine which data points are in the second pie or bar on
        a pie of pie or bar of pie chart.
        :param value: '''
        raise NotImplementedError()

    def setBubbleSizeRepresents(self, value : int) -> None:
        ''':deprecated: Use Aspose.Cells.Charts.Series.SizeRepresents property instead.'''
        raise NotImplementedError()

    def setFirstSliceAngle(self, value : int) -> None:
        '''Sets the angle of the first pie-chart or doughnut-chart slice, in degrees (clockwise from vertical).
        Applies only to pie, 3-D pie, and doughnut charts, 0 to 360.
        :param value: '''
        raise NotImplementedError()

    def setBubbleScale(self, value : int) -> None:
        '''Sets the scale factor for bubbles in the specified chart group.
        It can be an integer value from 0 (zero) to 300,
        corresponding to a percentage of the default size.
        Applies only to bubble charts.
        :param value: '''
        raise NotImplementedError()

    def getMarker(self) -> Marker:
        '''Gets the :meth:`Series.getMarker()`.'''
        raise NotImplementedError()

    def isVerticalValues(self) -> bool:
        '''Indicates whether the data source is vertical.'''
        raise NotImplementedError()

    def getSecondPlotSize(self) -> int:
        '''Returns or sets the size of the secondary section of either a pie of pie chart or a bar of pie chart,
        as a percentage of the size of the primary pie.
        Can be a value from 5 to 200.'''
        raise NotImplementedError()

    def setHasUpDownBars(self, value : bool) -> None:
        '''True if a line chart has up and down bars.
        Applies only to line charts.
        :param value: '''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets a data series' type.
        See :class:`ChartType`
        :param value: '''
        raise NotImplementedError()

    def isColorVaried(self) -> bool:
        '''Represents if the color of points is varied.
        The chart must contain only one series.'''
        raise NotImplementedError()

    def getPoints(self) -> ChartPointCollection:
        '''Gets the collection of points in a series in a chart.'''
        raise NotImplementedError()

    def getLegendEntry(self) -> LegendEntry:
        '''Gets the legend entry according to this series.'''
        raise NotImplementedError()

    def setSecondPlotSize(self, value : int) -> None:
        '''Returns or sets the size of the secondary section of either a pie of pie chart or a bar of pie chart,
        as a percentage of the size of the primary pie.
        Can be a value from 5 to 200.
        :param value: '''
        raise NotImplementedError()

    def getSplitValue(self) -> int:
        '''Returns or sets a value that shall be used to determine which data points are in the second pie or bar on
        a pie of pie or bar of pie chart.'''
        raise NotImplementedError()

    def getSmooth(self) -> bool:
        '''Represents curve smoothing.
        True if curve smoothing is turned on for the line chart or scatter chart.
        Applies only to line and scatter connected by lines charts.'''
        raise NotImplementedError()

    def setHasRadarAxisLabels(self, value : bool) -> None:
        '''True if a radar chart has category axis labels. Applies only to radar charts.
        :param value: '''
        raise NotImplementedError()

    def getBubbleScale(self) -> int:
        '''Gets the scale factor for bubbles in the specified chart group.
        It can be an integer value from 0 (zero) to 300,
        corresponding to a percentage of the default size.
        Applies only to bubble charts.'''
        raise NotImplementedError()

    def setExplosion(self, value : int) -> None:
        '''The distance of an open pie slice from the center of the pie chart is expressed as a percentage of the pie diameter.
        :param value: '''
        raise NotImplementedError()

    def isAutoSplit(self) -> bool:
        '''Indicates whether the threshold value is automatic.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the data series.
        :param value: '''
        raise NotImplementedError()

    def setValuesFormatCode(self, value : str) -> None:
        '''Represents format code of Values's NumberList.
        :param value: '''
        raise NotImplementedError()

    def getExplosion(self) -> int:
        '''The distance of an open pie slice from the center of the pie chart is expressed as a percentage of the pie diameter.'''
        raise NotImplementedError()

    def setFiltered(self, value : bool) -> None:
        '''Indicates whether the series is selected or filtered.True represents this series is filtered, and it will not be displayed on the chart.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets a data series' type.
        See :class:`ChartType`'''
        raise NotImplementedError()

    def setGapWidth(self, value : int) -> None:
        '''Returns or sets the space between bar or column clusters, as a percentage of the bar or column width.
        The value of this property must be between 0 and 500.
        :param value: '''
        raise NotImplementedError()

    def getShowNegativeBubbles(self) -> bool:
        '''True if negative bubbles are shown for the chart group. Valid only for bubble charts.'''
        raise NotImplementedError()

    def getFirstSliceAngle(self) -> int:
        '''Gets the angle of the first pie-chart or doughnut-chart slice, in degrees (clockwise from vertical).
        Applies only to pie, 3-D pie, and doughnut charts, 0 to 360.'''
        raise NotImplementedError()

    def setColorVaried(self, value : bool) -> None:
        '''Represents if the color of points is varied.
        The chart must contain only one series.
        :param value: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the data series.'''
        raise NotImplementedError()

    def hasUpDownBars(self) -> bool:
        '''True if a line chart has up and down bars.
        Applies only to line charts.'''
        raise NotImplementedError()

    def setPlotOnSecondAxis(self, value : bool) -> None:
        '''Indicates if this series is plotted on second value axis.
        :param value: '''
        raise NotImplementedError()

    def getHiLoLines(self) -> Line:
        '''Returns a HiLoLines object that represents the high-low lines for a series on a line chart.
        Applies only to line charts.'''
        raise NotImplementedError()

    def getValuesFormatCode(self) -> str:
        '''Represents format code of Values's NumberList.'''
        raise NotImplementedError()

    def setXValuesFormatCode(self, value : str) -> None:
        '''Represents format code of X Values's NumberList.
        :param value: '''
        raise NotImplementedError()

    def getXErrorBar(self) -> ErrorBar:
        '''Represents X direction error bar of the series.'''
        raise NotImplementedError()

    def getPlotOnSecondAxis(self) -> bool:
        '''Indicates if this series is plotted on second value axis.'''
        raise NotImplementedError()

    def getBar3DShapeType(self) -> int:
        '''Gets the 3D shape type used with the 3-D bar or column chart.
        See :class:`Bar3DShapeType`'''
        raise NotImplementedError()

    def hasHiLoLines(self) -> bool:
        '''True if the line chart has high-low lines.
        Applies only to line charts.'''
        raise NotImplementedError()

    def setShadow(self, value : bool) -> None:
        '''True if the series has a shadow.
        :param value: '''
        raise NotImplementedError()

    def getUpBars(self) -> DropBars:
        '''Returns an DropBars object that represents the up bars on a line chart.
        Applies only to line charts.'''
        raise NotImplementedError()

    def getLayoutProperties(self) -> SeriesLayoutProperties:
        '''Represents the properties of layout.'''
        raise NotImplementedError()

    def getTrendLines(self) -> TrendlineCollection:
        '''Returns all the trendlines of this series.'''
        raise NotImplementedError()

    def hasLeaderLines(self) -> bool:
        '''True if the series has leader lines.'''
        raise NotImplementedError()

    def isFiltered(self) -> bool:
        '''Indicates whether the series is selected or filtered.True represents this series is filtered, and it will not be displayed on the chart.'''
        raise NotImplementedError()

    def setBar3DShapeType(self, value : int) -> None:
        '''Sets the 3D shape type used with the 3-D bar or column chart.
        See :class:`Bar3DShapeType`
        :param value: '''
        raise NotImplementedError()

    def setBubbleSizes(self, value : str) -> None:
        '''Sets the bubble sizes values of the chart series.
        :param value: '''
        raise NotImplementedError()

    def getXValues(self) -> str:
        '''Represents the x values of the chart series.'''
        raise NotImplementedError()

    def getOverlap(self) -> int:
        '''Specifies how bars and columns are positioned.
        Can be a value between ?100 and 100.
        Applies only to 2-D bar and 2-D column charts.'''
        raise NotImplementedError()

    def getGapWidth(self) -> int:
        '''Returns or sets the space between bar or column clusters, as a percentage of the bar or column width.
        The value of this property must be between 0 and 500.'''
        raise NotImplementedError()

    def getXValuesFormatCode(self) -> str:
        '''Represents format code of X Values's NumberList.'''
        raise NotImplementedError()

    def getSizeRepresents(self) -> int:
        '''Gets what the bubble size represents on a bubble chart.
        See :class:`BubbleSizeRepresents`'''
        raise NotImplementedError()

    def setDoughnutHoleSize(self, value : int) -> None:
        '''Returns or sets the size of the hole in a doughnut chart group.
        The hole size is expressed as a percentage of the chart size, between 10 and 90 percent.
        :param value: '''
        raise NotImplementedError()

    def getBubbleSizes(self) -> str:
        '''Gets the bubble sizes values of the chart series.'''
        raise NotImplementedError()

    def getDropLines(self) -> Line:
        '''Returns a :class:`Line` object that represents the drop lines for a series on the line chart or area chart.
        Applies only to line chart or area charts.'''
        raise NotImplementedError()

    def getLeaderLines(self) -> Line:
        '''Represents leader lines on a chart. Leader lines connect data labels to data points.
        This object isn a collection; there no object that represents a single leader line.'''
        raise NotImplementedError()

    def setValues(self, value : str) -> None:
        '''Represents the Y values of this chart series.
        :param value: '''
        raise NotImplementedError()

    def setHasHiLoLines(self, value : bool) -> None:
        '''True if the line chart has high-low lines.
        Applies only to line charts.
        :param value: '''
        raise NotImplementedError()

    def setHasLeaderLines(self, value : bool) -> None:
        '''True if the series has leader lines.
        :param value: '''
        raise NotImplementedError()

    def getDataLabels(self) -> DataLabels:
        '''Represents the DataLabels object for the specified ASeries.'''
        raise NotImplementedError()

    def getDisplayName(self) -> str:
        '''Gets the series's name that displays on the chart graph.'''
        raise NotImplementedError()

    def getDoughnutHoleSize(self) -> int:
        '''Returns or sets the size of the hole in a doughnut chart group.
        The hole size is expressed as a percentage of the chart size, between 10 and 90 percent.'''
        raise NotImplementedError()

    def hasSeriesLines(self) -> bool:
        '''True if a stacked column chart or bar chart has series lines or
        if a Pie of Pie chart or Bar of Pie chart has connector lines between the two sections.
        Applies only to stacked column charts, bar charts, Pie of Pie charts, or Bar of Pie charts.'''
        raise NotImplementedError()

    def hasDropLines(self) -> bool:
        '''True if the chart has drop lines.
        Applies only to line chart or area charts.'''
        raise NotImplementedError()

    def move(self, count : int) -> None:
        '''Moves the series up or down.
        :param count: The number of moving up or down.'''
        raise NotImplementedError()

    def setSizeRepresents(self, value : int) -> None:
        '''Sets what the bubble size represents on a bubble chart.
        See :class:`BubbleSizeRepresents`
        :param value: '''
        raise NotImplementedError()

    def setSmooth(self, value : bool) -> None:
        '''Represents curve smoothing.
        True if curve smoothing is turned on for the line chart or scatter chart.
        Applies only to line and scatter connected by lines charts.
        :param value: '''
        raise NotImplementedError()

    def getCountOfDataValues(self) -> int:
        '''Gets the number of the data values.'''
        raise NotImplementedError()

    def getArea(self) -> Area:
        '''Represents the background area of Series object.'''
        raise NotImplementedError()

    def getDownBars(self) -> DropBars:
        '''Returns a :class:`DropBars` object that represents the down bars on a line chart.
        Applies only to line charts.'''
        raise NotImplementedError()

    def getShadow(self) -> bool:
        '''True if the series has a shadow.'''
        raise NotImplementedError()

    def getSeriesLines(self) -> Line:
        '''Returns a SeriesLines object that represents the series lines for a stacked bar chart or a stacked column chart.
        Applies only to stacked bar and stacked column charts.'''
        raise NotImplementedError()

    def setHas3DEffect(self, value : bool) -> None:
        '''True if the series has a three-dimensional appearance.
        Applies only to bubble charts.
        :param value: '''
        raise NotImplementedError()

    def setShowNegativeBubbles(self, value : bool) -> None:
        '''True if negative bubbles are shown for the chart group. Valid only for bubble charts.
        :param value: '''
        raise NotImplementedError()

    def setHasSeriesLines(self, value : bool) -> None:
        '''True if a stacked column chart or bar chart has series lines or
        if a Pie of Pie chart or Bar of Pie chart has connector lines between the two sections.
        Applies only to stacked column charts, bar charts, Pie of Pie charts, or Bar of Pie charts.
        :param value: '''
        raise NotImplementedError()

    def setXValues(self, value : str) -> None:
        '''Represents the x values of the chart series.
        :param value: '''
        raise NotImplementedError()

    def setOverlap(self, value : int) -> None:
        '''Specifies how bars and columns are positioned.
        Can be a value between ?100 and 100.
        Applies only to 2-D bar and 2-D column charts.
        :param value: '''
        raise NotImplementedError()

    def setHasDropLines(self, value : bool) -> None:
        '''True if the chart has drop lines.
        Applies only to line chart or area charts.
        :param value: '''
        raise NotImplementedError()

    def hasRadarAxisLabels(self) -> bool:
        '''True if a radar chart has category axis labels. Applies only to radar charts.'''
        raise NotImplementedError()

    def setSplitType(self, value : int) -> None:
        '''Returns or sets a value that how to determine which data points are in the second pie or bar on a pie of pie or bar of
        pie chart.
        See :class:`ChartSplitType`
        :param value: '''
        raise NotImplementedError()

    def getYErrorBar(self) -> ErrorBar:
        '''Represents Y direction error bar of the series.'''
        raise NotImplementedError()

    def getBorder(self) -> Line:
        '''Represents border of Series object.'''
        raise NotImplementedError()

    def getSplitType(self) -> int:
        '''Returns or sets a value that how to determine which data points are in the second pie or bar on a pie of pie or bar of
        pie chart.
        See :class:`ChartSplitType`'''
        raise NotImplementedError()

    def getHas3DEffect(self) -> bool:
        '''True if the series has a three-dimensional appearance.
        Applies only to bubble charts.'''
        raise NotImplementedError()

    def getShapeProperties(self) -> ShapePropertyCollection:
        '''Gets the :class:`ShapePropertyCollection` object that holds the visual shape properties of the Series.'''
        raise NotImplementedError()

    def getValues(self) -> str:
        '''Represents the Y values of this chart series.'''
        raise NotImplementedError()


class SeriesCollection:
    '''Encapsulates a collection of :class:`Series` objects.'''

    def getCategoryData(self) -> str:
        '''Gets the range of category Axis values.
        It can be a range of cells (such as, "d1:e10"),
        or a sequence of values (such as,"{2,6,8,10}").'''
        raise NotImplementedError()

    def get(self, index : int) -> Series:
        '''Gets the :class:`Series` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    def changeSeriesOrder(self, sourceIndex : int, destIndex : int) -> None:
        ''':deprecated: Use SeriesCollection.SwapSeries property, instead.'''
        raise NotImplementedError()

    def getSeriesByOrder(self, order : int) -> Series:
        '''Gets the :class:`Series` element by order.
        :param order: The order of series
        :returns: The element series'''
        raise NotImplementedError()

    def isColorVaried(self) -> bool:
        '''Represents if the color of points is varied.'''
        raise NotImplementedError()

    def addR1C1(self, area : str, isVertical : bool) -> int:
        '''Adds the :class:`Series` collection to a chart.
        :param area: Specifies values from which to plot the data series
        :param isVertical: Specifies whether to plot the series from a range of cell values by row or by column.
        :returns: Return the first index of the added ASeries in the NSeries.'''
        raise NotImplementedError()

    def clear(self) -> None:
        '''Clears the collection'''
        raise NotImplementedError()

    def setCategoryData(self, value : str) -> None:
        '''Sets the range of category Axis values.
        It can be a range of cells (such as, "d1:e10"),
        or a sequence of values (such as,"{2,6,8,10}").
        :param value: '''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Remove at a series at the specific index.
        :param index: The index.'''
        raise NotImplementedError()

    def setColorVaried(self, value : bool) -> None:
        '''Represents if the color of points is varied.
        :param value: '''
        raise NotImplementedError()

    def setSecondCategoryData(self, value : str) -> None:
        '''Sets the range of second category Axis values.
        It can be a range of cells (such as, "d1:e10"),
        or a sequence of values (such as,"{2,6,8,10}").
        Only effects when some ASerieses plot on the second axis.
        :param value: '''
        raise NotImplementedError()

    def swapSeries(self, sourceIndex : int, destIndex : int) -> None:
        '''Directly changes the orders of the two series.
        :param sourceIndex: The current index
        :param destIndex: The dest index'''
        raise NotImplementedError()

    def getSecondCategoryData(self) -> str:
        '''Gets the range of second category Axis values.
        It can be a range of cells (such as, "d1:e10"),
        or a sequence of values (such as,"{2,6,8,10}").
        Only effects when some ASerieses plot on the second axis.'''
        raise NotImplementedError()

    @overload
    def add(self, area : str, isVertical : bool) -> int:
        '''Adds the :class:`Series` collection to a chart.
        :param area: Specifies values from which to plot the data series
        :param isVertical: Specifies whether to plot the series from a range of cell values by row or by column.
        :returns: Return the first index of the added ASeries in the NSeries.'''
        raise NotImplementedError()

    @overload
    def add(self, area : str, isVertical : bool, checkLabels : bool) -> int:
        '''Adds the :class:`Series` collection to a chart.
        :param area: Specifies values from which to plot the data series
        :param isVertical: Specifies whether to plot the series from a range of cell values by row or by column.
        :param checkLabels: Indicates whether the range contains series's name
        :returns: Return the first index of the added ASeries in the NSeries.'''
        raise NotImplementedError()

    def setSeriesNames(self, startIndex : int, area : str, isVertical : bool) -> None:
        '''Sets the name of all the serieses in the chart.
        :param startIndex: The index of the first series which you want to set the name.
        :param area: Specifies the area for the series name.
        :param isVertical: >Specifies whether to plot the series from a range of cell values by row or by column.'''
        raise NotImplementedError()


class SeriesLayoutProperties:
    '''Represents the properties of series layout.'''

    def setQuartileCalculation(self, value : int) -> None:
        '''Represents the statistical properties for the series.
        See :class:`QuartileCalculationType`
        :param value: '''
        raise NotImplementedError()

    def getMapChartRegionType(self) -> int:
        '''Gets the region type of the map.
        See :class:`MapChartRegionType`'''
        raise NotImplementedError()

    def getShowConnectorLines(self) -> bool:
        '''Indicates whether showing connector lines between data points.'''
        raise NotImplementedError()

    def getSubtotals(self) -> list[int]:
        '''Represents the index of a subtotal data point.'''
        raise NotImplementedError()

    def setShowOutlierPoints(self, value : bool) -> None:
        '''Indicates whether showing outlier data points.
        :param value: '''
        raise NotImplementedError()

    def getMapLabelLayout(self) -> int:
        '''Gets the layout of map labels.
        See :class:`MapChartLabelLayout`'''
        raise NotImplementedError()

    def setSubtotals(self, value : list[int]) -> None:
        '''Represents the index of a subtotal data point.
        :param value: '''
        raise NotImplementedError()

    def getQuartileCalculation(self) -> int:
        '''Represents the statistical properties for the series.
        See :class:`QuartileCalculationType`'''
        raise NotImplementedError()

    def setMapLabelLayout(self, value : int) -> None:
        '''Sets the layout of map labels.
        See :class:`MapChartLabelLayout`
        :param value: '''
        raise NotImplementedError()

    def setShowMeanMarker(self, value : bool) -> None:
        '''Indicates whether showing markers denoting the mean.
        :param value: '''
        raise NotImplementedError()

    def setMapChartRegionType(self, value : int) -> None:
        '''Sets the region type of the map.
        See :class:`MapChartRegionType`
        :param value: '''
        raise NotImplementedError()

    def setShowConnectorLines(self, value : bool) -> None:
        '''Indicates whether showing connector lines between data points.
        :param value: '''
        raise NotImplementedError()

    def getMapChartProjectionType(self) -> int:
        '''Gets the projection type of the map.
        See :class:`MapChartProjectionType`'''
        raise NotImplementedError()

    def getShowMeanLine(self) -> bool:
        '''Indicates whether showing the line connecting all mean points.'''
        raise NotImplementedError()

    def isIntervalLeftClosed(self) -> bool:
        '''Indicates whether the interval is closed on the left side.'''
        raise NotImplementedError()

    def getShowMeanMarker(self) -> bool:
        '''Indicates whether showing markers denoting the mean.'''
        raise NotImplementedError()

    def setShowInnerPoints(self, value : bool) -> None:
        '''Indicates whether showing non-outlier data points.
        :param value: '''
        raise NotImplementedError()

    def setMapChartProjectionType(self, value : int) -> None:
        '''Sets the projection type of the map.
        See :class:`MapChartProjectionType`
        :param value: '''
        raise NotImplementedError()

    def getShowOutlierPoints(self) -> bool:
        '''Indicates whether showing outlier data points.'''
        raise NotImplementedError()

    def setShowMeanLine(self, value : bool) -> None:
        '''Indicates whether showing the line connecting all mean points.
        :param value: '''
        raise NotImplementedError()

    def getShowInnerPoints(self) -> bool:
        '''Indicates whether showing non-outlier data points.'''
        raise NotImplementedError()

    def setIntervalLeftClosed(self, value : bool) -> None:
        '''Indicates whether the interval is closed on the left side.
        :param value: '''
        raise NotImplementedError()


class SettableChartGlobalizationSettings:
    '''Implementation of PivotGlobalizationSettings that supports user to set/change pre-defined texts.'''

    def setLegendIncreaseName(self, name : str) -> None:
        '''Sets the name of increase for Legend.
        :param name: local dependent name'''
        raise NotImplementedError()

    def getChartTitleName(self) -> str:
        '''Gets the name of Chart Title.'''
        raise NotImplementedError()

    def setOtherName(self, name : str) -> None:
        '''Sets the name of "Other" labels for Chart.
        :param name: local dependent name'''
        raise NotImplementedError()

    def getLegendDecreaseName(self) -> str:
        '''Gets the name of Decrease for Legend.'''
        raise NotImplementedError()

    def getSeriesName(self) -> str:
        '''Gets the name of Series in the Chart.'''
        raise NotImplementedError()

    def setAxisUnitName(self, type : int, name : str) -> None:
        '''Sets the Name of Axis Unit.
        :param type: :class:`DisplayUnitType`. The unit type for displaying axis labels.
        :param name: local dependent name'''
        raise NotImplementedError()

    def getLegendIncreaseName(self) -> str:
        '''Gets the name of increase for Legend.'''
        raise NotImplementedError()

    def setChartTitleName(self, name : str) -> None:
        '''Sets the name of Chart Title.
        :param name: local dependent name'''
        raise NotImplementedError()

    def setSeriesName(self, name : str) -> None:
        '''Sets the name of Series in the Chart.
        :param name: local dependent name'''
        raise NotImplementedError()

    def setLegendTotalName(self, name : str) -> None:
        '''Sets the name of Total for Legend.
        :param name: local dependent name'''
        raise NotImplementedError()

    def getAxisTitleName(self) -> str:
        '''Gets the name of Title for Axis.'''
        raise NotImplementedError()

    def setAxisTitleName(self, name : str) -> None:
        '''Sets the name of Title for Axis.
        :param name: local dependent name'''
        raise NotImplementedError()

    def getLegendTotalName(self) -> str:
        '''Gets the name of Total for Legend.'''
        raise NotImplementedError()

    def getOtherName(self) -> str:
        '''Gets the name of "Other" labels for Chart.'''
        raise NotImplementedError()

    def getAxisUnitName(self, type : int) -> str:
        '''Gets the Name of Axis Unit.
        :param type: '''
        raise NotImplementedError()

    def setLegendDecreaseName(self, name : str) -> None:
        '''Sets the name of Decrease for Legend.
        :param name: local dependent name'''
        raise NotImplementedError()


class SettableGlobalizationSettings:
    '''Implementation of GlobalizationSettings that supports user to set/change pre-defined texts.'''

    def setRowSeparatorOfFormulaArray(self, c : str) -> None:
        '''Sets the separator for rows in array data in formula.
        :param c: the specified separator'''
        raise NotImplementedError()

    def setTableRowTypeOfData(self, name : str) -> None:
        '''Sets the type name of table rows that consists of data region of referenced table.
        :param name: the type name of table rows'''
        raise NotImplementedError()

    def setCommentTitleName(self, type : int, name : str) -> None:
        '''Gets the locale dependent comment title name according to comment title type.
        :param type: :class:`CommentTitleType`. type of comment title
        :param name: locale dependent comment title name'''
        raise NotImplementedError()

    def getColumnSeparatorOfFormulaArray(self) -> str:
        '''Gets the separator for the items in array's row data in formula.'''
        raise NotImplementedError()

    def setColumnSeparatorOfFormulaArray(self, c : str) -> None:
        '''Sets the separator for the items in array's row data in formula.
        :param c: the specified separator'''
        raise NotImplementedError()

    def getTableRowTypeOfTotals(self) -> str:
        '''Gets the type name of table rows that consists of the total row of referenced table.'''
        raise NotImplementedError()

    def getTotalName(self, functionType : int) -> str:
        '''Gets the total name of specific function.
        :param functionType: :class:`ConsolidationFunction`. The function type.
        :returns: The total name of the function.'''
        raise NotImplementedError()

    def getTableRowTypeOfHeaders(self) -> str:
        '''Gets the type name of table rows that consists of the table header.
        Default is "Headers", so in formula "#Headers" represents the table header.'''
        raise NotImplementedError()

    def getGrandTotalName(self, functionType : int) -> str:
        '''Gets the grand total name of the function.
        :param functionType: :class:`ConsolidationFunction`. The function type.
        :returns: The grand total name of the function.'''
        raise NotImplementedError()

    def setGrandTotalName(self, functionType : int, name : str) -> None:
        '''Sets the grand total name of specific function.
        :param functionType: :class:`ConsolidationFunction`. The function type.
        :param name: The grand total name of the function.'''
        raise NotImplementedError()

    def getLocalBuiltInName(self, standardName : str) -> str:
        '''Gets the locale dependent text for built-in Name according to given standard text.
        :param standardName: Standard(en-US locale) text of built-in Name.
        :returns: Locale dependent text. The locale was specified by the Workbook for which this settings is used.'''
        raise NotImplementedError()

    def getStandardHeaderFooterFontStyleName(self, localfontStyleName : str) -> str:
        '''Gets standard English font style name(Regular, Bold, Italic) for Header/Footer according to given locale font style name.
        :param localfontStyleName: Locale font style name for Header/Footer.
        :returns: Standard English font style name(Regular, Bold, Italic)'''
        raise NotImplementedError()

    def setTableRowTypeOfTotals(self, name : str) -> None:
        '''Sets the type name of table rows that consists of the total row of referenced table.
        :param name: the type name of table rows'''
        raise NotImplementedError()

    def setTableRowTypeOfHeaders(self, name : str) -> None:
        '''Sets the type name of table rows that consists of the table header.
        :param name: the type name of table rows'''
        raise NotImplementedError()

    def getStandardBuiltInName(self, localName : str) -> str:
        '''Gets the standard text of built-in Name according to given locale dependent text.
        :param localName: Locale dependent text of built-in Name. The locale was specified by the Workbook for which this settings is used.
        :returns: Standard(en-US locale) text.'''
        raise NotImplementedError()

    def setListSeparator(self, c : str) -> None:
        '''Sets the separator for list, parameters of function, ...etc.
        :param c: the specified separator'''
        raise NotImplementedError()

    def getBooleanValueString(self, bv : bool) -> str:
        '''Gets the display string value for cell's boolean value
        :param bv: boolean value
        :returns: By default returns "TRUE" for true value and "FALSE" for false value.'''
        raise NotImplementedError()

    def getRowSeparatorOfFormulaArray(self) -> str:
        '''Gets the separator for rows in array data in formula.'''
        raise NotImplementedError()

    def setStandardBuiltInName(self, localName : str, standardName : str, bidirectional : bool) -> None:
        '''Sets the locale dependent function name according to given standard function name.
        :param localName: Locale dependent function name
        :param standardName: Standard(en-US locale) function name.
        :param bidirectional: Whether map the standard name text to local name text automatically.'''
        raise NotImplementedError()

    def setTotalName(self, functionType : int, name : str) -> None:
        '''Sets the total name of specific function.
        :param functionType: :class:`ConsolidationFunction`. The function type.
        :param name: The total name of the function.'''
        raise NotImplementedError()

    def getTableRowTypeOfAll(self) -> str:
        '''Gets the type name of table rows that consists of all rows in referenced table.'''
        raise NotImplementedError()

    def getStandardFunctionName(self, localName : str) -> str:
        '''Gets the standard function name according to given locale dependent function name.
        :param localName: Locale dependent function name. The locale was specified by the Workbook for which this settings is used.
        :returns: Standard(en-US locale) function name.'''
        raise NotImplementedError()

    def setLocalFunctionName(self, standardName : str, localName : str, bidirectional : bool) -> None:
        '''Sets the locale dependent function name corresponding to given standard function name.
        :param standardName: Standard(en-US locale) function name.
        :param localName: Locale dependent function name
        :param bidirectional: Whether map the local function name to standard function name automatically.'''
        raise NotImplementedError()

    def getErrorValueString(self, err : str) -> str:
        '''Gets the display string value for cell's error value
        :param err: error values such as #VALUE!,#NAME?
        :returns: By default returns the error value itself'''
        raise NotImplementedError()

    def getTableRowTypeOfCurrent(self) -> str:
        '''Gets the type name of table rows that consists of the current row in referenced table.'''
        raise NotImplementedError()

    def setBooleanValueString(self, bv : bool, name : str) -> None:
        '''Sets the display string value for cell's boolean value
        :param bv: boolean value
        :param name: string value of the boolean value'''
        raise NotImplementedError()

    def getTableRowTypeOfData(self) -> str:
        '''Gets the type name of table rows that consists of data region of referenced table.
        Default is "Data", so in formula "#Data" represents the data region of the table.'''
        raise NotImplementedError()

    def getLocalFunctionName(self, standardName : str) -> str:
        '''Gets the locale dependent function name according to given standard function name.
        :param standardName: Standard(en-US locale) function name.
        :returns: Locale dependent function name. The locale was specified by the Workbook for which this settings is used.'''
        raise NotImplementedError()

    def setTableRowTypeOfCurrent(self, name : str) -> None:
        '''Sets the type name of table rows that consists of the current row in referenced table.
        :param name: the type name of table rows'''
        raise NotImplementedError()

    def getCommentTitleName(self, type : int) -> str:
        '''Gets the locale dependent comment title name according to comment title type.
        :param type: :class:`CommentTitleType`. type of comment title
        :returns: locale dependent comment title name'''
        raise NotImplementedError()

    def getListSeparator(self) -> str:
        '''Gets the separator for list, parameters of function, ...etc.'''
        raise NotImplementedError()

    def setLocalBuiltInName(self, standardName : str, localName : str, bidirectional : bool) -> None:
        '''Sets the locale dependent text for the built-in name with given standard name text.
        :param standardName: Standard(en-US locale) name text of built-in name.
        :param localName: Locale dependent name text
        :param bidirectional: Whether map the local name text to standard name text automatically.'''
        raise NotImplementedError()

    def setStandardFunctionName(self, localName : str, standardName : str, bidirectional : bool) -> None:
        '''Sets the locale dependent function name according to given standard function name.
        :param localName: Locale dependent function name
        :param standardName: Standard(en-US locale) function name.
        :param bidirectional: Whether map the standard function name to local function name automatically.'''
        raise NotImplementedError()

    def setStandardHeaderFooterFontStyleName(self, localfontStyleName : str, standardName : str) -> None:
        '''Sets the locale dependent function name according to given standard function name.
        :param localfontStyleName: Locale font style name for Header/Footer.
        :param standardName: Standard(en-US locale) function name.'''
        raise NotImplementedError()

    def setTableRowTypeOfAll(self, name : str) -> None:
        '''Sets the type name of table rows that consists of all rows in referenced table.
        :param name: the type name of table rows'''
        raise NotImplementedError()


class SettablePivotGlobalizationSettings:
    '''Implementation of PivotGlobalizationSettings that supports user to set/change pre-defined texts.'''

    def setTextOfRowLabels(self, text : str) -> None:
        '''Sets the text of "Row Labels" label in the PivotTable.
        :param text: The text of row labels'''
        raise NotImplementedError()

    def getTextOfProtectedName(self, protectedName : str) -> str:
        '''Gets the text for specified protected name.
        :param protectedName: The protected name in PivotTable.
        :returns: The local prorected names of PivotTable.'''
        raise NotImplementedError()

    def setTextOfMultipleItems(self, text : str) -> None:
        '''Sets the text of "(Multiple Items)" label in the PivotTable.
        :param text: custom text'''
        raise NotImplementedError()

    def getTextOfEmptyData(self) -> str:
        '''Gets the text of "(blank)" label in the PivotTable.'''
        raise NotImplementedError()

    def setTextOfAll(self, text : str) -> None:
        '''Sets the text of "(All)" label in the PivotTable.
        :param text: custom text'''
        raise NotImplementedError()

    def setTextOfProtectedName(self, protectedName : str, text : str) -> None:
        '''Sets the text for specific protected name.
        :param protectedName: The protected name in PivotTable.
        :param text: The local prorected names of PivotTable.'''
        raise NotImplementedError()

    def getTextOfTotal(self) -> str:
        '''Gets the text of "Total" label in the PivotTable.
        You need to override this method when the PivotTable contains two or more PivotFields in the data area.'''
        raise NotImplementedError()

    def getTextOfSubTotal(self, subTotalType : int) -> str:
        '''Gets the text of :class:`PivotFieldSubtotalType` type in the PivotTable.
        :param subTotalType: :class:`PivotFieldSubtotalType`. The :class:`PivotFieldSubtotalType`
        :returns: The text of given type'''
        raise NotImplementedError()

    def setTextOfEmptyData(self, text : str) -> None:
        '''Sets the text of "(blank)" label in the PivotTable.
        :param text: The text of empty data'''
        raise NotImplementedError()

    def getTextOfRowLabels(self) -> str:
        '''Gets the text of "Row Labels" label in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfColumnLabels(self) -> str:
        '''Gets the text of "Column Labels" label in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfDataFieldHeader(self) -> str:
        '''Gets the the text of the value area field header in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfGrandTotal(self) -> str:
        '''Gets the text of "Grand Total" label in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfAll(self) -> str:
        '''Gets the text of "(All)" label in the PivotTable.'''
        raise NotImplementedError()

    def getTextOfMultipleItems(self) -> str:
        '''Gets the text of "(Multiple Items)" label in the PivotTable.'''
        raise NotImplementedError()

    def setTextOfDataFieldHeader(self, text : str) -> None:
        '''Sets the the text of the value area field header in the PivotTable.
        :param text: The text of data field header name'''
        raise NotImplementedError()

    def setTextOfSubTotal(self, subTotalType : int, text : str) -> None:
        '''Sets the text of :class:`PivotFieldSubtotalType` type in the PivotTable.
        :param subTotalType: :class:`PivotFieldSubtotalType`. The :class:`PivotFieldSubtotalType`
        :param text: The text of given type'''
        raise NotImplementedError()

    def setTextOfColumnLabels(self, text : str) -> None:
        '''Gets the text of "Column Labels" label in the PivotTable.
        :param text: The text of column labels'''
        raise NotImplementedError()

    def setTextOfGrandTotal(self, text : str) -> None:
        '''Sets the text of "Grand Total" label in the PivotTable.
        :param text: custom text'''
        raise NotImplementedError()

    def setTextOfTotal(self, text : str) -> None:
        '''Sets the text of "Total" label in the PivotTable.
        :param text: custom text'''
        raise NotImplementedError()


class ShadowEffect:
    '''This class specifies the shadow effect of the chart element or shape.'''

    def setTransparency(self, value : int) -> None:
        '''Sets the degree of transparency of the shadow. Range from 0.0 (opaque) to 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def setPresetType(self, value : int) -> None:
        '''Sets the preset shadow type of the shadow.
        See :class:`PresetShadowType`
        :param value: '''
        raise NotImplementedError()

    def getBlur(self) -> int:
        '''Gets the blur of the shadow. Range from 0 to 100 points.'''
        raise NotImplementedError()

    def setDistance(self, value : int) -> None:
        '''Sets the distance of the shadow. Range from 0 to 200 points.
        :param value: '''
        raise NotImplementedError()

    def setSize(self, value : int) -> None:
        '''Sets the size of the shadow. Range from 0 to 2.0.
        Meaningless in inner shadow.
        :param value: '''
        raise NotImplementedError()

    def getDistance(self) -> int:
        '''Gets the distance of the shadow. Range from 0 to 200 points.'''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Gets the degree of transparency of the shadow. Range from 0.0 (opaque) to 1.0 (clear).'''
        raise NotImplementedError()

    def setAngle(self, value : int) -> None:
        '''Sets the lighting angle. Range from 0 to 359.9 degrees.
        :param value: '''
        raise NotImplementedError()

    def setBlur(self, value : int) -> None:
        '''Sets the blur of the shadow. Range from 0 to 100 points.
        :param value: '''
        raise NotImplementedError()

    def setColor(self, value : CellsColor) -> None:
        '''Sets the color of the shadow.
        :param value: '''
        raise NotImplementedError()

    def getAngle(self) -> int:
        '''Gets the lighting angle. Range from 0 to 359.9 degrees.'''
        raise NotImplementedError()

    def getColor(self) -> CellsColor:
        '''Gets the color of the shadow.'''
        raise NotImplementedError()

    def getSize(self) -> int:
        '''Gets the size of the shadow. Range from 0 to 2.0.
        Meaningless in inner shadow.'''
        raise NotImplementedError()

    def getPresetType(self) -> int:
        '''Gets the preset shadow type of the shadow.
        See :class:`PresetShadowType`'''
        raise NotImplementedError()


class Shape:
    '''Represents the msodrawing object.'''

    def getTextOrientationType(self) -> int:
        '''Gets the text orientation type of the shape.
        See :class:`TextOrientationType`'''
        raise NotImplementedError()

    def setLowerDeltaY(self, value : int) -> None:
        '''Sets the shape's vertical offset from its lower right corner row.
        :param value: '''
        raise NotImplementedError()

    def getTextOptions(self) -> TextOptions:
        '''Represents the text options of the shape.'''
        raise NotImplementedError()

    def setLowerDeltaX(self, value : int) -> None:
        '''Sets the shape's horizontal  offset from its lower right corner column.
        :param value: '''
        raise NotImplementedError()

    def setHeightInch(self, value : int) -> None:
        '''Represents the height of the shape, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def getWidthInch(self) -> int:
        '''Represents the width of the shape, in unit of inch.'''
        raise NotImplementedError()

    def getRichFormattings(self) -> list[FontSetting]:
        '''Returns all Characters objects
        that represents a range of characters within the text .'''
        raise NotImplementedError()

    def setHasLine(self, value : bool) -> None:
        '''Sets the line border of the shape is visible.
        :param value: '''
        raise NotImplementedError()

    def getTopToCorner(self) -> int:
        '''Gets the vertical offset of shape from worksheet top border, in unit of pixels.'''
        raise NotImplementedError()

    def formatCharacters(self, startIndex : int, length : int, font : Font, flag : StyleFlag) -> None:
        '''Formats some characters with the font setting.
        :param startIndex: The start index.
        :param length: The length.
        :param font: The font setting.
        :param flag: The flag of the font setting.'''
        raise NotImplementedError()

    @overload
    def toImage(self, stream : OutputStream, imageFormat : ImageFormat) -> None:
        '''Creates the shape image and saves it to a stream in the specified format.
        :param stream: The output stream.
        :param imageFormat: The format in which to save the image.'''
        raise NotImplementedError()

    @overload
    def toImage(self, imageFile : str, options : ImageOrPrintOptions) -> None:
        '''Saves the shape to a file.
        :param imageFile: 
        :param options: '''
        raise NotImplementedError()

    @overload
    def toImage(self, stream : OutputStream, options : ImageOrPrintOptions) -> None:
        '''Saves the shape to a stream.
        :param stream: 
        :param options: '''
        raise NotImplementedError()

    def getTextDirection(self) -> int:
        '''Gets the direction of the text flow for this object.
        See :class:`TextDirectionType`'''
        raise NotImplementedError()

    def getHeightCM(self) -> int:
        '''Represents the height of the shape, in unit of centimeters.'''
        raise NotImplementedError()

    def getGeometry(self) -> Geometry:
        '''Gets the geometry'''
        raise NotImplementedError()

    def getHeightScale(self) -> int:
        '''Gets the height scale,in unit of percent of the original picture height.
        If the shape is not picture ,the HeightScale property only returns 100;'''
        raise NotImplementedError()

    def getGroup(self) -> GroupShape:
        '''Gets the group shape which contains this shape.'''
        raise NotImplementedError()

    def setLocked(self, value : bool) -> None:
        '''True means the object can not be modified when the sheet is protected.
        Note that this value is meaningful only if the worksheet or objects in the worksheet are protected.
        :param value: '''
        raise NotImplementedError()

    def setAutoShapeType(self, value : int) -> None:
        '''Sets the auto shape type.
        See :class:`AutoShapeType`
        :param value: '''
        raise NotImplementedError()

    def hasLine(self) -> bool:
        '''Gets the line border of the shape is visible.'''
        raise NotImplementedError()

    def setTextHorizontalOverflow(self, value : int) -> None:
        '''Sets the text horizontal overflow type of the shape which contains text.
        See :class:`TextOverflowType`
        :param value: '''
        raise NotImplementedError()

    def getZOrderPosition(self) -> int:
        '''Returns the position of a shape in the z-order.'''
        raise NotImplementedError()

    def getLowerRightColumn(self) -> int:
        '''Represents lower right corner column index.'''
        raise NotImplementedError()

    def getRight(self) -> int:
        '''Represents the width of the shape's horizontal  offset from its lower right corner column, in unit of pixels.'''
        raise NotImplementedError()

    def addHyperlink(self, address : str) -> Hyperlink:
        '''Adds a hyperlink to the shape.
        :param address: Address of the hyperlink.
        :returns: Return the new hyperlink object.'''
        raise NotImplementedError()

    def removeHyperlink(self) -> None:
        '''Removes the hyperlink of the shape.'''
        raise NotImplementedError()

    def setFlippedHorizontally(self, value : bool) -> None:
        '''Sets whether shape is horizontally flipped .
        :param value: '''
        raise NotImplementedError()

    def getWidthScale(self) -> int:
        '''Gets the width scale, in unit of percent of the original picture width.
        If the shape is not picture ,the WidthScale property only returns 100;'''
        raise NotImplementedError()

    def setLowerRightColumn(self, value : int) -> None:
        '''Represents lower right corner column index.
        :param value: '''
        raise NotImplementedError()

    def getLowerRightRow(self) -> int:
        '''Represents lower right corner row index.'''
        raise NotImplementedError()

    def getGlow(self) -> GlowEffect:
        '''Represents a :meth:`ShapePropertyCollection.getGlowEffect()` object that specifies glow effect for the chart element or shape.'''
        raise NotImplementedError()

    def getWidthInShape(self) -> int:
        '''Represents the width of the shape, in unit of 1/4000 of the parent shape.'''
        raise NotImplementedError()

    def getTop(self) -> int:
        '''Represents the vertical offset of shape from its top row, in unit of pixels.'''
        raise NotImplementedError()

    def getWorksheet(self) -> Worksheet:
        '''Gets the :meth:`Range.getWorksheet()` object which contains this shape.'''
        raise NotImplementedError()

    def getHeightInShape(self) -> int:
        '''Represents the vertical offset of shape from the top border of the parent shape, in unit of 1/4000 of height of the parent shape..'''
        raise NotImplementedError()

    def getHyperlink(self) -> Hyperlink:
        '''Gets the hyperlink of the shape.'''
        raise NotImplementedError()

    def setHtmlText(self, value : str) -> None:
        '''Sets the html string which contains data and some formats in this textbox.
        :param value: '''
        raise NotImplementedError()

    def isRichText(self) -> bool:
        '''Whether or not the text is rich text.'''
        raise NotImplementedError()

    def getReflection(self) -> ReflectionEffect:
        '''Represents a :class:`ReflectionEffect` object that specifies reflection effect for the chart element or shape.'''
        raise NotImplementedError()

    def setTextDirection(self, value : int) -> None:
        '''Sets the direction of the text flow for this object.
        See :class:`TextDirectionType`
        :param value: '''
        raise NotImplementedError()

    def setZOrderPosition(self, value : int) -> None:
        '''Returns the position of a shape in the z-order.
        :param value: '''
        raise NotImplementedError()

    def getLeftInShape(self) -> int:
        '''Represents the horizontal offset of shape from the left border of the parent shape,
        in unit of 1/4000 of width of the parent shape.'''
        raise NotImplementedError()

    def setTextOptions(self, value : TextOptions) -> None:
        '''Represents the text options of the shape.
        :param value: '''
        raise NotImplementedError()

    def getTextShapeType(self) -> int:
        '''Gets the preset text shape type.
        See :class:`AutoShapeType`'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the shape.
        :param value: '''
        raise NotImplementedError()

    def setLowerRightRow(self, value : int) -> None:
        '''Represents lower right corner row index.
        :param value: '''
        raise NotImplementedError()

    def setTopToCorner(self, value : int) -> None:
        '''Sets the vertical offset of shape from worksheet top border, in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def setFont(self, value : Font) -> None:
        '''Represents the font of shape.
        :param value: '''
        raise NotImplementedError()

    def getResultOfSmartArt(self) -> GroupShape:
        '''Converting smart art to grouped shapes.'''
        raise NotImplementedError()

    def setWidthInShape(self, value : int) -> None:
        '''Represents the width of the shape, in unit of 1/4000 of the parent shape.
        :param value: '''
        raise NotImplementedError()

    def setHeightScale(self, value : int) -> None:
        '''Sets the height scale,in unit of percent of the original picture height.
        If the shape is not picture ,the HeightScale property only returns 100;
        :param value: '''
        raise NotImplementedError()

    def setTitle(self, value : str) -> None:
        '''Specifies the title (caption) of the current shape object.
        :param value: '''
        raise NotImplementedError()

    def getSpid(self) -> str:
        '''Specifies an optional string identifier that an application can use to identify the particular shape.'''
        raise NotImplementedError()

    def getHtmlText(self) -> str:
        '''Gets the html string which contains data and some formats in this textbox.'''
        raise NotImplementedError()

    def calculateTextSize(self) -> list[int]:
        '''Recalculate the text area'''
        raise NotImplementedError()

    def setLeft(self, value : int) -> None:
        '''Represents the horizontal offset of shape from its left column, in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def setTop(self, value : int) -> None:
        '''Represents the vertical offset of shape from its top row, in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def setLeftToCorner(self, value : int) -> None:
        '''Sets the horizonal offset of shape from worksheet left border.
        :param value: '''
        raise NotImplementedError()

    def isHidden(self) -> bool:
        '''Indicates whether the object is visible.'''
        raise NotImplementedError()

    def getLeftToCorner(self) -> int:
        '''Gets the horizonal offset of shape from worksheet left border.'''
        raise NotImplementedError()

    def moveToRange(self, upperLeftRow : int, upperLeftColumn : int, lowerRightRow : int, lowerRightColumn : int) -> None:
        '''Moves the shape to a specified range.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param lowerRightRow: Lower right row index
        :param lowerRightColumn: Lower right column index'''
        raise NotImplementedError()

    def getY(self) -> int:
        '''Gets the vertical offset of shape from worksheet top border,in unit of pixels.'''
        raise NotImplementedError()

    def getX(self) -> int:
        '''Gets the horizontal offset of shape from worksheet left border,in unit of pixels.'''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Represents the width of shape, in unit of pixels.'''
        raise NotImplementedError()

    def isPrintable(self) -> bool:
        '''Indicates whether the object is printable.
        If False, this shape will not be printed when printing.'''
        raise NotImplementedError()

    def getWidthPt(self) -> int:
        '''Represents the width of the shape, in unit of point.'''
        raise NotImplementedError()

    def setHeightInShape(self, value : int) -> None:
        '''Represents the vertical offset of shape from the top border of the parent shape, in unit of 1/4000 of height of the parent shape..
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the auto shape type.
        See :class:`AutoShapeType`'''
        raise NotImplementedError()

    def setSoftEdges(self, value : int) -> None:
        '''Sets the radius of blur to apply to the edges, in unit of points.
        :param value: '''
        raise NotImplementedError()

    def getPaths(self) -> ShapePathCollection:
        '''Gets the paths of a custom geometric shape.'''
        raise NotImplementedError()

    def alignTopRightCorner(self, topRow : int, rightColumn : int) -> None:
        '''Moves the picture to the top-right corner.
        :param topRow: the row index.
        :param rightColumn: the column index.'''
        raise NotImplementedError()

    def getControlData(self) -> list[int]:
        '''Gets the data of control.'''
        raise NotImplementedError()

    def getHeightInch(self) -> int:
        '''Represents the height of the shape, in unit of inches.'''
        raise NotImplementedError()

    def isEquation(self) -> bool:
        '''Indicates whether the shape only contains an equation.'''
        raise NotImplementedError()

    def setTextShapeType(self, value : int) -> None:
        '''Sets the preset text shape type.
        See :class:`AutoShapeType`
        :param value: '''
        raise NotImplementedError()

    def isWordArt(self) -> bool:
        '''Indicates whether this shape is a word art.'''
        raise NotImplementedError()

    def getTopCM(self) -> int:
        '''Represents the vertical offset of shape from its top row, in unit of centimeters.'''
        raise NotImplementedError()

    def getTextBody(self) -> FontSettingCollection:
        '''Gets the setting of the shape's text.'''
        raise NotImplementedError()

    def setLeftInShape(self, value : int) -> None:
        '''Represents the horizontal offset of shape from the left border of the parent shape,
        in unit of 1/4000 of width of the parent shape.
        :param value: '''
        raise NotImplementedError()

    def setPlacement(self, value : int) -> None:
        '''Represents the way the drawing object is attached to the cells below it.
        The property controls the placement of an object on a worksheet.
        See :class:`PlacementType`
        :param value: '''
        raise NotImplementedError()

    def getUpperDeltaY(self) -> int:
        '''Gets the shape's vertical offset from its upper left corner row.'''
        raise NotImplementedError()

    def setTextVerticalOverflow(self, value : int) -> None:
        '''Sets the text vertical overflow type of the shape which contains text.
        See :class:`TextOverflowType`
        :param value: '''
        raise NotImplementedError()

    def getUpperDeltaX(self) -> int:
        '''Gets the shape's horizontal offset from its upper left corner column.'''
        raise NotImplementedError()

    def setTopInShape(self, value : int) -> None:
        '''Represents the vertical offset of shape from the top border of the parent shape,
        in unit of 1/4000 of height of the parent shape.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setInputRange(self, value : str) -> None:
        '''Sets the worksheet range used to fill the specified combo box.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setInputRange(self, formula : str, isR1C1 : bool, isLocal : bool) -> None:
        '''Sets the range used to fill the control.
        :param formula: The range used to fill the control.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.'''
        raise NotImplementedError()

    def isDecorative(self) -> bool:
        '''Indicates whether the object is decorative.'''
        raise NotImplementedError()

    def getFillFormat(self) -> MsoFillFormat:
        ''':deprecated: Use Shape.Fill property instead.'''
        raise NotImplementedError()

    def getActiveXControl(self) -> ActiveXControl:
        '''Gets the ActiveX control.'''
        raise NotImplementedError()

    @overload
    def setLinkedCell(self, value : str) -> None:
        '''Sets the worksheet range linked to the control's value.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setLinkedCell(self, formula : str, isR1C1 : bool, isLocal : bool) -> None:
        '''Sets the range linked to the control's value.
        :param formula: The range linked to the control's value.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.'''
        raise NotImplementedError()

    def getUpperLeftColumn(self) -> int:
        '''Represents upper left corner column index.'''
        raise NotImplementedError()

    def setLeftInch(self, value : int) -> None:
        '''Represents the horizontal offset of shape from its left column, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def isFilled(self) -> bool:
        '''Indicates whether the fill format is visible.'''
        raise NotImplementedError()

    def isSameSetting(self, obj : Object) -> bool:
        '''Returns whether the shape is same.
        :param obj: '''
        raise NotImplementedError()

    def getWidthCM(self) -> int:
        '''Represents the width of the shape, in unit of centimeters.'''
        raise NotImplementedError()

    def setHidden(self, value : bool) -> None:
        '''Indicates whether the object is visible.
        :param value: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the shape.'''
        raise NotImplementedError()

    def setMacroName(self, value : str) -> None:
        '''Sets the name of macro.
        :param value: '''
        raise NotImplementedError()

    def setWidthPt(self, value : int) -> None:
        '''Represents the width of the shape, in unit of point.
        :param value: '''
        raise NotImplementedError()

    def getFont(self) -> Font:
        '''Represents the font of shape.'''
        raise NotImplementedError()

    def getSoftEdges(self) -> int:
        '''Gets the radius of blur to apply to the edges, in unit of points.'''
        raise NotImplementedError()

    def getLockedProperty(self, type : int) -> bool:
        '''Gets the value of locked property.
        :param type: :class:`ShapeLockType`. The type of the shape locked property.
        :returns: Returns the value of locked property.'''
        raise NotImplementedError()

    def getLeftInch(self) -> int:
        '''Represents the horizontal offset of shape from its left column, in unit of inches.'''
        raise NotImplementedError()

    def setAnchorType(self, value : int) -> None:
        '''Sets the type of the shape anchor placeholder.
        See :class:`ShapeAnchorType`
        :param value: '''
        raise NotImplementedError()

    def isFlippedVertically(self) -> bool:
        '''Gets whether shape is vertically flipped .'''
        raise NotImplementedError()

    def getTextEffect(self) -> TextEffectFormat:
        '''Returns a TextEffectFormat object that contains text-effect formatting properties for the specified shape.
        Applies to Shape objects that represent WordArt.'''
        raise NotImplementedError()

    def getLeft(self) -> int:
        '''Represents the horizontal offset of shape from its left column, in unit of pixels.'''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''Sets the text of this shape.
        :param value: '''
        raise NotImplementedError()

    def getMsoDrawingType(self) -> int:
        '''Gets drawing type.
        See :class:`MsoDrawingType`'''
        raise NotImplementedError()

    def isAspectRatioLocked(self) -> bool:
        '''True means that aspect ratio of the shape is locked.'''
        raise NotImplementedError()

    def setCreateId(self, value : java.util.UUID) -> None:
        '''Sets create id for this shape.
        :param value: '''
        raise NotImplementedError()

    def setUpperDeltaY(self, value : int) -> None:
        '''Sets the shape's vertical offset from its upper left corner row.
        :param value: '''
        raise NotImplementedError()

    def setUpperDeltaX(self, value : int) -> None:
        '''Sets the shape's horizontal offset from its upper left corner column.
        :param value: '''
        raise NotImplementedError()

    def getTextVerticalAlignment(self) -> int:
        '''Gets the text vertical alignment type of the shape.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def setTextOrientationType(self, value : int) -> None:
        '''Sets the text orientation type of the shape.
        See :class:`TextOrientationType`
        :param value: '''
        raise NotImplementedError()

    def getSpt(self) -> int:
        '''Specifies an optional number that an application can use to associate the particular shape with a defined shape type.'''
        raise NotImplementedError()

    def isLockAspectRatio(self) -> bool:
        ''':deprecated: Use Shape.IsAspectRatioLocked property instead.'''
        raise NotImplementedError()

    def toFrontOrBack(self, orders : int) -> None:
        '''Brings the shape to the front or sends the shape to back.
        :param orders: '''
        raise NotImplementedError()

    def removeActiveXControl(self) -> None:
        '''Remove activeX control.'''
        raise NotImplementedError()

    def characters(self, startIndex : int, length : int) -> FontSetting:
        '''Returns a Characters object that represents a range of characters within the text.
        :param startIndex: The index of the start of the character.
        :param length: The number of characters.
        :returns: Characters object.'''
        raise NotImplementedError()

    def setLockedProperty(self, type : int, value : bool) -> None:
        '''Set the locked property.
        :param type: :class:`ShapeLockType`. The locked type.
        :param value: The value of the property.'''
        raise NotImplementedError()

    def setTextWrapped(self, value : bool) -> None:
        '''Sets the text wrapped type of the shape which contains text.
        :param value: '''
        raise NotImplementedError()

    def getId(self) -> int:
        '''Gets the identifier of this shape.'''
        raise NotImplementedError()

    def getCreateId(self) -> java.util.UUID:
        '''Gets create id for this shape.'''
        raise NotImplementedError()

    def setFilled(self, value : bool) -> None:
        '''Indicates whether the fill format is visible.
        :param value: '''
        raise NotImplementedError()

    def getPlacement(self) -> int:
        '''Represents the way the drawing object is attached to the cells below it.
        The property controls the placement of an object on a worksheet.
        See :class:`PlacementType`'''
        raise NotImplementedError()

    def getThreeDFormat(self) -> ThreeDFormat:
        '''Gets 3d format of the shape.'''
        raise NotImplementedError()

    def setWidthCM(self, value : int) -> None:
        '''Represents the width of the shape, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def getTitle(self) -> str:
        '''Specifies the title (caption) of the current shape object.'''
        raise NotImplementedError()

    def setLockAspectRatio(self, value : bool) -> None:
        ''':deprecated: Use Shape.IsAspectRatioLocked property instead.'''
        raise NotImplementedError()

    def getTextVerticalOverflow(self) -> int:
        '''Gets the text vertical overflow type of the shape which contains text.
        See :class:`TextOverflowType`'''
        raise NotImplementedError()

    def setUpperLeftColumn(self, value : int) -> None:
        '''Represents upper left corner column index.
        :param value: '''
        raise NotImplementedError()

    def getActualLowerRightRow(self) -> int:
        '''Get the actual bottom row.'''
        raise NotImplementedError()

    def getTopInShape(self) -> int:
        '''Represents the vertical offset of shape from the top border of the parent shape,
        in unit of 1/4000 of height of the parent shape.'''
        raise NotImplementedError()

    def setRelativeToOriginalPictureSize(self, value : bool) -> None:
        '''Indicates whether shape is relative to original picture size.
        :param value: '''
        raise NotImplementedError()

    def setRight(self, value : int) -> None:
        '''Represents the width of the shape's horizontal  offset from its lower right corner column, in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def getAlternativeText(self) -> str:
        '''Returns or sets the descriptive (alternative) text string of the :class:`Shape` object.'''
        raise NotImplementedError()

    @overload
    def getInputRange(self) -> str:
        '''Gets the worksheet range used to fill the specified combo box.'''
        raise NotImplementedError()

    @overload
    def getInputRange(self, isR1C1 : bool, isLocal : bool) -> str:
        '''Gets the range used to fill the control.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :returns: The range used to fill the control.'''
        raise NotImplementedError()

    def updateSelectedValue(self) -> None:
        '''Update the selected value by the value of the linked cell.'''
        raise NotImplementedError()

    def isGroup(self) -> bool:
        '''Indicates whether this shape is a group shape.'''
        raise NotImplementedError()

    def getShadowEffect(self) -> ShadowEffect:
        '''Represents a :class:`ShadowEffect` object that specifies shadow effect for the chart element or shape.'''
        raise NotImplementedError()

    def getUpperLeftRow(self) -> int:
        '''Represents the top row index.'''
        raise NotImplementedError()

    def getTopInch(self) -> int:
        '''Represents the vertical offset of shape from its top row, in unit of inches.'''
        raise NotImplementedError()

    @overload
    def getLinkedCell(self) -> str:
        '''Gets the worksheet range linked to the control's value.'''
        raise NotImplementedError()

    @overload
    def getLinkedCell(self, isR1C1 : bool, isLocal : bool) -> str:
        '''Gets the range linked to the control's value.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :returns: The range linked to the control's value.'''
        raise NotImplementedError()

    def getFill(self) -> FillFormat:
        '''Returns a :meth:`Area.getFillFormat()` object that contains fill formatting properties for the specified shape.'''
        raise NotImplementedError()

    def setBottom(self, value : int) -> None:
        '''Represents the width of the shape's vertical offset from its lower bottom corner row, in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def setLeftCM(self, value : int) -> None:
        '''Represents the horizontal offset of shape from its left column, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def getMacroName(self) -> str:
        '''Gets the name of macro.'''
        raise NotImplementedError()

    def setPrintable(self, value : bool) -> None:
        '''Indicates whether the object is printable.
        If False, this shape will not be printed when printing.
        :param value: '''
        raise NotImplementedError()

    def isSmartArt(self) -> bool:
        '''Indicates whether the shape is a smart art.'''
        raise NotImplementedError()

    def setWidthInch(self, value : int) -> None:
        '''Represents the width of the shape, in unit of inch.
        :param value: '''
        raise NotImplementedError()

    def getLineFormat(self) -> MsoLineFormat:
        ''':deprecated: Use Shape.Line property instead.'''
        raise NotImplementedError()

    def setUpperLeftRow(self, value : int) -> None:
        '''Represents the top row index.
        :param value: '''
        raise NotImplementedError()

    def getCharacters(self) -> list:
        ''':deprecated: Use Shape.GetRichFormattings() instead.'''
        raise NotImplementedError()

    def getText(self) -> str:
        '''Gets the text of this shape.'''
        raise NotImplementedError()

    def setHeightPt(self, value : int) -> None:
        '''Represents the height of the shape, in unit of points.
        :param value: '''
        raise NotImplementedError()

    def setWidthScale(self, value : int) -> None:
        '''Sets the width scale, in unit of percent of the original picture width.
        If the shape is not picture ,the WidthScale property only returns 100;
        :param value: '''
        raise NotImplementedError()

    def getTextBoxOptions(self) -> TextBoxOptions:
        '''Gets the text information in the shape'''
        raise NotImplementedError()

    def getAnchorType(self) -> int:
        '''Gets the type of the shape anchor placeholder.
        See :class:`ShapeAnchorType`'''
        raise NotImplementedError()

    def getActualBox(self) -> list[float]:
        '''Get the actual position and size of the shape (after applying rotation, flip, etc.)'''
        raise NotImplementedError()

    def getBottom(self) -> int:
        '''Represents the width of the shape's vertical offset from its lower bottom corner row, in unit of pixels.'''
        raise NotImplementedError()

    def getRotationAngle(self) -> int:
        '''Gets the rotation of the shape.'''
        raise NotImplementedError()

    def getLowerDeltaY(self) -> int:
        '''Gets the shape's vertical offset from its lower right corner row.'''
        raise NotImplementedError()

    def getLowerDeltaX(self) -> int:
        '''Gets the shape's horizontal  offset from its lower right corner column.'''
        raise NotImplementedError()

    def getLeftCM(self) -> int:
        '''Represents the horizontal offset of shape from its left column, in unit of centimeters.'''
        raise NotImplementedError()

    def getRelativeToOriginalPictureSize(self) -> bool:
        '''Indicates whether shape is relative to original picture size.'''
        raise NotImplementedError()

    def setTextVerticalAlignment(self, value : int) -> None:
        '''Sets the text vertical alignment type of the shape.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def isLocked(self) -> bool:
        '''True means the object can not be modified when the sheet is protected.
        Note that this value is meaningful only if the worksheet or objects in the worksheet are protected.'''
        raise NotImplementedError()

    def setWidth(self, value : int) -> None:
        '''Represents the width of shape, in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def getFormatPicture(self) -> MsoFormatPicture:
        '''Gets the options of the picture format.'''
        raise NotImplementedError()

    def setY(self, value : int) -> None:
        '''Sets the vertical offset of shape from worksheet top border,in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def getLine(self) -> LineFormat:
        '''Gets line style'''
        raise NotImplementedError()

    def setX(self, value : int) -> None:
        '''Sets the horizontal offset of shape from worksheet left border,in unit of pixels.
        :param value: '''
        raise NotImplementedError()

    def setHeight(self, value : int) -> None:
        '''Represents the height of shape, in unit of pixel.
        :param value: '''
        raise NotImplementedError()

    def getHeightPt(self) -> int:
        '''Represents the height of the shape, in unit of points.'''
        raise NotImplementedError()

    def setDecorative(self, value : bool) -> None:
        '''Indicates whether the object is decorative.
        :param value: '''
        raise NotImplementedError()

    def getConnectionPoints(self) -> list[list[float]]:
        '''Get the connection points'''
        raise NotImplementedError()

    def getAutoShapeType(self) -> int:
        '''Gets the auto shape type.
        See :class:`AutoShapeType`'''
        raise NotImplementedError()

    def setTopInch(self, value : int) -> None:
        '''Represents the vertical offset of shape from its top row, in unit of inches.
        :param value: '''
        raise NotImplementedError()

    def isInGroup(self) -> bool:
        '''Indicates whether the shape is grouped.'''
        raise NotImplementedError()

    def setTextHorizontalAlignment(self, value : int) -> None:
        '''Sets the text horizontal alignment type of the shape.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def setFlippedVertically(self, value : bool) -> None:
        '''Sets whether shape is vertically flipped .
        :param value: '''
        raise NotImplementedError()

    def setTopCM(self, value : int) -> None:
        '''Represents the vertical offset of shape from its top row, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def isFlippedHorizontally(self) -> bool:
        '''Gets whether shape is horizontally flipped .'''
        raise NotImplementedError()

    def setHeightCM(self, value : int) -> None:
        '''Represents the height of the shape, in unit of centimeters.
        :param value: '''
        raise NotImplementedError()

    def setAspectRatioLocked(self, value : bool) -> None:
        '''True means that aspect ratio of the shape is locked.
        :param value: '''
        raise NotImplementedError()

    def getTextHorizontalOverflow(self) -> int:
        '''Gets the text horizontal overflow type of the shape which contains text.
        See :class:`TextOverflowType`'''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Represents the height of shape, in unit of pixel.'''
        raise NotImplementedError()

    def setRotationAngle(self, value : int) -> None:
        '''Sets the rotation of the shape.
        :param value: '''
        raise NotImplementedError()

    def getTextHorizontalAlignment(self) -> int:
        '''Gets the text horizontal alignment type of the shape.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def setAlternativeText(self, value : str) -> None:
        '''Returns or sets the descriptive (alternative) text string of the :class:`Shape` object.
        :param value: '''
        raise NotImplementedError()

    def isTextWrapped(self) -> bool:
        '''Gets the text wrapped type of the shape which contains text.'''
        raise NotImplementedError()


class ShapeAnchorType:
    '''Represents the anchor type.'''

    TWO_CELL_ANCHOR : ShapeAnchorType
    '''Represents a two cell anchor placeholder'''

    ONE_CELL_ANCHOR : ShapeAnchorType
    '''Represents a one cell anchor placeholder'''


class ShapeCollection:
    '''Represents all the shape in a worksheet/chart.'''

    def addRectangle(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> RectangleShape:
        '''Adds a RectangleShape to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of RectangleShape from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of RectangleShape from its left column, in unit of pixel.
        :param height: Represents the height of RectangleShape, in unit of pixel.
        :param width: Represents the width of RectangleShape, in unit of pixel.
        :returns: A RectangleShape object.'''
        raise NotImplementedError()

    def addLabel(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> Label:
        '''Adds a Label to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of Label from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of Label from its left column, in unit of pixel.
        :param height: Represents the height of Label, in unit of pixel.
        :param width: Represents the width of Label, in unit of pixel.
        :returns: A Label object.'''
        raise NotImplementedError()

    def addTextEffect(self, effect : int, text : str, fontName : str, size : int, fontBold : bool, fontItalic : bool, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> Shape:
        '''Inserts a WordArt object.
        :param effect: :class:`MsoPresetTextEffect`. The mso preset text effect type.
        :param text: The WordArt text.
        :param fontName: The font name.
        :param size: The font size
        :param fontBold: Indicates whether font is bold.
        :param fontItalic: Indicates whether font is italic.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of shape from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of shape from its left column, in unit of pixel.
        :param height: Represents the height of shape, in unit of pixel.
        :param width: Represents the width of shape, in unit of pixel.
        :returns: Returns a Shape object that represents the new WordArt object.'''
        raise NotImplementedError()

    def addCheckBox(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> CheckBox:
        '''Adds a checkbox to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of checkbox from its top row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of textbox from its left column, in unit of pixel.
        :param height: Height of textbox, in unit of pixel.
        :param width: Width of textbox, in unit of pixel.
        :returns: The new CheckBox object index.'''
        raise NotImplementedError()

    def addSpinner(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> Spinner:
        '''Adds a Spinner to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of Spinner from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of Spinner from its left column, in unit of pixel.
        :param height: Represents the height of Spinner, in unit of pixel.
        :param width: Represents the width of Spinner, in unit of pixel.
        :returns: A Spinner object.'''
        raise NotImplementedError()

    def addPictureInChart(self, top : int, left : int, stream : InputStream, widthScale : int, heightScale : int) -> Picture:
        '''Adds a picture to the chart.
        :param top: Represents the vertical offset of shape from the upper left corner in units of 1/4000 of the chart area.
        :param left: Represents the horizontal offset of shape from the upper left corner in units of 1/4000 of the chart area.
        :param stream: Stream object which contains the image data.
        :param widthScale: Scale of image width, a percentage.
        :param heightScale: Scale of image height, a percentage.
        :returns: Returns a Picture object.'''
        raise NotImplementedError()

    def deleteShape(self, shape : Shape) -> None:
        '''Delete a shape. If the shape is in the group or is a comment shape, it will not be deleted.
        :param shape: '''
        raise NotImplementedError()

    def addTextBoxInChart(self, top : int, left : int, height : int, width : int) -> TextBox:
        '''Adds a textbox to the chart.
        :param top: Represents the vertical offset of textbox from the upper left corner in units of 1/4000 of the chart area.
        :param left: Represents the vertical offset of textbox from the upper left corner in units of 1/4000 of the chart area.
        :param height: Represents the height of textbox, in units of 1/4000 of the chart area.
        :param width: Represents the width of textbox, in units of 1/4000 of the chart area.
        :returns: A TextBox object.'''
        raise NotImplementedError()

    def addComboBox(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> ComboBox:
        '''Adds a ComboBox to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of ComboBox from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of ComboBox from its left column, in unit of pixel.
        :param height: Represents the height of ComboBox, in unit of pixel.
        :param width: Represents the width of ComboBox, in unit of pixel.
        :returns: A ComboBox object.'''
        raise NotImplementedError()

    def addIcons(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int, imageByteData : list[int], compatibleImageData : list[int]) -> Picture:
        '''Adds svg image.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of shape from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: The horizontal offset of shape from its left column, in unit of pixel.
        :param height: The height of shape, in unit of pixel.
        :param width: The width of shape, in unit of pixel.
        :param imageByteData: The image byte data.
        :param compatibleImageData: Converted image data from svg in order to be compatible with Excel 2016 or lower versions.'''
        raise NotImplementedError()

    def addLabelInChart(self, top : int, left : int, height : int, width : int) -> Label:
        '''Adds a label to the chart.
        :param top: Represents the vertical offset of label from the upper left corner in units of 1/4000 of the chart area.
        :param left: Represents the vertical offset of label from the upper left corner in units of 1/4000 of the chart area.
        :param height: Represents the height of label, in units of 1/4000 of the chart area.
        :param width: Represents the width of label, in units of 1/4000 of the chart area.
        :returns: A new Label object.'''
        raise NotImplementedError()

    @overload
    def addShapeInChartByScale(self, type : int, placement : int, left : int, top : int, right : int, bottom : int) -> Shape:
        '''Add a shape to chart. All unit is percent scale of chart area.
        :param type: :class:`MsoDrawingType`. The drawing type.
        :param placement: :class:`PlacementType`. the placement type.
        :param left: Unit is percent scale of chart area width.
        :param top: Unit is percent scale of chart area height.
        :param right: Unit is percent scale of chart area width.
        :param bottom: Unit is percent scale of chart area height.'''
        raise NotImplementedError()

    @overload
    def addShapeInChartByScale(self, type : int, placement : int, left : int, top : int, right : int, bottom : int, imageData : list[int]) -> Shape:
        '''Add a shape to chart .All unit is 1/4000 of chart area.
        :param type: :class:`MsoDrawingType`. The drawing type.
        :param placement: :class:`PlacementType`. the placement type.
        :param left: Unit is percent scale of chart area width.
        :param top: Unit is percent scale of chart area height.
        :param right: Unit is percent scale of chart area width.
        :param bottom: Unit is percent scale of chart area height.
        :param imageData: If the shape is not a picture or ole object,imageData should be null.'''
        raise NotImplementedError()

    def addButton(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> Button:
        '''Adds a Button to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of Button from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of Button from its left column, in unit of pixel.
        :param height: Represents the height of Button, in unit of pixel.
        :param width: Represents the width of Button, in unit of pixel.
        :returns: A Button object.'''
        raise NotImplementedError()

    def addAutoShape(self, type : int, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> Shape:
        '''Adds a AutoShape to the worksheet.
        :param type: :class:`AutoShapeType`. Auto shape type.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of Shape from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of Shape from its left column, in unit of pixel.
        :param height: Represents the height of Shape, in unit of pixel.
        :param width: Represents the width of Shape, in unit of pixel.
        :returns: A Shape object.'''
        raise NotImplementedError()

    def addOleObject(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int, imageData : list[int]) -> OleObject:
        '''Adds an OleObject.
        :param upperLeftRow: 
        :param top: 
        :param upperLeftColumn: 
        :param left: 
        :param height: 
        :param width: 
        :param imageData: '''
        raise NotImplementedError()

    def addCopy(self, sourceShape : Shape, topRow : int, top : int, leftColumn : int, left : int) -> Shape:
        '''Adds and copy a shape to the worksheet.
        :param sourceShape: Source shape.
        :param topRow: The top row index.
        :param top: Represents the vertical offset from its top row, in unit of pixel.
        :param leftColumn: The left column index.
        :param left: Represents the horizontal offset from its left column, in unit of pixel.
        :returns: The new :class:`Shape` object.'''
        raise NotImplementedError()

    def addEquation(self, topRow : int, top : int, leftColumn : int, left : int, height : int, width : int) -> TextBox:
        '''Add an equation object to the worksheet.
        :param topRow: The top row index.
        :param top: The vertical offset its top row, in unit of pixel.
        :param leftColumn: The left column index.
        :param left: The horizontal offset from its left column, in unit of pixel.
        :param height: The height of equation, in unit of pixel.
        :param width: The width of equation, in unit of pixel.'''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Remove the shape.
        :param index: The index of the shape.'''
        raise NotImplementedError()

    def addLinkedPicture(self, upperLeftRow : int, upperLeftColumn : int, height : int, width : int, sourceFullName : str) -> Picture:
        '''Add a linked picture.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param height: The height of the shape. In unit of pixels
        :param width: The width of the shape. In unit of pixels
        :param sourceFullName: 
        :returns: :class:`Picture` Picture object.'''
        raise NotImplementedError()

    def copyInRange(self, sourceShapes : ShapeCollection, ca : CellArea, destRow : int, destColumn : int, isContained : bool) -> None:
        '''Copy shapes in the range to destination range.
        :param sourceShapes: Source shapes.
        :param ca: The source range.
        :param destRow: The dest row index of the dest range.
        :param destColumn: The dest column of the dest range.
        :param isContained: Whether only copy the shapes which are contained in the range.'''
        raise NotImplementedError()

    def group(self, groupItems : list[Shape]) -> GroupShape:
        '''Group the shapes.
        :param groupItems: the group items.
        :returns: Return the group shape.'''
        raise NotImplementedError()

    def ungroup(self, group : GroupShape) -> None:
        '''Ungroups the shape items.
        :param group: The group shape.'''
        raise NotImplementedError()

    def addOval(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> Oval:
        '''Adds a Oval to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of Oval from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of Oval from its left column, in unit of pixel.
        :param height: Represents the height of Oval, in unit of pixel.
        :param width: Represents the width of Oval, in unit of pixel.
        :returns: A Oval object.'''
        raise NotImplementedError()

    def remove(self, shape : Shape) -> None:
        '''Remove the shape.
        :param shape: '''
        raise NotImplementedError()

    def addSvg(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int, svgData : list[int], compatibleImageData : list[int]) -> Picture:
        '''Adds svg image.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of shape from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: The horizontal offset of shape from its left column, in unit of pixel.
        :param height: The height of shape, in unit of pixel.
        :param width: The width of shape, in unit of pixel.
        :param svgData: The svg image data.
        :param compatibleImageData: Converted image data from svg in order to be compatible with Excel 2016 or lower versions.'''
        raise NotImplementedError()

    def addLine(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> LineShape:
        '''Adds a LineShape to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of LineShape from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of LineShape from its left column, in unit of pixel.
        :param height: Represents the height of LineShape, in unit of pixel.
        :param width: Represents the width of LineShape, in unit of pixel.
        :returns: A LineShape object.'''
        raise NotImplementedError()

    def addTextBox(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> TextBox:
        '''Adds a text box to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of textbox from its top row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of textbox from its left column, in unit of pixel.
        :param height: Represents the height of textbox, in unit of pixel.
        :param width: Represents the width of textbox, in unit of pixel.
        :returns: A :class:`TextBox` object.'''
        raise NotImplementedError()

    def addShape(self, type : int, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> Shape:
        '''Adds a Shape to the worksheet.
        :param type: :class:`MsoDrawingType`. Mso drawing type.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of Shape from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of Shape from its left column, in unit of pixel.
        :param height: Represents the height of Shape, in unit of pixel.
        :param width: Represents the width of Shape, in unit of pixel.
        :returns: A Shape object.'''
        raise NotImplementedError()

    def updateSelectedValue(self) -> None:
        '''Update the selected value by the value of the linked cell or range of the shape.'''
        raise NotImplementedError()

    def addRadioButton(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> RadioButton:
        '''Adds a RadioButton to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of RadioButton from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of RadioButton from its left column, in unit of pixel.
        :param height: Represents the height of RadioButton, in unit of pixel.
        :param width: Represents the width of RadioButton, in unit of pixel.
        :returns: A RadioButton object.'''
        raise NotImplementedError()

    def addAutoShapeInChart(self, type : int, top : int, left : int, height : int, width : int) -> Shape:
        '''Adds a AutoShape to the chart.
        :param type: :class:`AutoShapeType`. Auto shape type.
        :param top: Represents the vertical offset of textbox from the upper left corner in units of 1/4000 of the chart area.
        :param left: Represents the vertical offset of textbox from the upper left corner in units of 1/4000 of the chart area.
        :param height: Represents the height of textbox, in units of 1/4000 of the chart area.
        :param width: Represents the width of textbox, in units of 1/4000 of the chart area.
        :returns: Returns a shape object.'''
        raise NotImplementedError()

    def addFreeform(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int, paths : list[ShapePath]) -> Shape:
        '''Adds a freeform shape to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of Polygon from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of Polygon from its left column, in unit of pixel.
        :param height: Represents the height of Polygon, in unit of pixel.
        :param width: Represents the width of Polygon, in unit of pixel.
        :param paths: Represents a user-defined path
        :returns: A freeform shape.'''
        raise NotImplementedError()

    def copyCommentsInRange(self, shapes : ShapeCollection, ca : CellArea, destRow : int, destColumn : int) -> None:
        '''Copy all comments in the range.
        :param shapes: The source shapes.
        :param ca: The source range.
        :param destRow: The dest range start row.
        :param destColumn: The dest range start column.'''
        raise NotImplementedError()

    @overload
    def addPicture(self, upperLeftRow : int, upperLeftColumn : int, lowerRightRow : int, lowerRightColumn : int, stream : InputStream) -> Picture:
        '''Adds a picture to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param lowerRightRow: Lower right row index
        :param lowerRightColumn: Lower right column index
        :param stream: Stream object which contains the image data.
        :returns: :class:`Picture` Picture object.'''
        raise NotImplementedError()

    @overload
    def addPicture(self, upperLeftRow : int, upperLeftColumn : int, stream : InputStream, widthScale : int, heightScale : int) -> Picture:
        '''Adds a picture to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param stream: Stream object which contains the image data.
        :param widthScale: Scale of image width, a percentage.
        :param heightScale: Scale of image height, a percentage.
        :returns: :class:`Picture` Picture object.'''
        raise NotImplementedError()

    def addScrollBar(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> ScrollBar:
        '''Adds a ScrollBar to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of ScrollBar from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of ScrollBar from its left column, in unit of pixel.
        :param height: Represents the height of ScrollBar, in unit of pixel.
        :param width: Represents the width of ScrollBar, in unit of pixel.
        :returns: A ScrollBar object.'''
        raise NotImplementedError()

    def addGroupBox(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> GroupBox:
        '''Adds a GroupBox to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of GroupBox from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of GroupBox from its left column, in unit of pixel.
        :param height: Represents the height of GroupBox, in unit of pixel.
        :param width: Represents the width of GroupBox, in unit of pixel.
        :returns: A GroupBox object.'''
        raise NotImplementedError()

    def clear(self) -> None:
        '''Clear all shapes in the worksheet.'''
        raise NotImplementedError()

    def addActiveXControl(self, type : int, topRow : int, top : int, leftColumn : int, left : int, width : int, height : int) -> Shape:
        '''Creates an Activex Control.
        :param type: :class:`ControlType`. The type of the control.
        :param topRow: Upper left row index.
        :param top: Represents the vertical offset of Shape from its left row, in unit of pixel.
        :param leftColumn: Upper left column index.
        :param left: Represents the horizontal offset of Shape from its left column, in unit of pixel.
        :param width: Represents the width of Shape, in unit of pixel.
        :param height: Represents the height of Shape, in unit of pixel.'''
        raise NotImplementedError()

    def addTextEffectInChart(self, effect : int, text : str, fontName : str, size : int, fontBold : bool, fontItalic : bool, top : int, left : int, height : int, width : int) -> Shape:
        '''Inserts a WordArt object to the chart
        :param effect: :class:`MsoPresetTextEffect`. The mso preset text effect type.
        :param text: The WordArt text.
        :param fontName: The font name.
        :param size: The font size
        :param fontBold: Indicates whether font is bold.
        :param fontItalic: Indicates whether font is italic.
        :param top: Represents the vertical offset of shape from the upper left corner in units of 1/4000 of the chart area.
        :param left: Represents the vertical offset of shape from the upper left corner in units of 1/4000 of the chart area.
        :param height: Represents the height of shape, in units of 1/4000 of the chart area.
        :param width: Represents the width of shape, in units of 1/4000 of the chart area.
        :returns: Returns a Shape object that represents the new WordArt object.'''
        raise NotImplementedError()

    def addSignatureLine(self, upperLeftRow : int, upperLeftColumn : int, signatureLine : SignatureLine) -> Picture:
        '''Adds a Signature Line to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param signatureLine: Represents a signature line object.'''
        raise NotImplementedError()

    def addOleObjectWithLinkedImage(self, upperLeftRow : int, upperLeftColumn : int, height : int, width : int, sourceFullName : str) -> OleObject:
        '''Add a linked picture.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param height: The height of the shape. In unit of pixels
        :param width: The width of the shape. In unit of pixels
        :param sourceFullName: 
        :returns: :class:`Picture` Picture object.'''
        raise NotImplementedError()

    def deleteInRange(self, ca : CellArea) -> None:
        '''Delete shapes in the range.Comment shapes will not be deleted.
        :param ca: The range.If the shapes are contained in the range, they will be removed.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> Shape:
        '''Gets the :class:`Shape` object at the specific index in the list.
        :param index: The index.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> Shape:
        '''Gets the :class:`Shape` object by the name of the shape.
        :param name: The name of the shape.'''
        raise NotImplementedError()

    @overload
    def addShapeInChart(self, type : int, placement : int, left : int, top : int, right : int, bottom : int, imageData : list[int]) -> Shape:
        '''Add a shape to chart .All unit is 1/4000 of chart area.
        :param type: :class:`MsoDrawingType`. The drawing type.
        :param placement: :class:`PlacementType`. the placement type.
        :param left: In unit of 1/4000 chart area width.
        :param top: In unit of 1/4000 chart area height.
        :param right: In unit of 1/4000 chart area width.
        :param bottom: In unit of 1/4000 chart area height.
        :param imageData: If the shape is not a picture or ole object,imageData should be null.'''
        raise NotImplementedError()

    @overload
    def addShapeInChart(self, type : int, placement : int, left : int, top : int, right : int, bottom : int) -> Shape:
        '''Add a shape to chart .All unit is 1/4000 of chart area.
        :param type: :class:`MsoDrawingType`. The drawing type.
        :param placement: :class:`PlacementType`. the placement type.
        :param left: In unit of 1/4000 chart area width.
        :param top: In unit of 1/4000 chart area height.
        :param right: In unit of 1/4000 chart area width.
        :param bottom: In unit of 1/4000 chart area height.'''
        raise NotImplementedError()

    def addFreeFloatingShape(self, type : int, top : int, left : int, height : int, width : int, imageData : list[int], isOriginalSize : bool) -> Shape:
        '''Adds a free floating shape to the worksheet.Only applies for line/image shape.
        :param type: :class:`MsoDrawingType`. The shape type.
        :param top: Represents the vertical offset of shape from the worksheet's top row, in unit of pixel.
        :param left: Represents the horizontal offset of shape from the worksheet's left column, in unit of pixel.
        :param height: Represents the height of LineShape, in unit of pixel.
        :param width: Represents the width of LineShape, in unit of pixel.
        :param imageData: The image data,only applies for the picture.
        :param isOriginalSize: Whether the shape use original size if the shape is image.'''
        raise NotImplementedError()

    def addListBox(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> ListBox:
        '''Adds a ListBox to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of ListBox from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of ListBox from its left column, in unit of pixel.
        :param height: Represents the height of ListBox, in unit of pixel.
        :param width: Represents the width of ListBox, in unit of pixel.
        :returns: A ListBox object.'''
        raise NotImplementedError()

    def addWordArt(self, style : int, text : str, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> Shape:
        '''Adds preset WordArt since Excel 2007.s
        :param style: :class:`PresetWordArtStyle`. The preset WordArt Style.
        :param text: The text.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of shape from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of shape from its left column, in unit of pixel.
        :param height: Represents the height of shape, in unit of pixel.
        :param width: Represents the width of shape, in unit of pixel.'''
        raise NotImplementedError()

    def addArc(self, upperLeftRow : int, top : int, upperLeftColumn : int, left : int, height : int, width : int) -> ArcShape:
        '''Adds a ArcShape to the worksheet.
        :param upperLeftRow: Upper left row index.
        :param top: Represents the vertical offset of ArcShape from its left row, in unit of pixel.
        :param upperLeftColumn: Upper left column index.
        :param left: Represents the horizontal offset of ArcShape from its left column, in unit of pixel.
        :param height: Represents the height of ArcShape, in unit of pixel.
        :param width: Represents the width of ArcShape, in unit of pixel.
        :returns: A ArcShape object.'''
        raise NotImplementedError()



class ShapeGuide:
    '''Encapsulates a shape guide specifies the presence of a shape guide that will be used to
    govern the geometry of the specified shape'''

    def getValue(self) -> int:
        '''Gets value of this guide'''
        raise NotImplementedError()

    def setValue(self, value : int) -> None:
        '''Sets value of this guide
        :param value: '''
        raise NotImplementedError()


class ShapeGuideCollection:
    '''Encapsulates a collection of shape guide'''

    def get(self, index : int) -> ShapeGuide:
        '''Gets a shape guide by index
        :param index: '''
        raise NotImplementedError()

    def add(self, name : str, val : int) -> int:
        '''Adds a shape guide.(Important: This feature is currently only available for Excel07 and above)
        :param name: the name of adjust. It's as "adj(Used when there is only one adjustment value)", "adj1", "adj2", "adj3" and so on.
        :param val: the value of adjust'''
        raise NotImplementedError()


class ShapeLockType:
    '''Represents type of the property to be locked.'''

    GROUP : ShapeLockType
    '''Group'''

    ADJUST_HANDLES : ShapeLockType
    '''AdjustHandles'''

    TEXT : ShapeLockType
    '''Text'''

    POINTS : ShapeLockType
    '''Points'''

    CROP : ShapeLockType
    '''Crop'''

    SELECTION : ShapeLockType
    '''Selection'''

    MOVE : ShapeLockType
    '''Move'''

    ASPECT_RATIO : ShapeLockType
    '''AspectRatio'''

    ROTATION : ShapeLockType
    '''Rotation'''

    UNGROUP : ShapeLockType
    '''Ungroup'''

    RESIZE : ShapeLockType
    '''Resize'''

    SHAPE_TYPE : ShapeLockType
    '''ShapeType'''

    ARROWHEAD : ShapeLockType
    '''Arrowhead'''


class ShapePath:
    '''Represents a creation path consisting of a series of moves, lines and curves that when combined will form a geometric shape.'''

    def lineTo(self, x : float, y : float) -> None:
        '''Appends a line segment to the current figure. The starting point is the end point of the current figure.
        :param x: The x-coordinate of the endpoint of the line segment.
        :param y: The y-coordinate of the endpoint of the line segment.'''
        raise NotImplementedError()

    def moveTo(self, x : float, y : float) -> None:
        '''Starts a new figure from the specified point without closing the current figure. All subsequent points added to the path are added to this new figure.
        :param x: The x-coordinate of the starting point of the figure.
        :param y: The y-coordinate of the starting point of the figure.'''
        raise NotImplementedError()

    def close(self) -> None:
        '''Closes the current figure and starts a new figure. If the current figure contains a sequence of connected lines and curves, the method closes the loop by connecting a line from the endpoint to the starting point.'''
        raise NotImplementedError()

    def cubicBezierTo(self, ctrX1 : float, ctrY1 : float, ctrX2 : float, ctrY2 : float, endX : float, endY : float) -> None:
        '''Appends a cubic Bzier curve to the current figure. The starting point is the end point of the current figure.
        :param ctrX1: The x-coordinate of the first control point for the curve.
        :param ctrY1: The y-coordinate of the first control point for the curve.
        :param ctrX2: The x-coordinate of the second control point for the curve.
        :param ctrY2: The y-coordinate of the second control point for the curve.
        :param endX: The x-coordinate of the endpoint of the curve.
        :param endY: The y-coordinate of the endpoint of the curve.'''
        raise NotImplementedError()

    def getPathSegementList(self) -> ShapeSegmentPathCollection:
        '''Gets :class:`ShapeSegmentPathCollection` list'''
        raise NotImplementedError()

    def arcTo(self, wR : float, hR : float, stAng : float, swAng : float) -> None:
        '''Appends an elliptical arc to the current figure. The starting point is the end point of the current figure.
        :param wR: The half-width of the rectangular area of he ellipse that draws the arc.
        :param hR: The half-height of the rectangular area of he ellipse that draws the arc.
        :param stAng: The starting angle of the arc, measured in degrees clockwise from the x-axis.
        :param swAng: The angle between startAngle and the end of the arc.'''
        raise NotImplementedError()


class ShapePathCollection:
    '''Represents path collection information in NotPrimitive autoshape'''

    def getCount(self) -> int:
        '''Gets the count of paths'''
        raise NotImplementedError()

    def get(self, index : int) -> ShapePath:
        '''Gets a creation path.
        :param index: The index.
        :returns: Returns :class:`ShapePath` object.'''
        raise NotImplementedError()

    def add(self) -> int:
        '''Add a creation path.'''
        raise NotImplementedError()


class ShapePathPoint:
    '''Represents an x-y coordinate within the path coordinate space.'''

    def getY(self) -> int:
        '''Gets y coordinate for this position coordinate.'''
        raise NotImplementedError()

    def getX(self) -> int:
        '''Gets x coordinate for this position coordinate.'''
        raise NotImplementedError()

    def setY(self, value : int) -> None:
        '''Gets y coordinate for this position coordinate.
        :param value: '''
        raise NotImplementedError()

    def setX(self, value : int) -> None:
        '''Sets x coordinate for this position coordinate.
        :param value: '''
        raise NotImplementedError()


class ShapePathPointCollection:
    '''Represents all shape path points.'''

    def get(self, index : int) -> ShapePathPoint:
        '''Gets shape path point by index.
        :param index: The index
        :returns: Returns :class:`ShapePathPoint` object'''
        raise NotImplementedError()

    def add(self, x : int, y : int) -> int:
        '''Adds a path point.
        :param x: The x coordinate.
        :param y: The y coordinate.'''
        raise NotImplementedError()


class ShapePathType:
    '''Represents path segment type.'''

    LINE_TO : ShapePathType
    '''Straight line segment'''

    CUBIC_BEZIER_CURVE_TO : ShapePathType
    '''Cubic Bezier curve'''

    MOVE_TO : ShapePathType
    '''Start a new path'''

    CLOSE : ShapePathType
    '''If the starting POINT and the end POINT are not the same, a single
    straight line is drawn to connect the starting POINT and ending POINT of the path.'''

    END : ShapePathType
    '''The end of the current path'''

    ESCAPE : ShapePathType
    '''Escape'''

    ARC_TO : ShapePathType
    '''An arc'''

    UNKNOWN : ShapePathType
    '''Unknown'''


class ShapePropertyCollection:
    '''This class specifies the visual shape properties for a chart element or shape.'''

    def hasShadowEffect(self) -> bool:
        '''Indicates if the shape has shadow effect data.'''
        raise NotImplementedError()

    def getFormat3D(self) -> Format3D:
        '''Represents a :meth:`ShapePropertyCollection.getFormat3D()` object that specifies 3D shape properties for the chart element or shape.'''
        raise NotImplementedError()

    def getGlowEffect(self) -> GlowEffect:
        '''Represents a :meth:`ShapePropertyCollection.getGlowEffect()` object that specifies glow effect for the chart element or shape.'''
        raise NotImplementedError()

    def getSoftEdgeRadius(self) -> int:
        '''Gets the radius of blur to apply to the edges, in unit of points.'''
        raise NotImplementedError()

    def clearFormat3D(self) -> None:
        '''Clears the 3D shape properties of the shape.'''
        raise NotImplementedError()

    def hasGlowEffect(self) -> bool:
        '''Indicates if the shape has glow effect data.'''
        raise NotImplementedError()

    def clearGlowEffect(self) -> None:
        '''Clears the glow effect of the shape.'''
        raise NotImplementedError()

    def hasFormat3D(self) -> bool:
        '''Indicates if the shape has 3d format data.'''
        raise NotImplementedError()

    def setSoftEdgeRadius(self, value : int) -> None:
        '''Sets the radius of blur to apply to the edges, in unit of points.
        :param value: '''
        raise NotImplementedError()

    def clearShadowEffect(self) -> None:
        '''Clears the shadow effect of the chart element or shape.'''
        raise NotImplementedError()

    def getShadowEffect(self) -> ShadowEffect:
        '''Represents a :class:`ShadowEffect` object that specifies shadow effect for the chart element or shape.'''
        raise NotImplementedError()


class ShapeSegmentPath:
    '''Represents a segment path in a path of the freeform.'''

    def getPoints(self) -> ShapePathPointCollection:
        '''Gets the points in path segment'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the path segment type
        See :class:`ShapePathType`'''
        raise NotImplementedError()


class ShapeSegmentPathCollection:
    '''Represents a creation path consisting of a series of moves, lines and curves that when combined will form a geometric shape.'''

    def get(self, index : int) -> ShapeSegmentPath:
        '''Gets :class:`ShapeSegmentPath` object.
        :param index: The index.
        :returns: Returns a :class:`ShapeSegmentPath` object.'''
        raise NotImplementedError()

    def add(self, type : int) -> int:
        '''Add a segment path in creation path.
        :param type: :class:`ShapePathType`. The path type.
        :returns: Returns the position of :class:`ShapeSegmentPath` object in the list.'''
        raise NotImplementedError()


class ShapeTextAlignment:
    '''Represents the setting of shape's text alignment;'''

    def setRightMarginPt(self, value : int) -> None:
        '''Returns the right margin in unit of Points
        :param value: '''
        raise NotImplementedError()

    def setTextShapeType(self, value : int) -> None:
        '''Sets the transform type of text.
        See :class:`AutoShapeType`
        :param value: '''
        raise NotImplementedError()

    def setAutoMargin(self, value : bool) -> None:
        '''Indicates whether the margin of the text frame is automatic.
        :param value: '''
        raise NotImplementedError()

    def setTopMarginPt(self, value : int) -> None:
        '''Returns the top margin in unit of Points
        :param value: '''
        raise NotImplementedError()

    def isAutoMargin(self) -> bool:
        '''Indicates whether the margin of the text frame is automatic.'''
        raise NotImplementedError()

    def isTextWrapped(self) -> bool:
        '''Gets the text wrapped type of the shape which contains text.'''
        raise NotImplementedError()

    def setBottomMarginPt(self, value : int) -> None:
        '''Returns the bottom margin in unit of Points
        :param value: '''
        raise NotImplementedError()

    def getRotateTextWithShape(self) -> bool:
        '''Indicates whether rotating text with shape.'''
        raise NotImplementedError()

    def getAutoSize(self) -> bool:
        '''Indicates if size of shape is adjusted automatically according to its content.'''
        raise NotImplementedError()

    def setTextWrapped(self, value : bool) -> None:
        '''Sets the text wrapped type of the shape which contains text.
        :param value: '''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determines whether this instance has the same value as another specified :class:`ShapeTextAlignment` object.
        :param obj: The :class:`ShapeTextAlignment` object to compare with this instance.
        :returns: true if the value of the obj parameter is the same as the value of this instance; otherwise, false. If obj is null, this method returns false.'''
        raise NotImplementedError()

    def getLeftMarginPt(self) -> int:
        '''Returns the left margin in unit of Points'''
        raise NotImplementedError()

    def getTextVerticalType(self) -> int:
        '''Gets the text direction.
        See :class:`TextVerticalType`'''
        raise NotImplementedError()

    def getTopMarginPt(self) -> int:
        '''Returns the top margin in unit of Points'''
        raise NotImplementedError()

    def setAutoSize(self, value : bool) -> None:
        '''Indicates if size of shape is adjusted automatically according to its content.
        :param value: '''
        raise NotImplementedError()

    def getTextHorizontalOverflow(self) -> int:
        '''Gets the text horizontal overflow type of the text box.
        See :class:`TextOverflowType`'''
        raise NotImplementedError()

    def setRotateTextWithShape(self, value : bool) -> None:
        '''Indicates whether rotating text with shape.
        :param value: '''
        raise NotImplementedError()

    def setLeftMarginPt(self, value : int) -> None:
        '''Returns the left margin in unit of Points
        :param value: '''
        raise NotImplementedError()

    def setTextVerticalType(self, value : int) -> None:
        '''Sets the text direction.
        See :class:`TextVerticalType`
        :param value: '''
        raise NotImplementedError()

    def getTextVerticalOverflow(self) -> int:
        '''Gets the text vertical overflow type of the text box.
        See :class:`TextOverflowType`'''
        raise NotImplementedError()

    def hashCode(self) -> int:
        ''''''
        raise NotImplementedError()

    def getRotationAngle(self) -> int:
        '''Gets the rotation of the shape.'''
        raise NotImplementedError()

    def setNumberOfColumns(self, value : int) -> None:
        '''Sets the number of columns of text in the bounding rectangle.
        :param value: '''
        raise NotImplementedError()

    def getRightMarginPt(self) -> int:
        '''Returns the right margin in unit of Points'''
        raise NotImplementedError()

    def setLockedText(self, value : bool) -> None:
        '''Indicates whether the shape is locked when worksheet is protected.
        :param value: '''
        raise NotImplementedError()

    def getBottomMarginPt(self) -> int:
        '''Returns the bottom margin in unit of Points'''
        raise NotImplementedError()

    def getTextShapeType(self) -> int:
        '''Gets the transform type of text.
        See :class:`AutoShapeType`'''
        raise NotImplementedError()

    def setTextHorizontalOverflow(self, value : int) -> None:
        '''Sets the text horizontal overflow type of the text box.
        See :class:`TextOverflowType`
        :param value: '''
        raise NotImplementedError()

    def getNumberOfColumns(self) -> int:
        '''Gets the number of columns of text in the bounding rectangle.'''
        raise NotImplementedError()

    def isLockedText(self) -> bool:
        '''Indicates whether the shape is locked when worksheet is protected.'''
        raise NotImplementedError()

    def setTextVerticalOverflow(self, value : int) -> None:
        '''Sets the text vertical overflow type of the text box.
        See :class:`TextOverflowType`
        :param value: '''
        raise NotImplementedError()

    def setRotationAngle(self, value : int) -> None:
        '''Sets the rotation of the shape.
        :param value: '''
        raise NotImplementedError()


class ShapeTextVerticalAlignmentType:
    '''It corresponds to "Format Shape - Text Options - Text Box - Vertical Alignment" in Excel.'''

    TOP : ShapeTextVerticalAlignmentType
    ''''''

    MIDDLE : ShapeTextVerticalAlignmentType
    ''''''

    BOTTOM : ShapeTextVerticalAlignmentType
    ''''''

    TOP_CENTERED : ShapeTextVerticalAlignmentType
    ''''''

    MIDDLE_CENTERED : ShapeTextVerticalAlignmentType
    ''''''

    BOTTOM_CENTERED : ShapeTextVerticalAlignmentType
    ''''''

    LEFT : ShapeTextVerticalAlignmentType
    ''''''

    CENTER : ShapeTextVerticalAlignmentType
    ''''''

    RIGHT : ShapeTextVerticalAlignmentType
    ''''''

    LEFT_MIDDLE : ShapeTextVerticalAlignmentType
    ''''''

    CENTER_MIDDLE : ShapeTextVerticalAlignmentType
    ''''''

    RIGHT_MIDDLE : ShapeTextVerticalAlignmentType
    ''''''


class SheetPrintingPreview:
    '''Worksheet printing preview.'''

    def getEvaluatedPageCount(self) -> int:
        '''Evaluate the total page count of this worksheet
        The following code shows the fastest way to get page count of a worksheet.'''
        raise NotImplementedError()


class SheetRender:
    '''Represents a worksheet render which can render worksheet to various images such as (BMP, PNG, JPEG, TIFF..)
    The constructor of this class , must be used after modification of pagesetup, cell style.'''

    def getPageCount(self) -> int:
        '''Gets the total page count of current worksheet.'''
        raise NotImplementedError()

    @overload
    def toImage(self, pageIndex : int, fileName : str) -> None:
        '''Render certain page to a file.
        The following code outputs the first page of the first sheet to png image.
        :param pageIndex: indicate which page is to be converted
        :param fileName: filename of the output image'''
        raise NotImplementedError()

    @overload
    def toImage(self, pageIndex : int, stream : java.io.InputStream) -> None:
        '''Render certain page to a stream.
        :param pageIndex: indicate which page is to be converted
        :param stream: the stream of the output image'''
        raise NotImplementedError()

    @overload
    def toImage(self, pageIndex : int, stream : OutputStream) -> None:
        '''Render certain page to a stream.
        :param pageIndex: indicate which page is to be converted
        :param stream: the stream of the output image'''
        raise NotImplementedError()

    def toTiff(self, stream : InputStream) -> None:
        '''Render whole worksheet as Tiff Image to stream.
        :param stream: the stream of the output image'''
        raise NotImplementedError()

    def getPageScale(self) -> int:
        '''Gets calculated page scale of the sheet.
        Returns the set scale if :meth:`PageSetup.getZoom()` is set. Otherwise, returns the calculated scale according to :meth:`PageSetup.getFitToPagesWide()` and :meth:`PageSetup.getFitToPagesTall()`.'''
        raise NotImplementedError()

    @overload
    def toPrinter(self, printerName : str) -> None:
        '''Render worksheet to Printer
        :param printerName: the name of the printer , for example: "Microsoft Office Document Image Writer"'''
        raise NotImplementedError()

    @overload
    def toPrinter(self, printerName : str, jobName : str) -> None:
        '''Render worksheet to Printer
        :param printerName: the name of the printer , for example: "Microsoft Office Document Image Writer"
        :param jobName: set the print job name'''
        raise NotImplementedError()

    @overload
    def toPrinter(self, printerName : str, printPageIndex : int, printPageCount : int) -> None:
        ''':deprecated: Use ToPrinter(string PrinterName) and ImageOrPrintOptions.PageIndex, PageCount instead.'''
        raise NotImplementedError()

    def getPageSizeInch(self, pageIndex : int) -> list[float]:
        '''Get page size in inch of output image.
        :param pageIndex: The page index is based on zero.
        :returns: Page size of image, [0] for width and [1] for height'''
        raise NotImplementedError()

    def dispose(self) -> None:
        '''Releases resources created and used for rendering.'''
        raise NotImplementedError()


class SheetSet:
    '''Describes a set of sheets.'''

    def getAll(self) -> SheetSet:
        '''Gets a set with all sheets of the workbook in their original order.'''
        raise NotImplementedError()

    def getActive(self) -> SheetSet:
        '''Gets a set with active sheet of the workbook.'''
        raise NotImplementedError()

    def getVisible(self) -> SheetSet:
        '''Gets a set with visible sheets of the workbook in their original order.'''
        raise NotImplementedError()


class SheetType:
    '''Specifies the worksheet type.'''

    VB : SheetType
    '''Visual Basic module'''

    WORKSHEET : SheetType
    ''''''

    CHART : SheetType
    '''Chart'''

    BIFF_4_MACRO : SheetType
    '''BIFF4 Macro sheet'''

    INTERNATIONAL_MACRO : SheetType
    '''International Macro sheet'''

    OTHER : SheetType
    ''''''

    DIALOG : SheetType
    '''Dialog worksheet'''


class ShiftType:
    '''Represent the shift options when deleting a range of cells.'''

    DOWN : ShiftType
    '''Shift cells down.'''

    LEFT : ShiftType
    '''Shift cells left.'''

    NONE : ShiftType
    '''Do not shift cells.'''

    RIGHT : ShiftType
    '''Shift cells right.'''

    UP : ShiftType
    '''Shift cells up.'''


class ShowDropButtonType:
    '''Specifies when to show the drop button'''

    NEVER : ShowDropButtonType
    '''Never show the drop button.'''

    FOCUS : ShowDropButtonType
    '''Show the drop button when the control has the focus.'''

    ALWAYS : ShowDropButtonType
    '''Always show the drop button.'''


class SignatureLine:
    '''Represent the signature line.'''

    def setShowSignedDate(self, value : bool) -> None:
        '''Indicates whether show signed date.
        :param value: '''
        raise NotImplementedError()

    def setEmail(self, value : str) -> None:
        '''Sets the email of singer.
        :param value: '''
        raise NotImplementedError()

    def getEmail(self) -> str:
        '''Gets the email of singer.'''
        raise NotImplementedError()

    def setProviderId(self, value : java.util.UUID) -> None:
        '''Sets the id of signature provider.
        :param value: '''
        raise NotImplementedError()

    def setTitle(self, value : str) -> None:
        '''Sets the title of singer.
        :param value: '''
        raise NotImplementedError()

    def getAllowComments(self) -> bool:
        '''Indicates whether comments could be attached.'''
        raise NotImplementedError()

    def getTitle(self) -> str:
        '''Gets the title of singer.'''
        raise NotImplementedError()

    def getId(self) -> java.util.UUID:
        '''Gets identifier for this signature line.'''
        raise NotImplementedError()

    def isLine(self) -> bool:
        '''Indicates whether it is a signature line.'''
        raise NotImplementedError()

    def getSignatureLineType(self) -> int:
        '''Gets the signature type.
        Default - When the default value is set, the corresponding ProviderId value is fixed to {0000000000-0000-0000-0000-0000000000}.
        Stamp - When the value is Stamp, the corresponding ProviderId value is usually {000CD6A4-0000-0000-C000-000000000046}.
        Custom - When the value is Custom, the corresponding ProviderId value usually needs to be set by the user. it should be obtained from the documentation shipped with the provider.
        See :class:`SignatureType`'''
        raise NotImplementedError()

    def getProviderId(self) -> java.util.UUID:
        '''Gets the id of signature provider.'''
        raise NotImplementedError()

    def setAllowComments(self, value : bool) -> None:
        '''Indicates whether comments could be attached.
        :param value: '''
        raise NotImplementedError()

    def setInstructions(self, value : str) -> None:
        '''Sets the text shown to user at signing time.
        :param value: '''
        raise NotImplementedError()

    def setLine(self, value : bool) -> None:
        '''Indicates whether it is a signature line.
        :param value: '''
        raise NotImplementedError()

    def setSigner(self, value : str) -> None:
        '''Sets the signer.
        :param value: '''
        raise NotImplementedError()

    def setSignatureLineType(self, value : int) -> None:
        '''Sets the signature type.
        Default - When the default value is set, the corresponding ProviderId value is fixed to {0000000000-0000-0000-0000-0000000000}.
        Stamp - When the value is Stamp, the corresponding ProviderId value is usually {000CD6A4-0000-0000-C000-000000000046}.
        Custom - When the value is Custom, the corresponding ProviderId value usually needs to be set by the user. it should be obtained from the documentation shipped with the provider.
        See :class:`SignatureType`
        :param value: '''
        raise NotImplementedError()

    def setId(self, value : java.util.UUID) -> None:
        '''Sets identifier for this signature line.
        :param value: '''
        raise NotImplementedError()

    def getSigner(self) -> str:
        '''Gets the signer.'''
        raise NotImplementedError()

    def getShowSignedDate(self) -> bool:
        '''Indicates whether show signed date.'''
        raise NotImplementedError()

    def getInstructions(self) -> str:
        '''Gets the text shown to user at signing time.'''
        raise NotImplementedError()


class SignatureType:
    '''Specifies the signature type.'''

    DEFAULT : SignatureType
    '''The default value , the corresponding ProviderId value is fixed to {0000000000-0000-0000-0000-0000000000}.'''

    STAMP : SignatureType
    '''The corresponding ProviderId value is usually {000CD6A4-0000-0000-C000-000000000046}.'''

    CUSTOM : SignatureType
    '''The corresponding ProviderId value usually needs to be set by the user. it should be obtained from the documentation shipped with the provider.'''


class Slicer:
    '''summary description of Slicer View'''

    def getNumberOfColumns(self) -> int:
        '''Returns or sets the number of columns in the specified slicer.'''
        raise NotImplementedError()

    def getWidthPixel(self) -> int:
        '''Returns or sets the width of the specified slicer, in pixels.'''
        raise NotImplementedError()

    def getRowHeight(self) -> int:
        '''Returns or sets the height, in points, of each row in the specified slicer.'''
        raise NotImplementedError()

    def getCaption(self) -> str:
        '''Returns or sets the caption of the specified slicer.'''
        raise NotImplementedError()

    def getCaptionVisible(self) -> bool:
        '''Returns or sets whether the header that displays the slicer Caption is visible
        the default value is true'''
        raise NotImplementedError()

    def isPrintable(self) -> bool:
        '''Indicates whether the slicer object is printable.'''
        raise NotImplementedError()

    def getTopPixel(self) -> int:
        '''Returns or sets the vertical offset of slicer shape from its top row, in pixels.'''
        raise NotImplementedError()

    def setLocked(self, value : bool) -> None:
        '''Indicates whether the slicer shape is locked.
        :param value: '''
        raise NotImplementedError()

    def addPivotConnection(self, pivot : PivotTable) -> None:
        '''Adds PivotTable connection.
        :param pivot: The PivotTable object'''
        raise NotImplementedError()

    def getLeftPixel(self) -> int:
        '''Returns or sets the horizontal offset of slicer shape from its left column, in pixels.'''
        raise NotImplementedError()

    def getLockedPosition(self) -> bool:
        '''Indicates whether the specified slicer can be moved or resized by using the user interface.'''
        raise NotImplementedError()

    def setPlacement(self, value : int) -> None:
        '''Represents the way the drawing object is attached to the cells below it.
        The property controls the placement of an object on a worksheet.
        See :class:`PlacementType`
        :param value: '''
        raise NotImplementedError()

    def setNumberOfColumns(self, value : int) -> None:
        '''Returns or sets the number of columns in the specified slicer.
        :param value: '''
        raise NotImplementedError()

    def getStyleType(self) -> int:
        '''Specify the type of Built-in slicer style
        the default type is SlicerStyleLight1
        See :class:`SlicerStyleType`'''
        raise NotImplementedError()

    def getAlternativeText(self) -> str:
        '''Returns or sets the descriptive (alternative) text string of the Slicer object.'''
        raise NotImplementedError()

    def setColumnWidth(self, value : int) -> None:
        '''Returns or sets the width, in points, of each column in the slicer.
        :param value: '''
        raise NotImplementedError()

    def getRowHeightPixel(self) -> int:
        '''Returns or sets the height, in pixels, of each row in the specified slicer.'''
        raise NotImplementedError()

    def setWidthPixel(self, value : int) -> None:
        '''Returns or sets the width of the specified slicer, in pixels.
        :param value: '''
        raise NotImplementedError()

    def setTitle(self, value : str) -> None:
        '''Specifies the title of the current Slicer object.
        :param value: '''
        raise NotImplementedError()

    def setTopPixel(self, value : int) -> None:
        '''Returns or sets the vertical offset of slicer shape from its top row, in pixels.
        :param value: '''
        raise NotImplementedError()

    def getTitle(self) -> str:
        '''Specifies the title of the current Slicer object.'''
        raise NotImplementedError()

    def isLocked(self) -> bool:
        '''Indicates whether the slicer shape is locked.'''
        raise NotImplementedError()

    def setPrintable(self, value : bool) -> None:
        '''Indicates whether the slicer object is printable.
        :param value: '''
        raise NotImplementedError()

    def setCaptionVisible(self, value : bool) -> None:
        '''Returns or sets whether the header that displays the slicer Caption is visible
        the default value is true
        :param value: '''
        raise NotImplementedError()

    def setRowHeight(self, value : int) -> None:
        '''Returns or sets the height, in points, of each row in the specified slicer.
        :param value: '''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Returns or sets the height of the specified slicer, in points.'''
        raise NotImplementedError()

    def setCaption(self, value : str) -> None:
        '''Returns or sets the caption of the specified slicer.
        :param value: '''
        raise NotImplementedError()

    def setLockedAspectRatio(self, value : bool) -> None:
        '''Indicates whether locking aspect ratio.
        :param value: '''
        raise NotImplementedError()

    def getSlicerCache(self) -> SlicerCache:
        '''Returns the SlicerCache object associated with the slicer. Read-only.'''
        raise NotImplementedError()

    def setColumnWidthPixel(self, value : int) -> None:
        '''Sets the width in unit ofpixels foreach column ofthe slicer.
        :param value: '''
        raise NotImplementedError()

    def setAlternativeText(self, value : str) -> None:
        '''Returns or sets the descriptive (alternative) text string of the Slicer object.
        :param value: '''
        raise NotImplementedError()

    def getColumnWidth(self) -> int:
        '''Returns or sets the width, in points, of each column in the slicer.'''
        raise NotImplementedError()

    def getColumnWidthPixel(self) -> int:
        '''Gets the width in unit ofpixels foreach column ofthe slicer.'''
        raise NotImplementedError()

    def setHeightPixel(self, value : int) -> None:
        '''Returns or sets the height of the specified slicer, in pixels.
        :param value: '''
        raise NotImplementedError()

    def setHeight(self, value : int) -> None:
        '''Returns or sets the height of the specified slicer, in points.
        :param value: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Returns or sets the name of the specified slicer'''
        raise NotImplementedError()

    def setLeftPixel(self, value : int) -> None:
        '''Returns or sets the horizontal offset of slicer shape from its left column, in pixels.
        :param value: '''
        raise NotImplementedError()

    def setLockedPosition(self, value : bool) -> None:
        '''Indicates whether the specified slicer can be moved or resized by using the user interface.
        :param value: '''
        raise NotImplementedError()

    def getParent(self) -> Worksheet:
        '''Returns the :meth:`Range.getWorksheet()` object which contains this slicer. Read-only.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Returns or sets the name of the specified slicer
        :param value: '''
        raise NotImplementedError()

    def getPlacement(self) -> int:
        '''Represents the way the drawing object is attached to the cells below it.
        The property controls the placement of an object on a worksheet.
        See :class:`PlacementType`'''
        raise NotImplementedError()

    def setStyleType(self, value : int) -> None:
        '''Specify the type of Built-in slicer style
        the default type is SlicerStyleLight1
        See :class:`SlicerStyleType`
        :param value: '''
        raise NotImplementedError()

    def setWidth(self, value : int) -> None:
        '''Returns or sets the width of the specified slicer, in points.
        :param value: '''
        raise NotImplementedError()

    def setRowHeightPixel(self, value : int) -> None:
        '''Returns or sets the height, in pixels, of each row in the specified slicer.
        :param value: '''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Returns or sets the width of the specified slicer, in points.'''
        raise NotImplementedError()

    def refresh(self) -> None:
        '''Refreshing the slicer.Meanwhile, Refreshing and Calculating  relative PivotTables.'''
        raise NotImplementedError()

    def getHeightPixel(self) -> int:
        '''Returns or sets the height of the specified slicer, in pixels.'''
        raise NotImplementedError()

    def removePivotConnection(self, pivot : PivotTable) -> None:
        '''Removes PivotTable connection.
        :param pivot: The PivotTable object'''
        raise NotImplementedError()

    def getLockedAspectRatio(self) -> bool:
        '''Indicates whether locking aspect ratio.'''
        raise NotImplementedError()


class SlicerCache:
    '''Represent summary description of slicer cache'''

    def getList(self) -> bool:
        '''Returns whether the slicer associated with the specified slicer cache is based on an Non-OLAP data source. Read-only'''
        raise NotImplementedError()

    def getSlicerCacheItems(self) -> SlicerCacheItemCollection:
        '''Returns a SlicerCacheItem collection that contains the collection of all items in the slicer cache. Read-only'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Returns the name of the slicer cache.'''
        raise NotImplementedError()

    def getCrossFilterType(self) -> int:
        '''Returns or sets whether a slicer is participating in cross filtering with other slicers
        that share the same slicer cache, and how cross filtering is displayed. Read/write
        See :class:`SlicerCacheCrossFilterType`'''
        raise NotImplementedError()

    def getSourceName(self) -> str:
        '''Returns the name of this slicer cache.'''
        raise NotImplementedError()

    def setCrossFilterType(self, value : int) -> None:
        '''Returns or sets whether a slicer is participating in cross filtering with other slicers
        that share the same slicer cache, and how cross filtering is displayed. Read/write
        See :class:`SlicerCacheCrossFilterType`
        :param value: '''
        raise NotImplementedError()


class SlicerCacheCrossFilterType:
    '''Represent the type of SlicerCacheCrossFilterType'''

    NONE : SlicerCacheCrossFilterType
    '''The table style element of the slicer style for slicer items
    with no data is not applied to slicer items with no data, and slicer items
    with no data are not sorted separately in the list of slicer items in the slicer view'''

    SHOW_ITEMS_WITH_DATA_AT_TOP : SlicerCacheCrossFilterType
    '''The table style element of the slicer style for slicer items with
    no data is applied to slicer items with no data, and slicer items
    with no data are sorted at the bottom in the list of slicer items in the slicer view'''

    SHOW_ITEMS_WITH_NO_DATA : SlicerCacheCrossFilterType
    '''The table style element of the slicer style for slicer items with no data
    is applied to slicer items with no data, and slicer items with no data
    are not sorted separately in the list of slicer items in the slicer view.'''


class SlicerCacheItem:
    '''Represent slicer data source item'''

    def getSelected(self) -> bool:
        '''Specifies whether the SlicerItem is selected or not.'''
        raise NotImplementedError()

    def getValue(self) -> str:
        '''Returns the label text for the slicer item. Read-only.'''
        raise NotImplementedError()

    def setSelected(self, value : bool) -> None:
        '''Specifies whether the SlicerItem is selected or not.
        :param value: '''
        raise NotImplementedError()


class SlicerCacheItemCollection:
    '''Represent the collection of SlicerCacheItem'''

    def getCount(self) -> int:
        '''Gets the count of the SlicerCacheItem.'''
        raise NotImplementedError()

    def get(self, index : int) -> SlicerCacheItem:
        '''Gets the SlicerCacheItem object by index.
        :param index: '''
        raise NotImplementedError()


class SlicerCacheItemSortType:
    '''Specify the sort type of SlicerCacheItem'''

    NATURAL : SlicerCacheItemSortType
    '''Original data order.'''

    ASCENDING : SlicerCacheItemSortType
    '''Ascending sort type'''

    DESCENDING : SlicerCacheItemSortType
    '''Descending sort type'''


class SlicerCollection:
    '''Specifies the collection of all the Slicer objects on the specified worksheet.'''

    def clear(self) -> None:
        '''Clear all Slicers.'''
        raise NotImplementedError()

    def remove(self, slicer : Slicer) -> None:
        '''Remove the specified Slicer
        :param slicer: The Slicer object'''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Deletes the Slicer at the specified index
        :param index: The position index in Slicer collection'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> Slicer:
        '''Gets the Slicer by index.
        :param index: '''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> Slicer:
        '''Gets the Slicer  by slicer's name.
        :param name: '''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, destCellName : str, baseFieldName : str) -> int:
        '''Add a new Slicer using PivotTable as data source
        :param pivot: PivotTable object
        :param destCellName: The cell in the upper-left corner of the Slicer range.
        :param baseFieldName: The name of PivotField in PivotTable.BaseFields
        :returns: The new add Slicer index'''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, row : int, column : int, baseFieldName : str) -> int:
        '''Add a new Slicer using PivotTable as data source
        :param pivot: PivotTable object
        :param row: Row index of the cell in the upper-left corner of the Slicer range.
        :param column: Column index of the cell in the upper-left corner of the Slicer range.
        :param baseFieldName: The name of PivotField in PivotTable.BaseFields
        :returns: The new add Slicer index'''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, row : int, column : int, baseFieldIndex : int) -> int:
        '''Add a new Slicer using PivotTable as data source
        :param pivot: PivotTable object
        :param row: Row index of the cell in the upper-left corner of the Slicer range.
        :param column: Column index of the cell in the upper-left corner of the Slicer range.
        :param baseFieldIndex: The index of PivotField in PivotTable.BaseFields
        :returns: The new add Slicer index'''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, destCellName : str, baseFieldIndex : int) -> int:
        '''Add a new Slicer using PivotTable as data source
        :param pivot: PivotTable object
        :param destCellName: The cell in the upper-left corner of the Slicer range.
        :param baseFieldIndex: The index of PivotField in PivotTable.BaseFields
        :returns: The new add Slicer index'''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, row : int, column : int, baseField : PivotField) -> int:
        '''Add a new Slicer using PivotTable as data source
        :param pivot: PivotTable object
        :param row: Row index of the cell in the upper-left corner of the Slicer range.
        :param column: Column index of the cell in the upper-left corner of the Slicer range.
        :param baseField: The PivotField in PivotTable.BaseFields
        :returns: The new add Slicer index'''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, destCellName : str, baseField : PivotField) -> int:
        '''Add a new Slicer using PivotTable as data source
        :param pivot: PivotTable object
        :param destCellName: The cell in the upper-left corner of the Slicer range.
        :param baseField: The PivotField in PivotTable.BaseFields
        :returns: The new add Slicer index'''
        raise NotImplementedError()

    @overload
    def add(self, table : ListObject, index : int, destCellName : str) -> int:
        '''Add a new Slicer using ListObjet as data source
        :param table: ListObject object
        :param index: The index of ListColumn in ListObject.ListColumns
        :param destCellName: The cell in the upper-left corner of the Slicer range.
        :returns: The new add Slicer index'''
        raise NotImplementedError()

    @overload
    def add(self, table : ListObject, listColumn : ListColumn, destCellName : str) -> int:
        '''Add a new Slicer using ListObjet as data source
        :param table: ListObject object
        :param listColumn: The ListColumn in ListObject.ListColumns
        :param destCellName: The cell in the upper-left corner of the Slicer range.
        :returns: The new add Slicer index'''
        raise NotImplementedError()

    @overload
    def add(self, table : ListObject, listColumn : ListColumn, row : int, column : int) -> int:
        '''Add a new Slicer using ListObjet as data source
        :param table: ListObject object
        :param listColumn: The ListColumn in ListObject.ListColumns
        :param row: Row index of the cell in the upper-left corner of the Slicer range.
        :param column: Column index of the cell in the upper-left corner of the Slicer range.
        :returns: The new add Slicer index'''
        raise NotImplementedError()


class SlicerStyleType:
    '''Specify the style of slicer view'''

    SLICER_STYLE_LIGHT_1 : SlicerStyleType
    '''built-in light style one'''

    SLICER_STYLE_LIGHT_2 : SlicerStyleType
    '''built-in light style two'''

    SLICER_STYLE_LIGHT_3 : SlicerStyleType
    '''built-in light style three'''

    SLICER_STYLE_LIGHT_4 : SlicerStyleType
    '''built-in light style four'''

    SLICER_STYLE_LIGHT_5 : SlicerStyleType
    '''built-in light style five'''

    SLICER_STYLE_LIGHT_6 : SlicerStyleType
    '''built-in light style six'''

    SLICER_STYLE_OTHER_1 : SlicerStyleType
    '''built-in style other one'''

    SLICER_STYLE_OTHER_2 : SlicerStyleType
    '''built-in style other two'''

    SLICER_STYLE_DARK_1 : SlicerStyleType
    '''built-in dark style one'''

    SLICER_STYLE_DARK_2 : SlicerStyleType
    '''built-in dark style tow'''

    SLICER_STYLE_DARK_3 : SlicerStyleType
    '''built-in dark style three'''

    SLICER_STYLE_DARK_4 : SlicerStyleType
    '''built-in dark style four'''

    SLICER_STYLE_DARK_5 : SlicerStyleType
    '''built-in dark style five'''

    SLICER_STYLE_DARK_6 : SlicerStyleType
    '''built-in dark style six'''

    CUSTOM : SlicerStyleType
    '''user-defined style, unsupported for now'''


class SlideViewType:
    '''Represents the type when exporting to slides.'''

    VIEW : SlideViewType
    '''Exporting as view in MS Excel.'''

    PRINT : SlideViewType
    '''Exporting as printing.'''


class SmartArtShape:
    '''Represents the smart art.'''

    def getResultOfSmartArt(self) -> GroupShape:
        '''Converting smart art to grouped shapes.'''
        raise NotImplementedError()


class SmartTag:
    '''Represents a smart tag.'''

    def setLink(self, uri : str, name : str) -> None:
        '''Change the name and  the namespace URI of the smart tag.
        :param uri: The namespace URI of the smart tag.
        :param name: The name of the smart tag.'''
        raise NotImplementedError()

    def setProperties(self, value : SmartTagPropertyCollection) -> None:
        '''Sets the properties of the smart tag.
        :param value: '''
        raise NotImplementedError()

    def setDeleted(self, value : bool) -> None:
        '''Indicates whether the smart tag is deleted.
        :param value: '''
        raise NotImplementedError()

    def getDeleted(self) -> bool:
        '''Indicates whether the smart tag is deleted.'''
        raise NotImplementedError()

    def getUri(self) -> str:
        '''Gets the namespace URI of the smart tag.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the smart tag.'''
        raise NotImplementedError()

    def getProperties(self) -> SmartTagPropertyCollection:
        '''Gets the properties of the smart tag.'''
        raise NotImplementedError()


class SmartTagCollection:
    '''Represents all smart tags in the cell.'''

    def get(self, index : int) -> SmartTag:
        '''Gets a :class:`SmartTag` object at the specific index
        :param index: The index.
        :returns: returns a :class:`SmartTag` object.'''
        raise NotImplementedError()

    def getColumn(self) -> int:
        '''Gets the column of the cell smart tags.'''
        raise NotImplementedError()

    def add(self, uri : str, name : str) -> int:
        '''Adds a smart tag.
        :param uri: Specifies the namespace URI of the smart tag
        :param name: Specifies the name of the smart tag.
        :returns: The index of smart tag in the list.'''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets the row of the cell smart tags.'''
        raise NotImplementedError()


class SmartTagOptions:
    '''Represents the options of the smart tag.'''

    def setShowType(self, value : int) -> None:
        '''Represents the show type of smart tag.
        See :class:`SmartTagShowType`
        :param value: '''
        raise NotImplementedError()

    def getShowType(self) -> int:
        '''Represents the show type of smart tag.
        See :class:`SmartTagShowType`'''
        raise NotImplementedError()

    def getEmbedSmartTags(self) -> bool:
        '''Indicates whether saving smart tags with the workbook.'''
        raise NotImplementedError()

    def setEmbedSmartTags(self, value : bool) -> None:
        '''Indicates whether saving smart tags with the workbook.
        :param value: '''
        raise NotImplementedError()


class SmartTagProperty:
    '''Represents the property of the cell smart tag.'''

    def getValue(self) -> str:
        '''Gets the value of the property.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the property.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the property.
        :param value: '''
        raise NotImplementedError()

    def setValue(self, value : str) -> None:
        '''Sets the value of the property.
        :param value: '''
        raise NotImplementedError()


class SmartTagPropertyCollection:
    '''Represents all properties of cell smart tag.'''

    @overload
    def get(self, index : int) -> SmartTagProperty:
        '''Gets a :class:`SmartTagProperty` object.
        :param index: The index
        :returns: Returns a :class:`SmartTagProperty` object.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> SmartTagProperty:
        '''Gets a :class:`SmartTagProperty` object by the name of the property.
        :param name: The name of the property.
        :returns: Returns a :class:`SmartTagProperty` object.'''
        raise NotImplementedError()

    def add(self, name : str, value : str) -> int:
        '''Adds a property of cell's smart tag.
        :param name: The name of the property
        :param value: The value of the property.
        :returns: return :class:`SmartTagProperty`'''
        raise NotImplementedError()


class SmartTagSetting:
    '''Represents all :class:`SmartTagCollection` object in the worksheet.'''

    @overload
    def get(self, index : int) -> SmartTagCollection:
        '''Gets a :class:`SmartTagCollection` object by the index.
        :param index: The index of the :class:`SmartTagCollection` object in the list.'''
        raise NotImplementedError()

    @overload
    def get(self, row : int, column : int) -> SmartTagCollection:
        '''Gets the :class:`SmartTagCollection` object of the cell.
        :param row: The row index of the cell.
        :param column: The column index of the cell
        :returns: Returns the :class:`SmartTagCollection` object of the cell. Returns null if there is no any smart tags on the cell.'''
        raise NotImplementedError()

    @overload
    def get(self, cellName : str) -> SmartTagCollection:
        '''Gets the :class:`SmartTagCollection` object of the cell.
        :param cellName: The name of the cell.
        :returns: Returns the :class:`SmartTagCollection` object of the cell. Returns null if there is no any smart tags on the cell.'''
        raise NotImplementedError()

    @overload
    def add(self, row : int, column : int) -> int:
        '''Adds a :class:`SmartTagCollection` object to a cell.
        :param row: The row of the cell.
        :param column: The column of the cell.
        :returns: Returns index of a :class:`SmartTagCollection` object in the worksheet.'''
        raise NotImplementedError()

    @overload
    def add(self, cellName : str) -> int:
        '''Add a cell smart tags.
        :param cellName: The name of the cell.'''
        raise NotImplementedError()


class SmartTagShowType:
    '''Represents the show type of the smart tag.'''

    ALL : SmartTagShowType
    '''Indicates that smart tags are enabled and shown'''

    NO_SMART_TAG_INDICATOR : SmartTagShowType
    '''Indicates that the smart tags are enabled but the indicator not be shown.'''

    NONE : SmartTagShowType
    '''Indicates that smart tags are disabled and not displayed.'''


class SolidFill:
    '''Encapsulates the object that represents solid fill format'''

    def setTransparency(self, value : int) -> None:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def getCellsColor(self) -> CellsColor:
        '''Gets the :class:`CellsColor` object.'''
        raise NotImplementedError()

    def hashCode(self) -> int:
        '''Gets the hash code.'''
        raise NotImplementedError()

    def setColor(self, value : Color) -> None:
        '''Sets the :class:`Color`.
        :param value: '''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''
        :param obj: '''
        raise NotImplementedError()

    def setCellsColor(self, value : CellsColor) -> None:
        '''Sets the :class:`CellsColor` object.
        :param value: '''
        raise NotImplementedError()

    def getColor(self) -> Color:
        '''Gets the :class:`Color`.'''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()


class SortOnType:
    '''Sorted value type.'''

    VALUE : SortOnType
    '''Sorts by cells' value.'''

    CELL_COLOR : SortOnType
    '''Sorts by cells' color.'''

    FONT_COLOR : SortOnType
    '''Sorts by cells' font color.'''

    ICON : SortOnType
    '''Sorts by conditional icon.'''


class SortOrder:
    '''Represents sort order for the data range.'''

    ASCENDING : SortOrder
    '''Sorts data in ascending order'''

    DESCENDING : SortOrder
    '''Sorts data in descending order'''

    NATURAL : SortOrder
    '''Keeps original data order without sorting. Only applies to some special scenarios such as PivotTable.'''


class Sparkline:
    '''A sparkline represents a tiny chart or graphic in a worksheet cell that provides a visual representation of data.'''

    def getDataRange(self) -> str:
        '''Represents the data range of the sparkline.'''
        raise NotImplementedError()

    @overload
    def toImage(self, fileName : str, options : ImageOrPrintOptions) -> None:
        '''Converts a sparkline to an image.
        :param fileName: The image file name.
        :param options: The image options'''
        raise NotImplementedError()

    @overload
    def toImage(self, stream : OutputStream, options : ImageOrPrintOptions) -> None:
        '''Converts a sparkline to an image.
        :param stream: The image stream.
        :param options: The image options.'''
        raise NotImplementedError()

    def getColumn(self) -> int:
        '''Gets the column index of the sparkline.'''
        raise NotImplementedError()

    def setDataRange(self, value : str) -> None:
        '''Represents the data range of the sparkline.
        :param value: '''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets the row index of the sparkline.'''
        raise NotImplementedError()


class SparklineAxisMinMaxType:
    '''Represents the minimum and maximum value types for the sparkline vertical axis.'''

    AUTO_INDIVIDUAL : SparklineAxisMinMaxType
    '''Automatic for each sparkline.'''

    GROUP : SparklineAxisMinMaxType
    '''Same for all sparklines in the group.'''

    CUSTOM : SparklineAxisMinMaxType
    '''Custom value for sparkline.'''


class SparklineCollection:
    '''Encapsulates a collection of :class:`Sparkline` objects.'''

    def remove(self, o : Object) -> None:
        '''Removes the sparkline
        :param o: '''
        raise NotImplementedError()

    def get(self, index : int) -> Sparkline:
        '''Gets the :class:`Sparkline` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    def add(self, dataRange : str, row : int, column : int) -> int:
        '''Add a sparkline.
        :param dataRange: Specifies the new data range of the sparkline.
        :param row: The row index of the location.
        :param column: The column index of the location.'''
        raise NotImplementedError()


class SparklineGroup:
    ''':class:`Sparkline` is organized into sparkline group. A SparklineGroup contains a variable number of sparkline items.
    A sparkline group specifies the type, display settings and axis settings for the sparklines.'''

    def setHorizontalAxisColor(self, value : CellsColor) -> None:
        '''Sets the color of the horizontal axis in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def setSeriesColor(self, value : CellsColor) -> None:
        '''Sets the color of the sparklines in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def setVerticalAxisMinValue(self, value : int) -> None:
        '''Sets the custom minimum value for the vertical axis.
        :param value: '''
        raise NotImplementedError()

    def getPlotRightToLeft(self) -> bool:
        '''Indicates whether the plot data is right to left.'''
        raise NotImplementedError()

    def getVerticalAxisMaxValueType(self) -> int:
        '''Represents the vertical axis maximum value type.
        See :class:`SparklineAxisMinMaxType`'''
        raise NotImplementedError()

    def getShowHorizontalAxis(self) -> bool:
        '''Indicates whether to show the sparkline horizontal axis.
        The horizontal axis appears if the sparkline has data that crosses the zero axis.'''
        raise NotImplementedError()

    def getVerticalAxisMaxValue(self) -> int:
        '''Gets the custom maximum value for the vertical axis.'''
        raise NotImplementedError()

    def getShowFirstPoint(self) -> bool:
        '''Indicates whether to highlight the first point of data in the sparkline group.'''
        raise NotImplementedError()

    def setShowLowPoint(self, value : bool) -> None:
        '''Indicates whether to highlight the lowest points of data in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def getShowNegativePoints(self) -> bool:
        '''Indicates whether to highlight the negative values on the sparkline group with a different color or marker.'''
        raise NotImplementedError()

    def setVerticalAxisMaxValue(self, value : int) -> None:
        '''Sets the custom maximum value for the vertical axis.
        :param value: '''
        raise NotImplementedError()

    def setHighPointColor(self, value : CellsColor) -> None:
        '''Sets the color of the highest points of data in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def setMarkersColor(self, value : CellsColor) -> None:
        '''Sets the color of points in each line sparkline in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def getHorizontalAxisColor(self) -> CellsColor:
        '''Gets the color of the horizontal axis in the sparkline group.'''
        raise NotImplementedError()

    def setDisplayHidden(self, value : bool) -> None:
        '''Indicates whether to show data in hidden rows and columns.
        :param value: '''
        raise NotImplementedError()

    def setLastPointColor(self, value : CellsColor) -> None:
        '''Sets the color of the last point of data in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def setHorizontalAxisDateRange(self, value : str) -> None:
        '''Represents the range that contains the date values for the sparkline data.
        :param value: '''
        raise NotImplementedError()

    def getShowLastPoint(self) -> bool:
        '''Indicates whether to highlight the last point of data in the sparkline group.'''
        raise NotImplementedError()

    def getSeriesColor(self) -> CellsColor:
        '''Gets the color of the sparklines in the sparkline group.'''
        raise NotImplementedError()

    def setLineWeight(self, value : int) -> None:
        '''Sets the line weight in each line sparkline in the sparkline group, in the unit of points.
        :param value: '''
        raise NotImplementedError()

    def setPlotRightToLeft(self, value : bool) -> None:
        '''Indicates whether the plot data is right to left.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Indicates the sparkline type of the sparkline group.
        See :class:`SparklineType`'''
        raise NotImplementedError()

    def setShowHighPoint(self, value : bool) -> None:
        '''Indicates whether to highlight the highest points of data in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def setShowMarkers(self, value : bool) -> None:
        '''Indicates whether to highlight each point in each line sparkline in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def setPlotEmptyCellsType(self, value : int) -> None:
        '''Indicates how to plot empty cells.
        See :class:`PlotEmptyCellsType`
        :param value: '''
        raise NotImplementedError()

    def setLowPointColor(self, value : CellsColor) -> None:
        '''Sets the color of the lowest points of data in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Indicates the sparkline type of the sparkline group.
        See :class:`SparklineType`
        :param value: '''
        raise NotImplementedError()

    def setPresetStyle(self, value : int) -> None:
        '''Sets the preset style type of the sparkline group.
        See :class:`SparklinePresetStyleType`
        :param value: '''
        raise NotImplementedError()

    def getVerticalAxisMinValueType(self) -> int:
        '''Represents the vertical axis minimum value type.
        See :class:`SparklineAxisMinMaxType`'''
        raise NotImplementedError()

    def getSparklineCollection(self) -> SparklineCollection:
        ''':deprecated: Use SparklineGroup.Sparklines property instead.'''
        raise NotImplementedError()

    def setVerticalAxisMaxValueType(self, value : int) -> None:
        '''Represents the vertical axis maximum value type.
        See :class:`SparklineAxisMinMaxType`
        :param value: '''
        raise NotImplementedError()

    def setShowFirstPoint(self, value : bool) -> None:
        '''Indicates whether to highlight the first point of data in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def getFirstPointColor(self) -> CellsColor:
        '''Gets the color of the first point of data in the sparkline group.'''
        raise NotImplementedError()

    def getHorizontalAxisDateRange(self) -> str:
        '''Represents the range that contains the date values for the sparkline data.'''
        raise NotImplementedError()

    def setNegativePointsColor(self, value : CellsColor) -> None:
        '''Sets the color of the negative values on the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def setShowHorizontalAxis(self, value : bool) -> None:
        '''Indicates whether to show the sparkline horizontal axis.
        The horizontal axis appears if the sparkline has data that crosses the zero axis.
        :param value: '''
        raise NotImplementedError()

    def getShowMarkers(self) -> bool:
        '''Indicates whether to highlight each point in each line sparkline in the sparkline group.'''
        raise NotImplementedError()

    def getDisplayHidden(self) -> bool:
        '''Indicates whether to show data in hidden rows and columns.'''
        raise NotImplementedError()

    def resetRanges(self, dataRange : str, isVertical : bool, locationRange : CellArea) -> None:
        '''Resets the data range and location range of the sparkline group.
        This method will clear original sparkline items in the group and creates new sparkline items for the new ranges.
        :param dataRange: Specifies the new data range of the sparkline group.
        :param isVertical: Specifies whether to plot the sparklines from the new data range by row or by column.
        :param locationRange: Specifies where the sparklines to be placed.'''
        raise NotImplementedError()

    def getPresetStyle(self) -> int:
        '''Gets the preset style type of the sparkline group.
        See :class:`SparklinePresetStyleType`'''
        raise NotImplementedError()

    def getHighPointColor(self) -> CellsColor:
        '''Gets the color of the highest points of data in the sparkline group.'''
        raise NotImplementedError()

    def getLastPointColor(self) -> CellsColor:
        '''Gets the color of the last point of data in the sparkline group.'''
        raise NotImplementedError()

    def setShowLastPoint(self, value : bool) -> None:
        '''Indicates whether to highlight the last point of data in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def setShowNegativePoints(self, value : bool) -> None:
        '''Indicates whether to highlight the negative values on the sparkline group with a different color or marker.
        :param value: '''
        raise NotImplementedError()

    def getPlotEmptyCellsType(self) -> int:
        '''Indicates how to plot empty cells.
        See :class:`PlotEmptyCellsType`'''
        raise NotImplementedError()

    def getShowLowPoint(self) -> bool:
        '''Indicates whether to highlight the lowest points of data in the sparkline group.'''
        raise NotImplementedError()

    def getLineWeight(self) -> int:
        '''Gets the line weight in each line sparkline in the sparkline group, in the unit of points.'''
        raise NotImplementedError()

    def setFirstPointColor(self, value : CellsColor) -> None:
        '''Sets the color of the first point of data in the sparkline group.
        :param value: '''
        raise NotImplementedError()

    def getMarkersColor(self) -> CellsColor:
        '''Gets the color of points in each line sparkline in the sparkline group.'''
        raise NotImplementedError()

    def getNegativePointsColor(self) -> CellsColor:
        '''Gets the color of the negative values on the sparkline group.'''
        raise NotImplementedError()

    def getSparklines(self) -> SparklineCollection:
        '''Gets the collection of :class:`Sparkline` object.'''
        raise NotImplementedError()

    def getShowHighPoint(self) -> bool:
        '''Indicates whether to highlight the highest points of data in the sparkline group.'''
        raise NotImplementedError()

    def getLowPointColor(self) -> CellsColor:
        '''Gets the color of the lowest points of data in the sparkline group.'''
        raise NotImplementedError()

    def setVerticalAxisMinValueType(self, value : int) -> None:
        '''Represents the vertical axis minimum value type.
        See :class:`SparklineAxisMinMaxType`
        :param value: '''
        raise NotImplementedError()

    def getVerticalAxisMinValue(self) -> int:
        '''Gets the custom minimum value for the vertical axis.'''
        raise NotImplementedError()


class SparklineGroupCollection:
    '''Encapsulates a collection of :class:`SparklineGroup` objects.'''

    def get(self, index : int) -> SparklineGroup:
        '''Gets the :class:`SparklineGroup` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    def clearSparklines(self, cellArea : CellArea) -> None:
        '''Clears the sparklines that is inside an area of cells.
        :param cellArea: Specifies the area of cells'''
        raise NotImplementedError()

    @overload
    def add(self, type : int) -> int:
        '''Adds an :class:`SparklineGroup` with a :class:`Sparkline` to the collection.
        :param type: :class:`SparklineType`. Specifies the type of the Sparkline group.
        :returns: :class:`SparklineGroup` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, type : int, dataRange : str, isVertical : bool, locationRange : CellArea) -> int:
        '''Adds an :class:`SparklineGroup` with :class:`Sparkline` to the collection.
        :param type: :class:`SparklineType`. Specifies the type of the Sparkline group.
        :param dataRange: Specifies the data range of the sparkline group.
        :param isVertical: Specifies whether to plot the sparklines from the data range by row or by column.
        :param locationRange: Specifies where the sparklines to be placed.
        :returns: :class:`SparklineGroup` object index.'''
        raise NotImplementedError()

    def clearSparklineGroups(self, cellArea : CellArea) -> None:
        '''Clears the sparkline groups that overlaps an area of cells.
        :param cellArea: Specifies the area of cells'''
        raise NotImplementedError()


class SparklinePresetStyleType:
    '''Represents the preset style types for sparkline.'''

    STYLE_1 : SparklinePresetStyleType
    '''Style 1'''

    STYLE_2 : SparklinePresetStyleType
    '''Style 2'''

    STYLE_3 : SparklinePresetStyleType
    '''Style 3'''

    STYLE_4 : SparklinePresetStyleType
    '''Style 4'''

    STYLE_5 : SparklinePresetStyleType
    '''Style 5'''

    STYLE_6 : SparklinePresetStyleType
    '''Style 6'''

    STYLE_7 : SparklinePresetStyleType
    '''Style 7'''

    STYLE_8 : SparklinePresetStyleType
    '''Style 8'''

    STYLE_9 : SparklinePresetStyleType
    '''Style 9'''

    STYLE_10 : SparklinePresetStyleType
    '''Style 10'''

    STYLE_11 : SparklinePresetStyleType
    '''Style 11'''

    STYLE_12 : SparklinePresetStyleType
    '''Style 12'''

    STYLE_13 : SparklinePresetStyleType
    '''Style 13'''

    STYLE_14 : SparklinePresetStyleType
    '''Style 14'''

    STYLE_15 : SparklinePresetStyleType
    '''Style 15'''

    STYLE_16 : SparklinePresetStyleType
    '''Style 16'''

    STYLE_17 : SparklinePresetStyleType
    '''Style 17'''

    STYLE_18 : SparklinePresetStyleType
    '''Style 18'''

    STYLE_19 : SparklinePresetStyleType
    '''Style 19'''

    STYLE_20 : SparklinePresetStyleType
    '''Style 20'''

    STYLE_21 : SparklinePresetStyleType
    '''Style 21'''

    STYLE_22 : SparklinePresetStyleType
    '''Style 22'''

    STYLE_23 : SparklinePresetStyleType
    '''Style 23'''

    STYLE_24 : SparklinePresetStyleType
    '''Style 24'''

    STYLE_25 : SparklinePresetStyleType
    '''Style 25'''

    STYLE_26 : SparklinePresetStyleType
    '''Style 26'''

    STYLE_27 : SparklinePresetStyleType
    '''Style 27'''

    STYLE_28 : SparklinePresetStyleType
    '''Style 28'''

    STYLE_29 : SparklinePresetStyleType
    '''Style 29'''

    STYLE_30 : SparklinePresetStyleType
    '''Style 30'''

    STYLE_31 : SparklinePresetStyleType
    '''Style 31'''

    STYLE_32 : SparklinePresetStyleType
    '''Style 32'''

    STYLE_33 : SparklinePresetStyleType
    '''Style 33'''

    STYLE_34 : SparklinePresetStyleType
    '''Style 34'''

    STYLE_35 : SparklinePresetStyleType
    '''Style 35'''

    STYLE_36 : SparklinePresetStyleType
    '''Style 36'''

    CUSTOM : SparklinePresetStyleType
    '''No preset style.'''


class SparklineType:
    '''Represents the sparkline types.'''

    LINE : SparklineType
    '''Line sparkline.'''

    COLUMN : SparklineType
    '''Column sparkline.'''

    STACKED : SparklineType
    '''Win/Loss sparkline.'''


class SpinButtonActiveXControl:
    '''Represents the SpinButton control.'''

    def getOrientation(self) -> int:
        '''Gets whether the SpinButton or ScrollBar is oriented vertically or horizontally.
        See :class:`ControlScrollOrientation`'''
        raise NotImplementedError()

    def getMax(self) -> int:
        '''Gets the maximum acceptable value.'''
        raise NotImplementedError()

    def setSmallChange(self, value : int) -> None:
        '''Sets the amount by which the Position property changes
        :param value: '''
        raise NotImplementedError()

    def setMin(self, value : int) -> None:
        '''Sets the minimum acceptable value.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()

    def setPosition(self, value : int) -> None:
        '''Sets the value.
        :param value: '''
        raise NotImplementedError()

    def setOrientation(self, value : int) -> None:
        '''Sets whether the SpinButton or ScrollBar is oriented vertically or horizontally.
        See :class:`ControlScrollOrientation`
        :param value: '''
        raise NotImplementedError()

    def getSmallChange(self) -> int:
        '''Gets the amount by which the Position property changes'''
        raise NotImplementedError()

    def getPosition(self) -> int:
        '''Gets the value.'''
        raise NotImplementedError()

    def setMax(self, value : int) -> None:
        '''Sets the maximum acceptable value.
        :param value: '''
        raise NotImplementedError()

    def getMin(self) -> int:
        '''Gets the minimum acceptable value.'''
        raise NotImplementedError()


class Spinner:
    '''Represents the Forms control: Spinner.'''

    def getMax(self) -> int:
        '''Gets the maximum value of a scroll bar or spinner range.'''
        raise NotImplementedError()

    def getShadow(self) -> bool:
        '''Indicates whether the shape has 3-D shading.'''
        raise NotImplementedError()

    def setIncrementalChange(self, value : int) -> None:
        '''Sets the amount that the scroll bar or spinner is incremented a line scroll.
        :param value: '''
        raise NotImplementedError()

    def getCurrentValue(self) -> int:
        '''Gets the current value.'''
        raise NotImplementedError()

    def getIncrementalChange(self) -> int:
        '''Gets the amount that the scroll bar or spinner is incremented a line scroll.'''
        raise NotImplementedError()

    def setShadow(self, value : bool) -> None:
        '''Indicates whether the shape has 3-D shading.
        :param value: '''
        raise NotImplementedError()

    def setMin(self, value : int) -> None:
        '''Sets the minimum value of a scroll bar or spinner range.
        :param value: '''
        raise NotImplementedError()

    def setCurrentValue(self, value : int) -> None:
        '''Sets the current value.
        :param value: '''
        raise NotImplementedError()

    def isHorizontal(self) -> bool:
        '''Indicates whether this is a horizontal scroll bar.'''
        raise NotImplementedError()

    def setHorizontal(self, value : bool) -> None:
        '''Indicates whether this is a horizontal scroll bar.
        :param value: '''
        raise NotImplementedError()

    def setMax(self, value : int) -> None:
        '''Sets the maximum value of a scroll bar or spinner range.
        :param value: '''
        raise NotImplementedError()

    def getMin(self) -> int:
        '''Gets the minimum value of a scroll bar or spinner range.'''
        raise NotImplementedError()


class SpreadsheetML2003SaveOptions:
    '''Represents the options for saving Excel 2003 spreadml file.'''

    def getLimitAsXls(self) -> bool:
        '''Limit as xls, the max row index is 65535 and the max column index is 255.'''
        raise NotImplementedError()

    def getExportColumnIndexOfCell(self) -> bool:
        '''The default value is false, it means that column index  will be ignored if the cell is contiguous to the previous cell.'''
        raise NotImplementedError()

    def setLimitAsXls(self, value : bool) -> None:
        '''Limit as xls, the max row index is 65535 and the max column index is 255.
        :param value: '''
        raise NotImplementedError()

    def setIndentedFormatting(self, value : bool) -> None:
        '''Causes child elements to be indented.
        :param value: '''
        raise NotImplementedError()

    def isIndentedFormatting(self) -> bool:
        '''Causes child elements to be indented.'''
        raise NotImplementedError()

    def setExportColumnIndexOfCell(self, value : bool) -> None:
        '''The default value is false, it means that column index  will be ignored if the cell is contiguous to the previous cell.
        :param value: '''
        raise NotImplementedError()


class SqlDataType:
    '''Specifies SQL data type of the parameter. Only valid for ODBC sources.'''

    SQL_UNSIGNED_OFFSET : SqlDataType
    '''sql unsigned offset'''

    SQL_SIGNED_OFFSET : SqlDataType
    '''sql signed offset'''

    SQL_GUID : SqlDataType
    '''sql guid'''

    SQL_W_LONG_VARCHAR : SqlDataType
    '''sql wide long variable char'''

    SQL_W_VARCHAR : SqlDataType
    '''sql wide variable char'''

    SQL_W_CHAR : SqlDataType
    '''sql wide char'''

    SQL_BIT : SqlDataType
    '''sql bit'''

    SQL_TINY_INT : SqlDataType
    '''sql tiny int'''

    SQL_BIG_INT : SqlDataType
    '''sql big int'''

    SQL_LONG_VAR_BINARY : SqlDataType
    '''sql long variable binary'''

    SQL_VAR_BINARY : SqlDataType
    '''sql variable binary'''

    SQL_BINARY : SqlDataType
    '''sql binary'''

    SQL_LONG_VAR_CHAR : SqlDataType
    '''sql long variable char'''

    SQL_UNKNOWN_TYPE : SqlDataType
    '''sql unknown type'''

    SQL_CHAR : SqlDataType
    '''sql char'''

    SQL_NUMERIC : SqlDataType
    '''sql numeric'''

    SQL_DECIMAL : SqlDataType
    '''sql decimal'''

    SQL_INTEGER : SqlDataType
    '''sql integer'''

    SQL_SMALL_INT : SqlDataType
    '''sql small int'''

    SQL_FLOAT : SqlDataType
    '''sql float'''

    SQL_REAL : SqlDataType
    '''sql real'''

    SQL_DOUBLE : SqlDataType
    '''sql double'''

    SQL_TYPE_DATE : SqlDataType
    '''sql date type'''

    SQL_TYPE_TIME : SqlDataType
    '''sql time type'''

    SQL_TYPE_TIMESTAMP : SqlDataType
    '''sql timestamp type'''

    SQL_VAR_CHAR : SqlDataType
    '''sql variable char'''

    SQL_INTERVAL_YEAR : SqlDataType
    '''sql interval year'''

    SQL_INTERVAL_MONTH : SqlDataType
    '''sql interval month'''

    SQL_INTERVAL_DAY : SqlDataType
    '''sql interval day'''

    SQL_INTERVAL_HOUR : SqlDataType
    '''sql interval hour'''

    SQL_INTERVAL_MINUTE : SqlDataType
    '''sql interval minute'''

    SQL_INTERVAL_SECOND : SqlDataType
    '''sql interval second'''

    SQL_INTERVAL_YEAR_TO_MONTH : SqlDataType
    '''sql interval year to month'''

    SQL_INTERVAL_DAY_TO_HOUR : SqlDataType
    '''sql interval day to hour'''

    SQL_INTERVAL_DAY_TO_MINUTE : SqlDataType
    '''sql interval day to minute'''

    SQL_INTERVAL_DAY_TO_SECOND : SqlDataType
    '''sql interval day to second'''

    SQL_INTERVAL_HOUR_TO_MINUTE : SqlDataType
    '''sql interval hour to minute'''

    SQL_INTERVAL_HOUR_TO_SECOND : SqlDataType
    '''sql interval hour to second'''

    SQL_INTERVAL_MINUTE_TO_SECOND : SqlDataType
    '''sql interval minute to second'''


class SqlScriptColumnTypeMap:
    '''Represents column type map.'''

    def getNumbericType(self) -> str:
        '''Gets numeric type in the database.'''
        raise NotImplementedError()

    def getStringType(self) -> str:
        '''Gets string type in the database.'''
        raise NotImplementedError()


class SqlScriptOperatorType:
    '''Represents the type of operating data.'''

    INSERT : SqlScriptOperatorType
    '''Insert data.'''

    UPDATE : SqlScriptOperatorType
    '''Update data.'''

    DELETE : SqlScriptOperatorType
    '''Delete data.'''


class SqlScriptSaveOptions:
    '''Represents the options of saving sql.'''

    def setSheetIndexes(self, value : list[int]) -> None:
        '''Represents the indexes of exported sheets.
        :param value: '''
        raise NotImplementedError()

    def getAddBlankLineBetweenRows(self) -> bool:
        '''Insert blank line between each data.'''
        raise NotImplementedError()

    def hasHeaderRow(self) -> bool:
        '''Indicates whether the range contains header row.'''
        raise NotImplementedError()

    def setOperatorType(self, value : int) -> None:
        '''Sets the operator type of sql.
        See :class:`SqlScriptOperatorType`
        :param value: '''
        raise NotImplementedError()

    def setStartId(self, value : int) -> None:
        '''Sets the start id.
        :param value: '''
        raise NotImplementedError()

    def getPrimaryKey(self) -> int:
        '''Represents which column is primary key of the data table.'''
        raise NotImplementedError()

    def setExportArea(self, value : CellArea) -> None:
        '''Sets the exporting range.
        :param value: '''
        raise NotImplementedError()

    def getSheetIndexes(self) -> list[int]:
        '''Represents the indexes of exported sheets.'''
        raise NotImplementedError()

    def getColumnTypeMap(self) -> SqlScriptColumnTypeMap:
        '''Gets the map of column type for different database.'''
        raise NotImplementedError()

    def getCreateTable(self) -> bool:
        '''Indicates whether exporting sql of creating table.'''
        raise NotImplementedError()

    def getTableName(self) -> str:
        '''Gets the table name.'''
        raise NotImplementedError()

    def getSeparator(self) -> str:
        '''Gets character separator of sql script.'''
        raise NotImplementedError()

    def setTableName(self, value : str) -> None:
        '''Sets the table name.
        :param value: '''
        raise NotImplementedError()

    def setPrimaryKey(self, value : int) -> None:
        '''Represents which column is primary key of the data table.
        :param value: '''
        raise NotImplementedError()

    def setIdName(self, value : str) -> None:
        '''Sets the name of id column.
        :param value: '''
        raise NotImplementedError()

    def getCheckAllDataForColumnType(self) -> bool:
        '''Check all data to find columns' data type.'''
        raise NotImplementedError()

    def getExportAsString(self) -> bool:
        '''Indicates whether exporting all data as string value.'''
        raise NotImplementedError()

    def setCheckIfTableExists(self, value : bool) -> None:
        '''Check if the table name exists before creating
        :param value: '''
        raise NotImplementedError()

    def setColumnTypeMap(self, value : SqlScriptColumnTypeMap) -> None:
        '''Sets the map of column type for different database.
        :param value: '''
        raise NotImplementedError()

    def getIdName(self) -> str:
        '''Gets the name of id column.'''
        raise NotImplementedError()

    def getExportArea(self) -> CellArea:
        '''Gets the exporting range.'''
        raise NotImplementedError()

    def setHasHeaderRow(self, value : bool) -> None:
        '''Indicates whether the range contains header row.
        :param value: '''
        raise NotImplementedError()

    def getStartId(self) -> int:
        '''Gets the start id.'''
        raise NotImplementedError()

    def setAddBlankLineBetweenRows(self, value : bool) -> None:
        '''Insert blank line between each data.
        :param value: '''
        raise NotImplementedError()

    def setCreateTable(self, value : bool) -> None:
        '''Indicates whether exporting sql of creating table.
        :param value: '''
        raise NotImplementedError()

    def setCheckAllDataForColumnType(self, value : bool) -> None:
        '''Check all data to find columns' data type.
        :param value: '''
        raise NotImplementedError()

    def setSeparator(self, value : str) -> None:
        '''Sets character separator of sql script.
        :param value: '''
        raise NotImplementedError()

    def getCheckIfTableExists(self) -> bool:
        '''Check if the table name exists before creating'''
        raise NotImplementedError()

    def getOperatorType(self) -> int:
        '''Gets the operator type of sql.
        See :class:`SqlScriptOperatorType`'''
        raise NotImplementedError()

    def setExportAsString(self, value : bool) -> None:
        '''Indicates whether exporting all data as string value.
        :param value: '''
        raise NotImplementedError()


class StreamProviderOptions:
    '''Represents the stream options.'''

    def getCustomPath(self) -> str:
        '''The user custom path(URL) saved in generated html file for the referred source. If not defined by user, DefaultPath will be used.
        For example, the sheet data will be saved by user to d:/sheet001.htm, the url used in the main html file should be "d:/sheet001.htm" or other valid relative path that can be accessed by the main html file.'''
        raise NotImplementedError()

    def getInputStream(self) -> InputStream:
        '''Gets the input stream to get data.'''
        raise NotImplementedError()

    def setCustomPath(self, value : str) -> None:
        '''The user custom path(URL) saved in generated html file for the referred source. If not defined by user, DefaultPath will be used.
        For example, the sheet data will be saved by user to d:/sheet001.htm, the url used in the main html file should be "d:/sheet001.htm" or other valid relative path that can be accessed by the main html file.
        :param value: '''
        raise NotImplementedError()

    def getStream(self) -> OutputStream:
        '''Gets the output stream to write saved data.'''
        raise NotImplementedError()

    def setStream(self, value : OutputStream) -> None:
        '''Sets the output stream to write saved data.
        :param value: '''
        raise NotImplementedError()

    def setInputStream(self, value : InputStream) -> None:
        '''Sets the input stream to get data.
        :param value: '''
        raise NotImplementedError()

    def getResourceLoadingType(self) -> int:
        '''Gets the type of loading resource.
        See :class:`ResourceLoadingType`'''
        raise NotImplementedError()

    def getDefaultPath(self) -> str:
        '''The default path(URL) saved in generated html file for the referred source.
        For example, the sheet data saved in xxx_files/sheet001.htm, the url used in the main html file should be like "src="xxx_files/sheet001.htm""'''
        raise NotImplementedError()

    def setResourceLoadingType(self, value : int) -> None:
        '''Sets the type of loading resource.
        See :class:`ResourceLoadingType`
        :param value: '''
        raise NotImplementedError()


class Style:
    '''Represents display style of excel document,such as font,color,alignment,border,etc.
    The Style object contains all style attributes (font, number format, alignment, and so on) as properties.'''

    def setHorizontalAlignment(self, value : int) -> None:
        '''Sets the horizontal alignment type of the text in a cell.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def hashCode(self) -> int:
        '''Serves as a hash function for a Style object.'''
        raise NotImplementedError()

    def setPattern(self, value : int) -> None:
        '''Sets the cell background pattern type.
        See :class:`BackgroundType`
        :param value: '''
        raise NotImplementedError()

    def getTwoColorGradient(self) -> list[Object]:
        ''':deprecated: Use Style.GetTwoColorGradientSetting() method instead.'''
        raise NotImplementedError()

    def getForegroundArgbColor(self) -> int:
        '''Gets the foreground color with a 32-bit ARGB value.'''
        raise NotImplementedError()

    def setForegroundThemeColor(self, value : ThemeColor) -> None:
        '''Sets the foreground theme color.
        :param value: '''
        raise NotImplementedError()

    def setPatternColor(self, pattern : int, color1 : Color, color2 : Color) -> None:
        '''Sets the background color.
        :param pattern: :class:`BackgroundType`. The pattern.
        :param color1: The foreground color.
        :param color2: The background color. Only works when pattern is not BackgroundType.None and BackgroundType.Solid.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the style.
        :param value: '''
        raise NotImplementedError()

    def getForegroundThemeColor(self) -> ThemeColor:
        '''Gets the foreground theme color.'''
        raise NotImplementedError()

    def setNumber(self, value : int) -> None:
        '''Sets the display format of numbers and dates. The formatting patterns are different for different regions.
        :param value: '''
        raise NotImplementedError()

    def setVerticalAlignment(self, value : int) -> None:
        '''Sets the vertical alignment type of the text in a cell.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def isAlignmentApplied(self) -> bool:
        '''Indicate whether the alignment formatting should be applied.'''
        raise NotImplementedError()

    def getVerticalAlignment(self) -> int:
        '''Gets the vertical alignment type of the text in a cell.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def getTextDirection(self) -> int:
        '''Represents text reading order.
        See :class:`TextDirectionType`'''
        raise NotImplementedError()

    def copy(self, style : Style) -> None:
        '''Copies data from another style object
        :param style: Source Style object'''
        raise NotImplementedError()

    def setTextDirection(self, value : int) -> None:
        '''Represents text reading order.
        See :class:`TextDirectionType`
        :param value: '''
        raise NotImplementedError()

    def setIndentLevel(self, value : int) -> None:
        '''Represents the indent level for the cell or range. Can only be an integer from 0 to 250.
        :param value: '''
        raise NotImplementedError()

    def getBackgroundArgbColor(self) -> int:
        '''Gets the background color with a 32-bit ARGB value.'''
        raise NotImplementedError()

    def isFormulaHidden(self) -> bool:
        '''Represents if the formula will be hidden when the worksheet is protected.'''
        raise NotImplementedError()

    def getHorizontalAlignment(self) -> int:
        '''Gets the horizontal alignment type of the text in a cell.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determines whether two Style instances are equal.
        :param obj: The Style object to compare with the current Style object.
        :returns: true if the specified Object is equal to the current Object; otherwise, false.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the style.'''
        raise NotImplementedError()

    def getBorders(self) -> BorderCollection:
        '''Gets the :class:`BorderCollection` of the style.'''
        raise NotImplementedError()

    def getInvariantCustom(self) -> str:
        '''Gets the culture-independent pattern string for number format.
        If no number format has been set for this object, null will be returned.
        If number format is builtin, the pattern string corresponding to the builtin number will be returned.'''
        raise NotImplementedError()

    def update(self) -> None:
        '''Apply the named style to the styles of the cells which use this named style.
        It works like clicking the "ok" button after you finished modifying the style.
        Only applies for named style.'''
        raise NotImplementedError()

    def isFontApplied(self) -> bool:
        '''Indicate whether the font formatting should be applied.'''
        raise NotImplementedError()

    def isTextWrapped(self) -> bool:
        '''Gets a value indicating whether the text within a cell is wrapped.'''
        raise NotImplementedError()

    def getIndentLevel(self) -> int:
        '''Represents the indent level for the cell or range. Can only be an integer from 0 to 250.'''
        raise NotImplementedError()

    def isJustifyDistributed(self) -> bool:
        '''Indicates if the cells justified or distributed alignment should be used on the last line of text.'''
        raise NotImplementedError()

    def setGradient(self, value : bool) -> None:
        '''Indicates whether the cell shading is a gradient pattern.
        :param value: '''
        raise NotImplementedError()

    def setBackgroundColor(self, value : Color) -> None:
        '''Sets a style's background color.
        :param value: '''
        raise NotImplementedError()

    def getFont(self) -> Font:
        '''Gets a :meth:`ChartArea.getFont()` object.'''
        raise NotImplementedError()

    def setJustifyDistributed(self, value : bool) -> None:
        '''Indicates if the cells justified or distributed alignment should be used on the last line of text.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setCustom(self, custom : str, builtinPreference : bool) -> None:
        '''Sets the Custom number format string of a cell.
        :param custom: Custom number format string, should be InvariantCulture pattern.
        :param builtinPreference: If given Custom number format string matches one of the built-in number formats'''
        raise NotImplementedError()

    @overload
    def setCustom(self, value : str) -> None:
        '''Represents the custom number format string of this style object.
        If the custom number format is not set(For example, the number format is builtin), "" will be returned.
        :param value: '''
        raise NotImplementedError()

    def isFillApplied(self) -> bool:
        '''Indicate whether the fill formatting should be applied.'''
        raise NotImplementedError()

    @overload
    def setBorder(self, borderType : int, borderStyle : int, borderColor : Color) -> bool:
        '''Sets the borders of the style.
        :param borderType: :class:`BorderType`. The border(s) to be set, can be combination of :class:`BorderType`.
        :param borderStyle: :class:`CellBorderType`. The style of the border.
        :param borderColor: The color of the border.
        :returns: Whether current border settings have been changed.'''
        raise NotImplementedError()

    @overload
    def setBorder(self, borderType : int, borderStyle : int, borderColor : CellsColor) -> bool:
        '''Sets the borders of the style.
        :param borderType: :class:`BorderType`. The border(s) to be set, can be combination of :class:`BorderType`.
        :param borderStyle: :class:`CellBorderType`. The style of the border.
        :param borderColor: The color of the border.
        :returns: Whether current border settings have been changed.'''
        raise NotImplementedError()

    def setBackgroundThemeColor(self, value : ThemeColor) -> None:
        '''Sets the background theme color.
        :param value: '''
        raise NotImplementedError()

    def getRotationAngle(self) -> int:
        '''Represents text rotation angle.'''
        raise NotImplementedError()

    def setFontApplied(self, value : bool) -> None:
        '''Indicate whether the font formatting should be applied.
        :param value: '''
        raise NotImplementedError()

    def setBorderApplied(self, value : bool) -> None:
        '''Indicate whether the border formatting should be applied.
        :param value: '''
        raise NotImplementedError()

    def setTextWrapped(self, value : bool) -> None:
        '''Sets a value indicating whether the text within a cell is wrapped.
        :param value: '''
        raise NotImplementedError()

    def getBackgroundColor(self) -> Color:
        '''Gets a style's background color.'''
        raise NotImplementedError()

    def setLocked(self, value : bool) -> None:
        '''Sets a value indicating whether a cell can be modified or not.
        :param value: '''
        raise NotImplementedError()

    def setRotationAngle(self, value : int) -> None:
        '''Represents text rotation angle.
        :param value: '''
        raise NotImplementedError()

    def hasBorders(self) -> bool:
        '''Checks whether there are borders have been set for the style.'''
        raise NotImplementedError()

    def isDateTime(self) -> bool:
        '''Indicates whether the number format is a date format.'''
        raise NotImplementedError()

    def getNumber(self) -> int:
        '''Gets the display format of numbers and dates. The formatting patterns are different for different regions.'''
        raise NotImplementedError()

    def setForegroundArgbColor(self, value : int) -> None:
        '''Sets the foreground color with a 32-bit ARGB value.
        :param value: '''
        raise NotImplementedError()

    def getBackgroundThemeColor(self) -> ThemeColor:
        '''Gets the background theme color.'''
        raise NotImplementedError()

    def setShrinkToFit(self, value : bool) -> None:
        '''Represents if text automatically shrinks to fit in the available column width.
        :param value: '''
        raise NotImplementedError()

    def isGradient(self) -> bool:
        '''Indicates whether the cell shading is a gradient pattern.'''
        raise NotImplementedError()

    def setFillApplied(self, value : bool) -> None:
        '''Indicate whether the fill formatting should be applied.
        :param value: '''
        raise NotImplementedError()

    def getTwoColorGradientSetting(self) -> TwoColorGradient:
        '''Get the two-color gradient setting.'''
        raise NotImplementedError()

    def getPattern(self) -> int:
        '''Gets the cell background pattern type.
        See :class:`BackgroundType`'''
        raise NotImplementedError()

    def getParentStyle(self) -> Style:
        '''Gets the parent style of this style.'''
        raise NotImplementedError()

    def isProtectionApplied(self) -> bool:
        '''Indicate whether the protection formatting should be applied.'''
        raise NotImplementedError()

    def setProtectionApplied(self, value : bool) -> None:
        '''Indicate whether the protection formatting should be applied.
        :param value: '''
        raise NotImplementedError()

    def getShrinkToFit(self) -> bool:
        '''Represents if text automatically shrinks to fit in the available column width.'''
        raise NotImplementedError()

    def isLocked(self) -> bool:
        '''Gets a value indicating whether a cell can be modified or not.'''
        raise NotImplementedError()

    def setForegroundColor(self, value : Color) -> None:
        '''Sets a style's foreground color.
        :param value: '''
        raise NotImplementedError()

    def isModified(self, modifyFlag : int) -> bool:
        '''Checks whether the specified properties of the style have been modified.
        Used for style of ConditionalFormattings to check whether the specified properties of this style should be used when applying the ConditionalFormattings on a cell.
        :param modifyFlag: :class:`StyleModifyFlag`. Style modified flags
        :returns: true if the specified properties have been modified'''
        raise NotImplementedError()

    def setAlignmentApplied(self, value : bool) -> None:
        '''Indicate whether the alignment formatting should be applied.
        :param value: '''
        raise NotImplementedError()

    def isPercent(self) -> bool:
        '''Indicates whether the number format is a percent format.'''
        raise NotImplementedError()

    def getCultureCustom(self) -> str:
        '''Gets the culture-dependent pattern string for number format.
        If no number format has been set for this object, null will be returned.
        If number format is builtin, the pattern string corresponding to the builtin number will be returned.'''
        raise NotImplementedError()

    def setNumberFormatApplied(self, value : bool) -> None:
        '''Indicate whether the number formatting should be applied.
        :param value: '''
        raise NotImplementedError()

    def setCultureCustom(self, value : str) -> None:
        '''Sets the culture-dependent pattern string for number format.
        If no number format has been set for this object, null will be returned.
        If number format is builtin, the pattern string corresponding to the builtin number will be returned.
        :param value: '''
        raise NotImplementedError()

    def getCustom(self) -> str:
        '''Represents the custom number format string of this style object.
        If the custom number format is not set(For example, the number format is builtin), "" will be returned.'''
        raise NotImplementedError()

    def setBackgroundArgbColor(self, value : int) -> None:
        '''Sets the background color with a 32-bit ARGB value.
        :param value: '''
        raise NotImplementedError()

    def setQuotePrefix(self, value : bool) -> None:
        '''Indicates whether the cell's value starts with single quote mark.
        :param value: '''
        raise NotImplementedError()

    def getForegroundColor(self) -> Color:
        '''Gets a style's foreground color.'''
        raise NotImplementedError()

    def toJson(self) -> str:
        '''Convert :class:`Style` to JSON struct data.'''
        raise NotImplementedError()

    def setFormulaHidden(self, value : bool) -> None:
        '''Represents if the formula will be hidden when the worksheet is protected.
        :param value: '''
        raise NotImplementedError()

    def isBorderApplied(self) -> bool:
        '''Indicate whether the border formatting should be applied.'''
        raise NotImplementedError()

    def isNumberFormatApplied(self) -> bool:
        '''Indicate whether the number formatting should be applied.'''
        raise NotImplementedError()

    def setTwoColorGradient(self, color1 : Color, color2 : Color, gradientStyleType : int, variant : int) -> None:
        '''Sets the specified fill to a two-color gradient.
        :param color1: One gradient color.
        :param color2: Two gradient color.
        :param gradientStyleType: :class:`GradientStyleType`. Gradient shading style.
        :param variant: The gradient variant. Can be a value from 1 through 4, corresponding to one of the four variants on the Gradient tab in the Fill Effects dialog box. If style is GradientStyle.FromCenter, the Variant argument can only be 1 or 2.'''
        raise NotImplementedError()

    def getQuotePrefix(self) -> bool:
        '''Indicates whether the cell's value starts with single quote mark.'''
        raise NotImplementedError()


class StyleFlag:
    '''Represents flags which indicates applied formatting properties.'''

    def setIndent(self, value : bool) -> None:
        '''Indent level setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def setFontScript(self, value : bool) -> None:
        '''Font script setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def setNumberFormat(self, value : bool) -> None:
        '''Number format setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def setFontColor(self, value : bool) -> None:
        '''Font color setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def getLeftBorder(self) -> bool:
        '''Left border settings will be applied.'''
        raise NotImplementedError()

    def getRightBorder(self) -> bool:
        '''Right border settings will be applied.'''
        raise NotImplementedError()

    def setFontUnderline(self, value : bool) -> None:
        '''Font underline setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def getFontBold(self) -> bool:
        '''Font bold setting will be applied.'''
        raise NotImplementedError()

    def setHideFormula(self, value : bool) -> None:
        '''Hide formula setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def setCellShading(self, value : bool) -> None:
        '''Cell shading setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def setFontStrike(self, value : bool) -> None:
        '''Font strikeout setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def getLocked(self) -> bool:
        '''Locked setting will be applied.'''
        raise NotImplementedError()

    def getTopBorder(self) -> bool:
        '''Top border settings will be applied.'''
        raise NotImplementedError()

    def setBorders(self, value : bool) -> None:
        '''All borders settings will be applied.
        :param value: '''
        raise NotImplementedError()

    def getFontSize(self) -> bool:
        '''Font size setting will be applied.'''
        raise NotImplementedError()

    def getBottomBorder(self) -> bool:
        '''Bottom border settings will be applied.'''
        raise NotImplementedError()

    def setDiagonalUpBorder(self, value : bool) -> None:
        '''Diagonal up border settings will be applied.
        :param value: '''
        raise NotImplementedError()

    def getAll(self) -> bool:
        '''All properties will be applied.'''
        raise NotImplementedError()

    def setAlignments(self, value : bool) -> None:
        '''Alignment setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def setTextDirection(self, value : bool) -> None:
        '''Text direction setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def getWrapText(self) -> bool:
        '''Wrap text setting will be applied.'''
        raise NotImplementedError()

    def setLocked(self, value : bool) -> None:
        '''Locked setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def setShrinkToFit(self, value : bool) -> None:
        '''Shrink to fit setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def getDiagonalUpBorder(self) -> bool:
        '''Diagonal up border settings will be applied.'''
        raise NotImplementedError()

    def getFontName(self) -> bool:
        '''Font name setting will be applied.'''
        raise NotImplementedError()

    def setFontItalic(self, value : bool) -> None:
        '''Font italic setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def setFontBold(self, value : bool) -> None:
        '''Font bold setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def getHideFormula(self) -> bool:
        '''Hide formula setting will be applied.'''
        raise NotImplementedError()

    def getCellShading(self) -> bool:
        '''Cell shading setting will be applied.'''
        raise NotImplementedError()

    def getDiagonalDownBorder(self) -> bool:
        '''Diagonal down border settings will be applied.'''
        raise NotImplementedError()

    def getFont(self) -> bool:
        '''Font settings will be applied.'''
        raise NotImplementedError()

    def setHorizontalAlignment(self, value : bool) -> None:
        '''Horizontal alignment setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def setFont(self, value : bool) -> None:
        '''Font settings will be applied.
        :param value: '''
        raise NotImplementedError()

    def setAll(self, value : bool) -> None:
        '''All properties will be applied.
        :param value: '''
        raise NotImplementedError()

    def setFontSize(self, value : bool) -> None:
        '''Font size setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def getRotation(self) -> bool:
        '''Rotation setting will be applied.'''
        raise NotImplementedError()

    def setLeftBorder(self, value : bool) -> None:
        '''Left border settings will be applied.
        :param value: '''
        raise NotImplementedError()

    def setWrapText(self, value : bool) -> None:
        '''Wrap text setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def getShrinkToFit(self) -> bool:
        '''Shrink to fit setting will be applied.'''
        raise NotImplementedError()

    def setFontName(self, value : bool) -> None:
        '''Font name setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def setBottomBorder(self, value : bool) -> None:
        '''Bottom border settings will be applied.
        :param value: '''
        raise NotImplementedError()

    def setVerticalAlignment(self, value : bool) -> None:
        '''Vertical alignment setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def getFontUnderline(self) -> bool:
        '''Font underline setting will be applied.'''
        raise NotImplementedError()

    def getFontScript(self) -> bool:
        '''Font script setting will be applied.'''
        raise NotImplementedError()

    def setTopBorder(self, value : bool) -> None:
        '''Top border settings will be applied.
        :param value: '''
        raise NotImplementedError()

    def getFontColor(self) -> bool:
        '''Font color setting will be applied.'''
        raise NotImplementedError()

    def getHorizontalAlignment(self) -> bool:
        '''Horizontal alignment setting will be applied.'''
        raise NotImplementedError()

    def setQuotePrefix(self, value : bool) -> None:
        '''Hide formula setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def getBorders(self) -> bool:
        '''All borders settings will be applied.'''
        raise NotImplementedError()

    def setRotation(self, value : bool) -> None:
        '''Rotation setting will be applied.
        :param value: '''
        raise NotImplementedError()

    def getNumberFormat(self) -> bool:
        '''Number format setting will be applied.'''
        raise NotImplementedError()

    def getTextDirection(self) -> bool:
        '''Text direction setting will be applied.'''
        raise NotImplementedError()

    def getFontStrike(self) -> bool:
        '''Font strikeout setting will be applied.'''
        raise NotImplementedError()

    def setRightBorder(self, value : bool) -> None:
        '''Right border settings will be applied.
        :param value: '''
        raise NotImplementedError()

    def getAlignments(self) -> bool:
        '''Alignment setting will be applied.'''
        raise NotImplementedError()

    def getIndent(self) -> bool:
        '''Indent level setting will be applied.'''
        raise NotImplementedError()

    def getQuotePrefix(self) -> bool:
        '''Hide formula setting will be applied.'''
        raise NotImplementedError()

    def getFontItalic(self) -> bool:
        '''Font italic setting will be applied.'''
        raise NotImplementedError()

    def getVerticalAlignment(self) -> bool:
        '''Vertical alignment setting will be applied.'''
        raise NotImplementedError()

    def setDiagonalDownBorder(self, value : bool) -> None:
        '''Diagonal down border settings will be applied.
        :param value: '''
        raise NotImplementedError()


class StyleModifyFlag:
    '''The style modified flags.'''

    LEFT_BORDER : StyleModifyFlag
    '''Indicates whether left border has been modified for the style.'''

    RIGHT_BORDER : StyleModifyFlag
    '''Indicates whether right border has been modified for the style.'''

    TOP_BORDER : StyleModifyFlag
    '''Indicates whether top border has been modified for the style.'''

    BOTTOM_BORDER : StyleModifyFlag
    '''Indicates whether bottom border has been modified for the style.'''

    DIAGONAL_DOWN_BORDER : StyleModifyFlag
    '''Indicates whether diagonal-down border has been modified for the style.'''

    DIAGONAL_UP_BORDER : StyleModifyFlag
    '''Indicates whether diagonal-up border has been modified for the style.'''

    DIAGONAL : StyleModifyFlag
    '''Indicates whether one or more diagonal borders(:attr:`StyleModifyFlag.DIAGONAL_DOWN_BORDER`,
    :attr:`StyleModifyFlag.DIAGONAL_UP_BORDER`) have been modified for the style.'''

    HORIZONTAL_BORDER : StyleModifyFlag
    '''Indicates whether horizontal border has been modified for the style.
    Only for dynamic style, such as conditional formatting.'''

    VERTICAL_BORDER : StyleModifyFlag
    '''Indicates whether vertical border has been modified for the style.
    Only for dynamic style, such as conditional formatting.'''

    BORDERS : StyleModifyFlag
    '''Indicates whether one or more borders(:attr:`StyleModifyFlag.LEFT_BORDER`,
    :attr:`StyleModifyFlag.RIGHT_BORDER`, :attr:`StyleModifyFlag.TOP_BORDER`, :attr:`StyleModifyFlag.BOTTOM_BORDER`,
    :attr:`StyleModifyFlag.DIAGONAL`, :attr:`StyleModifyFlag.HORIZONTAL_BORDER`, :attr:`StyleModifyFlag.VERTICAL_BORDER`)
    have been modified for the style.'''

    NUMBER_FORMAT : StyleModifyFlag
    '''Indicates whether numberformat has been modified.'''

    HORIZONTAL_ALIGNMENT : StyleModifyFlag
    '''Indicates whether horizontal alignment has been modified.'''

    VERTICAL_ALIGNMENT : StyleModifyFlag
    '''Indicates whether vertical alignment has been modified.'''

    INDENT : StyleModifyFlag
    '''Indicates whether indent property has been modified.'''

    ROTATION : StyleModifyFlag
    '''Indicates whether rotation property has been modified.'''

    WRAP_TEXT : StyleModifyFlag
    '''Indicates whether wrap text property has been modified.'''

    SHRINK_TO_FIT : StyleModifyFlag
    '''Indicates whether shrink to fit property has been modified.'''

    TEXT_DIRECTION : StyleModifyFlag
    '''Indicates whether text direction property has been modified.'''

    RELATIVE_INDENT : StyleModifyFlag
    '''Indicates whether relative indent property has been modified for the style.
    Only for dynamic style, such as conditional formatting.'''

    ALIGNMENT_SETTINGS : StyleModifyFlag
    '''Indicates whether one or more alignment-related properties(:attr:`StyleModifyFlag.HORIZONTAL_ALIGNMENT`,
    :attr:`StyleModifyFlag.VERTICAL_ALIGNMENT`, :attr:`StyleModifyFlag.ROTATION`, :attr:`StyleModifyFlag.WRAP_TEXT`,
    :attr:`StyleModifyFlag.WRAP_TEXT`, :attr:`StyleModifyFlag.INDENT`, :attr:`StyleModifyFlag.SHRINK_TO_FIT`, :attr:`StyleModifyFlag.TEXT_DIRECTION`,
    :attr:`StyleModifyFlag.RELATIVE_INDENT`) have been modified.'''

    PATTERN : StyleModifyFlag
    '''Indicates whether pattern of the shading has been modified.'''

    FOREGROUND_COLOR : StyleModifyFlag
    '''Indicates whether foreground color has been modified.'''

    BACKGROUND_COLOR : StyleModifyFlag
    '''Indicates whether background color has been modified.'''

    CELL_SHADING : StyleModifyFlag
    '''Indicates whether one or more shading-related properties(:attr:`StyleModifyFlag.PATTERN`,
    :attr:`StyleModifyFlag.FOREGROUND_COLOR`, :attr:`StyleModifyFlag.BACKGROUND_COLOR`) have been modified.'''

    LOCKED : StyleModifyFlag
    '''Indicates whether locked property has been modified.'''

    HIDE_FORMULA : StyleModifyFlag
    '''Indicates whether hide formula has been modified.'''

    PROTECTION_SETTINGS : StyleModifyFlag
    '''Indicates whether one or more protection-related properties(:attr:`StyleModifyFlag.LOCKED`,
    :attr:`StyleModifyFlag.HIDE_FORMULA`) have been modified.'''

    FONT_SIZE : StyleModifyFlag
    '''Indicates whether font size has been modified.'''

    FONT_NAME : StyleModifyFlag
    '''Indicates whether font name has been modified.'''

    FONT_COLOR : StyleModifyFlag
    '''Indicates whether font color has been modified.'''

    FONT_WEIGHT : StyleModifyFlag
    '''Indicates whether font weight has been modified.'''

    FONT_ITALIC : StyleModifyFlag
    '''Indicates whether italic property of font has been modified.'''

    FONT_UNDERLINE : StyleModifyFlag
    '''Indicates whether underline property of font has been modified.'''

    FONT_STRIKE : StyleModifyFlag
    '''Indicates whether strike property font has been modified.'''

    FONT_SCRIPT : StyleModifyFlag
    '''Indicates whether subscript or superscript property of font has been modified.'''

    FONT_FAMILY : StyleModifyFlag
    '''Indicates whether font family has been modified.'''

    FONT_CHARSET : StyleModifyFlag
    '''Indicates whether charset of the font has been modified.'''

    FONT_SCHEME : StyleModifyFlag
    '''unused.'''

    FONT_DIRTY : StyleModifyFlag
    '''unused.'''

    FONT_SPELLING_ERROR : StyleModifyFlag
    '''unused.'''

    FONT_U_FILL_TX : StyleModifyFlag
    '''unused.'''

    FONT_SPACING : StyleModifyFlag
    '''unused.'''

    FONT_KERNING : StyleModifyFlag
    '''unused.'''

    FONT_EQUALIZE : StyleModifyFlag
    '''unused.'''

    FONT_CAP : StyleModifyFlag
    '''unused.'''

    FONT_VERTICAL_TEXT : StyleModifyFlag
    ''''''

    FONT : StyleModifyFlag
    '''Indicates whether one or more properties have been modified for the font of the style.'''

    ALL : StyleModifyFlag
    '''Indicates whether one or more properties have been modified for the style.'''


class SubSupEquationNode:
    '''This class specifies an equation that can optionally be superscript or subscript.
    There are four main forms of this equation, superscriptubscriptuperscript and subscript placed to the left of the base, superscript and subscript placed to the right of the base.'''

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class SubtotalSetting:
    '''Represents the setting of the subtotal .'''

    def getTotalList(self) -> list[int]:
        '''An array of zero-based field offsets, indicating the fields to which the subtotals are added.'''
        raise NotImplementedError()

    def getSubtotalFunction(self) -> int:
        '''The subtotal function.
        See :class:`ConsolidationFunction`'''
        raise NotImplementedError()

    def getGroupBy(self) -> int:
        '''The field to group by, as a zero-based integer offset'''
        raise NotImplementedError()

    def getSummaryBelowData(self) -> bool:
        '''Indicates whether add summary below data.'''
        raise NotImplementedError()


class SvgSaveOptions:
    '''Represents Svg save options.
    For advanced usage, please use :class:`WorkbookRender` or :class:`SheetRender`.'''

    def getSheetIndex(self) -> int:
        ''':deprecated: Use ImageSaveOptions.ImageOrPrintOptions.SheetSet instead.'''
        raise NotImplementedError()

    def setSheetIndex(self, value : int) -> None:
        ''':deprecated: Use ImageSaveOptions.ImageOrPrintOptions.SheetSet instead.'''
        raise NotImplementedError()


class SxRng:
    '''Represents Group Range in a PivotField.'''

    def getEnd(self) -> Object:
        '''Represents the end object for the group range.'''
        raise NotImplementedError()

    def getGroupByTypes(self) -> list[bool]:
        '''Represents the group type for the group range.
        rangeofvalue Seconds Minutes Hours Days Months Quarters Years'''
        raise NotImplementedError()

    def getBy(self) -> Object:
        '''Represents the interval object for the group range.'''
        raise NotImplementedError()

    def getStart(self) -> Object:
        '''Represents the start object for the group range.'''
        raise NotImplementedError()

    def isAutoEnd(self) -> Object:
        '''Specifies a boolean value that indicates whether the application will use the source data to set the end range value.'''
        raise NotImplementedError()

    def isAutoStart(self) -> Object:
        '''Specifies a boolean value that indicates whether the application will use the source data to set the beginning range value.'''
        raise NotImplementedError()


class SystemTimeInterruptMonitor:
    '''Simple implementation of :class:`AbstractInterruptMonitor` by checking and comparing current system time with user specified limit.'''

    def getTerminateWithoutException(self) -> bool:
        '''See :meth:`AbstractInterruptMonitor.getTerminateWithoutException()`.
        This property is specified by user when constructing this monitor instance.'''
        raise NotImplementedError()

    def startMonitor(self, msLimit : int) -> None:
        '''Starts the monitor with the specified time limit. The start time to calculate time cost is just when this method is called,
        so the procedure which needs to be monitored should be started just after this call.
        :param msLimit: time limit(ms) to require the interruption.'''
        raise NotImplementedError()

    def isInterruptionRequested(self) -> bool:
        '''This implementation just checks whether the time cost(from the time when starting this monitor to now) is greater than user specified limit.'''
        raise NotImplementedError()


class TableDataSourceType:
    '''Represents the table's data source type.'''

    WORKSHEET : TableDataSourceType
    '''Excel Worksheet Table'''

    SHARE_POINT : TableDataSourceType
    '''Read-write SharePoint linked List'''

    XML : TableDataSourceType
    '''XML mapper Table'''

    QUERY_TABLE : TableDataSourceType
    '''Query Table'''


class TableStyle:
    '''Represents the table style.'''

    def getName(self) -> str:
        '''Gets the name of table style.'''
        raise NotImplementedError()

    def getTableStyleElements(self) -> TableStyleElementCollection:
        '''Gets all elements of the table style.'''
        raise NotImplementedError()


class TableStyleCollection:
    '''Represents all custom table styles.'''

    def addPivotTableStyle(self, name : str) -> int:
        '''Adds a custom pivot table style.
        :param name: The pivot table style name.
        :returns: The index of the pivot table style.'''
        raise NotImplementedError()

    def getBuiltinTableStyle(self, type : int) -> TableStyle:
        '''Gets the builtin table style
        :param type: :class:`TableStyleType`. The builtin table style type.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> TableStyle:
        '''Gets the table style by the index.
        :param index: The position of the table style in the list.
        :returns: The table style object.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> TableStyle:
        '''Gets the table style by the name.
        :param name: The table style name.
        :returns: The table style object.'''
        raise NotImplementedError()

    def setDefaultPivotStyleName(self, value : str) -> None:
        '''Sets the  default style name of pivot table .
        :param value: '''
        raise NotImplementedError()

    def getDefaultPivotStyleName(self) -> str:
        '''Gets the  default style name of pivot table .'''
        raise NotImplementedError()

    def addTableStyle(self, name : str) -> int:
        '''Adds a custom table style.
        :param name: The table style name.
        :returns: The index of the table style.'''
        raise NotImplementedError()

    def setDefaultTableStyleName(self, value : str) -> None:
        '''Sets the default style name of the table.
        :param value: '''
        raise NotImplementedError()

    def getDefaultTableStyleName(self) -> str:
        '''Gets the default style name of the table.'''
        raise NotImplementedError()


class TableStyleElement:
    '''Represents the element of the table style.'''

    def setElementStyle(self, style : Style) -> None:
        '''Sets the element style.
        :param style: The element style.'''
        raise NotImplementedError()

    def getElementStyle(self) -> Style:
        '''Gets the element style.'''
        raise NotImplementedError()

    def getSize(self) -> int:
        '''Number of rows or columns in a single band of striping.
        Applies only when type is firstRowStripe, secondRowStripe, firstColumnStripe, or secondColumnStripe.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the element type.
        See :class:`TableStyleElementType`'''
        raise NotImplementedError()

    def setSize(self, value : int) -> None:
        '''Number of rows or columns in a single band of striping.
        Applies only when type is firstRowStripe, secondRowStripe, firstColumnStripe, or secondColumnStripe.
        :param value: '''
        raise NotImplementedError()


class TableStyleElementCollection:
    '''Represents all elements of the table style.'''

    def getTableStyleElementWithType(self, type : int) -> TableStyleElement:
        ''':deprecated: Use Aspose.Cells.Tables.TableStyleElementCollection.this[TableStyleElementType type] property instead.'''
        raise NotImplementedError()

    def get(self, index : int) -> TableStyleElement:
        '''Gets an element of the table style by the index.
        :param index: The index.
        :returns: Returns :class:`TableStyleElement` object'''
        raise NotImplementedError()

    def getTableStyleElementWithIndex(self, index : int) -> TableStyleElement:
        ''':deprecated: Use Aspose.Cells.Tables.TableStyleElementCollection.this[int index] property instead.'''
        raise NotImplementedError()

    def add(self, type : int) -> int:
        '''Adds an element.
        :param type: :class:`TableStyleElementType`. The type of the element
        :returns: Returns the index of the element in the list.'''
        raise NotImplementedError()

    def getByTableStyleElementType(self, type : int) -> TableStyleElement:
        '''Gets the element of the table style by the element type.
        :param type: :class:`TableStyleElementType`. The element type.
        :returns: Returns :class:`TableStyleElement` object'''
        raise NotImplementedError()


class TableStyleElementType:
    '''Represents the Table or PivotTable style element type.'''

    BLANK_ROW : TableStyleElementType
    '''Table style element that applies to PivotTable's blank rows.'''

    FIRST_COLUMN : TableStyleElementType
    '''Table style element that applies to table's first column.'''

    FIRST_COLUMN_STRIPE : TableStyleElementType
    '''Table style element that applies to table's first column stripes.'''

    FIRST_COLUMN_SUBHEADING : TableStyleElementType
    '''Table style element that applies to PivotTable's first column subheading.'''

    FIRST_HEADER_CELL : TableStyleElementType
    '''Table style element that applies to table's first header row cell.'''

    FIRST_ROW_STRIPE : TableStyleElementType
    '''Table style element that applies to table's first row stripes.'''

    FIRST_ROW_SUBHEADING : TableStyleElementType
    '''Table style element that applies to PivotTable's first row subheading.'''

    FIRST_SUBTOTAL_COLUMN : TableStyleElementType
    '''Table style element that applies to PivotTable's first subtotal column.'''

    FIRST_SUBTOTAL_ROW : TableStyleElementType
    '''Table style element that applies to pivot table's first subtotal row.'''

    GRAND_TOTAL_COLUMN : TableStyleElementType
    '''Table style element that applies to pivot table's grand total column.'''

    GRAND_TOTAL_ROW : TableStyleElementType
    '''Table style element that applies to pivot table's grand total row.'''

    FIRST_TOTAL_CELL : TableStyleElementType
    '''Table style element that applies to table's first total row cell.'''

    HEADER_ROW : TableStyleElementType
    '''Table style element that applies to table's header row.'''

    LAST_COLUMN : TableStyleElementType
    '''Table style element that applies to table's last column.'''

    LAST_HEADER_CELL : TableStyleElementType
    '''Table style element that applies to table's last header row cell.'''

    LAST_TOTAL_CELL : TableStyleElementType
    '''Table style element that applies to table's last total row cell.'''

    PAGE_FIELD_LABELS : TableStyleElementType
    '''Table style element that applies to pivot table's page field labels.'''

    PAGE_FIELD_VALUES : TableStyleElementType
    '''Table style element that applies to pivot table's page field values.'''

    SECOND_COLUMN_STRIPE : TableStyleElementType
    '''Table style element that applies to table's second column stripes.'''

    SECOND_COLUMN_SUBHEADING : TableStyleElementType
    '''Table style element that applies to pivot table's second column subheading.'''

    SECOND_ROW_STRIPE : TableStyleElementType
    '''Table style element that applies to table's second row stripes.'''

    SECOND_ROW_SUBHEADING : TableStyleElementType
    '''Table style element that applies to pivot table's second row subheading.'''

    SECOND_SUBTOTAL_COLUMN : TableStyleElementType
    '''Table style element that applies to PivotTable's second subtotal column.'''

    SECOND_SUBTOTAL_ROW : TableStyleElementType
    '''Table style element that applies to PivotTable's second subtotal row.'''

    THIRD_COLUMN_SUBHEADING : TableStyleElementType
    '''Table style element that applies to PivotTable's third column subheading.'''

    THIRD_ROW_SUBHEADING : TableStyleElementType
    '''Table style element that applies to PivotTable's third row subheading.'''

    THIRD_SUBTOTAL_COLUMN : TableStyleElementType
    '''Table style element that applies to pivot table's third subtotal column.'''

    THIRD_SUBTOTAL_ROW : TableStyleElementType
    '''Table style element that applies to PivotTable's third subtotal row.'''

    TOTAL_ROW : TableStyleElementType
    '''Table style element that applies to table's total row.'''

    WHOLE_TABLE : TableStyleElementType
    '''Table style element that applies to table's entire content.'''


class TableStyleType:
    '''Represents the built-in table style type.'''

    NONE : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_1 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_2 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_3 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_4 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_5 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_6 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_7 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_8 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_9 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_10 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_11 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_12 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_13 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_14 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_15 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_16 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_17 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_18 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_19 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_20 : TableStyleType
    ''''''

    TABLE_STYLE_LIGHT_21 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_1 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_2 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_3 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_4 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_5 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_6 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_7 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_8 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_9 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_10 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_11 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_12 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_13 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_14 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_15 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_16 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_17 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_18 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_19 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_20 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_21 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_22 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_23 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_24 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_25 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_26 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_27 : TableStyleType
    ''''''

    TABLE_STYLE_MEDIUM_28 : TableStyleType
    ''''''

    TABLE_STYLE_DARK_1 : TableStyleType
    ''''''

    TABLE_STYLE_DARK_2 : TableStyleType
    ''''''

    TABLE_STYLE_DARK_3 : TableStyleType
    ''''''

    TABLE_STYLE_DARK_4 : TableStyleType
    ''''''

    TABLE_STYLE_DARK_5 : TableStyleType
    ''''''

    TABLE_STYLE_DARK_6 : TableStyleType
    ''''''

    TABLE_STYLE_DARK_7 : TableStyleType
    ''''''

    TABLE_STYLE_DARK_8 : TableStyleType
    ''''''

    TABLE_STYLE_DARK_9 : TableStyleType
    ''''''

    TABLE_STYLE_DARK_10 : TableStyleType
    ''''''

    TABLE_STYLE_DARK_11 : TableStyleType
    ''''''

    CUSTOM : TableStyleType
    ''''''


class TableToRangeOptions:
    '''Represents the options when converting table to range.'''

    def setLastRow(self, value : int) -> None:
        '''Sets the last row index of the table.
        :param value: '''
        raise NotImplementedError()

    def getLastRow(self) -> int:
        '''Gets the last row index of the table.'''
        raise NotImplementedError()


class TargetModeType:
    '''Represents the type of target mode.'''

    EXTERNAL : TargetModeType
    '''External link'''

    FILE_PATH : TargetModeType
    '''Local and full paths to files or folders.'''

    EMAIL : TargetModeType
    '''Email.'''

    CELL_REFERENCE : TargetModeType
    '''Link on cell or named range.'''


class TextAlignmentType:
    '''Enumerates text alignment types.'''

    GENERAL : TextAlignmentType
    '''Represents general text alignment.'''

    BOTTOM : TextAlignmentType
    '''Represents bottom text alignment.'''

    CENTER : TextAlignmentType
    '''Represents center text alignment.'''

    CENTER_ACROSS : TextAlignmentType
    '''Represents center across text alignment.'''

    DISTRIBUTED : TextAlignmentType
    '''Represents distributed text alignment.'''

    FILL : TextAlignmentType
    '''Represents fill text alignment.'''

    JUSTIFY : TextAlignmentType
    '''Represents justify text alignment.'''

    LEFT : TextAlignmentType
    '''Represents left text alignment.'''

    RIGHT : TextAlignmentType
    '''Represents right text alignment.'''

    TOP : TextAlignmentType
    '''Represents top text alignment.'''

    JUSTIFIED_LOW : TextAlignmentType
    '''Aligns the text with an adjusted kashida length for Arabic text.'''

    THAI_DISTRIBUTED : TextAlignmentType
    '''Distributes Thai text specially, because each character is treated as a word.'''


class TextAutonumberScheme:
    '''Represents all automatic number scheme.'''

    NONE : TextAutonumberScheme
    ''''''

    ALPHA_LC_PAREN_BOTH : TextAutonumberScheme
    '''(a), (b), (c), ?'''

    ALPHA_LC_PAREN_R : TextAutonumberScheme
    '''a), b), c), ?'''

    ALPHA_LC_PERIOD : TextAutonumberScheme
    '''a., b., c., ?*'''

    ALPHA_UC_PAREN_BOTH : TextAutonumberScheme
    '''(A), (B), (C), ?'''

    ALPHA_UC_PAREN_R : TextAutonumberScheme
    '''A), B), C), ?'''

    ALPHA_UC_PERIOD : TextAutonumberScheme
    '''A., B., C., ?'''

    ARABIC_1_MINUS : TextAutonumberScheme
    '''Bidi Arabic 1 (AraAlpha) with ANSI minus symbol'''

    ARABIC_2_MINUS : TextAutonumberScheme
    '''Bidi Arabic 2 (AraAbjad) with ANSI minus symbol'''

    ARABIC_DB_PERIOD : TextAutonumberScheme
    '''Dbl-byte Arabic numbers w/ double-byte period'''

    ARABIC_DB_PLAIN : TextAutonumberScheme
    '''Dbl-byte Arabic numbers'''

    ARABIC_PAREN_BOTH : TextAutonumberScheme
    '''(1), (2), (3), ?'''

    ARABIC_PAREN_R : TextAutonumberScheme
    '''1), 2), 3), ?'''

    ARABIC_PERIOD : TextAutonumberScheme
    '''1., 2., 3., ?'''

    ARABIC_PLAIN : TextAutonumberScheme
    '''1, 2, 3, ?'''

    CIRCLE_NUM_DB_PLAIN : TextAutonumberScheme
    '''Dbl-byte circle numbers (1-10 circle[0x2460-], 11-arabic numbers)'''

    CIRCLE_NUM_WD_BLACK_PLAIN : TextAutonumberScheme
    '''Wingdings black circle numbers'''

    CIRCLE_NUM_WD_WHITE_PLAIN : TextAutonumberScheme
    '''Wingdings white circle numbers (0-10 circle[0x0080-],11- arabic numbers)'''

    EA_1_CHS_PERIOD : TextAutonumberScheme
    '''EA: Simplified Chinese w/ single-byte period'''

    EA_1_CHS_PLAIN : TextAutonumberScheme
    '''EA: Simplified Chinese (TypeA 1-99, TypeC 100-)'''

    EA_1_CHT_PERIOD : TextAutonumberScheme
    '''EA: Traditional Chinese w/ single-byte period'''

    EA_1_CHT_PLAIN : TextAutonumberScheme
    '''EA: Traditional Chinese (TypeA 1-19, TypeC 20-)'''

    EA_1_JPN_CHS_DB_PERIOD : TextAutonumberScheme
    '''EA: Japanese w/ double-byte period'''

    EA_1_JPN_KOR_PERIOD : TextAutonumberScheme
    '''EA: Japanese/Korean w/ single-byte period'''

    EA_1_JPN_KOR_PLAIN : TextAutonumberScheme
    '''EA: Japanese/Korean (TypeC 1-)'''

    HEBREW_2_MINUS : TextAutonumberScheme
    '''Bidi Hebrew 2 with ANSI minus symbol'''

    HINDI_ALPHA_1_PERIOD : TextAutonumberScheme
    '''Hindi alphabet period - consonants'''

    HINDI_ALPHA_PERIOD : TextAutonumberScheme
    '''Hindi alphabet period - vowels'''

    HINDI_NUM_PAREN_R : TextAutonumberScheme
    '''Hindi numerical parentheses - right'''

    HINDI_NUM_PERIOD : TextAutonumberScheme
    '''Hindi numerical period'''

    ROMAN_LC_PAREN_BOTH : TextAutonumberScheme
    '''(i), (ii), (iii), ?'''

    ROMAN_LC_PAREN_R : TextAutonumberScheme
    '''i), ii), iii), ?'''

    ROMAN_LC_PERIOD : TextAutonumberScheme
    '''i., ii., iii., ?'''

    ROMAN_UC_PAREN_BOTH : TextAutonumberScheme
    '''(I), (II), (III), ?'''

    ROMAN_UC_PAREN_R : TextAutonumberScheme
    '''I), II), III), ?'''

    ROMAN_UC_PERIOD : TextAutonumberScheme
    '''I., II., III., ?'''

    THAI_ALPHA_PAREN_BOTH : TextAutonumberScheme
    '''Thai alphabet parentheses - both'''

    THAI_ALPHA_PAREN_R : TextAutonumberScheme
    '''Thai alphabet parentheses - right'''

    THAI_ALPHA_PERIOD : TextAutonumberScheme
    '''Thai alphabet period'''

    THAI_NUM_PAREN_BOTH : TextAutonumberScheme
    '''Thai numerical parentheses - both'''

    THAI_NUM_PAREN_R : TextAutonumberScheme
    '''Thai numerical parentheses - right'''

    THAI_NUM_PERIOD : TextAutonumberScheme
    '''Thai numerical period'''


class TextBox:
    '''Encapsulates the object that represents a textbox in a spreadsheet.'''

    @overload
    def getEquationParagraph(self, index : int) -> EquationNode:
        '''Get the specified math paragraph from the TextBody property of the TextBox object.
        Notice:
        (1) Returns NULL when the index is out of bounds or not found.
        (2) Also returns NULL if the specified index position is not a math paragraph.
        :param index: The position index of the math paragraph, starting from 0.
        :returns: Returns the math paragraph specified by index.'''
        raise NotImplementedError()

    @overload
    def getEquationParagraph(self) -> EquationNode:
        '''Gets the first math paragraph from the TextBody property of the TextBox object.'''
        raise NotImplementedError()


class TextBoxActiveXControl:
    '''Represents a text box ActiveX control.'''

    def getText(self) -> str:
        '''Gets text of the control.'''
        raise NotImplementedError()

    def setSpecialEffect(self, value : int) -> None:
        '''Sets the special effect of the control.
        See :class:`ControlSpecialEffectType`
        :param value: '''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''Sets text of the control.
        :param value: '''
        raise NotImplementedError()

    def isEditable(self) -> bool:
        '''Indicates whether the user can type into the control.'''
        raise NotImplementedError()

    def setWordWrapped(self, value : bool) -> None:
        '''Indicates whether the contents of the control automatically wrap at the end of a line.
        :param value: '''
        raise NotImplementedError()

    def setBorderStyle(self, value : int) -> None:
        '''Sets the type of border used by the control.
        See :class:`ControlBorderType`
        :param value: '''
        raise NotImplementedError()

    def setBorderOleColor(self, value : int) -> None:
        '''Sets the ole color of the background.
        :param value: '''
        raise NotImplementedError()

    def setEnterKeyBehavior(self, value : bool) -> None:
        '''Specifies the behavior of the ENTER key.
        True specifies that pressing ENTER will create a new line.
        False specifies that pressing ENTER will move the focus to the next object in the tab order.
        :param value: '''
        raise NotImplementedError()

    def setAutoWordSelected(self, value : bool) -> None:
        '''Specifies the basic unit used to extend a selection.
        True specifies that the basic unit is a single character.
        false specifies that the basic unit is a whole word.
        :param value: '''
        raise NotImplementedError()

    def isMultiLine(self) -> bool:
        '''Indicates whether the control can display more than one line of text.'''
        raise NotImplementedError()

    def setHideSelection(self, value : bool) -> None:
        '''Indicates whether selected text in the control appears highlighted when the control does not have focus.
        :param value: '''
        raise NotImplementedError()

    def getEnterKeyBehavior(self) -> bool:
        '''Specifies the behavior of the ENTER key.
        True specifies that pressing ENTER will create a new line.
        False specifies that pressing ENTER will move the focus to the next object in the tab order.'''
        raise NotImplementedError()

    def getMaxLength(self) -> int:
        '''Gets the maximum number of characters'''
        raise NotImplementedError()

    def setPasswordChar(self, value : str) -> None:
        '''Sets a character to be displayed in place of the characters entered.
        :param value: '''
        raise NotImplementedError()

    def getDropButtonStyle(self) -> int:
        '''Specifies the symbol displayed on the drop button
        See :class:`DropButtonStyle`'''
        raise NotImplementedError()

    def getBorderStyle(self) -> int:
        '''Gets the type of border used by the control.
        See :class:`ControlBorderType`'''
        raise NotImplementedError()

    def setTabKeyBehavior(self, value : bool) -> None:
        '''Indicates whether tab characters are allowed in the text of the control.
        :param value: '''
        raise NotImplementedError()

    def setShowDropButtonTypeWhen(self, value : int) -> None:
        '''Specifies the symbol displayed on the drop button
        See :class:`ShowDropButtonType`
        :param value: '''
        raise NotImplementedError()

    def getSpecialEffect(self) -> int:
        '''Gets the special effect of the control.
        See :class:`ControlSpecialEffectType`'''
        raise NotImplementedError()

    def isDragBehaviorEnabled(self) -> bool:
        '''Indicates whether dragging and dropping is enabled for the control.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()

    def getScrollBars(self) -> int:
        '''Indicates specifies whether the control has vertical scroll bars, horizontal scroll bars, both, or neither.
        See :class:`ControlScrollBarType`'''
        raise NotImplementedError()

    def getIntegralHeight(self) -> bool:
        '''Indicates whether the control will only show complete lines of text without showing any partial lines.'''
        raise NotImplementedError()

    def isWordWrapped(self) -> bool:
        '''Indicates whether the contents of the control automatically wrap at the end of a line.'''
        raise NotImplementedError()

    def setEnterFieldBehavior(self, value : bool) -> None:
        '''Specifies selection behavior when entering the control.
        True specifies that the selection remains unchanged from last time the control was active.
        False specifies that all the text in the control will be selected when entering the control.
        :param value: '''
        raise NotImplementedError()

    def setDragBehaviorEnabled(self, value : bool) -> None:
        '''Indicates whether dragging and dropping is enabled for the control.
        :param value: '''
        raise NotImplementedError()

    def setDropButtonStyle(self, value : int) -> None:
        '''Specifies the symbol displayed on the drop button
        See :class:`DropButtonStyle`
        :param value: '''
        raise NotImplementedError()

    def setMultiLine(self, value : bool) -> None:
        '''Indicates whether the control can display more than one line of text.
        :param value: '''
        raise NotImplementedError()

    def getBorderOleColor(self) -> int:
        '''Gets the ole color of the background.'''
        raise NotImplementedError()

    def getHideSelection(self) -> bool:
        '''Indicates whether selected text in the control appears highlighted when the control does not have focus.'''
        raise NotImplementedError()

    def isAutoTab(self) -> bool:
        '''Indicates whether the focus will automatically move to the next control when the user enters the maximum number of characters.'''
        raise NotImplementedError()

    def getShowDropButtonTypeWhen(self) -> int:
        '''Specifies the symbol displayed on the drop button
        See :class:`ShowDropButtonType`'''
        raise NotImplementedError()

    def setMaxLength(self, value : int) -> None:
        '''Sets the maximum number of characters
        :param value: '''
        raise NotImplementedError()

    def isAutoWordSelected(self) -> bool:
        '''Specifies the basic unit used to extend a selection.
        True specifies that the basic unit is a single character.
        false specifies that the basic unit is a whole word.'''
        raise NotImplementedError()

    def setEditable(self, value : bool) -> None:
        '''Indicates whether the user can type into the control.
        :param value: '''
        raise NotImplementedError()

    def getEnterFieldBehavior(self) -> bool:
        '''Specifies selection behavior when entering the control.
        True specifies that the selection remains unchanged from last time the control was active.
        False specifies that all the text in the control will be selected when entering the control.'''
        raise NotImplementedError()

    def setScrollBars(self, value : int) -> None:
        '''Indicates specifies whether the control has vertical scroll bars, horizontal scroll bars, both, or neither.
        See :class:`ControlScrollBarType`
        :param value: '''
        raise NotImplementedError()

    def setAutoTab(self, value : bool) -> None:
        '''Indicates whether the focus will automatically move to the next control when the user enters the maximum number of characters.
        :param value: '''
        raise NotImplementedError()

    def getTabKeyBehavior(self) -> bool:
        '''Indicates whether tab characters are allowed in the text of the control.'''
        raise NotImplementedError()

    def setIntegralHeight(self, value : bool) -> None:
        '''Indicates whether the control will only show complete lines of text without showing any partial lines.
        :param value: '''
        raise NotImplementedError()

    def getPasswordChar(self) -> str:
        '''Gets a character to be displayed in place of the characters entered.'''
        raise NotImplementedError()


class TextBoxCollection:
    '''Encapsulates a collection of :class:`TextBox` objects.'''

    def clear(self) -> None:
        '''Clear all text boxes.'''
        raise NotImplementedError()

    def removeAt(self, index : int) -> None:
        '''Remove a text box from the file.
        :param index: The text box index.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> TextBox:
        '''Gets the :class:`TextBox` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> TextBox:
        '''Gets the :class:`TextBox` element by the name.
        :param name: The name of the text box.'''
        raise NotImplementedError()

    def add(self, upperLeftRow : int, upperLeftColumn : int, height : int, width : int) -> int:
        '''Adds a textbox to the collection.
        :param upperLeftRow: Upper left row index.
        :param upperLeftColumn: Upper left column index.
        :param height: Height of textbox, in unit of pixel.
        :param width: Width of textbox, in unit of pixel.
        :returns: :class:`TextBox` object index.'''
        raise NotImplementedError()


class TextBoxOptions:
    '''Represents the text options of the shape'''

    def setRightMarginPt(self, value : int) -> None:
        '''Sets the right margin in unit of Points.
        :param value: '''
        raise NotImplementedError()

    def setShapeTextDirection(self, value : int) -> None:
        '''Sets the text display direction within a given text body.
        It corresponds to "Format Shape - Text Options - Text Box - Text direction" in Excel
        See :class:`TextVerticalType`
        :param value: '''
        raise NotImplementedError()

    def setTopMarginPt(self, value : int) -> None:
        '''Sets the top margin in unit of Points.
        :param value: '''
        raise NotImplementedError()

    def setResizeToFitText(self, value : bool) -> None:
        '''Indicates whether to resize the shape to fit the text
        :param value: '''
        raise NotImplementedError()

    def getResizeToFitText(self) -> bool:
        '''Indicates whether to resize the shape to fit the text'''
        raise NotImplementedError()

    def setWrapTextInShape(self, value : bool) -> None:
        '''Specifies text wrapping within a shape.
        False - No wrapping will occur on text body.
        True - Wrapping will occur on text body.
        :param value: '''
        raise NotImplementedError()

    def setBottomMarginPt(self, value : int) -> None:
        '''Returns the bottom margin in unit of Points
        :param value: '''
        raise NotImplementedError()

    def getWrapTextInShape(self) -> bool:
        '''Specifies text wrapping within a shape.
        False - No wrapping will occur on text body.
        True - Wrapping will occur on text body.'''
        raise NotImplementedError()

    def getLeftMarginPt(self) -> int:
        '''Gets the left margin in unit of Points.'''
        raise NotImplementedError()

    def setShapeTextVerticalAlignment(self, value : int) -> None:
        '''It corresponds to "Format Shape - Text Options - Text Box - Vertical Alignment" in Excel.
        See :class:`ShapeTextVerticalAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getTopMarginPt(self) -> int:
        '''Gets the top margin in unit of Points.'''
        raise NotImplementedError()

    def setLeftMarginPt(self, value : int) -> None:
        '''Sets the left margin in unit of Points.
        :param value: '''
        raise NotImplementedError()

    def getShapeTextVerticalAlignment(self) -> int:
        '''It corresponds to "Format Shape - Text Options - Text Box - Vertical Alignment" in Excel.
        See :class:`ShapeTextVerticalAlignmentType`'''
        raise NotImplementedError()

    def setAllowTextToOverflow(self, value : bool) -> None:
        '''Whether allow text to overflow shape.
        :param value: '''
        raise NotImplementedError()

    def getRightMarginPt(self) -> int:
        '''Gets the right margin in unit of Points.'''
        raise NotImplementedError()

    def getAllowTextToOverflow(self) -> bool:
        '''Whether allow text to overflow shape.'''
        raise NotImplementedError()

    def getBottomMarginPt(self) -> int:
        '''Returns the bottom margin in unit of Points'''
        raise NotImplementedError()

    def getShapeTextDirection(self) -> int:
        '''Gets the text display direction within a given text body.
        It corresponds to "Format Shape - Text Options - Text Box - Text direction" in Excel
        See :class:`TextVerticalType`'''
        raise NotImplementedError()


class TextCapsType:
    '''This type specifies the cap types of the text.'''

    NONE : TextCapsType
    '''None caps'''

    ALL : TextCapsType
    '''Apply all caps on the text.'''

    SMALL : TextCapsType
    '''Apply small caps to the text.'''


class TextCrossType:
    '''Enumerates displaying text type when the text width is larger than cell width.'''

    DEFAULT : TextCrossType
    '''Display text like in Microsoft Excel.'''

    CROSS_KEEP : TextCrossType
    '''Display all the text by crossing other cells and keep text of crossed cells.'''

    CROSS_OVERRIDE : TextCrossType
    '''Display all the text by crossing other cells and override text of crossed cells.'''

    STRICT_IN_CELL : TextCrossType
    '''Only display the text within the width of cell.'''


class TextDirectionType:
    '''Represents the direction of the text flow for this paragraph.'''

    CONTEXT : TextDirectionType
    ''''''

    LEFT_TO_RIGHT : TextDirectionType
    ''''''

    RIGHT_TO_LEFT : TextDirectionType
    ''''''


class TextEffectFormat:
    '''Contains properties and methods that apply to WordArt objects.'''

    def setPresetShape(self, value : int) -> None:
        '''Sets the preset shape type.
        See :class:`MsoPresetTextEffectShape`
        :param value: '''
        raise NotImplementedError()

    def getFontBold(self) -> bool:
        '''Indicates whether font is bold.'''
        raise NotImplementedError()

    def getRotatedChars(self) -> bool:
        '''If true,characters in the specified WordArt are rotated 90 degrees relative to the WordArt's bounding shape.'''
        raise NotImplementedError()

    def getFontItalic(self) -> bool:
        '''Indicates whether font is italic.'''
        raise NotImplementedError()

    def setFontSize(self, value : int) -> None:
        '''The size (in points) of the font used in the WordArt.
        :param value: '''
        raise NotImplementedError()

    def setFontName(self, value : str) -> None:
        '''The name of the font used in the WordArt.
        :param value: '''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''The text in the WordArt.
        :param value: '''
        raise NotImplementedError()

    def getPresetShape(self) -> int:
        '''Gets the preset shape type.
        See :class:`MsoPresetTextEffectShape`'''
        raise NotImplementedError()

    def getFontSize(self) -> int:
        '''The size (in points) of the font used in the WordArt.'''
        raise NotImplementedError()

    def setFontItalic(self, value : bool) -> None:
        '''Indicates whether font is italic.
        :param value: '''
        raise NotImplementedError()

    def setTextEffect(self, effect : int) -> None:
        '''Sets the preset text effect.
        :param effect: :class:`MsoPresetTextEffect`. The preset text effect.'''
        raise NotImplementedError()

    def getFontName(self) -> str:
        '''The name of the font used in the WordArt.'''
        raise NotImplementedError()

    def setRotatedChars(self, value : bool) -> None:
        '''If true,characters in the specified WordArt are rotated 90 degrees relative to the WordArt's bounding shape.
        :param value: '''
        raise NotImplementedError()

    def getText(self) -> str:
        '''The text in the WordArt.'''
        raise NotImplementedError()

    def setFontBold(self, value : bool) -> None:
        '''Indicates whether font is bold.
        :param value: '''
        raise NotImplementedError()


class TextFontAlignType:
    '''Represents the different types of font alignment.'''

    AUTOMATIC : TextFontAlignType
    '''When the text flow is horizontal or simple vertical same as fontBaseline
    but for other vertical modes same as fontCenter.'''

    BOTTOM : TextFontAlignType
    '''The letters are anchored to the very bottom of a single line.'''

    BASELINE : TextFontAlignType
    '''The letters are anchored to the bottom baseline of a single line.'''

    CENTER : TextFontAlignType
    '''The letters are anchored between the two baselines of a single line.'''

    TOP : TextFontAlignType
    '''The letters are anchored to the top baseline of a single line.'''


class TextNodeType:
    '''Represents the node type.'''

    TEXT_RUN : TextNodeType
    '''Represents the text node.'''

    TEXT_PARAGRAPH : TextNodeType
    '''Represents the text paragraph.'''

    EQUATION : TextNodeType
    '''Represents the equation text.'''


class TextOptions:
    '''Represents the text options.'''

    def getName(self) -> str:
        '''Gets the name of the shape.'''
        raise NotImplementedError()

    def setFarEastName(self, value : str) -> None:
        '''Sets the FarEast name.
        :param value: '''
        raise NotImplementedError()

    def setSpacing(self, value : int) -> None:
        '''Specifies the spacing between characters within a text run.
        :param value: '''
        raise NotImplementedError()

    def getUnderlineColor(self) -> CellsColor:
        '''Gets the color of underline.'''
        raise NotImplementedError()

    def getSpacing(self) -> int:
        '''Specifies the spacing between characters within a text run.'''
        raise NotImplementedError()

    def setKerning(self, value : int) -> None:
        '''Specifies the minimum font size at which character kerning will occur for this text run.
        :param value: '''
        raise NotImplementedError()

    def setLatinName(self, value : str) -> None:
        '''Sets the latin name.
        :param value: '''
        raise NotImplementedError()

    def getKerning(self) -> int:
        '''Specifies the minimum font size at which character kerning will occur for this text run.'''
        raise NotImplementedError()

    def getShadow(self) -> ShadowEffect:
        '''Represents a :class:`ShadowEffect` object that specifies shadow effect for the chart element or shape.'''
        raise NotImplementedError()

    def getLanguageCode(self) -> int:
        '''Gets the user interface language.
        See :class:`CountryCode`'''
        raise NotImplementedError()

    def getFarEastName(self) -> str:
        '''Gets the FarEast name.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the shape.
        :param value: '''
        raise NotImplementedError()

    def getOutline(self) -> LineFormat:
        '''Represents the outline format of the text.'''
        raise NotImplementedError()

    def setLanguageCode(self, value : int) -> None:
        '''Sets the user interface language.
        See :class:`CountryCode`
        :param value: '''
        raise NotImplementedError()

    def setUnderlineColor(self, value : CellsColor) -> None:
        '''Sets the color of underline.
        :param value: '''
        raise NotImplementedError()

    def getFill(self) -> FillFormat:
        '''Represents the fill format of the text.'''
        raise NotImplementedError()

    def getLatinName(self) -> str:
        '''Gets the latin name.'''
        raise NotImplementedError()


class TextOrientationType:
    '''Enumerates text orientation types.'''

    CLOCK_WISE : TextOrientationType
    '''Rotates text with 90 degrees clockwise.'''

    COUNTER_CLOCK_WISE : TextOrientationType
    '''Rotates text with 90 degrees counterclockwise.'''

    NO_ROTATION : TextOrientationType
    '''Represents the default value.'''

    TOP_TO_BOTTOM : TextOrientationType
    '''Displays text from top to bottom of the cell. Stacked text.'''


class TextOverflowType:
    '''Represents the way the text vertical or horizontal overflow.'''

    CLIP : TextOverflowType
    '''Pay attention to top and bottom barriers.
    Provide no indication that there is text which is not visible.'''

    ELLIPSIS : TextOverflowType
    '''Pay attention to top and bottom barriers.
    Use an ellipsis to denote that there is text which is not visible.
    Only for vertical overflow.'''

    OVERFLOW : TextOverflowType
    '''Overflow the text and pay no attention to top and bottom barriers.'''


class TextParagraph:
    '''Represents the text paragraph setting.'''

    def getSpaceBefore(self) -> int:
        '''Gets the amount of vertical white space that will be present before a paragraph.'''
        raise NotImplementedError()

    def setSpaceAfter(self, value : int) -> None:
        '''Sets the amount of vertical white space that will be present after a paragraph.
        :param value: '''
        raise NotImplementedError()

    def getLineSpaceSizeType(self) -> int:
        '''Gets the amount of vertical white space that will be used within a paragraph.
        See :class:`LineSpaceSizeType`'''
        raise NotImplementedError()

    def setFontAlignType(self, value : int) -> None:
        '''Determines where vertically on a line of text the actual words are positioned. This deals
        with vertical placement of the characters with respect to the baselines.
        See :class:`TextFontAlignType`
        :param value: '''
        raise NotImplementedError()

    def getChildren(self) -> list[FontSetting]:
        '''Gets all text runs in this paragraph.
        If this paragraph is empty, return paragraph itself.'''
        raise NotImplementedError()

    def getAlignmentType(self) -> int:
        '''Gets the text horizontal alignment type of the paragraph.
        See :class:`TextAlignmentType`'''
        raise NotImplementedError()

    def getSpaceAfterSizeType(self) -> int:
        '''Gets the amount of vertical white space that will be present after a paragraph.
        See :class:`LineSpaceSizeType`'''
        raise NotImplementedError()

    def isLatinLineBreak(self) -> bool:
        '''Specifies whether a Latin word can be broken in half and wrapped onto the next line without a hyphen being added.'''
        raise NotImplementedError()

    def setEastAsianLineBreak(self, value : bool) -> None:
        '''Specifies whether an East Asian word can be broken in half and wrapped onto the next line without a hyphen being added.
        :param value: '''
        raise NotImplementedError()

    def isHangingPunctuation(self) -> bool:
        '''Specifies whether punctuation is to be forcefully laid out on a line of text or put on a different line of text.'''
        raise NotImplementedError()

    def getLineSpace(self) -> int:
        '''Gets the amount of vertical white space that will be used within a paragraph.'''
        raise NotImplementedError()

    def setLineSpaceSizeType(self, value : int) -> None:
        '''Sets the amount of vertical white space that will be used within a paragraph.
        See :class:`LineSpaceSizeType`
        :param value: '''
        raise NotImplementedError()

    def setRightMargin(self, value : int) -> None:
        '''Specifies the right margin of the paragraph.
        :param value: '''
        raise NotImplementedError()

    def setLineSpace(self, value : int) -> None:
        '''Sets the amount of vertical white space that will be used within a paragraph.
        :param value: '''
        raise NotImplementedError()

    def isEastAsianLineBreak(self) -> bool:
        '''Specifies whether an East Asian word can be broken in half and wrapped onto the next line without a hyphen being added.'''
        raise NotImplementedError()

    def setSpaceAfterSizeType(self, value : int) -> None:
        '''Sets the amount of vertical white space that will be present after a paragraph.
        See :class:`LineSpaceSizeType`
        :param value: '''
        raise NotImplementedError()

    def setAlignmentType(self, value : int) -> None:
        '''Sets the text horizontal alignment type of the paragraph.
        See :class:`TextAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getSpaceBeforeSizeType(self) -> int:
        '''Gets the amount of vertical white space that will be present before a paragraph.
        See :class:`LineSpaceSizeType`'''
        raise NotImplementedError()

    def setSpaceBefore(self, value : int) -> None:
        '''Sets the amount of vertical white space that will be present before a paragraph.
        :param value: '''
        raise NotImplementedError()

    def getFirstLineIndent(self) -> int:
        '''Specifies the indent size that will be applied to the first line of text in the paragraph.'''
        raise NotImplementedError()

    def setLeftMargin(self, value : int) -> None:
        '''Specifies the left margin of the paragraph.
        :param value: '''
        raise NotImplementedError()

    def setLatinLineBreak(self, value : bool) -> None:
        '''Specifies whether a Latin word can be broken in half and wrapped onto the next line without a hyphen being added.
        :param value: '''
        raise NotImplementedError()

    def setHangingPunctuation(self, value : bool) -> None:
        '''Specifies whether punctuation is to be forcefully laid out on a line of text or put on a different line of text.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of text node.
        See :class:`TextNodeType`'''
        raise NotImplementedError()

    def getStops(self) -> TextTabStopCollection:
        '''Gets tab stop list.'''
        raise NotImplementedError()

    def getBullet(self) -> Bullet:
        '''Gets the bullet.'''
        raise NotImplementedError()

    def setSpaceBeforeSizeType(self, value : int) -> None:
        '''Sets the amount of vertical white space that will be present before a paragraph.
        See :class:`LineSpaceSizeType`
        :param value: '''
        raise NotImplementedError()

    def getDefaultTabSize(self) -> int:
        '''Gets the default size for a tab character within this paragraph.'''
        raise NotImplementedError()

    def setDefaultTabSize(self, value : int) -> None:
        '''Sets the default size for a tab character within this paragraph.
        :param value: '''
        raise NotImplementedError()

    def getFontAlignType(self) -> int:
        '''Determines where vertically on a line of text the actual words are positioned. This deals
        with vertical placement of the characters with respect to the baselines.
        See :class:`TextFontAlignType`'''
        raise NotImplementedError()

    def getRightMargin(self) -> int:
        '''Specifies the right margin of the paragraph.'''
        raise NotImplementedError()

    def setFirstLineIndent(self, value : int) -> None:
        '''Specifies the indent size that will be applied to the first line of text in the paragraph.
        :param value: '''
        raise NotImplementedError()

    def getSpaceAfter(self) -> int:
        '''Gets the amount of vertical white space that will be present after a paragraph.'''
        raise NotImplementedError()

    def getLeftMargin(self) -> int:
        '''Specifies the left margin of the paragraph.'''
        raise NotImplementedError()


class TextParagraphCollection:
    '''Represents all text paragraph.'''

    def getCount(self) -> int:
        '''Gets the count of text paragraphs.'''
        raise NotImplementedError()

    def get(self, index : int) -> TextParagraph:
        '''Gets the :class:`TextParagraph` object at specific index.
        :param index: The index.'''
        raise NotImplementedError()

    def iterator(self) -> Iterator:
        '''Gets the enumerator of the paragraphs.'''
        raise NotImplementedError()


class TextRunEquationNode:
    '''This class in the equation node is used to store the actual content(a sequence of mathematical text) of the equation.
    Usually a node object per character.'''

    def getText(self) -> str:
        '''Set the content of the text node(Usually a node object per character).'''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''Set the content of the text node(Usually a node object per character).
        :param value: '''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class TextStrikeType:
    '''This type specifies the strike type.'''

    SINGLE : TextStrikeType
    '''A single strikethrough applied on the text.'''

    DOUBLE : TextStrikeType
    '''A double strikethrough applied on the text.
    Only works for the text of the shapes or charts.'''

    NONE : TextStrikeType
    '''No strike is applied to the text.'''


class TextTabAlignmentType:
    '''Represents the text tab alignment types.'''

    CENTER : TextTabAlignmentType
    '''The text at this tab stop is center aligned.'''

    DECIMAL : TextTabAlignmentType
    '''At this tab stop, the decimals are lined up.'''

    LEFT : TextTabAlignmentType
    '''The text at this tab stop is left aligned.'''

    RIGHT : TextTabAlignmentType
    '''The text at this tab stop is right aligned.'''


class TextTabStop:
    '''Represents tab stop.'''

    def setTabAlignment(self, value : int) -> None:
        '''Specifies the alignment that is to be applied to text using this tab stop.
        See :class:`TextTabAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getTabAlignment(self) -> int:
        '''Specifies the alignment that is to be applied to text using this tab stop.
        See :class:`TextTabAlignmentType`'''
        raise NotImplementedError()

    def getTabPosition(self) -> int:
        '''Specifies the position of the tab stop relative to the left margin.'''
        raise NotImplementedError()

    def setTabPosition(self, value : int) -> None:
        '''Specifies the position of the tab stop relative to the left margin.
        :param value: '''
        raise NotImplementedError()


class TextTabStopCollection:
    '''Represents the list of all tab stops.'''

    def get(self, index : int) -> TextTabStop:
        '''Gets :class:`TextTabStop` by the index.
        :param index: The index.'''
        raise NotImplementedError()

    def add(self, tabAlignment : int, tabPosition : int) -> int:
        '''Adds a tab stop.
        :param tabAlignment: :class:`TextTabAlignmentType`.
        :param tabPosition: '''
        raise NotImplementedError()


class TextureFill:
    '''Encapsulates the object that represents texture fill format'''

    def setTransparency(self, value : int) -> None:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).
        :param value: '''
        raise NotImplementedError()

    def setTilePicOption(self, value : TilePicOption) -> None:
        '''Sets tile picture option.
        :param value: '''
        raise NotImplementedError()

    def setTiling(self, value : bool) -> None:
        '''Indicates whether tile picture as texture.
        :param value: '''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Sets the texture type
        See :class:`TextureType`
        :param value: '''
        raise NotImplementedError()

    def getTilePicOption(self) -> TilePicOption:
        '''Gets tile picture option.'''
        raise NotImplementedError()

    def setImageData(self, value : list[int]) -> None:
        '''Sets the image data of the fill.
        :param value: '''
        raise NotImplementedError()

    def setPicFormatOption(self, value : PicFormatOption) -> None:
        '''Sets picture format option.
        :param value: '''
        raise NotImplementedError()

    def getPicFormatOption(self) -> PicFormatOption:
        '''Gets picture format option.'''
        raise NotImplementedError()

    def getPictureFormatType(self) -> int:
        '''Gets the picture format type.
        See :class:`FillPictureType`'''
        raise NotImplementedError()

    def getImageData(self) -> list[int]:
        '''Gets the image data of the fill.'''
        raise NotImplementedError()

    def getTransparency(self) -> int:
        '''Returns or sets the degree of transparency of the area as a value from 0.0 (opaque) through 1.0 (clear).'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the texture type
        See :class:`TextureType`'''
        raise NotImplementedError()

    def setPictureFormatType(self, value : int) -> None:
        '''Sets the picture format type.
        See :class:`FillPictureType`
        :param value: '''
        raise NotImplementedError()

    def setScale(self, value : int) -> None:
        '''Sets the picture format scale.
        :param value: '''
        raise NotImplementedError()

    def getScale(self) -> int:
        '''Gets the picture format scale.'''
        raise NotImplementedError()

    def isTiling(self) -> bool:
        '''Indicates whether tile picture as texture.'''
        raise NotImplementedError()


class TextureType:
    '''Represents the preset texture type.'''

    BLUE_TISSUE_PAPER : TextureType
    '''Represents Blue Tissue Paper texture type.'''

    BOUQUET : TextureType
    '''Represents Bouquet texture type.'''

    BROWN_MARBLE : TextureType
    '''Represents Brown Marble texture type.'''

    CANVAS : TextureType
    '''Represents Canvas texture type.'''

    CORK : TextureType
    '''Represents Cork texture type.'''

    DENIM : TextureType
    '''Represents Denim texture type.'''

    FISH_FOSSIL : TextureType
    '''Represents Fish Fossil texture type.'''

    GRANITE : TextureType
    '''Represents Granite texture type.'''

    GREEN_MARBLE : TextureType
    '''Represents Green Marble texture type.'''

    MEDIUM_WOOD : TextureType
    '''Represents Medium Wood texture type.'''

    NEWSPRINT : TextureType
    '''Represents Newsprint texture type.'''

    OAK : TextureType
    '''Represents Oak texture type.'''

    PAPER_BAG : TextureType
    '''Represents Paper Bag texture type.'''

    PAPYRUS : TextureType
    '''Represents Papyrus texture type.'''

    PARCHMENT : TextureType
    '''Represents Parchment texture type.'''

    PINK_TISSUE_PAPER : TextureType
    '''Represents Pink Tissue Paper texture type.'''

    PURPLE_MESH : TextureType
    '''Represents Purple Mesh texture type.'''

    RECYCLED_PAPER : TextureType
    '''Represents Recycled Paper texture type.'''

    SAND : TextureType
    '''Represents Sand texture type.'''

    STATIONERY : TextureType
    '''Represents Stationery texture type.'''

    WALNUT : TextureType
    '''Represents Walnut Droplets texture type.'''

    WATER_DROPLETS : TextureType
    '''Represents Water Droplets texture type.'''

    WHITE_MARBLE : TextureType
    '''Represents White Marble texture type.'''

    WOVEN_MAT : TextureType
    '''Represents Woven Mat texture type.'''

    UNKNOWN : TextureType
    '''Represents Unknown texture type.'''


class TextVerticalType:
    '''Represents the text direct type.'''

    VERTICAL : TextVerticalType
    '''East Asian Vertical display.'''

    HORIZONTAL : TextVerticalType
    '''Horizontal text.'''

    VERTICAL_LEFT_TO_RIGHT : TextVerticalType
    '''Displayed vertical and the text flows top down then LEFT to RIGHT'''

    VERTICAL_90 : TextVerticalType
    '''Each line is 90 degrees rotated clockwise'''

    VERTICAL_270 : TextVerticalType
    '''Each line is 270 degrees rotated clockwise'''

    STACKED : TextVerticalType
    '''Determines if all of the text is vertical'''

    STACKED_RIGHT_TO_LEFT : TextVerticalType
    '''Specifies that vertical WordArt should be shown from right to left rather than left to right.'''


class ThemeColor:
    '''Represents a theme color.'''

    def setTint(self, value : int) -> None:
        '''Sets the tint value.
        :param value: '''
        raise NotImplementedError()

    def setColorType(self, value : int) -> None:
        '''Sets the theme type.
        See :class:`ThemeColorType`
        :param value: '''
        raise NotImplementedError()

    def getTint(self) -> int:
        '''Gets the tint value.'''
        raise NotImplementedError()

    def getColorType(self) -> int:
        '''Gets the theme type.
        See :class:`ThemeColorType`'''
        raise NotImplementedError()


class ThemeColorType:
    '''Enumerates  the theme color types.'''

    BACKGROUND_1 : ThemeColorType
    ''''''

    TEXT_1 : ThemeColorType
    ''''''

    BACKGROUND_2 : ThemeColorType
    ''''''

    TEXT_2 : ThemeColorType
    ''''''

    ACCENT_1 : ThemeColorType
    ''''''

    ACCENT_2 : ThemeColorType
    ''''''

    ACCENT_3 : ThemeColorType
    ''''''

    ACCENT_4 : ThemeColorType
    ''''''

    ACCENT_5 : ThemeColorType
    ''''''

    ACCENT_6 : ThemeColorType
    ''''''

    HYPERLINK : ThemeColorType
    ''''''

    FOLLOWED_HYPERLINK : ThemeColorType
    ''''''

    STYLE_COLOR : ThemeColorType
    '''Inner used.
    A color used in theme definitions which means to use the color of the style.'''


class ThreadedComment:
    '''Represents the threaded comment.'''

    def setCreatedTime(self, value : DateTime) -> None:
        '''Sets the created time of this threaded comment.
        :param value: '''
        raise NotImplementedError()

    def getAuthor(self) -> ThreadedCommentAuthor:
        '''Gets the author of the comment.'''
        raise NotImplementedError()

    def getColumn(self) -> int:
        '''Gets the column index of the comment.'''
        raise NotImplementedError()

    def setAuthor(self, value : ThreadedCommentAuthor) -> None:
        '''Gets the author of the comment.
        :param value: '''
        raise NotImplementedError()

    def setNotes(self, value : str) -> None:
        '''Sets the text of the comment.
        :param value: '''
        raise NotImplementedError()

    def getCreatedTime(self) -> DateTime:
        '''Gets the created time of this threaded comment.'''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets the row index of the comment.'''
        raise NotImplementedError()

    def getNotes(self) -> str:
        '''Gets the text of the comment.'''
        raise NotImplementedError()


class ThreadedCommentAuthor:
    '''Represents the person who creates the threaded comments;'''

    def getUserId(self) -> str:
        '''Gets the id of the user.'''
        raise NotImplementedError()

    def getProviderId(self) -> str:
        '''Gets the id of the provider.'''
        raise NotImplementedError()

    def setUserId(self, value : str) -> None:
        '''Sets the id of the user.
        :param value: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name.
        :param value: '''
        raise NotImplementedError()

    def setProviderId(self, value : str) -> None:
        '''Gets the id of the provider.
        :param value: '''
        raise NotImplementedError()


class ThreadedCommentAuthorCollection:
    '''Represents all persons who .'''

    def setCurrentPerson(self, value : ThreadedCommentAuthor) -> None:
        '''Sets the current user.
        :param value: '''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> ThreadedCommentAuthor:
        '''Gets the person who create threaded comments.
        :param index: The index'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> ThreadedCommentAuthor:
        '''Gets the person who create threaded comments.
        :param name: The name of the author.'''
        raise NotImplementedError()

    def indexOf(self, author : ThreadedCommentAuthor) -> int:
        '''Gets the index of ThreadedCommentAuthor object
        :param author: The ThreadedCommentAuthor object
        :returns: The index in the ThreadedCommentAuthor collection'''
        raise NotImplementedError()

    def add(self, name : str, userId : str, providerId : str) -> int:
        '''Adds one thread comment person.
        :param name: The name of the person.
        :param userId: 
        :param providerId: The id of the provider'''
        raise NotImplementedError()

    def getCurrentPerson(self) -> ThreadedCommentAuthor:
        '''Gets the current user.'''
        raise NotImplementedError()


class ThreadedCommentCollection:
    '''Represents the list of threaded comments.'''

    def get(self, index : int) -> ThreadedComment:
        '''Gets the threaded comment by the specific index.
        :param index: The index'''
        raise NotImplementedError()

    def add(self, text : str, author : ThreadedCommentAuthor) -> int:
        '''Adds a threaded comment;
        :param text: The text of the threaded comment.
        :param author: The author of the threaded comment'''
        raise NotImplementedError()


class ThreadInterruptMonitor:
    '''Simple implementation of :class:`AbstractInterruptMonitor` by starting another thread to require the interruption after sleeping user specified limit.'''

    def getTerminateWithoutException(self) -> bool:
        '''See :meth:`AbstractInterruptMonitor.getTerminateWithoutException()`.
        This property is specified by user when constructing this monitor instance.'''
        raise NotImplementedError()

    def startMonitor(self, msLimit : int) -> None:
        '''Starts the monitor with the specified time limit. The start time to calculate time cost is just when this method is called,
        so the procedure which needs to be monitored should be started just after this call.
        :param msLimit: time limit(ms) to require the interruption.'''
        raise NotImplementedError()

    def isInterruptionRequested(self) -> bool:
        '''This implementation just checks whether the time cost(from the time when starting this monitor to now) is greater than user specified limit.'''
        raise NotImplementedError()

    def finishMonitor(self) -> None:
        '''Finishes the monitor for one procedure.'''
        raise NotImplementedError()


class ThreeDFormat:
    '''Represents a shape's three-dimensional formatting.'''

    def setLighting(self, value : int) -> None:
        '''Sets type of light rig.
        See :class:`LightRigType`
        :param value: '''
        raise NotImplementedError()

    def setTopBevelType(self, value : int) -> None:
        '''Sets the type of the top bevel, or how far into the shape it is applied.
        In unit of Points.
        See :class:`BevelType`
        :param value: '''
        raise NotImplementedError()

    def getPerspective(self) -> int:
        '''Gets the angle at which a ThreeDFormat object can be viewed.'''
        raise NotImplementedError()

    def getLightAngle(self) -> int:
        '''Gets the angle of the extrusion lights.'''
        raise NotImplementedError()

    def setExtrusionHeight(self, value : int) -> None:
        '''Sets the extrusion height of the applied to the shape, in unit of points.
        :param value: '''
        raise NotImplementedError()

    def setPresetCameraType(self, value : int) -> None:
        '''Sets the extrusion preset camera type.
        See :class:`PresetCameraType`
        :param value: '''
        raise NotImplementedError()

    def getBottomBevelHeight(self) -> int:
        '''Gets the height of the bottom bevel, or how far into the shape it is applied.
        In unit of Points.'''
        raise NotImplementedError()

    def getBottomBevelType(self) -> int:
        '''Gets the type of the bottom bevel, or how far into the shape it is applied.
        In unit of Points.
        See :class:`BevelType`'''
        raise NotImplementedError()

    def getLightingDirection(self) -> int:
        '''Gets the direction from which the light rig is oriented in relation to the scene.
        See :class:`LightRigDirectionType`'''
        raise NotImplementedError()

    def setTopBevelWidth(self, value : int) -> None:
        '''Sets the width of the top bevel, or how far into the shape it is applied.
        In unit of Points.
        :param value: '''
        raise NotImplementedError()

    def setExtrusionColor(self, value : CellsColor) -> None:
        '''Gets the extrusion color on a shape.
        :param value: '''
        raise NotImplementedError()

    def hashCode(self) -> int:
        '''Gets hashcode.'''
        raise NotImplementedError()

    def getPresetCameraType(self) -> int:
        '''Gets the extrusion preset camera type.
        See :class:`PresetCameraType`'''
        raise NotImplementedError()

    def setContourColor(self, value : CellsColor) -> None:
        '''Sets the contour color on a shape.
        :param value: '''
        raise NotImplementedError()

    def getRotationZ(self) -> int:
        '''Gets the rotation of the extruded shape around the z-axis in degrees.'''
        raise NotImplementedError()

    def getRotationY(self) -> int:
        '''Gets the rotation of the extruded shape around the y-axis in degrees.'''
        raise NotImplementedError()

    def getRotationX(self) -> int:
        '''Gets the rotation of the extruded shape around the x-axis in degrees.'''
        raise NotImplementedError()

    def getTopBevelHeight(self) -> int:
        '''Gets the height of the top bevel, or how far into the shape it is applied.
        In unit of Points.'''
        raise NotImplementedError()

    def getContourWidth(self) -> int:
        '''Gets the contour width on the shape, in unit of points.'''
        raise NotImplementedError()

    def setBottomBevelWidth(self, value : int) -> None:
        '''Sets the width of the bottom bevel, or how far into the shape it is applied.
        In unit of Points.
        :param value: '''
        raise NotImplementedError()

    def setBottomBevelType(self, value : int) -> None:
        '''Sets the type of the bottom bevel, or how far into the shape it is applied.
        In unit of Points.
        See :class:`BevelType`
        :param value: '''
        raise NotImplementedError()

    def getBottomBevelWidth(self) -> int:
        '''Gets the width of the bottom bevel, or how far into the shape it is applied.
        In unit of Points.'''
        raise NotImplementedError()

    def setLightAngle(self, value : int) -> None:
        '''Sets the angle of the extrusion lights.
        :param value: '''
        raise NotImplementedError()

    def equals(self, obj : Object) -> bool:
        '''
        :param obj: '''
        raise NotImplementedError()

    def getTopBevelWidth(self) -> int:
        '''Gets the width of the top bevel, or how far into the shape it is applied.
        In unit of Points.'''
        raise NotImplementedError()

    def setZ(self, value : int) -> None:
        '''Defines the distance from ground for the 3D shape.
        :param value: '''
        raise NotImplementedError()

    def getTopBevelType(self) -> int:
        '''Gets the type of the top bevel, or how far into the shape it is applied.
        In unit of Points.
        See :class:`BevelType`'''
        raise NotImplementedError()

    def getMaterial(self) -> int:
        '''Represents the preset material which is combined with the lighting properties to give the
        final look and feel of a shape.
        See :class:`PresetMaterialType`'''
        raise NotImplementedError()

    def setContourWidth(self, value : int) -> None:
        '''Sets the contour width on the shape, in unit of points.
        :param value: '''
        raise NotImplementedError()

    def getLighting(self) -> int:
        '''Gets type of light rig.
        See :class:`LightRigType`'''
        raise NotImplementedError()

    def getZ(self) -> int:
        '''Defines the distance from ground for the 3D shape.'''
        raise NotImplementedError()

    def getExtrusionColor(self) -> CellsColor:
        '''Gets the extrusion color on a shape.'''
        raise NotImplementedError()

    def setRotationZ(self, value : int) -> None:
        '''Sets the rotation of the extruded shape around the z-axis in degrees.
        :param value: '''
        raise NotImplementedError()

    def setRotationY(self, value : int) -> None:
        '''Sets the rotation of the extruded shape around the y-axis in degrees.
        :param value: '''
        raise NotImplementedError()

    def setRotationX(self, value : int) -> None:
        '''Sets the rotation of the extruded shape around the x-axis in degrees.
        :param value: '''
        raise NotImplementedError()

    def setPerspective(self, value : int) -> None:
        '''Sets the angle at which a ThreeDFormat object can be viewed.
        :param value: '''
        raise NotImplementedError()

    def setLightingDirection(self, value : int) -> None:
        '''Sets the direction from which the light rig is oriented in relation to the scene.
        See :class:`LightRigDirectionType`
        :param value: '''
        raise NotImplementedError()

    def setTopBevelHeight(self, value : int) -> None:
        '''Sets the height of the top bevel, or how far into the shape it is applied.
        In unit of Points.
        :param value: '''
        raise NotImplementedError()

    def setBottomBevelHeight(self, value : int) -> None:
        '''Sets the height of the bottom bevel, or how far into the shape it is applied.
        In unit of Points.
        :param value: '''
        raise NotImplementedError()

    def getExtrusionHeight(self) -> int:
        '''Gets the extrusion height of the applied to the shape, in unit of points.'''
        raise NotImplementedError()

    def getContourColor(self) -> CellsColor:
        '''Gets the contour color on a shape.'''
        raise NotImplementedError()

    def setMaterial(self, value : int) -> None:
        '''Represents the preset material which is combined with the lighting properties to give the
        final look and feel of a shape.
        See :class:`PresetMaterialType`
        :param value: '''
        raise NotImplementedError()


class TickLabelAlignmentType:
    '''Represents the text alignment type for the tick labels on the axis'''

    CENTER : TickLabelAlignmentType
    '''Represents the text shall be centered.'''

    LEFT : TickLabelAlignmentType
    '''Represents the text shall be left justified.'''

    RIGHT : TickLabelAlignmentType
    '''Represents the text shall be right justified.'''


class TickLabelItem:
    '''Represents a tick label in the chart.'''

    def getWidth(self) -> int:
        '''Width of Ticklabel item in ratio of chart width.'''
        raise NotImplementedError()

    def getY(self) -> int:
        '''Y coordinates of Ticklabel item in ratio of chart height.'''
        raise NotImplementedError()

    def getX(self) -> int:
        '''X coordinates of Ticklabel item in ratio of chart width.'''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Height of Ticklabel item in ratio of chart height.'''
        raise NotImplementedError()


class TickLabelPositionType:
    '''Represents the position type of tick-mark labels on the specified axis.'''

    HIGH : TickLabelPositionType
    '''Position type is high.'''

    LOW : TickLabelPositionType
    '''Position type is low.'''

    NEXT_TO_AXIS : TickLabelPositionType
    '''Position type is next to axis.'''

    NONE : TickLabelPositionType
    '''Position type is none.'''


class TickLabels:
    '''Represents the tick-mark labels associated with tick marks on a chart axis.'''

    def setAutomaticRotation(self, value : bool) -> None:
        '''Indicates whether the rotation angle is automatic
        :param value: '''
        raise NotImplementedError()

    def getFont(self) -> Font:
        '''Returns a :meth:`ChartArea.getFont()` object that represents the font of the specified TickLabels object.'''
        raise NotImplementedError()

    def getReadingOrder(self) -> int:
        '''Represents text reading order.
        See :class:`TextDirectionType`'''
        raise NotImplementedError()

    def getOffset(self) -> int:
        '''Gets the distance between the axis labels and the axis line.'''
        raise NotImplementedError()

    def getNumberFormatLinked(self) -> bool:
        '''True if the number format is linked to the cells
        (so that the number format changes in the labels when it changes in the cells).'''
        raise NotImplementedError()

    def getAutoScaleFont(self) -> bool:
        '''True if the text in the object changes font size when the object size changes. The default value is True.'''
        raise NotImplementedError()

    def getTickLabelItems(self) -> list[TickLabelItem]:
        '''Gets the display tick labels of the axis.'''
        raise NotImplementedError()

    def getTextDirection(self) -> int:
        ''':deprecated: Use TickLabels.ReadingOrder property instead.'''
        raise NotImplementedError()

    def getAlignmentType(self) -> int:
        '''Gets the text alignment for the tick labels on the axis.
        See :class:`TickLabelAlignmentType`'''
        raise NotImplementedError()

    def getBackgroundMode(self) -> int:
        '''Gets the display mode of the background
        See :class:`BackgroundMode`'''
        raise NotImplementedError()

    def getDisplayNumberFormat(self) -> str:
        '''Gets the display number format of tick labels.'''
        raise NotImplementedError()

    def isAutomaticRotation(self) -> bool:
        '''Indicates whether the rotation angle is automatic'''
        raise NotImplementedError()

    def setNumberFormat(self, value : str) -> None:
        '''Represents the format string for the TickLabels object.
        :param value: '''
        raise NotImplementedError()

    def setNumberFormatLinked(self, value : bool) -> None:
        '''True if the number format is linked to the cells
        (so that the number format changes in the labels when it changes in the cells).
        :param value: '''
        raise NotImplementedError()

    def setAutoScaleFont(self, value : bool) -> None:
        '''True if the text in the object changes font size when the object size changes. The default value is True.
        :param value: '''
        raise NotImplementedError()

    def setTextDirection(self, value : int) -> None:
        ''':deprecated: Use TickLabels.ReadingOrder property instead.'''
        raise NotImplementedError()

    def getDirectionType(self) -> int:
        '''Gets the direction of text.
        See :class:`ChartTextDirectionType`'''
        raise NotImplementedError()

    def setAlignmentType(self, value : int) -> None:
        '''Sets the text alignment for the tick labels on the axis.
        See :class:`TickLabelAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getNumberFormat(self) -> str:
        '''Represents the format string for the TickLabels object.'''
        raise NotImplementedError()

    def getRotationAngle(self) -> int:
        '''Represents text rotation angle in clockwise.'''
        raise NotImplementedError()

    def setDirectionType(self, value : int) -> None:
        '''Sets the direction of text.
        See :class:`ChartTextDirectionType`
        :param value: '''
        raise NotImplementedError()

    def setNumber(self, value : int) -> None:
        '''Represents the format number for the TickLabels object.
        :param value: '''
        raise NotImplementedError()

    def setBackgroundMode(self, value : int) -> None:
        '''Sets the display mode of the background
        See :class:`BackgroundMode`
        :param value: '''
        raise NotImplementedError()

    def setReadingOrder(self, value : int) -> None:
        '''Represents text reading order.
        See :class:`TextDirectionType`
        :param value: '''
        raise NotImplementedError()

    def setOffset(self, value : int) -> None:
        '''Sets the distance between the axis labels and the axis line.
        :param value: '''
        raise NotImplementedError()

    def setRotationAngle(self, value : int) -> None:
        '''Represents text rotation angle in clockwise.
        :param value: '''
        raise NotImplementedError()

    def getNumber(self) -> int:
        '''Represents the format number for the TickLabels object.'''
        raise NotImplementedError()


class TickMarkType:
    '''Represents the tick mark type for the specified axis.'''

    CROSS : TickMarkType
    '''Tick mark type is Cross.'''

    INSIDE : TickMarkType
    '''Tick mark type is Inside.'''

    NONE : TickMarkType
    '''Tick mark type is None.'''

    OUTSIDE : TickMarkType
    '''Tick mark type is Outside'''


class TiffCompression:
    '''Specifies what type of compression to apply when saving images into TIFF format file.'''

    COMPRESSION_NONE : TiffCompression
    '''Specifies no compression.'''

    COMPRESSION_RLE : TiffCompression
    '''Specifies the RLE compression scheme.'''

    COMPRESSION_LZW : TiffCompression
    '''Specifies the LZW compression scheme.'''

    COMPRESSION_CCITT_3 : TiffCompression
    '''Specifies the CCITT3 compression scheme.'''

    COMPRESSION_CCITT_4 : TiffCompression
    '''Specifies the CCITT4 compression scheme.'''


class TilePicOption:
    '''Represents tile picture as texture.'''

    def setOffsetY(self, value : int) -> None:
        '''Sets the Y offset for tiling picture.
        :param value: '''
        raise NotImplementedError()

    def setOffsetX(self, value : int) -> None:
        '''Sets the X offset for tiling picture.
        :param value: '''
        raise NotImplementedError()

    def getOffsetY(self) -> int:
        '''Gets the Y offset for tiling picture.'''
        raise NotImplementedError()

    def getOffsetX(self) -> int:
        '''Gets the X offset for tiling picture.'''
        raise NotImplementedError()

    def getMirrorType(self) -> int:
        '''Gets the mirror type for tiling.
        See :class:`MirrorType`'''
        raise NotImplementedError()

    def setAlignmentType(self, value : int) -> None:
        '''Sets the alignment for tiling.
        See :class:`RectangleAlignmentType`
        :param value: '''
        raise NotImplementedError()

    def getScaleY(self) -> int:
        '''Gets the Y scale for tiling picture.'''
        raise NotImplementedError()

    def getScaleX(self) -> int:
        '''Gets the X scale for tiling picture.'''
        raise NotImplementedError()

    def getAlignmentType(self) -> int:
        '''Gets the alignment for tiling.
        See :class:`RectangleAlignmentType`'''
        raise NotImplementedError()

    def setScaleY(self, value : int) -> None:
        '''Sets the Y scale for tiling picture.
        :param value: '''
        raise NotImplementedError()

    def setScaleX(self, value : int) -> None:
        '''Sets the X scale for tiling picture.
        :param value: '''
        raise NotImplementedError()

    def setMirrorType(self, value : int) -> None:
        '''Sets the mirror type for tiling.
        See :class:`MirrorType`
        :param value: '''
        raise NotImplementedError()


class Timeline:
    '''Summary description of Timeline View
    Due to MS Excel, Excel 2003 does not support Timeline'''

    def getName(self) -> str:
        '''Returns or sets the name of the specified Timeline'''
        raise NotImplementedError()

    def getTopPixel(self) -> int:
        '''Returns or sets the vertical offset of timeline shape from its top row, in pixels.'''
        raise NotImplementedError()

    def getHeightPixel(self) -> int:
        '''Returns or sets the height of the specified timeline, in pixels.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Returns or sets the name of the specified Timeline
        :param value: '''
        raise NotImplementedError()

    def setLeftPixel(self, value : int) -> None:
        '''Returns or sets the horizontal offset of timeline shape from its left column, in pixels.
        :param value: '''
        raise NotImplementedError()

    def setCaption(self, value : str) -> None:
        '''Returns or sets the caption of the specified Timeline.
        :param value: '''
        raise NotImplementedError()

    def getCaption(self) -> str:
        '''Returns or sets the caption of the specified Timeline.'''
        raise NotImplementedError()

    def getWidthPixel(self) -> int:
        '''Returns or sets the width of the specified timeline, in pixels.'''
        raise NotImplementedError()

    def setHeightPixel(self, value : int) -> None:
        '''Returns or sets the height of the specified timeline, in pixels.
        :param value: '''
        raise NotImplementedError()

    def setWidthPixel(self, value : int) -> None:
        '''Returns or sets the width of the specified timeline, in pixels.
        :param value: '''
        raise NotImplementedError()

    def getLeftPixel(self) -> int:
        '''Returns or sets the horizontal offset of timeline shape from its left column, in pixels.'''
        raise NotImplementedError()

    def setTopPixel(self, value : int) -> None:
        '''Returns or sets the vertical offset of timeline shape from its top row, in pixels.
        :param value: '''
        raise NotImplementedError()


class TimelineCollection:
    '''Specifies the collection of all the Timeline objects on the specified worksheet.
    Due to MS Excel, Excel 2003 does not support Timeline.'''

    @overload
    def get(self, index : int) -> Timeline:
        '''Gets the Timeline by index.
        :param index: '''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> Timeline:
        '''Gets the Timeline  by Timeline's name.
        :param name: '''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, row : int, column : int, baseFieldName : str) -> int:
        '''Add a new Timeline using PivotTable as data source
        :param pivot: PivotTable object
        :param row: Row index of the cell in the upper-left corner of the Timeline range.
        :param column: Column index of the cell in the upper-left corner of the Timeline range.
        :param baseFieldName: The name of PivotField in PivotTable.BaseFields
        :returns: The new add Timeline index'''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, destCellName : str, baseFieldName : str) -> int:
        '''Add a new Timeline using PivotTable as data source
        :param pivot: PivotTable object
        :param destCellName: The cell name in the upper-left corner of the Timeline range.
        :param baseFieldName: The name of PivotField in PivotTable.BaseFields
        :returns: The new add Timeline index'''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, row : int, column : int, baseFieldIndex : int) -> int:
        '''Add a new Timeline using PivotTable as data source
        :param pivot: PivotTable object
        :param row: Row index of the cell in the upper-left corner of the Timeline range.
        :param column: Column index of the cell in the upper-left corner of the Timeline range.
        :param baseFieldIndex: The index of PivotField in PivotTable.BaseFields
        :returns: The new add Timeline index'''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, destCellName : str, baseFieldIndex : int) -> int:
        '''Add a new Timeline using PivotTable as data source
        :param pivot: PivotTable object
        :param destCellName: The cell name in the upper-left corner of the Timeline range.
        :param baseFieldIndex: The index of PivotField in PivotTable.BaseFields
        :returns: The new add Timeline index'''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, row : int, column : int, baseField : PivotField) -> int:
        '''Add a new Timeline using PivotTable as data source
        :param pivot: PivotTable object
        :param row: Row index of the cell in the upper-left corner of the Timeline range.
        :param column: Column index of the cell in the upper-left corner of the Timeline range.
        :param baseField: The PivotField in PivotTable.BaseFields
        :returns: The new add Timeline index'''
        raise NotImplementedError()

    @overload
    def add(self, pivot : PivotTable, destCellName : str, baseField : PivotField) -> int:
        '''Add a new Timeline using PivotTable as data source
        :param pivot: PivotTable object
        :param destCellName: The cell name in the upper-left corner of the Timeline range.
        :param baseField: The PivotField in PivotTable.BaseFields
        :returns: The new add Timeline index'''
        raise NotImplementedError()


class TimePeriodType:
    '''Used in a FormatConditionType.TimePeriod conditional formatting rule.
    These are dynamic time periods, which change based on
    the date the conditional formatting is refreshed / applied.'''

    TODAY : TimePeriodType
    '''Today's date.'''

    YESTERDAY : TimePeriodType
    '''Yesterday's date.'''

    TOMORROW : TimePeriodType
    '''Tomorrow's date.'''

    LAST_7_DAYS : TimePeriodType
    '''A date in the last seven days.'''

    THIS_MONTH : TimePeriodType
    '''A date occurring in this calendar month.'''

    LAST_MONTH : TimePeriodType
    '''A date occurring in the last calendar month.'''

    NEXT_MONTH : TimePeriodType
    '''A date occurring in the next calendar month.'''

    THIS_WEEK : TimePeriodType
    '''A date occurring this week.'''

    LAST_WEEK : TimePeriodType
    '''A date occurring last week.'''

    NEXT_WEEK : TimePeriodType
    '''A date occurring next week.'''

    THIS_YEAR : TimePeriodType
    '''A date occurring this year.
    Only for .ods.'''

    LAST_YEAR : TimePeriodType
    '''A date occurring last year.
    Only for .ods.'''

    NEXT_YEAR : TimePeriodType
    '''A date occurring next year.
    Only for .ods.'''


class TimeUnit:
    '''Represents the base unit for the category axis.'''

    DAYS : TimeUnit
    '''Days'''

    MONTHS : TimeUnit
    '''Months'''

    YEARS : TimeUnit
    '''Years'''


class Title:
    '''Encapsulates the object that represents the title of chart or axis.'''

    def setOverLay(self, value : bool) -> None:
        '''Represents overlay centered title on chart without resizing chart.
        :param value: '''
        raise NotImplementedError()

    def getOverLay(self) -> bool:
        '''Represents overlay centered title on chart without resizing chart.'''
        raise NotImplementedError()

    def characters(self) -> list[FontSetting]:
        '''Gets rich text formatting of this Title.'''
        raise NotImplementedError()

    def setText(self, value : str) -> None:
        '''Sets the text of display unit label.
        :param value: '''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Represents whether the title is visible.'''
        raise NotImplementedError()

    def setY(self, value : int) -> None:
        '''Sets the y coordinate of the upper left corner in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def getCharacters(self) -> list[FontSetting]:
        ''':deprecated: Use Title.Characters() method instead.'''
        raise NotImplementedError()

    def setX(self, value : int) -> None:
        '''Sets the x coordinate of the upper left corner in units of 1/4000 of the chart area.
        :param value: '''
        raise NotImplementedError()

    def getY(self) -> int:
        '''Gets the y coordinate of the upper left corner in units of 1/4000 of the chart area.'''
        raise NotImplementedError()

    def setVisible(self, value : bool) -> None:
        '''Represents whether the title is visible.
        :param value: '''
        raise NotImplementedError()

    def getText(self) -> str:
        '''Gets the text of display unit label.'''
        raise NotImplementedError()

    def getX(self) -> int:
        '''Gets the x coordinate of the upper left corner in units of 1/4000 of the chart area.'''
        raise NotImplementedError()


class ToggleButtonActiveXControl:
    '''Represents a ToggleButton ActiveX control.'''

    def setPicturePosition(self, value : int) -> None:
        '''Sets the location of the control's picture relative to its caption.
        See :class:`ControlPicturePositionType`
        :param value: '''
        raise NotImplementedError()

    def getAccelerator(self) -> str:
        '''Gets the accelerator key for the control.'''
        raise NotImplementedError()

    def getPicturePosition(self) -> int:
        '''Gets the location of the control's picture relative to its caption.
        See :class:`ControlPicturePositionType`'''
        raise NotImplementedError()

    def setValue(self, value : int) -> None:
        '''Indicates if the control is checked or not.
        See :class:`CheckValueType`
        :param value: '''
        raise NotImplementedError()

    def setPicture(self, value : list[int]) -> None:
        '''Sets the data of the picture.
        :param value: '''
        raise NotImplementedError()

    def getValue(self) -> int:
        '''Indicates if the control is checked or not.
        See :class:`CheckValueType`'''
        raise NotImplementedError()

    def getPicture(self) -> list[int]:
        '''Gets the data of the picture.'''
        raise NotImplementedError()

    def getSpecialEffect(self) -> int:
        '''Gets the special effect of the control.
        See :class:`ControlSpecialEffectType`'''
        raise NotImplementedError()

    def setSpecialEffect(self, value : int) -> None:
        '''Sets the special effect of the control.
        See :class:`ControlSpecialEffectType`
        :param value: '''
        raise NotImplementedError()

    def setCaption(self, value : str) -> None:
        '''Sets the descriptive text that appears on a control.
        :param value: '''
        raise NotImplementedError()

    def getCaption(self) -> str:
        '''Gets the descriptive text that appears on a control.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()

    def setAccelerator(self, value : str) -> None:
        '''Sets the accelerator key for the control.
        :param value: '''
        raise NotImplementedError()

    def setTripleState(self, value : bool) -> None:
        '''Indicates how the specified control will display Null values.
        :param value: '''
        raise NotImplementedError()

    def isTripleState(self) -> bool:
        '''Indicates how the specified control will display Null values.'''
        raise NotImplementedError()


class Top10:
    '''Describe the Top10 conditional formatting rule.
    This conditional formatting rule highlights cells whose
    values fall in the top N or bottom N bracket, as specified.'''

    def getRank(self) -> int:
        '''Gets the value of "n" in a "top/bottom n" conditional formatting rule.
        If IsPercent is true, the value must between 0 and 100.
        Otherwise it must between 0 and 1000.
        Default value is 10.'''
        raise NotImplementedError()

    def setRank(self, value : int) -> None:
        '''Sets the value of "n" in a "top/bottom n" conditional formatting rule.
        If IsPercent is true, the value must between 0 and 100.
        Otherwise it must between 0 and 1000.
        Default value is 10.
        :param value: '''
        raise NotImplementedError()

    def setBottom(self, value : bool) -> None:
        '''Sets whether a "top/bottom n" rule is a "bottom n" rule.
        Default value is false.
        :param value: '''
        raise NotImplementedError()

    def setPercent(self, value : bool) -> None:
        '''Sets whether a "top/bottom n" rule is a "top/bottom n percent" rule.
        Default value is false.
        :param value: '''
        raise NotImplementedError()

    def isBottom(self) -> bool:
        '''Gets whether a "top/bottom n" rule is a "bottom n" rule.
        Default value is false.'''
        raise NotImplementedError()

    def isPercent(self) -> bool:
        '''Gets whether a "top/bottom n" rule is a "top/bottom n percent" rule.
        Default value is false.'''
        raise NotImplementedError()


class Top10Filter:
    '''Represents the top 10 filter.'''

    def setCriteria(self, value : Object) -> None:
        '''
        :param value: '''
        raise NotImplementedError()

    def isTop(self) -> bool:
        '''Indicates whether it's top filter.'''
        raise NotImplementedError()

    def setItems(self, value : int) -> None:
        '''Sets the items of the filter.
        :param value: '''
        raise NotImplementedError()

    def getCriteria(self) -> Object:
        ''''''
        raise NotImplementedError()

    def setTop(self, value : bool) -> None:
        '''Indicates whether it's top filter.
        :param value: '''
        raise NotImplementedError()

    def getItems(self) -> int:
        '''Gets the items of the filter.'''
        raise NotImplementedError()

    def setPercent(self, value : bool) -> None:
        '''Indicates whether the items is percent.
        :param value: '''
        raise NotImplementedError()

    def isPercent(self) -> bool:
        '''Indicates whether the items is percent.'''
        raise NotImplementedError()


class TotalsCalculation:
    '''Determines the type of calculation in the Totals row of the list column.'''

    SUM : TotalsCalculation
    '''Represents Sum totals calculation.'''

    COUNT : TotalsCalculation
    '''Represents Count totals calculation.'''

    AVERAGE : TotalsCalculation
    '''Represents Average totals calculation.'''

    MAX : TotalsCalculation
    '''Represents Max totals calculation.'''

    MIN : TotalsCalculation
    '''Represents Min totals calculation.'''

    VAR : TotalsCalculation
    '''Represents Var totals calculation.'''

    COUNT_NUMS : TotalsCalculation
    '''Represents Count Nums totals calculation.'''

    STD_DEV : TotalsCalculation
    '''Represents StdDev totals calculation.'''

    NONE : TotalsCalculation
    '''Represents No totals calculation.'''

    CUSTOM : TotalsCalculation
    '''Represents custom calculation.'''


class Trendline:
    '''Represents a trendline in a chart.'''

    def getIntercept(self) -> int:
        '''Returns or sets the point where the trendline crosses the value axis.'''
        raise NotImplementedError()

    def getForward(self) -> int:
        '''Returns or sets the number of periods (or units on a scatter chart) that the trendline extends forward.
        The number of periods must be greater than or equal to zero.'''
        raise NotImplementedError()

    def getLegendEntry(self) -> LegendEntry:
        '''Gets the legend entry according to this trendline'''
        raise NotImplementedError()

    def setIntercept(self, value : int) -> None:
        '''Returns or sets the point where the trendline crosses the value axis.
        :param value: '''
        raise NotImplementedError()

    def setOrder(self, value : int) -> None:
        '''Returns or sets the trendline order (an integer greater than 1) when the trendline type is Polynomial.
        The order must be between 2 and 6.
        :param value: '''
        raise NotImplementedError()

    def isNameAuto(self) -> bool:
        '''Returns if Microsoft Excel automatically determines the name of the trendline.'''
        raise NotImplementedError()

    def getOrder(self) -> int:
        '''Returns or sets the trendline order (an integer greater than 1) when the trendline type is Polynomial.
        The order must be between 2 and 6.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Returns the name of the trendline.
        :param value: '''
        raise NotImplementedError()

    def getDataLabels(self) -> DataLabels:
        '''Represents the DataLabels object for the specified series.'''
        raise NotImplementedError()

    def getBackward(self) -> int:
        '''Returns or sets the number of periods (or units on a scatter chart) that the trendline extends backward.
        The number of periods must be greater than or equal to zero.
        If the chart type is column ,the number of periods must be between 0 and 0.5'''
        raise NotImplementedError()

    def setPeriod(self, value : int) -> None:
        '''Returns or sets the period for the moving-average trendline.
        :param value: '''
        raise NotImplementedError()

    def setForward(self, value : int) -> None:
        '''Returns or sets the number of periods (or units on a scatter chart) that the trendline extends forward.
        The number of periods must be greater than or equal to zero.
        :param value: '''
        raise NotImplementedError()

    def setBackward(self, value : int) -> None:
        '''Returns or sets the number of periods (or units on a scatter chart) that the trendline extends backward.
        The number of periods must be greater than or equal to zero.
        If the chart type is column ,the number of periods must be between 0 and 0.5
        :param value: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Returns the name of the trendline.'''
        raise NotImplementedError()

    def setNameAuto(self, value : bool) -> None:
        '''Returns if Microsoft Excel automatically determines the name of the trendline.
        :param value: '''
        raise NotImplementedError()

    def getDisplayRSquared(self) -> bool:
        '''Represents if the R-squared value of the trendline is displayed on the chart (in the same data label as the equation). Setting this property to True automatically turns on data labels.'''
        raise NotImplementedError()

    def getPeriod(self) -> int:
        '''Returns or sets the period for the moving-average trendline.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Returns the trendline type.
        See :class:`TrendlineType`'''
        raise NotImplementedError()

    def setInterceptAuto(self, isInterceptAuto : bool) -> None:
        '''Sets whether Microsoft Workbook automatically determines the intercept of the trendline.
        :param isInterceptAuto: '''
        raise NotImplementedError()

    def setDisplayEquation(self, value : bool) -> None:
        '''Represents if the equation for the trendline is displayed on the chart (in the same data label as the R-squared value). Setting this property to True automatically turns on data labels.
        :param value: '''
        raise NotImplementedError()

    def isInterceptAuto(self) -> bool:
        '''Indicates whether Microsoft Workbook automatically determines the intercept of the trendline.'''
        raise NotImplementedError()

    def getDisplayEquation(self) -> bool:
        '''Represents if the equation for the trendline is displayed on the chart (in the same data label as the R-squared value). Setting this property to True automatically turns on data labels.'''
        raise NotImplementedError()

    def setDisplayRSquared(self, value : bool) -> None:
        '''Represents if the R-squared value of the trendline is displayed on the chart (in the same data label as the equation). Setting this property to True automatically turns on data labels.
        :param value: '''
        raise NotImplementedError()


class TrendlineCollection:
    '''Represents a collection of all the :class:`Trendline` objects for the specified data series.'''

    def get(self, index : int) -> Trendline:
        '''Gets a :class:`Trendline` object by its index.
        :param index: '''
        raise NotImplementedError()

    @overload
    def add(self, type : int) -> int:
        '''Adds a :class:`Trendline` object to this collection with specified type.
        :param type: :class:`TrendlineType`. Trendline type.
        :returns: :class:`Trendline` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, type : int, name : str) -> int:
        '''Adds a :class:`Trendline` object to this collection with specified type and name.
        :param type: :class:`TrendlineType`. Trendline type.
        :param name: Trendline name.
        :returns: :class:`Trendline` object index.'''
        raise NotImplementedError()


class TrendlineType:
    '''Represents the trendline type.'''

    EXPONENTIAL : TrendlineType
    '''Exponential'''

    LINEAR : TrendlineType
    '''Linear'''

    LOGARITHMIC : TrendlineType
    '''Logarithmic'''

    MOVING_AVERAGE : TrendlineType
    '''MovingAverage'''

    POLYNOMIAL : TrendlineType
    '''Polynomial'''

    POWER : TrendlineType
    '''Power'''


class TwoColorGradient:
    '''Represents two color gradient.'''

    def setColor2(self, value : Color) -> None:
        '''Sets the second gradient color.
        :param value: '''
        raise NotImplementedError()

    def getGradientStyleType(self) -> int:
        '''Gets gradient shading style.
        See :class:`GradientStyleType`'''
        raise NotImplementedError()

    def setColor1(self, value : Color) -> None:
        '''Sets the first gradient color.
        :param value: '''
        raise NotImplementedError()

    def setVariant(self, value : int) -> None:
        '''Sets the gradient variant.
        :param value: '''
        raise NotImplementedError()

    def getVariant(self) -> int:
        '''Gets the gradient variant.'''
        raise NotImplementedError()

    def setGradientStyleType(self, value : int) -> None:
        '''Sets gradient shading style.
        See :class:`GradientStyleType`
        :param value: '''
        raise NotImplementedError()

    def getColor2(self) -> Color:
        '''Gets the second gradient color.'''
        raise NotImplementedError()

    def getColor1(self) -> Color:
        '''Gets the first gradient color.'''
        raise NotImplementedError()


class TxtLoadOptions:
    '''Represents the options for loading text file.'''

    def getExtendToNextSheet(self) -> bool:
        '''Whether extends data to next sheet when the rows or columns of data exceed limit.
        Default is false.'''
        raise NotImplementedError()

    def getTreatConsecutiveDelimitersAsOne(self) -> bool:
        '''Whether consecutive delimiters should be treated as one.'''
        raise NotImplementedError()

    def getMaxColumnCount(self) -> int:
        '''The maximum count of columns to be imported for one sheet.'''
        raise NotImplementedError()

    def setTreatQuotePrefixAsValue(self, value : bool) -> None:
        '''Indicates whether the leading single quote sign should be taken as part of the value of one cell.
        Default is true. If it is false, the leading single quote will be removed from corresponding cell's value
        and :meth:`Style.getQuotePrefix()` will be set as true for the cell.
        :param value: '''
        raise NotImplementedError()

    def getTextQualifier(self) -> str:
        '''Specifies the text qualifier for cell values. Default qualifier is '"'.'''
        raise NotImplementedError()

    def setPreferredParsers(self, value : list[ICustomParser]) -> None:
        '''Sets preferred value parsers for loading text file.
        :param value: '''
        raise NotImplementedError()

    def getSeparatorString(self) -> str:
        '''Gets a string value as separator.'''
        raise NotImplementedError()

    def hasTextQualifier(self) -> bool:
        '''Whether there is text qualifier for cell value. Default is true.'''
        raise NotImplementedError()

    def hasFormula(self) -> bool:
        '''Indicates whether the text is formula if it starts with "=".'''
        raise NotImplementedError()

    def setTreatConsecutiveDelimitersAsOne(self, value : bool) -> None:
        '''Whether consecutive delimiters should be treated as one.
        :param value: '''
        raise NotImplementedError()

    def setExtendToNextSheet(self, value : bool) -> None:
        '''Whether extends data to next sheet when the rows or columns of data exceed limit.
        Default is false.
        :param value: '''
        raise NotImplementedError()

    def getHeaderColumnsCount(self) -> int:
        '''The count of header columns to be repeated for extended sheets.'''
        raise NotImplementedError()

    def setTextQualifier(self, value : str) -> None:
        '''Specifies the text qualifier for cell values. Default qualifier is '"'.
        :param value: '''
        raise NotImplementedError()

    def setMultiEncoded(self, value : bool) -> None:
        '''True means that the file contains several encoding.
        :param value: '''
        raise NotImplementedError()

    def getSeparator(self) -> str:
        '''Gets character separator of text file.'''
        raise NotImplementedError()

    def getMaxRowCount(self) -> int:
        '''The maximum count of rows to be imported for one sheet.'''
        raise NotImplementedError()

    def isMultiEncoded(self) -> bool:
        '''True means that the file contains several encoding.'''
        raise NotImplementedError()

    def setHasTextQualifier(self, value : bool) -> None:
        '''Whether there is text qualifier for cell value. Default is true.
        :param value: '''
        raise NotImplementedError()

    def getHeaderRowsCount(self) -> int:
        '''The count of header rows to be repeated for extended sheets.'''
        raise NotImplementedError()

    def getPreferredParsers(self) -> list[ICustomParser]:
        '''Gets preferred value parsers for loading text file.'''
        raise NotImplementedError()

    def setMaxColumnCount(self, value : int) -> None:
        '''The maximum count of columns to be imported for one sheet.
        :param value: '''
        raise NotImplementedError()

    def setHeaderColumnsCount(self, value : int) -> None:
        '''The count of header columns to be repeated for extended sheets.
        :param value: '''
        raise NotImplementedError()

    def setSeparatorString(self, value : str) -> None:
        '''Sets a string value as separator.
        :param value: '''
        raise NotImplementedError()

    def setHasFormula(self, value : bool) -> None:
        '''Indicates whether the text is formula if it starts with "=".
        :param value: '''
        raise NotImplementedError()

    def getTreatQuotePrefixAsValue(self) -> bool:
        '''Indicates whether the leading single quote sign should be taken as part of the value of one cell.
        Default is true. If it is false, the leading single quote will be removed from corresponding cell's value
        and :meth:`Style.getQuotePrefix()` will be set as true for the cell.'''
        raise NotImplementedError()

    def setHeaderRowsCount(self, value : int) -> None:
        '''The count of header rows to be repeated for extended sheets.
        :param value: '''
        raise NotImplementedError()

    def setSeparator(self, value : str) -> None:
        '''Sets character separator of text file.
        :param value: '''
        raise NotImplementedError()

    def setMaxRowCount(self, value : int) -> None:
        '''The maximum count of rows to be imported for one sheet.
        :param value: '''
        raise NotImplementedError()


class TxtLoadStyleStrategy:
    '''Specifies how to apply style for parsed values when converting string value to number or datetime.'''

    NONE : TxtLoadStyleStrategy
    '''Does not set style for the parsed value.'''

    BUILT_IN : TxtLoadStyleStrategy
    '''Set the style as built-in number/datetime when the parsed value are plain numeric/datetime values.'''

    EXACT_FORMAT : TxtLoadStyleStrategy
    '''Set the exact custom format for the parsed value to make the formatted value be same with the original input one.'''


class TxtSaveOptions:
    '''Represents the save options for csv/tab delimited/other text format.'''

    def setExportAllSheets(self, value : bool) -> None:
        '''Indicates whether exporting all sheets to the text file.
        If it is false, only export the activesheet, just like MS Excel.
        :param value: '''
        raise NotImplementedError()

    def getTrimTailingBlankCells(self) -> bool:
        '''Indicates whether tailing blank cells in one row should be trimmed. Default is false.'''
        raise NotImplementedError()

    def getTrimLeadingBlankRowAndColumn(self) -> bool:
        '''Indicates whether leading blank rows and columns should be trimmed like what ms excel does.
        Default is true.'''
        raise NotImplementedError()

    def getExportAllSheets(self) -> bool:
        '''Indicates whether exporting all sheets to the text file.
        If it is false, only export the activesheet, just like MS Excel.'''
        raise NotImplementedError()

    def getEncoding(self) -> Encoding:
        '''Gets the default encoding.'''
        raise NotImplementedError()

    def setLightCellsDataProvider(self, value : LightCellsDataProvider) -> None:
        '''The data provider for saving workbook in light mode.
        :param value: '''
        raise NotImplementedError()

    def getAlwaysQuoted(self) -> bool:
        ''':deprecated: Use QuoteType property instead.'''
        raise NotImplementedError()

    def setTrimTailingBlankCells(self, value : bool) -> None:
        '''Indicates whether tailing blank cells in one row should be trimmed. Default is false.
        :param value: '''
        raise NotImplementedError()

    def getSeparatorString(self) -> str:
        '''Gets a string value as separator.'''
        raise NotImplementedError()

    def setExportArea(self, value : CellArea) -> None:
        '''The range of cells to be exported.
        :param value: '''
        raise NotImplementedError()

    def setEncoding(self, value : Encoding) -> None:
        '''Sets the default encoding.
        :param value: '''
        raise NotImplementedError()

    def setQuoteType(self, value : int) -> None:
        '''Sets how to quote values in the exported text file.
        See :class:`TxtValueQuoteType`
        :param value: '''
        raise NotImplementedError()

    def setFormatStrategy(self, value : int) -> None:
        '''Sets the format strategy when exporting the cell value as string.
        See :class:`CellValueFormatStrategy`
        :param value: '''
        raise NotImplementedError()

    def getSeparator(self) -> str:
        '''Gets char Delimiter of text file.'''
        raise NotImplementedError()

    def setSeparatorString(self, value : str) -> None:
        '''Sets a string value as separator.
        :param value: '''
        raise NotImplementedError()

    def setTrimLeadingBlankRowAndColumn(self, value : bool) -> None:
        '''Indicates whether leading blank rows and columns should be trimmed like what ms excel does.
        Default is true.
        :param value: '''
        raise NotImplementedError()

    def getExportQuotePrefix(self) -> bool:
        '''Indicates whether the single quote sign should be exported as part of the value of one cell
        when :meth:`Style.getQuotePrefix()` is true for it. Default is false.'''
        raise NotImplementedError()

    def getExportArea(self) -> CellArea:
        '''The range of cells to be exported.'''
        raise NotImplementedError()

    def getQuoteType(self) -> int:
        '''Gets how to quote values in the exported text file.
        See :class:`TxtValueQuoteType`'''
        raise NotImplementedError()

    def getFormatStrategy(self) -> int:
        '''Gets the format strategy when exporting the cell value as string.
        See :class:`CellValueFormatStrategy`'''
        raise NotImplementedError()

    def getLightCellsDataProvider(self) -> LightCellsDataProvider:
        '''The data provider for saving workbook in light mode.'''
        raise NotImplementedError()

    def setKeepSeparatorsForBlankRow(self, value : bool) -> None:
        '''Indicates whether separators should be output for blank row.
        Default value is false so by default the content for blank row will be empty.
        :param value: '''
        raise NotImplementedError()

    def setSeparator(self, value : str) -> None:
        '''Sets char Delimiter of text file.
        :param value: '''
        raise NotImplementedError()

    def setAlwaysQuoted(self, value : bool) -> None:
        ''':deprecated: Use QuoteType property instead.'''
        raise NotImplementedError()

    def setExportQuotePrefix(self, value : bool) -> None:
        '''Indicates whether the single quote sign should be exported as part of the value of one cell
        when :meth:`Style.getQuotePrefix()` is true for it. Default is false.
        :param value: '''
        raise NotImplementedError()

    def getKeepSeparatorsForBlankRow(self) -> bool:
        '''Indicates whether separators should be output for blank row.
        Default value is false so by default the content for blank row will be empty.'''
        raise NotImplementedError()


class TxtValueQuoteType:
    '''Specifies the type of using quotation marks for values in text format files.'''

    NORMAL : TxtValueQuoteType
    '''All values that contain special characters such as quotation mark, separator character will be quoted.
    Same with the behavior of ms excel for exporting text file.'''

    ALWAYS : TxtValueQuoteType
    '''All values will be quoted always.'''

    MINIMUM : TxtValueQuoteType
    '''Only quote values when needed. Such as, if one value contains quotation mark but the quotation mark is not at the begin of this value, this value will not be quoted.'''

    NEVER : TxtValueQuoteType
    '''All values will not be quoted. The exported text file with this type may not be read back correctly because the needed quotation marks being absent.'''


class UnionRange:
    '''Represents union range.'''

    def getColumnCount(self) -> int:
        '''Gets the count of rows in the range.'''
        raise NotImplementedError()

    def getRanges(self) -> list[Range]:
        '''Gets all union ranges.'''
        raise NotImplementedError()

    def getFirstColumn(self) -> int:
        '''Gets the index of the first column of the range.'''
        raise NotImplementedError()

    def hasRange(self) -> bool:
        '''Indicates whether this has range.'''
        raise NotImplementedError()

    def putValue(self, stringValue : str, isConverted : bool, setStyle : bool) -> None:
        '''Puts a value into the range, if appropriate the value will be converted to other data type and cell's number format will be reset.
        :param stringValue: Input value
        :param isConverted: True: converted to other data type if appropriate.
        :param setStyle: True: set the number format to cell's style when converting to other data type'''
        raise NotImplementedError()

    @overload
    def union(self, range : str) -> UnionRange:
        '''Union another range.
        :param range: The range.'''
        raise NotImplementedError()

    @overload
    def union(self, unionRange : UnionRange) -> UnionRange:
        '''Union another range.
        :param unionRange: The range.'''
        raise NotImplementedError()

    @overload
    def union(self, ranges : list[Range]) -> UnionRange:
        '''Union the ranges.
        :param ranges: The ranges.'''
        raise NotImplementedError()

    def setValue(self, value : Object) -> None:
        '''Sets the values of the range.
        :param value: '''
        raise NotImplementedError()

    def getValue(self) -> Object:
        '''Gets the values of the range.'''
        raise NotImplementedError()

    def setStyle(self, style : Style) -> None:
        '''Sets the style of the range.
        :param style: The Style object.'''
        raise NotImplementedError()

    def getRangeCount(self) -> int:
        '''Gets the count of the ranges.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the range.
        :param value: '''
        raise NotImplementedError()

    def merge(self) -> None:
        '''Combines a range of cells into a single cell.'''
        raise NotImplementedError()

    def unMerge(self) -> None:
        '''Unmerges merged cells of this range.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the range.'''
        raise NotImplementedError()

    def getHyperlinks(self) -> list[Hyperlink]:
        '''Gets all hyperlink in the range.'''
        raise NotImplementedError()

    def iterator(self) -> Iterator:
        '''Gets the enumerator for cells in this Range.'''
        raise NotImplementedError()

    def getCellCount(self) -> int:
        '''Gets all cell count in the range.'''
        raise NotImplementedError()

    def copy(self, range : UnionRange, options : PasteOptions) -> None:
        '''Copying the range with paste special options.
        :param range: The source range.
        :param options: The paste special options.'''
        raise NotImplementedError()

    @overload
    def setOutlineBorders(self, borderStyles : list[int], borderColors : list[Color]) -> None:
        '''Sets out line borders around a range of cells.
        :param borderStyles: :class:`CellBorderType`. Border styles.
        :param borderColors: Border colors.'''
        raise NotImplementedError()

    @overload
    def setOutlineBorders(self, borderStyle : int, borderColor : Color) -> None:
        '''Sets the outline borders around a range of cells with same border style and color.
        :param borderStyle: :class:`CellBorderType`. Border style.
        :param borderColor: Border color.'''
        raise NotImplementedError()

    @overload
    def intersect(self, range : str) -> UnionRange:
        '''Intersects another range.
        :param range: The range.'''
        raise NotImplementedError()

    @overload
    def intersect(self, unionRange : UnionRange) -> UnionRange:
        '''Intersects another range.
        :param unionRange: The range.'''
        raise NotImplementedError()

    @overload
    def intersect(self, ranges : list[Range]) -> UnionRange:
        '''Intersects another range.
        :param ranges: The range.'''
        raise NotImplementedError()

    def applyStyle(self, style : Style, flag : StyleFlag) -> None:
        '''Applies formats for a whole range.
        :param style: The style object which will be applied.
        :param flag: Flags which indicates applied formatting properties.'''
        raise NotImplementedError()

    def getRowCount(self) -> int:
        '''Gets the count of rows in the range.'''
        raise NotImplementedError()

    def getFirstRow(self) -> int:
        '''Gets the index of the first row of the range.'''
        raise NotImplementedError()

    def getRefersTo(self) -> str:
        '''Gets the range's refers to.'''
        raise NotImplementedError()


class UnknowEquationNode:
    '''Equation node class of unknown type'''

    def equals(self, obj : Object) -> bool:
        '''Determine whether the current equation node is equal to the specified node
        :param obj: The specified node'''
        raise NotImplementedError()


class UnknownControl:
    '''Unknow control.'''

    def getData(self) -> list[int]:
        '''Gets the binary data of the control.'''
        raise NotImplementedError()

    def getRelationshipData(self, relId : str) -> list[int]:
        '''Gets the related data.
        :param relId: The relationship id.
        :returns: Returns the related data.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of the ActiveX control.
        See :class:`ControlType`'''
        raise NotImplementedError()


class UpdateLinksType:
    '''Represents how to update links to other workbooks when the workbook is opened.'''

    USER_SET : UpdateLinksType
    '''Prompt user to update.'''

    NEVER : UpdateLinksType
    '''Do not update, and do not prompt user.'''

    ALWAYS : UpdateLinksType
    '''Always update.'''


class Validation:
    '''Represents data validation.settings.'''

    def setInputMessage(self, value : str) -> None:
        '''Represents the data validation input message.
        :param value: '''
        raise NotImplementedError()

    def setShowInput(self, value : bool) -> None:
        '''Indicates whether the data validation input message will be displayed whenever the user selects a cell in the data validation range.
        :param value: '''
        raise NotImplementedError()

    def getShowError(self) -> bool:
        '''Indicates whether the data validation error message will be displayed whenever the user enters invalid data.'''
        raise NotImplementedError()

    def getValue2(self) -> Object:
        '''Represents the second value associated with the data validation.'''
        raise NotImplementedError()

    def getValue1(self) -> Object:
        '''Represents the first value associated with the data validation.'''
        raise NotImplementedError()

    def removeArea(self, cellArea : CellArea) -> None:
        '''Remove the validation settings in the range.
        :param cellArea: the areas where this validation settings should be removed.'''
        raise NotImplementedError()

    def setErrorMessage(self, value : str) -> None:
        '''Represents the data validation error message.
        :param value: '''
        raise NotImplementedError()

    def setValue2(self, value : Object) -> None:
        '''Represents the second value associated with the data validation.
        :param value: '''
        raise NotImplementedError()

    def setValue1(self, value : Object) -> None:
        '''Represents the first value associated with the data validation.
        :param value: '''
        raise NotImplementedError()

    def setIgnoreBlank(self, value : bool) -> None:
        '''Indicates whether blank values are permitted by the range data validation.
        :param value: '''
        raise NotImplementedError()

    def getAlertStyle(self) -> int:
        '''Represents the validation alert style.
        See :class:`ValidationAlertType`'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents the data validation type.
        See :class:`ValidationType`'''
        raise NotImplementedError()

    @overload
    def getFormula2(self, isR1C1 : bool, isLocal : bool) -> str:
        '''Gets the value or expression associated with this validation.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :returns: The value or expression associated with this validation.'''
        raise NotImplementedError()

    @overload
    def getFormula2(self, isR1C1 : bool, isLocal : bool, row : int, column : int) -> str:
        '''Gets the value or expression associated with this validation for specific cell.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :param row: The row index.
        :param column: The column index.
        :returns: The value or expression associated with this validation.'''
        raise NotImplementedError()

    @overload
    def getFormula2(self) -> str:
        '''Represents the value or expression associated with the data validation.'''
        raise NotImplementedError()

    @overload
    def getFormula1(self, isR1C1 : bool, isLocal : bool) -> str:
        '''Gets the value or expression associated with this validation.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :returns: The value or expression associated with this validation.'''
        raise NotImplementedError()

    @overload
    def getFormula1(self, isR1C1 : bool, isLocal : bool, row : int, column : int) -> str:
        '''Gets the value or expression associated with this validation for specific cell.
        :param isR1C1: Whether the formula needs to be formatted as R1C1.
        :param isLocal: Whether the formula needs to be formatted by locale.
        :param row: The row index.
        :param column: The column index.
        :returns: The value or expression associated with this validation.'''
        raise NotImplementedError()

    @overload
    def getFormula1(self) -> str:
        '''Represents the value or expression associated with the data validation.'''
        raise NotImplementedError()

    def getInCellDropDown(self) -> bool:
        '''Indicates whether data validation displays a drop-down list that contains acceptable values.'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Represents the data validation type.
        See :class:`ValidationType`
        :param value: '''
        raise NotImplementedError()

    def getErrorTitle(self) -> str:
        '''Represents the title of the data-validation error dialog box.'''
        raise NotImplementedError()

    def getInputTitle(self) -> str:
        '''Represents the title of the data-validation input dialog box.'''
        raise NotImplementedError()

    def getAreas(self) -> list[CellArea]:
        '''Gets all :class:`CellArea` which contain the data validation settings.'''
        raise NotImplementedError()

    def setShowError(self, value : bool) -> None:
        '''Indicates whether the data validation error message will be displayed whenever the user enters invalid data.
        :param value: '''
        raise NotImplementedError()

    def getIgnoreBlank(self) -> bool:
        '''Indicates whether blank values are permitted by the range data validation.'''
        raise NotImplementedError()

    def getInputMessage(self) -> str:
        '''Represents the data validation input message.'''
        raise NotImplementedError()

    def getShowInput(self) -> bool:
        '''Indicates whether the data validation input message will be displayed whenever the user selects a cell in the data validation range.'''
        raise NotImplementedError()

    def getValue(self, row : int, column : int, isValue1 : bool) -> Object:
        '''Get the value of validation on the specific cell.
        :param row: The row index.
        :param column: The column index.
        :param isValue1: Indicates whether getting the first value.'''
        raise NotImplementedError()

    def getOperator(self) -> int:
        '''Represents the operator for the data validation.
        See :class:`OperatorType`'''
        raise NotImplementedError()

    @overload
    def setFormula2(self, formula : str, isR1C1 : bool, isLocal : bool) -> None:
        '''Sets the value or expression associated with this validation.
        :param formula: The value or expression associated with this format condition.
        :param isR1C1: Whether the formula is R1C1 formula.
        :param isLocal: Whether the formula is locale formatted.'''
        raise NotImplementedError()

    @overload
    def setFormula2(self, value : str) -> None:
        '''Represents the value or expression associated with the data validation.
        :param value: '''
        raise NotImplementedError()

    def removeAreas(self, areas : list[CellArea]) -> None:
        '''Removes this validation from given areas.
        :param areas: the areas where this validation settings should be removed.'''
        raise NotImplementedError()

    @overload
    def setFormula1(self, formula : str, isR1C1 : bool, isLocal : bool) -> None:
        '''Sets the value or expression associated with this validation.
        :param formula: The value or expression associated with this format condition.
        :param isR1C1: Whether the formula is R1C1 formula.
        :param isLocal: Whether the formula is locale formatted.'''
        raise NotImplementedError()

    @overload
    def setFormula1(self, value : str) -> None:
        '''Represents the value or expression associated with the data validation.
        :param value: '''
        raise NotImplementedError()

    def setAlertStyle(self, value : int) -> None:
        '''Represents the validation alert style.
        See :class:`ValidationAlertType`
        :param value: '''
        raise NotImplementedError()

    def addAreas(self, areas : list[CellArea], checkIntersection : bool, checkEdge : bool) -> None:
        '''Applies the validation to given areas.
        :param areas: The areas.
        :param checkIntersection: Whether check the intersection of given area with existing validations' areas.
        :param checkEdge: Whether check the edge of this validation's applied areas.'''
        raise NotImplementedError()

    def removeACell(self, row : int, column : int) -> None:
        '''Remove the validation settings in the cell.
        :param row: The row index.
        :param column: The column index.'''
        raise NotImplementedError()

    def copy(self, source : Validation, copyOption : CopyOptions) -> None:
        '''Copy validation.
        :param source: The source validation.
        :param copyOption: The copy option.'''
        raise NotImplementedError()

    def setOperator(self, value : int) -> None:
        '''Represents the operator for the data validation.
        See :class:`OperatorType`
        :param value: '''
        raise NotImplementedError()

    def getListValue(self, row : int, column : int) -> Object:
        '''Get the value for list of the validation for the specified cell.
        :param row: The row index.
        :param column: The column index.
        :returns: The value to produce the list of this validation for the specified cell. If the list references to a range, then the returned value will be a :class:`ReferredArea` object; Otherwise the returned value may be null, object[], or simple object.'''
        raise NotImplementedError()

    def getErrorMessage(self) -> str:
        '''Represents the data validation error message.'''
        raise NotImplementedError()

    def setErrorTitle(self, value : str) -> None:
        '''Represents the title of the data-validation error dialog box.
        :param value: '''
        raise NotImplementedError()

    def setInCellDropDown(self, value : bool) -> None:
        '''Indicates whether data validation displays a drop-down list that contains acceptable values.
        :param value: '''
        raise NotImplementedError()

    @overload
    def addArea(self, cellArea : CellArea) -> None:
        '''Applies the validation to the area.
        :param cellArea: The area.'''
        raise NotImplementedError()

    @overload
    def addArea(self, cellArea : CellArea, checkIntersection : bool, checkEdge : bool) -> None:
        '''Applies the validation to the area.
        :param cellArea: The area.
        :param checkIntersection: Whether check the intersection of given area with existing validations' areas.
        :param checkEdge: Whether check the edge of this validation's applied areas.'''
        raise NotImplementedError()

    def setInputTitle(self, value : str) -> None:
        '''Represents the title of the data-validation input dialog box.
        :param value: '''
        raise NotImplementedError()


class ValidationAlertType:
    '''Represents the data validation alert style.'''

    INFORMATION : ValidationAlertType
    '''Information alert style.'''

    STOP : ValidationAlertType
    '''Stop alert style.'''

    WARNING : ValidationAlertType
    '''Warning alert style.'''


class ValidationCollection:
    '''Represents data validation collection.'''

    def get(self, index : int) -> Validation:
        '''Gets the :class:`Validation` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    def getValidationInCell(self, row : int, column : int) -> Validation:
        '''Gets the validation applied to given cell.
        :param row: The row index.
        :param column: The column index.
        :returns: Returns a :class:`Validation` object or null if there is no validation for given cell'''
        raise NotImplementedError()

    @overload
    def add(self) -> int:
        ''':deprecated: Use ValidationCollection.Add(CellArea) method instead.'''
        raise NotImplementedError()

    @overload
    def add(self, ca : CellArea) -> int:
        '''Adds a data validation to the collection.
        :param ca: The area contains this validation.
        :returns: :class:`Validation` object index.'''
        raise NotImplementedError()

    def removeArea(self, ca : CellArea) -> None:
        '''Removes all validation setting on the range..
        :param ca: The range which contains the validations setting.'''
        raise NotImplementedError()

    def removeACell(self, row : int, column : int) -> None:
        '''Removes all validation setting on the cell.
        :param row: The row index of the cell.
        :param column: The column index of the cell.'''
        raise NotImplementedError()


class ValidationType:
    '''Represents data validation type.'''

    ANY_VALUE : ValidationType
    '''Any value validation type.'''

    WHOLE_NUMBER : ValidationType
    '''Whole number validation type.'''

    DECIMAL : ValidationType
    '''Decimal validation type.'''

    LIST : ValidationType
    '''List validation type.'''

    DATE : ValidationType
    '''Date validation type.'''

    TIME : ValidationType
    '''Time validation type.'''

    TEXT_LENGTH : ValidationType
    '''Text length validation type.'''

    CUSTOM : ValidationType
    '''Custom validation type.'''


class VbaModule:
    '''Represents the module in VBA project.'''

    def setCodes(self, value : str) -> None:
        '''Sets the codes of module.
        :param value: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of Module.'''
        raise NotImplementedError()

    def getCodes(self) -> str:
        '''Gets the codes of module.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of Module.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of module.
        See :class:`VbaModuleType`'''
        raise NotImplementedError()


class VbaModuleCollection:
    '''Represents the list of :class:`VbaModule`'''

    @overload
    def remove(self, sheet : Worksheet) -> None:
        '''Removes module for a worksheet.
        :param sheet: The worksheet'''
        raise NotImplementedError()

    @overload
    def remove(self, name : str) -> None:
        '''Remove the module by the name
        :param name: '''
        raise NotImplementedError()

    def addDesignerStorage(self, name : str, data : list[int]) -> None:
        '''
        :param name: 
        :param data: '''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> VbaModule:
        '''Gets :class:`VbaModule` in the list by the index.
        :param index: The index.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> VbaModule:
        '''Gets :class:`VbaModule` in the list by the name.
        :param name: The name of module.'''
        raise NotImplementedError()

    def getDesignerStorage(self, name : str) -> list[int]:
        '''Represents the data of Designer.
        :param name: '''
        raise NotImplementedError()

    def addUserForm(self, name : str, codes : str, designerStorage : list[int]) -> int:
        '''Inser user form into VBA Project.
        :param name: The name of user form
        :param codes: The codes for the user form
        :param designerStorage: the designer setting about the user form'''
        raise NotImplementedError()

    @overload
    def add(self, sheet : Worksheet) -> int:
        '''Adds module for a worksheet.
        :param sheet: The worksheet'''
        raise NotImplementedError()

    @overload
    def add(self, type : int, name : str) -> int:
        '''Adds module.
        :param type: :class:`VbaModuleType`. The type of module.
        :param name: The name of module.'''
        raise NotImplementedError()


class VbaModuleType:
    '''Represents the type of VBA module.'''

    PROCEDURAL : VbaModuleType
    '''Represents a procedural module.'''

    DOCUMENT : VbaModuleType
    '''Represents a document module.'''

    CLASS : VbaModuleType
    '''Represents a class module.'''

    DESIGNER : VbaModuleType
    '''Represents a designer module.'''


class VbaProject:
    '''Represents the VBA project.'''

    def copy(self, source : VbaProject) -> None:
        '''Copy VBA project from other file.
        :param source: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the VBA project.'''
        raise NotImplementedError()

    def protect(self, islockedForViewing : bool, password : str) -> None:
        '''Protects or unprotects this VBA project.
        :param islockedForViewing: indicates whether locks project for viewing.
        :param password: '''
        raise NotImplementedError()

    def sign(self, digitalSignature : DigitalSignature) -> None:
        '''Sign this VBA project by a DigitalSignature
        :param digitalSignature: DigitalSignature'''
        raise NotImplementedError()

    def getModules(self) -> VbaModuleCollection:
        '''Gets all :class:`VbaModule` objects.'''
        raise NotImplementedError()

    def validatePassword(self, password : str) -> bool:
        '''Validates protection password.
        :param password: the password
        :returns: Whether password is the protection password of this VBA project'''
        raise NotImplementedError()

    def isSigned(self) -> bool:
        '''Indicates whether VBAcode is signed or not.'''
        raise NotImplementedError()

    def getReferences(self) -> VbaProjectReferenceCollection:
        '''Gets all references of VBA project.'''
        raise NotImplementedError()

    def getIslockedForViewing(self) -> bool:
        '''Indicates whether this VBA project is locked for viewing.'''
        raise NotImplementedError()

    def setEncoding(self, value : Encoding) -> None:
        '''Sets the encoding of VBA project.
        :param value: '''
        raise NotImplementedError()

    def isValidSigned(self) -> bool:
        '''Indicates whether the signature of VBA project is valid or not.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the VBA project.
        :param value: '''
        raise NotImplementedError()

    def getEncoding(self) -> Encoding:
        '''Gets the encoding of VBA project.'''
        raise NotImplementedError()

    def isProtected(self) -> bool:
        '''Indicates whether this VBA project is protected.'''
        raise NotImplementedError()

    def getCertRawData(self) -> list[int]:
        '''Gets certificate raw data if this VBA project is signed.'''
        raise NotImplementedError()


class VbaProjectReference:
    '''Represents the reference of VBA project.'''

    def setExtendedLibid(self, value : str) -> None:
        '''Sets the extended Libid of the reference.
        :param value: '''
        raise NotImplementedError()

    def copy(self, source : VbaProjectReference) -> None:
        '''
        :param source: '''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the reference.'''
        raise NotImplementedError()

    def setLibid(self, value : str) -> None:
        '''Sets the Libid of the reference.
        :param value: '''
        raise NotImplementedError()

    def getLibid(self) -> str:
        '''Gets the Libid of the reference.'''
        raise NotImplementedError()

    def getExtendedLibid(self) -> str:
        '''Gets the extended Libid of the reference.'''
        raise NotImplementedError()

    def setRelativeLibid(self, value : str) -> None:
        '''Sets the referenced VBA project's identifier with an relative path.
        :param value: '''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the reference.
        :param value: '''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Gets the type of this reference.
        See :class:`VbaProjectReferenceType`'''
        raise NotImplementedError()

    def setTwiddledlibid(self, value : str) -> None:
        '''Sets the twiddled Libid of the reference.
        :param value: '''
        raise NotImplementedError()

    def getRelativeLibid(self) -> str:
        '''Gets the referenced VBA project's identifier with an relative path.'''
        raise NotImplementedError()

    def getTwiddledlibid(self) -> str:
        '''Gets the twiddled Libid of the reference.'''
        raise NotImplementedError()


class VbaProjectReferenceCollection:
    '''Represents all references of VBA project.'''

    def addControlRefrernce(self, name : str, libid : str, twiddledlibid : str, extendedLibid : str) -> int:
        '''Add a reference to a twiddled type library and its extended type library.
        :param name: The name of reference.
        :param libid: The identifier of an Automation type library.
        :param twiddledlibid: The identifier of a twiddled type library
        :param extendedLibid: The identifier of an extended type library'''
        raise NotImplementedError()

    def get(self, i : int) -> VbaProjectReference:
        '''Get the reference in the list by the index.
        :param i: The index.'''
        raise NotImplementedError()

    def addProjectRefrernce(self, name : str, absoluteLibid : str, relativeLibid : str) -> int:
        '''Adds a reference to an external VBA project.
        :param name: The name of reference.
        :param absoluteLibid: The referenced VBA project's identifier with an absolute path.
        :param relativeLibid: The referenced VBA project's identifier with an relative path.'''
        raise NotImplementedError()

    def addRegisteredReference(self, name : str, libid : str) -> int:
        '''Add a reference to an Automation type library.
        :param name: The name of reference.
        :param libid: The identifier of an Automation type library.'''
        raise NotImplementedError()

    def copy(self, source : VbaProjectReferenceCollection) -> None:
        '''Copies references from other VBA project.
        :param source: The source references.'''
        raise NotImplementedError()


class VbaProjectReferenceType:
    '''Represents the type of VBA project reference.'''

    REGISTERED : VbaProjectReferenceType
    '''Specifies a reference to an Automation type library.'''

    CONTROL : VbaProjectReferenceType
    '''Specifies a reference to a twiddled type library and its extended type library.'''

    PROJECT : VbaProjectReferenceType
    '''Specifies a reference to an external VBA project.'''


class VerticalPageBreak:
    '''Encapsulates the object that represents a vertical page break.'''

    def getEndRow(self) -> int:
        '''Gets the end row index of the vertical page break.'''
        raise NotImplementedError()

    def getColumn(self) -> int:
        '''Gets the column index of the vertical page break.'''
        raise NotImplementedError()

    def getStartRow(self) -> int:
        '''Gets the start row index of the vertical page break.'''
        raise NotImplementedError()


class VerticalPageBreakCollection:
    '''Encapsulates a collection of :class:`VerticalPageBreak` objects.'''

    def removeAt(self, index : int) -> None:
        '''Removes the VPageBreak element at a specified name.
        :param index: Element index, zero based.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> VerticalPageBreak:
        '''Gets the :class:`VerticalPageBreak` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def get(self, cellName : str) -> VerticalPageBreak:
        '''Gets the :class:`VerticalPageBreak` element with the specified cell name.
        :param cellName: Cell name.
        :returns: The element with the specified cell name.'''
        raise NotImplementedError()

    @overload
    def add(self, startRow : int, endRow : int, column : int) -> int:
        '''Adds a vertical page break to the collection.
        :param startRow: Start row index, zero based.
        :param endRow: End row index, zero based.
        :param column: Column index, zero based.
        :returns: :class:`VerticalPageBreak` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, column : int) -> int:
        '''Adds a vertical page break to the collection.
        :param column: Cell column index, zero based.
        :returns: :class:`VerticalPageBreak` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, row : int, column : int) -> int:
        '''Adds a vertical page break to the collection.
        :param row: Cell row index, zero based.
        :param column: Cell column index, zero based.
        :returns: :class:`VerticalPageBreak` object index.'''
        raise NotImplementedError()

    @overload
    def add(self, cellName : str) -> int:
        '''Adds a vertical page break to the collection.
        :param cellName: Cell name.
        :returns: :class:`VerticalPageBreak` object index.'''
        raise NotImplementedError()


class ViewType:
    '''Represents the view type of the worksheet.'''

    NORMAL_VIEW : ViewType
    ''''''

    PAGE_BREAK_PREVIEW : ViewType
    ''''''

    PAGE_LAYOUT_VIEW : ViewType
    ''''''


class VisibilityType:
    '''Represents the states for sheet visibility.'''

    VISIBLE : VisibilityType
    '''Indicates the sheet is visible.'''

    HIDDEN : VisibilityType
    '''Indicates the sheet is hidden, but can be shown by the user via the user interface.'''

    VERY_HIDDEN : VisibilityType
    '''Indicates the sheet is hidden and cannot be shown in the user interface (UI).
    This state is only available programmatically.'''


class VmlShapeGuide:
    '''just for vml
    Encapsulates a shape guide specifies the presence of a shape
    guide that will be used to govern the geometry of the specified shape'''


class Walls:
    '''Encapsulates the object that represents the walls of a 3-D chart.'''

    def getCubePointXPx(self, index : int) -> float:
        '''Gets x-coordinate of the apex point of walls cube after calls Chart.Calculate() method.
        The number of apex points of walls cube is eight
        :param index: '''
        raise NotImplementedError()

    def getCenterY(self) -> int:
        '''Gets the y coordinate of the left-bottom corner of Wall center in units of 1/4000 of chart's height after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getCenterXPx(self) -> int:
        '''Gets the x coordinate of the left-bottom corner of Wall center in units of pixels after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getCenterX(self) -> int:
        '''Gets the x coordinate of the left-bottom corner of Wall center in units of 1/4000 of chart's width after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getCubePointYPx(self, index : int) -> float:
        '''Gets y-coordinate of the apex point of walls cube after calls Chart.Calculate() method.
        The number of apex points of walls cube is eight.
        :param index: '''
        raise NotImplementedError()

    def getCenterYPx(self) -> int:
        '''Gets the y coordinate of the left-bottom corner of Wall center in units of pixels after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getWidthPx(self) -> int:
        '''Gets the width of left to right in units of pixels after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getHeight(self) -> int:
        '''Gets the height of top to bottom in units of 1/4000 of chart's height after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getDepthPx(self) -> int:
        '''Gets the depth front to back in units of pixels after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Gets the width of left to right in units of 1/4000 of chart's width after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getCubePointCount(self) -> int:
        '''Gets the number of cube points after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getHeightPx(self) -> int:
        '''Gets the height of top to bottom in units of pixels after calls Chart.Calculate() method.'''
        raise NotImplementedError()

    def getDepth(self) -> int:
        '''Gets the depth front to back in units of 1/4000 of chart's width after calls Chart.Calculate() method.'''
        raise NotImplementedError()


class WarningInfo:
    '''Warning info'''

    def getWarningType(self) -> int:
        ''':deprecated: Use WarningInfo.Type property, instead.'''
        raise NotImplementedError()

    def getCorrectedObject(self) -> Object:
        '''Gets the corrected object.'''
        raise NotImplementedError()

    def setCorrectedObject(self, value : Object) -> None:
        '''Sets the corrected object.
        :param value: '''
        raise NotImplementedError()

    def getDescription(self) -> str:
        '''Get description of warning info.'''
        raise NotImplementedError()

    def getErrorObject(self) -> Object:
        '''The error object.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Get warning type.
        See :class:`ExceptionType`'''
        raise NotImplementedError()


class WarningType:
    '''WaringType'''

    FONT_SUBSTITUTION : WarningType
    '''Font substitution warning type
    when a font has not been found, this warning type can be get.'''

    DUPLICATE_DEFINED_NAME : WarningType
    '''Duplicate defined name is found in the file.'''

    UNSUPPORTED_FILE_FORMAT : WarningType
    '''Unsupported file format.'''

    INVALID_TEXT_OF_DEFINED_NAME : WarningType
    '''Invalid text of the defined name.'''

    INVALID_FONT_NAME : WarningType
    '''Invalid the font name.'''

    INVALID_AUTO_FILTER_RANGE : WarningType
    '''Invalid autofilter range.'''

    IO : WarningType
    '''The file is corrupted.'''

    LIMITATION : WarningType
    '''Out of MS Excel limitation error.'''

    INVALID_DATA : WarningType
    '''Invalid data.'''

    FORMULA : WarningType
    '''Invalid formula.'''

    INVALID_OPERATOR : WarningType
    '''Invalid operator.'''


class WebExtension:
    '''Represents an Office Add-in instance.'''

    def setId(self, value : str) -> None:
        '''Sets the uniquely identifies the Office Add-in instance in the current document.
        :param value: '''
        raise NotImplementedError()

    def getBindings(self) -> WebExtensionBindingCollection:
        '''Gets all bindings relationship between an Office Add-in and the data in the document.'''
        raise NotImplementedError()

    def isFrozen(self) -> bool:
        '''Indicates whether the user can interact with the Office Add-in or not.'''
        raise NotImplementedError()

    def getId(self) -> str:
        '''Gets the uniquely identifies the Office Add-in instance in the current document.'''
        raise NotImplementedError()

    def getReference(self) -> WebExtensionReference:
        '''Get the primary reference to an Office Add-in.'''
        raise NotImplementedError()

    def getAlterReferences(self) -> WebExtensionReferenceCollection:
        '''Gets a list of alter references.'''
        raise NotImplementedError()

    def setFrozen(self, value : bool) -> None:
        '''Indicates whether the user can interact with the Office Add-in or not.
        :param value: '''
        raise NotImplementedError()

    def getProperties(self) -> WebExtensionPropertyCollection:
        '''Gets all properties of web extension.'''
        raise NotImplementedError()


class WebExtensionBinding:
    '''Represents a binding relationship between an Office Add-in and the data in the document.'''

    def setId(self, value : str) -> None:
        '''Sets the binding identifier.
        :param value: '''
        raise NotImplementedError()

    def getAppref(self) -> str:
        '''Gets the binding key used to map the binding entry in this list with the bound data in the document.'''
        raise NotImplementedError()

    def setAppref(self, value : str) -> None:
        '''Sets the binding key used to map the binding entry in this list with the bound data in the document.
        :param value: '''
        raise NotImplementedError()

    def getId(self) -> str:
        '''Gets the binding identifier.'''
        raise NotImplementedError()

    def getType(self) -> str:
        '''Gets the binding type.'''
        raise NotImplementedError()

    def setType(self, value : str) -> None:
        '''Sets the binding type.
        :param value: '''
        raise NotImplementedError()


class WebExtensionBindingCollection:
    '''Represents the list of binding relationships between an Office Add-in and the data in the document.'''

    def get(self, index : int) -> WebExtensionBinding:
        '''Gets web extension binding relationship by the specific index.
        :param index: The index.
        :returns: The web extension binding relationship'''
        raise NotImplementedError()

    def add(self) -> int:
        '''Adds an a binding relationship between an Office Add-in and the data in the document.'''
        raise NotImplementedError()


class WebExtensionCollection:
    '''Represents the list of web extension.'''

    def removeAt(self, index : int) -> None:
        '''Remove web extension by the index.
        :param index: The index.'''
        raise NotImplementedError()

    def addWebVideoPlayer(self, url : str, autoPlay : bool, startTime : int, endTime : int) -> int:
        '''Add a web video player into exel.
        :param url: 
        :param autoPlay: Indicates whether auto playing the video.
        :param startTime: The start time in unit of seconds.
        :param endTime: The end time in unit of seconds.'''
        raise NotImplementedError()

    def get(self, index : int) -> WebExtension:
        '''Gets web extension by the specific index.
        :param index: The index.
        :returns: The web extension.'''
        raise NotImplementedError()

    def add(self) -> int:
        '''Adds a web extension.'''
        raise NotImplementedError()


class WebExtensionProperty:
    '''Represents an Office Add-in custom property.'''

    def getValue(self) -> str:
        '''Gets a custom property value.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets a custom property name.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets a custom property name.
        :param value: '''
        raise NotImplementedError()

    def setValue(self, value : str) -> None:
        '''Sets a custom property value.
        :param value: '''
        raise NotImplementedError()


class WebExtensionPropertyCollection:
    '''Represents the list of web extension properties.'''

    def removeAt(self, name : str) -> None:
        '''Remove the property by the name.
        :param name: The name of the property.'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> WebExtensionProperty:
        '''Gets the property of web extension by the index.
        :param index: The index.
        :returns: The property of web extension.'''
        raise NotImplementedError()

    @overload
    def get(self, name : str) -> WebExtensionProperty:
        '''Gets the property of web extension.
        :param name: The name of property.
        :returns: The property of web extension.'''
        raise NotImplementedError()

    def add(self, name : str, value : str) -> int:
        '''Adds web extension property.
        :param name: The name of property.
        :param value: The value of property.
        :returns: The index of added property.'''
        raise NotImplementedError()


class WebExtensionReference:
    '''Represents identify the provider location and version of the extension.'''

    def getStoreName(self) -> str:
        '''Gets the instance of the marketplace where the Office Add-in is stored. .'''
        raise NotImplementedError()

    def setVersion(self, value : str) -> None:
        '''Sets the version.
        :param value: '''
        raise NotImplementedError()

    def setId(self, value : str) -> None:
        '''Sets the identifier associated with the Office Add-in within a catalog provider.
        The identifier MUST be unique within a catalog provider.
        :param value: '''
        raise NotImplementedError()

    def getStoreType(self) -> int:
        '''Gets the type of marketplace that the store attribute identifies.
        See :class:`WebExtensionStoreType`'''
        raise NotImplementedError()

    def getVersion(self) -> str:
        '''Gets the version.'''
        raise NotImplementedError()

    def setStoreName(self, value : str) -> None:
        '''Sets the instance of the marketplace where the Office Add-in is stored. .
        :param value: '''
        raise NotImplementedError()

    def getId(self) -> str:
        '''Gets the identifier associated with the Office Add-in within a catalog provider.
        The identifier MUST be unique within a catalog provider.'''
        raise NotImplementedError()

    def setStoreType(self, value : int) -> None:
        '''Sets the type of marketplace that the store attribute identifies.
        See :class:`WebExtensionStoreType`
        :param value: '''
        raise NotImplementedError()


class WebExtensionReferenceCollection:
    '''Represents the list of web extension reference.'''

    def get(self, index : int) -> WebExtensionReference:
        '''Gets web extension by the specific index.
        :param index: The index.
        :returns: The web extension'''
        raise NotImplementedError()

    def add(self) -> int:
        '''Adds an empty reference of web extension.'''
        raise NotImplementedError()


class WebExtensionShape:
    '''Represents the shape of web extension.'''

    def setWebExtension(self, value : WebExtension) -> None:
        '''Sets the web extension.
        :param value: '''
        raise NotImplementedError()

    def getWebExtension(self) -> WebExtension:
        '''Gets the web extension.'''
        raise NotImplementedError()


class WebExtensionStoreType:
    '''Represents the store type of web extension.'''

    OMEX : WebExtensionStoreType
    '''Specifies that the store type is Office.com.'''

    SP_CATALOG : WebExtensionStoreType
    '''Specifies that the store type is SharePoint corporate catalog.'''

    SP_APP : WebExtensionStoreType
    '''Specifies that the store type is a SharePoint web application.'''

    EXCHANGE : WebExtensionStoreType
    '''Specifies that the store type is an Exchange server.'''

    FILE_SYSTEM : WebExtensionStoreType
    '''Specifies that the store type is a file system share.'''

    REGISTRY : WebExtensionStoreType
    '''Specifies that the store type is the system registry.'''

    EX_CATALOG : WebExtensionStoreType
    '''Specifies that the store type is Centralized Deployment via Exchange.'''


class WebExtensionTaskPane:
    '''Represents a persisted taskpane object.'''

    def isLocked(self) -> bool:
        '''Indicates whether the taskpane is locked to the document in the UI and cannot be closed by the user.'''
        raise NotImplementedError()

    def setDockState(self, value : str) -> None:
        '''Sets the last-docked location of this taskpane object.
        :param value: '''
        raise NotImplementedError()

    def setWebExtension(self, value : WebExtension) -> None:
        '''Sets the web extension part associated with the taskpane instance
        :param value: '''
        raise NotImplementedError()

    def setLocked(self, value : bool) -> None:
        '''Indicates whether the taskpane is locked to the document in the UI and cannot be closed by the user.
        :param value: '''
        raise NotImplementedError()

    def setRow(self, value : int) -> None:
        '''Sets the index, enumerating from the outside to the inside, of this taskpane among other persisted taskpanes docked in the same default location.
        :param value: '''
        raise NotImplementedError()

    def getDockState(self) -> str:
        '''Gets the last-docked location of this taskpane object.'''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Indicates whether the Task Pane shows as visible by default when the document opens.'''
        raise NotImplementedError()

    def getRow(self) -> int:
        '''Gets the index, enumerating from the outside to the inside, of this taskpane among other persisted taskpanes docked in the same default location.'''
        raise NotImplementedError()

    def setWidth(self, value : int) -> None:
        '''Sets the default width value for this taskpane instance.
        :param value: '''
        raise NotImplementedError()

    def getWidth(self) -> int:
        '''Gets the default width value for this taskpane instance.'''
        raise NotImplementedError()

    def setVisible(self, value : bool) -> None:
        '''Indicates whether the Task Pane shows as visible by default when the document opens.
        :param value: '''
        raise NotImplementedError()

    def getWebExtension(self) -> WebExtension:
        '''Gets the web extension part associated with the taskpane instance'''
        raise NotImplementedError()


class WebExtensionTaskPaneCollection:
    '''Represents the list of task pane.'''

    def get(self, index : int) -> WebExtensionTaskPane:
        '''Gets task pane by the specific index.
        :param index: The index.
        :returns: The task pane.'''
        raise NotImplementedError()

    def add(self) -> int:
        '''Adds task pane.'''
        raise NotImplementedError()


class WebQueryConnection:
    '''Specifies the properties for a web query source. A web query will retrieve data from HTML tables,
    and can also supply HTTP "Get" parameters to be processed by the web server in generating the HTML by
    including the parameters and parameter elements.'''

    def setPost(self, value : str) -> None:
        '''Returns or sets the string used with the post method of inputting data into a web server
        to return data from a web query.
        :param value: '''
        raise NotImplementedError()

    def setEditPage(self, value : str) -> None:
        ''':deprecated: Use WebQueryConnection.EditWebPage property instead.'''
        raise NotImplementedError()

    def isHtmlTables(self) -> bool:
        '''Flag indicating whether web queries should only work on HTML tables.'''
        raise NotImplementedError()

    def setXl97(self, value : bool) -> None:
        '''This flag exists for backward compatibility with older existing spreadsheet files, and is set
        to true if this web query was created in Microsoft Excel 97.
        This is an optional attribute that can be ignored.
        :param value: '''
        raise NotImplementedError()

    def setSameSettings(self, value : bool) -> None:
        '''Flag indicating whether to parse all tables inside a PRE block with the same width settings
        as the first row.
        :param value: '''
        raise NotImplementedError()

    def getConnectionFile(self) -> str:
        '''Gets the connection file.'''
        raise NotImplementedError()

    def setEditWebPage(self, value : str) -> None:
        '''The URL of the user-facing web page showing the web query data. This URL is persisted
        in the case that sourceData="true" and url has been redirected to reference an XML file.
        Then the user-facing page can be shown in the UI, and the XML data can be retrieved
        behind the scenes.
        :param value: '''
        raise NotImplementedError()

    def setConsecutive(self, value : bool) -> None:
        '''Flag indicating whether consecutive delimiters should be treated as just one delimiter.
        :param value: '''
        raise NotImplementedError()

    def isXl2000(self) -> bool:
        '''This flag exists for backward compatibility with older existing spreadsheet files, and is set
        to true if this web query was refreshed in a spreadsheet application newer than or equal
        to Microsoft Excel 2000.
        This is an optional attribute that can be ignored.'''
        raise NotImplementedError()

    def isSameSettings(self) -> bool:
        '''Flag indicating whether to parse all tables inside a PRE block with the same width settings
        as the first row.'''
        raise NotImplementedError()

    def setXml(self, value : bool) -> None:
        '''true if the web query source is XML (versus HTML), otherwise false.
        :param value: '''
        raise NotImplementedError()

    def setParsePre(self, value : bool) -> None:
        '''Flag indicating whether data contained within HTML PRE tags in the web page is
        parsed into columns when you import the page into a query table.
        :param value: '''
        raise NotImplementedError()

    def setUrl(self, value : str) -> None:
        '''URL to use to refresh external data.
        :param value: '''
        raise NotImplementedError()

    def getPost(self) -> str:
        '''Returns or sets the string used with the post method of inputting data into a web server
        to return data from a web query.'''
        raise NotImplementedError()

    def setHtmlFormat(self, value : int) -> None:
        '''How to handle formatting from the HTML source when bringing web query data into the
        worksheet. Relevant when sourceData is True.
        See :class:`HtmlFormatHandlingType`
        :param value: '''
        raise NotImplementedError()

    def setXl2000(self, value : bool) -> None:
        '''This flag exists for backward compatibility with older existing spreadsheet files, and is set
        to true if this web query was refreshed in a spreadsheet application newer than or equal
        to Microsoft Excel 2000.
        This is an optional attribute that can be ignored.
        :param value: '''
        raise NotImplementedError()

    def isXml(self) -> bool:
        '''true if the web query source is XML (versus HTML), otherwise false.'''
        raise NotImplementedError()

    def setXmlSourceData(self, value : bool) -> None:
        '''Flag indicating that XML source data should be imported instead of the HTML table itself.
        :param value: '''
        raise NotImplementedError()

    def isConsecutive(self) -> bool:
        '''Flag indicating whether consecutive delimiters should be treated as just one delimiter.'''
        raise NotImplementedError()

    def setTextDates(self, value : bool) -> None:
        '''Flag indicating whether dates should be imported into cells in the worksheet as text rather than dates.
        :param value: '''
        raise NotImplementedError()

    def getClassType(self) -> int:
        '''Gets the type of this :class:`ExternalConnection` object.
        See :class:`ExternalConnectionClassType`'''
        raise NotImplementedError()

    def isTextDates(self) -> bool:
        '''Flag indicating whether dates should be imported into cells in the worksheet as text rather than dates.'''
        raise NotImplementedError()

    def getEditWebPage(self) -> str:
        '''The URL of the user-facing web page showing the web query data. This URL is persisted
        in the case that sourceData="true" and url has been redirected to reference an XML file.
        Then the user-facing page can be shown in the UI, and the XML data can be retrieved
        behind the scenes.'''
        raise NotImplementedError()

    def getUrl(self) -> str:
        '''URL to use to refresh external data.'''
        raise NotImplementedError()

    def getHtmlFormat(self) -> int:
        '''How to handle formatting from the HTML source when bringing web query data into the
        worksheet. Relevant when sourceData is True.
        See :class:`HtmlFormatHandlingType`'''
        raise NotImplementedError()

    def isParsePre(self) -> bool:
        '''Flag indicating whether data contained within HTML PRE tags in the web page is
        parsed into columns when you import the page into a query table.'''
        raise NotImplementedError()

    def getEditPage(self) -> str:
        ''':deprecated: Use WebQueryConnection.EditWebPage property instead.'''
        raise NotImplementedError()

    def isXl97(self) -> bool:
        '''This flag exists for backward compatibility with older existing spreadsheet files, and is set
        to true if this web query was created in Microsoft Excel 97.
        This is an optional attribute that can be ignored.'''
        raise NotImplementedError()

    def isXmlSourceData(self) -> bool:
        '''Flag indicating that XML source data should be imported instead of the HTML table itself.'''
        raise NotImplementedError()

    def setHtmlTables(self, value : bool) -> None:
        '''Flag indicating whether web queries should only work on HTML tables.
        :param value: '''
        raise NotImplementedError()


class WeightType:
    '''Enumerates the weight types for a picture border or a chart line.'''

    HAIR_LINE : WeightType
    '''Represents the weight of hair line.'''

    MEDIUM_LINE : WeightType
    '''Represents the weight of medium line.'''

    SINGLE_LINE : WeightType
    '''Represents the weight of single line.'''

    WIDE_LINE : WeightType
    '''Represents the weight of wide line.'''


class Workbook:
    '''Represents a root object to create an Excel spreadsheet.'''

    def getAbsolutePath(self) -> str:
        '''Gets the absolute path of the file.'''
        raise NotImplementedError()

    def setInterruptMonitor(self, value : AbstractInterruptMonitor) -> None:
        '''Sets the interrupt monitor.
        :param value: '''
        raise NotImplementedError()

    def getFonts(self) -> list[Font]:
        '''Gets all fonts in the style pool.'''
        raise NotImplementedError()

    def addDigitalSignature(self, digitalSignatureCollection : DigitalSignatureCollection) -> None:
        '''Adds digital signature to an OOXML spreadsheet file (Excel2007 and later).
        :param digitalSignatureCollection: '''
        raise NotImplementedError()

    def hasRevisions(self) -> bool:
        '''Gets if the workbook has any tracked changes'''
        raise NotImplementedError()

    def removeDigitalSignature(self) -> None:
        '''Removes digital signature from this spreadsheet.'''
        raise NotImplementedError()

    def getDigitalSignature(self) -> DigitalSignatureCollection:
        '''Gets digital signature from file.'''
        raise NotImplementedError()

    def updateLinkedDataSource(self, externalWorkbooks : list[Workbook]) -> None:
        '''If this workbook contains external links to other data source,
        Aspose.Cells will attempt to retrieve the latest data from give sources.
        :param externalWorkbooks: '''
        raise NotImplementedError()

    def getInterruptMonitor(self) -> AbstractInterruptMonitor:
        '''Gets the interrupt monitor.'''
        raise NotImplementedError()

    def protect(self, protectionType : int, password : str) -> None:
        '''Protects a workbook.
        :param protectionType: :class:`ProtectionType`. Protection type.
        :param password: Password to protect the workbook.'''
        raise NotImplementedError()

    def getWorksheets(self) -> WorksheetCollection:
        '''Gets the :class:`WorksheetCollection` collection in the spreadsheet.'''
        raise NotImplementedError()

    def getBuiltInDocumentProperties(self) -> BuiltInDocumentPropertyCollection:
        '''Returns a :class:`DocumentProperty` collection that represents all the built-in document properties of the spreadsheet.'''
        raise NotImplementedError()

    def dispose(self) -> None:
        '''Performs application-defined tasks associated with freeing, releasing, or
        resetting unmanaged resources.'''
        raise NotImplementedError()

    def getCellsDataTableFactory(self) -> CellsDataTableFactory:
        '''Gets the factory for building ICellsDataTable from custom objects'''
        raise NotImplementedError()

    def parseFormulas(self, ignoreError : bool) -> None:
        '''Parses all formulas which have not been parsed when they were loaded from template file or set to a cell.
        :param ignoreError: Whether ignore error for invalid formula.'''
        raise NotImplementedError()

    def hasExernalLinks(self) -> bool:
        ''':deprecated: Use ExternalLinkCollection.Count property instead.'''
        raise NotImplementedError()

    def closeAccessCache(self, opts : int) -> None:
        '''Closes the session that uses caches to access data.
        :param opts: :class:`AccessCacheOptions`. options of data access'''
        raise NotImplementedError()

    @overload
    def exportXml(self, mapName : str, path : str) -> None:
        '''Export XML data linked by the specified XML map.
        The following code exported the data linked by the first XmlMap.
        :param mapName: name of the XML map that need to be exported
        :param path: the export path'''
        raise NotImplementedError()

    @overload
    def exportXml(self, mapName : str, stream : OutputStream) -> None:
        '''Export XML data linked by the specified XML map.
        :param mapName: name of the XML map that need to be exported
        :param stream: the export stream'''
        raise NotImplementedError()

    def getStyleInPool(self, index : int) -> Style:
        '''Gets the style in the style pool.
        All styles in the workbook will be gathered into a pool.
        There is only a simple reference index in the cells.
        :param index: The index.
        :returns: The style in the pool corresponds to given index, may be null.'''
        raise NotImplementedError()

    def setAbsolutePath(self, value : str) -> None:
        '''Sets the absolute path of the file.
        :param value: '''
        raise NotImplementedError()

    def getDataSorter(self) -> DataSorter:
        '''Gets a DataSorter object to sort data.'''
        raise NotImplementedError()

    def getDefaultStyle(self) -> Style:
        '''Gets the default :class:`Style` object of the workbook.'''
        raise NotImplementedError()

    def getContentTypeProperties(self) -> ContentTypePropertyCollection:
        '''Gets the list of  :class:`ContentTypeProperty` objects in the workbook.'''
        raise NotImplementedError()

    def unprotect(self, password : str) -> None:
        '''Unprotects a workbook.
        :param password: Password to unprotect the workbook.'''
        raise NotImplementedError()

    def startAccessCache(self, opts : int) -> None:
        '''Starts the session that uses caches to access data.
        :param opts: :class:`AccessCacheOptions`. options of data access'''
        raise NotImplementedError()

    def isDigitallySigned(self) -> bool:
        '''Indicates if this spreadsheet is digitally signed.'''
        raise NotImplementedError()

    def getNamedStyle(self, name : str) -> Style:
        '''Gets the named style in the style pool.
        :param name: name of the style
        :returns: named style, maybe null.'''
        raise NotImplementedError()

    @overload
    def save(self, fileName : str, saveFormat : int) -> None:
        '''Saves the workbook to the disk.
        :param fileName: The file name.
        :param saveFormat: :class:`SaveFormat`. The save format type.'''
        raise NotImplementedError()

    @overload
    def save(self, fileName : str) -> None:
        '''Save the workbook to the disk.
        :param fileName: '''
        raise NotImplementedError()

    @overload
    def save(self, fileName : str, saveOptions : SaveOptions) -> None:
        '''Saves the workbook to the disk.
        :param fileName: The file name.
        :param saveOptions: The save options.'''
        raise NotImplementedError()

    @overload
    def save(self, stream : OutputStream, saveOptions : SaveOptions) -> None:
        '''Save the workbook to the stream.
        :param stream: The file stream.
        :param saveOptions: The save options.'''
        raise NotImplementedError()

    @overload
    def save(self, stream : OutputStream, saveFormat : int) -> None:
        '''Save the workbook to the stream.
        :param stream: The file stream.
        :param saveFormat: :class:`SaveFormat`. The save file format type.'''
        raise NotImplementedError()

    @overload
    def copy(self, source : Workbook, copyOptions : CopyOptions) -> None:
        '''Copies another Workbook object.
        :param source: Source Workbook object.
        :param copyOptions: The options of copying other workbook.'''
        raise NotImplementedError()

    @overload
    def copy(self, source : Workbook) -> None:
        '''Copies data from a source Workbook object.
        :param source: Source Workbook object.'''
        raise NotImplementedError()

    def getCountOfStylesInPool(self) -> int:
        '''Gets number of the styles in the style pool.'''
        raise NotImplementedError()

    def getSettings(self) -> WorkbookSettings:
        '''Represents the workbook settings.'''
        raise NotImplementedError()

    def setDefaultStyle(self, value : Style) -> None:
        '''Sets the default :class:`Style` object of the workbook.
        :param value: '''
        raise NotImplementedError()

    def getThemeColor(self, type : int) -> Color:
        '''Gets theme color.
        :param type: :class:`ThemeColorType`. The theme color type.
        :returns: The theme color.'''
        raise NotImplementedError()

    def getFileFormat(self) -> int:
        '''Gets the file format.
        See :class:`FileFormatType`'''
        raise NotImplementedError()

    def setFileFormat(self, value : int) -> None:
        '''Sets the file format.
        See :class:`FileFormatType`
        :param value: '''
        raise NotImplementedError()

    def setThemeColor(self, type : int, color : Color) -> None:
        '''Sets the theme color
        :param type: :class:`ThemeColorType`. The theme color type.
        :param color: the theme color'''
        raise NotImplementedError()

    @overload
    def refreshDynamicArrayFormulas(self, calculate : bool) -> None:
        '''Refreshes dynamic array formulas(spill into new range of neighboring cells according to current data)
        Other formulas in the workbook will not be calculated recursively even if they were used by dynamic array formulas.
        :param calculate: Whether calculates and updates cell values for those dynamic array formulas'''
        raise NotImplementedError()

    @overload
    def refreshDynamicArrayFormulas(self, calculate : bool, copts : CalculationOptions) -> None:
        '''Refreshes dynamic array formulas(spill into new range of neighboring cells according to current data)
        :param calculate: Whether calculates and updates cell values for those dynamic array formulas
        :param copts: The options for calculating formulas'''
        raise NotImplementedError()

    def getColors(self) -> list[Color]:
        '''Returns colors in the palette for the spreadsheet.'''
        raise NotImplementedError()

    @overload
    def replace(self, placeHolder : str, newValue : str) -> int:
        '''Replaces a cell's value with a new string.
        :param placeHolder: Cell placeholder
        :param newValue: String value to replace'''
        raise NotImplementedError()

    @overload
    def replace(self, placeHolder : str, newValue : int) -> int:
        '''Replaces a cell's value with a new integer.
        :param placeHolder: Cell placeholder
        :param newValue: Integer value to replace'''
        raise NotImplementedError()

    @overload
    def replace(self, placeHolder : str, newValue : int) -> int:
        '''Replaces a cell's value with a new double.
        :param placeHolder: Cell placeholder
        :param newValue: Double value to replace'''
        raise NotImplementedError()

    @overload
    def replace(self, placeHolder : str, newValues : list[str], isVertical : bool) -> int:
        '''Replaces a cell's value with a new string array.
        :param placeHolder: Cell placeholder
        :param newValues: String array to replace
        :param isVertical: True - Vertical, False - Horizontal'''
        raise NotImplementedError()

    @overload
    def replace(self, placeHolder : str, newValues : list[int], isVertical : bool) -> int:
        '''Replaces cells' values with an integer array.
        :param placeHolder: Cell placeholder
        :param newValues: Integer array to replace
        :param isVertical: True - Vertical, False - Horizontal'''
        raise NotImplementedError()

    @overload
    def replace(self, placeHolder : str, newValues : list[int], isVertical : bool) -> int:
        '''Replaces cells' values with a double array.
        :param placeHolder: Cell placeholder
        :param newValues: Double array to replace
        :param isVertical: True - Vertical, False - Horizontal'''
        raise NotImplementedError()

    @overload
    def replace(self, boolValue : bool, newValue : Object) -> int:
        '''Replaces cells' values with new data.
        :param boolValue: The boolean value to be replaced.
        :param newValue: New value. Can be string, integer, double or DateTime value.'''
        raise NotImplementedError()

    @overload
    def replace(self, intValue : int, newValue : Object) -> int:
        '''Replaces cells' values with new data.
        :param intValue: The integer value to be replaced.
        :param newValue: New value. Can be string, integer, double or DateTime value.'''
        raise NotImplementedError()

    @overload
    def replace(self, placeHolder : str, newValue : str, options : ReplaceOptions) -> int:
        '''Replaces a cell's value with a new string.
        :param placeHolder: Cell placeholder
        :param newValue: String value to replace
        :param options: The replace options'''
        raise NotImplementedError()

    def createBuiltinStyle(self, type : int) -> Style:
        '''Creates built-in style by given type.
        :param type: :class:`BuiltinStyleType`. The builtin style stype.
        :returns: :class:`Style` object'''
        raise NotImplementedError()

    def removePersonalInformation(self) -> None:
        '''Removes personal information.'''
        raise NotImplementedError()

    def copyTheme(self, source : Workbook) -> None:
        '''Copies the theme from another workbook.
        :param source: Source workbook.'''
        raise NotImplementedError()

    def createStyle(self) -> Style:
        '''Creates a new style.'''
        raise NotImplementedError()

    def getMatchingColor(self, rawColor : Color) -> Color:
        '''Find best matching Color in current palette.
        :param rawColor: Raw color.
        :returns: Best matching color.'''
        raise NotImplementedError()

    def isWorkbookProtectedWithPassword(self) -> bool:
        '''Indicates whether structure or window is protected with password.'''
        raise NotImplementedError()

    def setEncryptionOptions(self, encryptionType : int, keyLength : int) -> None:
        '''Set Encryption Options.
        :param encryptionType: :class:`EncryptionType`. The encryption type.
        :param keyLength: The key length.'''
        raise NotImplementedError()

    def customTheme(self, themeName : str, colors : list[Color]) -> None:
        '''Customs the theme.
        :param themeName: The theme name
        :param colors: The theme colors'''
        raise NotImplementedError()

    def getTheme(self) -> str:
        '''Gets the theme name.'''
        raise NotImplementedError()

    def removeExternalLinks(self) -> None:
        ''':deprecated: Use ExternalLinkCollection.Clear() method instead.'''
        raise NotImplementedError()

    def getDataMashup(self) -> DataMashup:
        '''Gets mashup data.'''
        raise NotImplementedError()

    def setFileName(self, value : str) -> None:
        '''Sets the current file name.
        :param value: '''
        raise NotImplementedError()

    def updateCustomFunctionDefinition(self, definition : CustomFunctionDefinition) -> None:
        '''Updates definition of custom functions.
        :param definition: Special definition of custom functions for user's special requirement.'''
        raise NotImplementedError()

    def createCellsColor(self) -> CellsColor:
        '''Creates a :class:`CellsColor` object.'''
        raise NotImplementedError()

    def removeUnusedStyles(self) -> None:
        '''Remove all unused styles.'''
        raise NotImplementedError()

    def getDataModel(self) -> DataModel:
        '''Gets data model in the workbook.'''
        raise NotImplementedError()

    @overload
    def calculateFormula(self) -> None:
        '''Calculates the result of formulas.'''
        raise NotImplementedError()

    @overload
    def calculateFormula(self, ignoreError : bool) -> None:
        '''Calculates the result of formulas.
        :param ignoreError: Indicates if hide the error in calculating formulas. The error may be unsupported function, external links, etc.'''
        raise NotImplementedError()

    @overload
    def calculateFormula(self, options : CalculationOptions) -> None:
        '''Calculating formulas in this workbook.
        :param options: Options for calculation'''
        raise NotImplementedError()

    def protectSharedWorkbook(self, password : str) -> None:
        '''Protects a shared workbook.
        :param password: Password to protect the workbook.'''
        raise NotImplementedError()

    def getVbaProject(self) -> VbaProject:
        '''Gets the :meth:`Workbook.getVbaProject()` in a spreadsheet.'''
        raise NotImplementedError()

    def changePalette(self, color : Color, index : int) -> None:
        '''Changes the palette for the spreadsheet in the specified index.
        :param color: Color structure.
        :param index: Palette index, 0 - 55.'''
        raise NotImplementedError()

    def getDataConnections(self) -> ExternalConnectionCollection:
        '''Gets the :class:`ExternalConnection` collection.'''
        raise NotImplementedError()

    def isLicensed(self) -> bool:
        '''Indicates whether license is set.'''
        raise NotImplementedError()

    def getCustomXmlParts(self) -> CustomXmlPartCollection:
        '''Represents a Custom XML Data Storage Part (custom XML data within a package).'''
        raise NotImplementedError()

    def removeMacro(self) -> None:
        '''Removes VBA/macro from this spreadsheet.'''
        raise NotImplementedError()

    def unprotectSharedWorkbook(self, password : str) -> None:
        '''Unprotects a shared workbook.
        :param password: Password to unprotect the workbook.'''
        raise NotImplementedError()

    def acceptAllRevisions(self) -> None:
        '''Accepts all tracked changes in the workbook.'''
        raise NotImplementedError()

    def isColorInPalette(self, color : Color) -> bool:
        '''Checks if a color is in the palette for the spreadsheet.
        :param color: Color structure.
        :returns: Returns true if this color is in the palette. Otherwise, returns false'''
        raise NotImplementedError()

    def setRibbonXml(self, value : str) -> None:
        '''Sets the XML file that defines the Ribbon UI.
        :param value: '''
        raise NotImplementedError()

    def hasMacro(self) -> bool:
        '''Indicates if this spreadsheet contains macro/VBA.'''
        raise NotImplementedError()

    def getCustomDocumentProperties(self) -> CustomDocumentPropertyCollection:
        '''Returns a :class:`DocumentProperty` collection that represents all the custom document properties of the spreadsheet.'''
        raise NotImplementedError()

    def setDigitalSignature(self, digitalSignatureCollection : DigitalSignatureCollection) -> None:
        '''Sets digital signature to an spreadsheet file (Excel2007 and later).
        :param digitalSignatureCollection: '''
        raise NotImplementedError()

    def combine(self, secondWorkbook : Workbook) -> None:
        '''Combines another Workbook object.
        :param secondWorkbook: Another Workbook object.'''
        raise NotImplementedError()

    def getFileName(self) -> str:
        '''Gets the current file name.'''
        raise NotImplementedError()

    @overload
    def importXml(self, url : str, sheetName : str, row : int, col : int) -> None:
        '''Imports/Updates an XML data file into the workbook.
        The following code imports xml data into worksheet 'Sheet 1' at Cell A1.
        :param url: the url/path of the xml file.
        :param sheetName: the destination sheet name.
        :param row: the destination row
        :param col: the destination column'''
        raise NotImplementedError()

    @overload
    def importXml(self, stream : InputStream, sheetName : str, row : int, col : int) -> None:
        '''Imports/Updates an XML data file into the workbook.
        :param stream: the xml file stream.
        :param sheetName: the destination sheet name.
        :param row: the destination row.
        :param col: the destination column.'''
        raise NotImplementedError()

    def getRibbonXml(self) -> str:
        '''Gets the XML file that defines the Ribbon UI.'''
        raise NotImplementedError()


class WorkbookDesigner:
    '''Encapsulates the object that represents a designer spreadsheet.'''

    def getUpdateEmptyStringAsNull(self) -> bool:
        '''If TRUE, Null will be inserted if the value is "";'''
        raise NotImplementedError()

    def getCalculateFormula(self) -> bool:
        '''Indicates whether formulas should be calculated.'''
        raise NotImplementedError()

    def setJsonDataSource(self, variable : str, data : str) -> None:
        '''
        :param variable: 
        :param data: '''
        raise NotImplementedError()

    def getLineByLine(self) -> bool:
        '''Indicates whether processing the smart marker line by line.'''
        raise NotImplementedError()

    def clearDataSource(self) -> None:
        '''Clears all data sources.'''
        raise NotImplementedError()

    def setCalculateFormula(self, value : bool) -> None:
        '''Indicates whether formulas should be calculated.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setDataSource(self, dataSource : str, cellsDataTable : ICellsDataTable) -> None:
        '''Sets data source of a :class:`ICellsDataTable` object.
        :param dataSource: The name of the data source.
        :param cellsDataTable: data table.'''
        raise NotImplementedError()

    @overload
    def setDataSource(self, variable : str, data : Object) -> None:
        '''Sets data binding to a variable.
        :param variable: Variable name created using smart marker.
        :param data: Source data.'''
        raise NotImplementedError()

    @overload
    def setDataSource(self, dataSource : str, rs : ResultSet, rowCount : int) -> None:
        '''Set the data source.
        :param dataSource: The name of the data source.
        :param rs: The result set.
        :param rowCount: The data count of given resultset.'''
        raise NotImplementedError()

    @overload
    def setDataSource(self, dataSource : str, rs : ResultSet) -> None:
        '''Set the data source.
        :param dataSource: The name of the data source.
        :param rs: The result set.'''
        raise NotImplementedError()

    @overload
    def setDataSource(self, rs : ResultSet) -> None:
        '''Set the data source.
        :param rs: The result set.'''
        raise NotImplementedError()

    def setLineByLine(self, value : bool) -> None:
        '''Indicates whether processing the smart marker line by line.
        :param value: '''
        raise NotImplementedError()

    def getWorkbook(self) -> Workbook:
        '''Gets the :class:`Workbook` object.'''
        raise NotImplementedError()

    def setUpdateEmptyStringAsNull(self, value : bool) -> None:
        '''If TRUE, Null will be inserted if the value is "";
        :param value: '''
        raise NotImplementedError()

    def getUpdateReference(self) -> bool:
        '''Indicates if references in other worksheets will be updated.'''
        raise NotImplementedError()

    def getSmartMarkers(self) -> list[str]:
        '''Returns a collection of smart markers in a spreadsheet.'''
        raise NotImplementedError()

    def getCallBack(self) -> ISmartMarkerCallBack:
        '''Gets callback interface of processing smartmarker.'''
        raise NotImplementedError()

    def setWorkbook(self, value : Workbook) -> None:
        '''Sets the :class:`Workbook` object.
        :param value: '''
        raise NotImplementedError()

    def getRepeatFormulasWithSubtotal(self) -> bool:
        '''Indicates whether repeating formulas with subtotal row.'''
        raise NotImplementedError()

    @overload
    def process(self) -> None:
        '''Processes the smart markers and populates the data source values.'''
        raise NotImplementedError()

    @overload
    def process(self, isPreserved : bool) -> None:
        '''Processes the smart markers and populates the data source values.
        :param isPreserved: True if the unrecognized smart marker is preserved.'''
        raise NotImplementedError()

    @overload
    def process(self, sheetIndex : int, isPreserved : bool) -> None:
        '''Processes the smart markers and populates the data source values.
        :param sheetIndex: Worksheet index.
        :param isPreserved: True if the unrecognized smart marker is preserved.'''
        raise NotImplementedError()

    def setCallBack(self, value : ISmartMarkerCallBack) -> None:
        '''Sets callback interface of processing smartmarker.
        :param value: '''
        raise NotImplementedError()

    def setUpdateReference(self, value : bool) -> None:
        '''Indicates if references in other worksheets will be updated.
        :param value: '''
        raise NotImplementedError()

    def setRepeatFormulasWithSubtotal(self, value : bool) -> None:
        '''Indicates whether repeating formulas with subtotal row.
        :param value: '''
        raise NotImplementedError()


class WorkbookMetadata:
    '''Represents the meta data.
    The following example creates a WorkbookMetadata.'''

    def getBuiltInDocumentProperties(self) -> BuiltInDocumentPropertyCollection:
        '''Returns a :class:`DocumentProperty` collection that represents all the  built-in document properties of the spreadsheet.'''
        raise NotImplementedError()

    def getOptions(self) -> MetadataOptions:
        '''Gets the options of the metadata.'''
        raise NotImplementedError()

    def getCustomDocumentProperties(self) -> CustomDocumentPropertyCollection:
        '''Returns a :class:`DocumentProperty` collection that represents all the custom document properties of the spreadsheet.'''
        raise NotImplementedError()

    def save(self, fileName : str) -> None:
        '''Save the modified metadata to the file.
        :param fileName: The file name.'''
        raise NotImplementedError()


class WorkbookPrintingPreview:
    '''Workbook printing preview.'''

    def getEvaluatedPageCount(self) -> int:
        '''Evaluate the total page count of this workbook
        The following code shows the fastest way to get page count of a workbook.'''
        raise NotImplementedError()


class WorkbookRender:
    '''Represents a Workbook render.
    The constructor of this class , must be used after modification of pagesetup, cell style.'''

    def getPageCount(self) -> int:
        '''Gets the total page count of workbook.'''
        raise NotImplementedError()

    @overload
    def toImage(self, stream : OutputStream) -> None:
        '''Render whole workbook as Tiff Image to stream.
        :param stream: the stream of the output image'''
        raise NotImplementedError()

    @overload
    def toImage(self, filename : str) -> None:
        '''Render whole workbook as Tiff Image to a file.
        :param filename: the filename of the output image'''
        raise NotImplementedError()

    @overload
    def toImage(self, pageIndex : int, fileName : str) -> None:
        '''Render certain page to a file.
        :param pageIndex: indicate which page is to be converted
        :param fileName: filename of the output image'''
        raise NotImplementedError()

    @overload
    def toImage(self, pageIndex : int, stream : java.io.InputStream) -> None:
        '''Render certain page to a stream.
        :param pageIndex: indicate which page is to be converted
        :param stream: the stream of the output image'''
        raise NotImplementedError()

    @overload
    def toImage(self, pageIndex : int, stream : OutputStream) -> None:
        '''Render certain page to a stream.
        :param pageIndex: indicate which page is to be converted
        :param stream: the stream of the output image'''
        raise NotImplementedError()

    @overload
    def toPrinter(self, printerName : str) -> None:
        '''Render workbook to Printer
        :param printerName: the name of the printer , for example: "Microsoft Office Document Image Writer"'''
        raise NotImplementedError()

    @overload
    def toPrinter(self, printerName : str, jobName : str) -> None:
        '''Render workbook to Printer
        :param printerName: the name of the printer , for example: "Microsoft Office Document Image Writer"
        :param jobName: set the print job name'''
        raise NotImplementedError()

    @overload
    def toPrinter(self, printerName : str, printPageIndex : int, printPageCount : int) -> None:
        ''':deprecated: Use ToPrinter(string PrinterName) and ImageOrPrintOptions.PageIndex, PageCount instead.'''
        raise NotImplementedError()

    def getPageSizeInch(self, pageIndex : int) -> list[float]:
        '''Get page size in inch of output image.
        :param pageIndex: The page index is based on zero.
        :returns: Page size of image, [0] for width and [1] for height'''
        raise NotImplementedError()

    def dispose(self) -> None:
        '''Releases resources created and used for rendering.'''
        raise NotImplementedError()


class WorkbookSettings:
    '''Represents all settings of the workbook.'''

    def getPropertiesFollowChartPoint(self) -> bool:
        '''Indicates whether datapoint properties and datalabels in all charts in this workbook follow their reference.'''
        raise NotImplementedError()

    def getWindowHeightCM(self) -> int:
        '''The height of the window, in unit of centimeter.'''
        raise NotImplementedError()

    def setCheckCompatibility(self, value : bool) -> None:
        '''Indicates whether check compatibility with earlier versions when saving workbook.
        :param value: '''
        raise NotImplementedError()

    def setSheetTabBarWidth(self, value : int) -> None:
        '''Width of worksheet tab bar (in 1/1000 of window width).
        :param value: '''
        raise NotImplementedError()

    def getWindowLeftInch(self) -> int:
        '''The distance from the left edge of the client area to the left edge of the window.
        In unit of inch.'''
        raise NotImplementedError()

    def getDisplayDrawingObjects(self) -> int:
        '''Indicates whether and how to show objects in the workbook.
        See :class:`DisplayDrawingObjects`'''
        raise NotImplementedError()

    def getAutoCompressPictures(self) -> bool:
        '''Specifies a boolean value that indicates the application automatically compressed pictures in the workbook.'''
        raise NotImplementedError()

    def setPassword(self, value : str) -> None:
        '''Represents Workbook file encryption password.
        :param value: '''
        raise NotImplementedError()

    def setWindowHeightCM(self, value : int) -> None:
        '''The height of the window, in unit of centimeter.
        :param value: '''
        raise NotImplementedError()

    def getWriteProtection(self) -> WriteProtection:
        '''Provides access to the workbook write protection options.'''
        raise NotImplementedError()

    def getShared(self) -> bool:
        '''Gets a value that indicates whether the Workbook is shared.'''
        raise NotImplementedError()

    def setWindowLeftInch(self, value : int) -> None:
        '''The distance from the left edge of the client area to the left edge of the window.
        In unit of inch.
        :param value: '''
        raise NotImplementedError()

    def getUpdateAdjacentCellsBorder(self) -> bool:
        '''Indicates whether update adjacent cells' border.'''
        raise NotImplementedError()

    def getMaxRowsOfSharedFormula(self) -> int:
        '''Gets the max row number of shared formula.'''
        raise NotImplementedError()

    def getProtectionType(self) -> int:
        '''Gets the protection type of the workbook.
        See :class:`ProtectionType`'''
        raise NotImplementedError()

    def getWindowLeftCM(self) -> int:
        '''The distance from the left edge of the client area to the left edge of the window.
        In unit of centimeter.'''
        raise NotImplementedError()

    def getLocale(self) -> Locale:
        '''Gets the Locale used by this workbook.'''
        raise NotImplementedError()

    def setDate1904(self, value : bool) -> None:
        '''Sets a value which represents if the workbook uses the 1904 date system.
        :param value: '''
        raise NotImplementedError()

    def dispose(self) -> None:
        '''Releases resources.'''
        raise NotImplementedError()

    def getHidePivotFieldList(self) -> bool:
        '''Gets whether hide the field list for the PivotTable.'''
        raise NotImplementedError()

    def getShowTabs(self) -> bool:
        '''Gets a value whether the Workbook tabs are displayed.'''
        raise NotImplementedError()

    def getSheetTabBarWidth(self) -> int:
        '''Width of worksheet tab bar (in 1/1000 of window width).'''
        raise NotImplementedError()

    def getDataExtractLoad(self) -> bool:
        '''indicates whether the application last opened the workbook for data recovery.'''
        raise NotImplementedError()

    def setGlobalizationSettings(self, value : GlobalizationSettings) -> None:
        '''Sets the globalization settings.
        :param value: '''
        raise NotImplementedError()

    def isProtected(self) -> bool:
        '''Gets a value that indicates whether the structure or window of the Workbook is protected.'''
        raise NotImplementedError()

    def setDefaultEncrypted(self, value : bool) -> None:
        '''Indicates whether encrypting the workbook with default password if Structure and Windows of the workbook are locked.
        :param value: '''
        raise NotImplementedError()

    def getMaxColumn(self) -> int:
        '''Gets the max column index, zero-based.'''
        raise NotImplementedError()

    def setHidden(self, value : bool) -> None:
        '''Indicates whether this workbook is hidden.
        :param value: '''
        raise NotImplementedError()

    def getRegion(self) -> int:
        '''Gets the regional settings for workbook.
        See :class:`CountryCode`'''
        raise NotImplementedError()

    def setRepairLoad(self, value : bool) -> None:
        '''Indicates whether the application last opened the workbook in safe or repair mode.
        :param value: '''
        raise NotImplementedError()

    def setWindowLeftCM(self, value : int) -> None:
        '''The distance from the left edge of the client area to the left edge of the window.
        In unit of centimeter.
        :param value: '''
        raise NotImplementedError()

    def setPropertiesFollowChartPoint(self, value : bool) -> None:
        '''Indicates whether datapoint properties and datalabels in all charts in this workbook follow their reference.
        :param value: '''
        raise NotImplementedError()

    def setWindowTopCM(self, value : int) -> None:
        '''The distance from the top edge of the client area to the top edge of the window, in unit of centimeter.
        :param value: '''
        raise NotImplementedError()

    def setCheckExcelRestriction(self, value : bool) -> None:
        '''Whether check restriction of excel file when user modify cells related objects.
        For example, excel does not allow inputting string value longer than 32K.
        When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
        If this property is false, we will accept your input string value as the cell's value so that later
        you can output the complete string value for other file formats such as CSV.
        However, if you have set such kind of value that is invalid for excel file format,
        you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.
        :param value: '''
        raise NotImplementedError()

    def getDefaultImageResolution(self) -> int:
        '''Gets default resolution of image.'''
        raise NotImplementedError()

    def setWindowWidthCM(self, value : int) -> None:
        '''The width of the window, in unit of centimeter.
        :param value: '''
        raise NotImplementedError()

    def getPassword(self) -> str:
        '''Represents Workbook file encryption password.'''
        raise NotImplementedError()

    def getMaxRow(self) -> int:
        '''Gets the max row index, zero-based.'''
        raise NotImplementedError()

    def setPaperSize(self, value : int) -> None:
        '''Sets the default print paper size.
        See :class:`PaperSizeType`
        :param value: '''
        raise NotImplementedError()

    def setWindowHeightInch(self, value : int) -> None:
        '''The height of the window, in unit of inch.
        :param value: '''
        raise NotImplementedError()

    def getRepairLoad(self) -> bool:
        '''Indicates whether the application last opened the workbook in safe or repair mode.'''
        raise NotImplementedError()

    def getDate1904(self) -> bool:
        '''Gets a value which represents if the workbook uses the 1904 date system.'''
        raise NotImplementedError()

    def setDisplayDrawingObjects(self, value : int) -> None:
        '''Indicates whether and how to show objects in the workbook.
        See :class:`DisplayDrawingObjects`
        :param value: '''
        raise NotImplementedError()

    def setFirstVisibleTab(self, value : int) -> None:
        '''Sets the first visible worksheet tab.
        :param value: '''
        raise NotImplementedError()

    def getPaperSize(self) -> int:
        '''Gets the default print paper size.
        See :class:`PaperSizeType`'''
        raise NotImplementedError()

    def setCheckCustomNumberFormat(self, value : bool) -> None:
        '''Indicates whether checking custom number format when setting Style.Custom.
        :param value: '''
        raise NotImplementedError()

    def getWindowTopCM(self) -> int:
        '''The distance from the top edge of the client area to the top edge of the window, in unit of centimeter.'''
        raise NotImplementedError()

    def getEnableMacros(self) -> bool:
        '''Enable macros;'''
        raise NotImplementedError()

    def getDefaultStyleSettings(self) -> DefaultStyleSettings:
        '''Gets the settings for default values of style-related properties for this workbook.'''
        raise NotImplementedError()

    def getWindowWidthCM(self) -> int:
        '''The width of the window, in unit of centimeter.'''
        raise NotImplementedError()

    def setResourceProvider(self, value : IStreamProvider) -> None:
        '''Sets the stream provider for external resource, such as loading image data for picture of type "LinkToFile".
        :param value: '''
        raise NotImplementedError()

    def setWarningCallback(self, value : IWarningCallback) -> None:
        '''Sets warning callback.
        :param value: '''
        raise NotImplementedError()

    def setWindowTop(self, value : int) -> None:
        '''The distance from the top edge of the client area to the top edge of the window, in unit of point.
        :param value: '''
        raise NotImplementedError()

    def getCompliance(self) -> int:
        '''Specifies the OOXML version for the output document. The default value is Ecma376_2006.
        See :class:`OoxmlCompliance`'''
        raise NotImplementedError()

    def setCompliance(self, value : int) -> None:
        '''Specifies the OOXML version for the output document. The default value is Ecma376_2006.
        See :class:`OoxmlCompliance`
        :param value: '''
        raise NotImplementedError()

    def setQuotePrefixToStyle(self, value : bool) -> None:
        '''Indicates whether setting :meth:`Style.getQuotePrefix()` property when entering the string value(which starts  with single quote mark ) to the cell
        :param value: '''
        raise NotImplementedError()

    def isHidden(self) -> bool:
        '''Indicates whether this workbook is hidden.'''
        raise NotImplementedError()

    def isVScrollBarVisible(self) -> bool:
        '''Gets a value indicating whether the generated spreadsheet will contain a vertical scroll bar.'''
        raise NotImplementedError()

    def setEnableMacros(self, value : bool) -> None:
        '''Enable macros;
        :param value: '''
        raise NotImplementedError()

    def getLanguageCode(self) -> int:
        '''Gets the user interface language of the Workbook version based on CountryCode that has saved the file.
        See :class:`CountryCode`'''
        raise NotImplementedError()

    def getResourceProvider(self) -> IStreamProvider:
        '''Gets the stream provider for external resource, such as loading image data for picture of type "LinkToFile".'''
        raise NotImplementedError()

    def setUpdateLinksType(self, value : int) -> None:
        '''Sets how updates external links when the workbook is opened.
        See :class:`UpdateLinksType`
        :param value: '''
        raise NotImplementedError()

    def setMaxRowsOfSharedFormula(self, value : int) -> None:
        '''Sets the max row number of shared formula.
        :param value: '''
        raise NotImplementedError()

    def getBuildVersion(self) -> str:
        '''Specifies the incremental public release of the application.'''
        raise NotImplementedError()

    def getCheckCompatibility(self) -> bool:
        '''Indicates whether check compatibility with earlier versions when saving workbook.'''
        raise NotImplementedError()

    def getThemeFont(self, type : int) -> str:
        '''Gets the default theme font name.
        :param type: :class:`FontSchemeType`. The scheme type of the font.'''
        raise NotImplementedError()

    def setAuthor(self, value : str) -> None:
        '''Sets the author of the file.
        :param value: '''
        raise NotImplementedError()

    def getWindowHeightInch(self) -> int:
        '''The height of the window, in unit of inch.'''
        raise NotImplementedError()

    def setLanguageCode(self, value : int) -> None:
        '''Sets the user interface language of the Workbook version based on CountryCode that has saved the file.
        See :class:`CountryCode`
        :param value: '''
        raise NotImplementedError()

    def setAutoRecover(self, value : bool) -> None:
        '''Indicates whether the file is marked for auto-recovery.
        :param value: '''
        raise NotImplementedError()

    def setUpdateAdjacentCellsBorder(self, value : bool) -> None:
        '''Indicates whether update adjacent cells' border.
        :param value: '''
        raise NotImplementedError()

    def getRemovePersonalInformation(self) -> bool:
        '''True if personal information can be removed from the specified workbook.'''
        raise NotImplementedError()

    def setVScrollBarVisible(self, value : bool) -> None:
        '''Sets a value indicating whether the generated spreadsheet will contain a vertical scroll bar.
        :param value: '''
        raise NotImplementedError()

    def isEncrypted(self) -> bool:
        '''Gets a value that indicates whether a password is required to open this workbook.'''
        raise NotImplementedError()

    def getWindowTop(self) -> int:
        '''The distance from the top edge of the client area to the top edge of the window, in unit of point.'''
        raise NotImplementedError()

    def getNumberDecimalSeparator(self) -> str:
        '''Gets the decimal separator for formatting/parsing numeric values. Default is the decimal separator of current Region.'''
        raise NotImplementedError()

    def isMinimized(self) -> bool:
        '''Represents whether the generated spreadsheet will be opened Minimized.'''
        raise NotImplementedError()

    def setDiscardImageEditData(self, value : bool) -> None:
        '''Indicates whether discarding editting image data.
        :param value: '''
        raise NotImplementedError()

    def getFirstVisibleTab(self) -> int:
        '''Gets the first visible worksheet tab.'''
        raise NotImplementedError()

    def setDefaultImageResolution(self, value : int) -> None:
        '''Sets default resolution of image.
        :param value: '''
        raise NotImplementedError()

    def setHidePivotFieldList(self, value : bool) -> None:
        '''Sets whether hide the field list for the PivotTable.
        :param value: '''
        raise NotImplementedError()

    def setNumberGroupSeparator(self, value : str) -> None:
        '''Sets the character that separates groups of digits to the left of the decimal in numeric values. Default is the group separator of current Region.
        :param value: '''
        raise NotImplementedError()

    def getFormulaSettings(self) -> FormulaSettings:
        '''Gets the settings for formula-related features.'''
        raise NotImplementedError()

    def getWarningCallback(self) -> IWarningCallback:
        '''Gets warning callback.'''
        raise NotImplementedError()

    def getAutoRecover(self) -> bool:
        '''Indicates whether the file is marked for auto-recovery.'''
        raise NotImplementedError()

    def isHScrollBarVisible(self) -> bool:
        '''Gets a value indicating whether the generated spreadsheet will contain a horizontal scroll bar.'''
        raise NotImplementedError()

    def setBuildVersion(self, value : str) -> None:
        '''Specifies the incremental public release of the application.
        :param value: '''
        raise NotImplementedError()

    def setShared(self, value : bool) -> None:
        '''Sets a value that indicates whether the Workbook is shared.
        :param value: '''
        raise NotImplementedError()

    def getDiscardImageEditData(self) -> bool:
        '''Indicates whether discarding editting image data.'''
        raise NotImplementedError()

    def setWindowLeft(self, value : int) -> None:
        '''The distance from the left edge of the client area to the left edge of the window, in unit of point.
        :param value: '''
        raise NotImplementedError()

    def setLocale(self, value : Locale) -> None:
        '''Sets the Locale used by this workbook.
        :param value: '''
        raise NotImplementedError()

    def getUpdateLinksType(self) -> int:
        '''Gets how updates external links when the workbook is opened.
        See :class:`UpdateLinksType`'''
        raise NotImplementedError()

    def getNumberGroupSeparator(self) -> str:
        '''Gets the character that separates groups of digits to the left of the decimal in numeric values. Default is the group separator of current Region.'''
        raise NotImplementedError()

    def setWindowWidthInch(self, value : int) -> None:
        '''The width of the window, in unit of inch.
        :param value: '''
        raise NotImplementedError()

    def getWindowHeight(self) -> int:
        '''The height of the window, in unit of point.'''
        raise NotImplementedError()

    def setPageOrientationType(self, pageOrientationType : int) -> None:
        '''Set the type of  print orientation for the whole workbook.
        :param pageOrientationType: :class:`PageOrientationType`. The page orientation type'''
        raise NotImplementedError()

    def isDefaultEncrypted(self) -> bool:
        '''Indicates whether encrypting the workbook with default password if Structure and Windows of the workbook are locked.'''
        raise NotImplementedError()

    def setSignificantDigits(self, value : int) -> None:
        '''Sets the number of significant digits.
        The default value is :meth:`CellsHelper.getSignificantDigits()`.
        :param value: '''
        raise NotImplementedError()

    def getCheckCustomNumberFormat(self) -> bool:
        '''Indicates whether checking custom number format when setting Style.Custom.'''
        raise NotImplementedError()

    def getStreamProvider(self) -> IStreamProvider:
        ''':deprecated: Use ResourceProvider property instead.'''
        raise NotImplementedError()

    def setCrashSave(self, value : bool) -> None:
        '''indicates whether the application last saved the workbook file after a crash.
        :param value: '''
        raise NotImplementedError()

    def setHScrollBarVisible(self, value : bool) -> None:
        '''Sets a value indicating whether the generated spreadsheet will contain a horizontal scroll bar.
        :param value: '''
        raise NotImplementedError()

    def getWindowLeft(self) -> int:
        '''The distance from the left edge of the client area to the left edge of the window, in unit of point.'''
        raise NotImplementedError()

    def getCheckExcelRestriction(self) -> bool:
        '''Whether check restriction of excel file when user modify cells related objects.
        For example, excel does not allow inputting string value longer than 32K.
        When you input a value longer than 32K such as by Cell.PutValue(string), if this property is true, you will get an Exception.
        If this property is false, we will accept your input string value as the cell's value so that later
        you can output the complete string value for other file formats such as CSV.
        However, if you have set such kind of value that is invalid for excel file format,
        you should not save the workbook as excel file format later. Otherwise there may be unexpected error for the generated excel file.'''
        raise NotImplementedError()

    def getGlobalizationSettings(self) -> GlobalizationSettings:
        '''Gets the globalization settings.'''
        raise NotImplementedError()

    def setWindowWidth(self, value : int) -> None:
        '''The width of the window, in unit of point.
        :param value: '''
        raise NotImplementedError()

    def setRegion(self, value : int) -> None:
        '''Sets the regional settings for workbook.
        See :class:`CountryCode`
        :param value: '''
        raise NotImplementedError()

    def setNumberDecimalSeparator(self, value : str) -> None:
        '''Sets the decimal separator for formatting/parsing numeric values. Default is the decimal separator of current Region.
        :param value: '''
        raise NotImplementedError()

    def setShowTabs(self, value : bool) -> None:
        '''Sets a value whether the Workbook tabs are displayed.
        :param value: '''
        raise NotImplementedError()

    def getAuthor(self) -> str:
        '''Gets the author of the file.'''
        raise NotImplementedError()

    def setWindowHeight(self, value : int) -> None:
        '''The height of the window, in unit of point.
        :param value: '''
        raise NotImplementedError()

    def getSignificantDigits(self) -> int:
        '''Gets the number of significant digits.
        The default value is :meth:`CellsHelper.getSignificantDigits()`.'''
        raise NotImplementedError()

    def getMemorySetting(self) -> int:
        '''Gets the memory usage options. The new option will be taken as the default option for newly created worksheets but does not take effect for existing worksheets.
        See :class:`MemorySetting`'''
        raise NotImplementedError()

    def setAutoCompressPictures(self, value : bool) -> None:
        '''Specifies a boolean value that indicates the application automatically compressed pictures in the workbook.
        :param value: '''
        raise NotImplementedError()

    def getQuotePrefixToStyle(self) -> bool:
        '''Indicates whether setting :meth:`Style.getQuotePrefix()` property when entering the string value(which starts  with single quote mark ) to the cell'''
        raise NotImplementedError()

    def getCrashSave(self) -> bool:
        '''indicates whether the application last saved the workbook file after a crash.'''
        raise NotImplementedError()

    def getWindowTopInch(self) -> int:
        '''The distance from the top edge of the client area to the top edge of the window, in unit of inch.'''
        raise NotImplementedError()

    def setMemorySetting(self, value : int) -> None:
        '''Sets the memory usage options. The new option will be taken as the default option for newly created worksheets but does not take effect for existing worksheets.
        See :class:`MemorySetting`
        :param value: '''
        raise NotImplementedError()

    def getWindowWidthInch(self) -> int:
        '''The width of the window, in unit of inch.'''
        raise NotImplementedError()

    def setMinimized(self, value : bool) -> None:
        '''Represents whether the generated spreadsheet will be opened Minimized.
        :param value: '''
        raise NotImplementedError()

    def setRemovePersonalInformation(self, value : bool) -> None:
        '''True if personal information can be removed from the specified workbook.
        :param value: '''
        raise NotImplementedError()

    def getWindowWidth(self) -> int:
        '''The width of the window, in unit of point.'''
        raise NotImplementedError()

    def setDataExtractLoad(self, value : bool) -> None:
        '''indicates whether the application last opened the workbook for data recovery.
        :param value: '''
        raise NotImplementedError()

    def setWindowTopInch(self, value : int) -> None:
        '''The distance from the top edge of the client area to the top edge of the window, in unit of inch.
        :param value: '''
        raise NotImplementedError()

    def setStreamProvider(self, value : IStreamProvider) -> None:
        ''':deprecated: Use ResourceProvider property instead.'''
        raise NotImplementedError()


class Worksheet:
    '''Encapsulates the object that represents a single worksheet.
    The following example shows how to freeze panes and insert hyperlink to worksheet with .Net or VB.'''

    @overload
    def refreshPivotTables(self) -> None:
        '''Refreshes all the PivotTables in this Worksheet.'''
        raise NotImplementedError()

    @overload
    def refreshPivotTables(self, option : PivotTableRefreshOption) -> bool:
        '''Refreshes all the PivotTables in this Worksheet.
        :param option: for refreshing data source of pivot table.'''
        raise NotImplementedError()

    def setTabId(self, value : int) -> None:
        '''Specifies the internal identifier for the sheet.
        :param value: '''
        raise NotImplementedError()

    def getHorizontalPageBreaks(self) -> HorizontalPageBreakCollection:
        '''Gets the :class:`HorizontalPageBreakCollection` collection.'''
        raise NotImplementedError()

    def getPrintingPageBreaks(self, options : ImageOrPrintOptions) -> list[CellArea]:
        '''Gets automatic page breaks.
        :param options: The print options
        :returns: The automatic page breaks areas.'''
        raise NotImplementedError()

    def getTransitionEvaluation(self) -> bool:
        '''Indicates whether the Transition Formula Evaluation (Lotus compatibility) option is enabled.'''
        raise NotImplementedError()

    @overload
    def calculateArrayFormula(self, formula : str, opts : CalculationOptions) -> list[list[Object]]:
        '''Calculates a formula as array formula.
        :param formula: Formula to be calculated.
        :param opts: Options for calculating formula'''
        raise NotImplementedError()

    @overload
    def calculateArrayFormula(self, formula : str, opts : CalculationOptions, maxRowCount : int, maxColumnCount : int) -> list[list[Object]]:
        '''Calculates a formula as array formula.
        :param formula: Formula to be calculated.
        :param opts: Options for calculating formula
        :param maxRowCount: the maximum row count of resultant data.
        :param maxColumnCount: the maximum column count of resultant data.
        :returns: Calculated formula result.'''
        raise NotImplementedError()

    @overload
    def calculateArrayFormula(self, formula : str, pOpts : FormulaParseOptions, cOpts : CalculationOptions, baseCellRow : int, baseCellColumn : int, maxRowCount : int, maxColumnCount : int, calculationData : CalculationData) -> list[list[Object]]:
        '''Calculates a formula as array formula.
        :param formula: Formula to be calculated.
        :param pOpts: Options for parsing formula
        :param cOpts: Options for calculating formula
        :param baseCellRow: The row index of the base cell.
        :param baseCellColumn: The column index of the base cell.
        :param maxRowCount: The maximum row count of resultant data.
        :param maxColumnCount: The maximum column count of resultant data.
        :param calculationData: The calculation data. It is used for the situation
        :returns: Calculated formula result.'''
        raise NotImplementedError()

    def clearComments(self) -> None:
        '''Clears all comments in designer spreadsheet.'''
        raise NotImplementedError()

    def getQueryTables(self) -> QueryTableCollection:
        '''Gets :class:`QueryTableCollection` in the worksheet.'''
        raise NotImplementedError()

    def getCharts(self) -> ChartCollection:
        '''Gets a :class:`Chart` collection'''
        raise NotImplementedError()

    def setFirstVisibleRow(self, value : int) -> None:
        '''Represents first visible row index.
        :param value: '''
        raise NotImplementedError()

    def getShapes(self) -> ShapeCollection:
        '''Returns all drawing shapes in this worksheet.'''
        raise NotImplementedError()

    def getBackgroundImage(self) -> list[int]:
        '''Gets worksheet background image.'''
        raise NotImplementedError()

    def setFirstVisibleColumn(self, value : int) -> None:
        '''Represents first visible column index.
        :param value: '''
        raise NotImplementedError()

    def unFreezePanes(self) -> None:
        '''Unfreezes panes in the worksheet.'''
        raise NotImplementedError()

    @overload
    def freezePanes(self, row : int, column : int, freezedRows : int, freezedColumns : int) -> None:
        '''Freezes panes at the specified cell in the worksheet.
        :param row: Row index.
        :param column: Column index.
        :param freezedRows: Number of visible rows in top pane, no more than row index.
        :param freezedColumns: Number of visible columns in left pane, no more than column index.'''
        raise NotImplementedError()

    @overload
    def freezePanes(self, cellName : str, freezedRows : int, freezedColumns : int) -> None:
        '''Freezes panes at the specified cell in the worksheet.
        :param cellName: Cell name.
        :param freezedRows: Number of visible rows in top pane, no more than row index.
        :param freezedColumns: Number of visible columns in left pane, no more than column index.'''
        raise NotImplementedError()

    @overload
    def protect(self, type : int) -> None:
        '''Protects worksheet.
        :param type: :class:`ProtectionType`. Protection type.'''
        raise NotImplementedError()

    @overload
    def protect(self, type : int, password : str, oldPassword : str) -> None:
        '''Protects worksheet.
        :param type: :class:`ProtectionType`. Protection type.
        :param password: Password.
        :param oldPassword: If the worksheet is already protected by a password, please supply the old password.'''
        raise NotImplementedError()

    def setType(self, value : int) -> None:
        '''Represents worksheet type.
        See :class:`SheetType`
        :param value: '''
        raise NotImplementedError()

    def setDisplayRightToLeft(self, value : bool) -> None:
        '''Indicates if the specified worksheet is displayed from right to left instead of from left to right.
        Default is false.
        :param value: '''
        raise NotImplementedError()

    def getListObjects(self) -> ListObjectCollection:
        '''Gets all ListObjects in this worksheet.'''
        raise NotImplementedError()

    def getUniqueId(self) -> str:
        '''Gets the unique id, it is same as {15DB5C3C-A5A1-48AF-8F25-3D86AC232D4F}.'''
        raise NotImplementedError()

    def getPictures(self) -> PictureCollection:
        '''Gets a :class:`Picture` collection.'''
        raise NotImplementedError()

    def getCustomProperties(self) -> CustomPropertyCollection:
        '''Gets an object representing
        the identifier information associated with a worksheet.'''
        raise NotImplementedError()

    def getVisibilityType(self) -> int:
        '''Indicates the visible state for this sheet.
        See :class:`VisibilityType`'''
        raise NotImplementedError()

    def dispose(self) -> None:
        '''Performs application-defined tasks associated with freeing, releasing, or
        resetting unmanaged resources.'''
        raise NotImplementedError()

    def getIndex(self) -> int:
        '''Gets the index of sheet in the worksheet collection.'''
        raise NotImplementedError()

    def getComments(self) -> CommentCollection:
        '''Gets the :class:`Comment` collection.'''
        raise NotImplementedError()

    def closeAccessCache(self, opts : int) -> None:
        '''Closes the session that uses caches to access the data in this worksheet.
        :param opts: :class:`AccessCacheOptions`. options of data access'''
        raise NotImplementedError()

    @overload
    def autoFitRows(self) -> None:
        '''Autofits all rows in this worksheet.'''
        raise NotImplementedError()

    @overload
    def autoFitRows(self, onlyAuto : bool) -> None:
        '''Autofits all rows in this worksheet.
        :param onlyAuto: '''
        raise NotImplementedError()

    @overload
    def autoFitRows(self, options : AutoFitterOptions) -> None:
        '''Autofits all rows in this worksheet.
        :param options: The auto fitter options'''
        raise NotImplementedError()

    @overload
    def autoFitRows(self, startRow : int, endRow : int) -> None:
        '''Autofits row height in a range.
        :param startRow: Start row index.
        :param endRow: End row index.'''
        raise NotImplementedError()

    @overload
    def autoFitRows(self, startRow : int, endRow : int, options : AutoFitterOptions) -> None:
        '''Autofits row height in a range.
        :param startRow: Start row index.
        :param endRow: End row index.
        :param options: The options of auto fitter.'''
        raise NotImplementedError()

    def removeAutoFilter(self) -> None:
        '''Removes the auto filter of the worksheet.'''
        raise NotImplementedError()

    @overload
    def autoFitColumn(self, columnIndex : int, firstRow : int, lastRow : int) -> None:
        '''Autofits the column width.
        :param columnIndex: Column index.
        :param firstRow: First row index.
        :param lastRow: Last row index.'''
        raise NotImplementedError()

    @overload
    def autoFitColumn(self, columnIndex : int) -> None:
        '''Autofits the column width.
        :param columnIndex: Column index.'''
        raise NotImplementedError()

    def getDisplayZeros(self) -> bool:
        '''True if zero values are displayed.'''
        raise NotImplementedError()

    def setPageBreakPreview(self, value : bool) -> None:
        '''Indicates whether the specified worksheet is shown in normal view or page break preview.
        :param value: '''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Sets the name of the worksheet.
        :param value: '''
        raise NotImplementedError()

    def getPanes(self) -> PaneCollection:
        '''Gets the window panes.'''
        raise NotImplementedError()

    def setRowColumnHeadersVisible(self, value : bool) -> None:
        '''Sets a value indicating whether the worksheet will display row and column headers.
        Default is true.
        :param value: '''
        raise NotImplementedError()

    def split(self) -> None:
        '''Splits window.'''
        raise NotImplementedError()

    def isProtected(self) -> bool:
        '''Indicates if the worksheet is protected.'''
        raise NotImplementedError()

    def setGridlinesVisible(self, value : bool) -> None:
        '''Sets a value indicating whether the gridlines are visible.Default is true.
        :param value: '''
        raise NotImplementedError()

    @overload
    def unprotect(self) -> None:
        '''Unprotects worksheet.'''
        raise NotImplementedError()

    @overload
    def unprotect(self, password : str) -> None:
        '''Unprotects worksheet.
        :param password: Password'''
        raise NotImplementedError()

    def startAccessCache(self, opts : int) -> None:
        '''Starts the session that uses caches to access the data in this worksheet.
        :param opts: :class:`AccessCacheOptions`. options of data access'''
        raise NotImplementedError()

    def getCodeName(self) -> str:
        '''Gets worksheet code name.'''
        raise NotImplementedError()

    def getType(self) -> int:
        '''Represents worksheet type.
        See :class:`SheetType`'''
        raise NotImplementedError()

    def xmlMapQuery(self, path : str, xmlMap : XmlMap) -> list:
        '''Query cell areas that mapped/linked to the specific path of xml map.
        :param path: xml element path
        :param xmlMap: Specify an xml map if you want to query for the specific path within a specific map
        :returns: :class:`CellArea` list that mapped/linked to the specific path of xml map, an empty list is returned if nothing is mapped/linked.'''
        raise NotImplementedError()

    def getCellWatches(self) -> CellWatchCollection:
        '''Gets collection of cells on this worksheet being watched in the 'watch window'.'''
        raise NotImplementedError()

    @overload
    def setVisible(self, isVisible : bool, ignoreError : bool) -> None:
        '''Sets the visible options.
        :param isVisible: Whether the worksheet is visible
        :param ignoreError: Whether to ignore error if this option is not valid.'''
        raise NotImplementedError()

    @overload
    def setVisible(self, value : bool) -> None:
        '''Represents if the worksheet is visible.
        :param value: '''
        raise NotImplementedError()

    @overload
    def copy(self, sourceSheet : Worksheet) -> None:
        '''Copies contents and formats from another worksheet.
        :param sourceSheet: Source worksheet.'''
        raise NotImplementedError()

    @overload
    def copy(self, sourceSheet : Worksheet, copyOptions : CopyOptions) -> None:
        '''Copies contents and formats from another worksheet.
        :param sourceSheet: Source worksheet.
        :param copyOptions: '''
        raise NotImplementedError()

    def setRulerVisible(self, value : bool) -> None:
        '''Indicates whether the ruler is visible. This property is only applied for page break preview.
        :param value: '''
        raise NotImplementedError()

    def removeSplit(self) -> None:
        '''Removes split window.'''
        raise NotImplementedError()

    def getFirstVisibleRow(self) -> int:
        '''Represents first visible row index.'''
        raise NotImplementedError()

    def getSmartTagSetting(self) -> SmartTagSetting:
        '''Gets all :class:`SmartTagCollection` objects of the worksheet.'''
        raise NotImplementedError()

    def setVisibilityType(self, value : int) -> None:
        '''Indicates the visible state for this sheet.
        See :class:`VisibilityType`
        :param value: '''
        raise NotImplementedError()

    def selectRange(self, startRow : int, startColumn : int, totalRows : int, totalColumns : int, removeOthers : bool) -> None:
        '''Selects a range.
        :param startRow: The start row.
        :param startColumn: The start column
        :param totalRows: The number of rows.
        :param totalColumns: The number of columns
        :param removeOthers: True means removing other selected range and only select this range.'''
        raise NotImplementedError()

    def getSelectedRanges(self) -> list:
        '''Gets selected ranges of cells in the designer spreadsheet.'''
        raise NotImplementedError()

    def getValidations(self) -> ValidationCollection:
        '''Gets the data validation setting collection in the worksheet.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Gets the name of the worksheet.'''
        raise NotImplementedError()

    def setDisplayZeros(self, value : bool) -> None:
        '''True if zero values are displayed.
        :param value: '''
        raise NotImplementedError()

    def getHyperlinks(self) -> HyperlinkCollection:
        '''Gets the :class:`HyperlinkCollection` collection.'''
        raise NotImplementedError()

    def isRulerVisible(self) -> bool:
        '''Indicates whether the ruler is visible. This property is only applied for page break preview.'''
        raise NotImplementedError()

    def setTransitionEntry(self, value : bool) -> None:
        '''Indicates whether the Transition Formula Entry (Lotus compatibility) option is enabled.
        :param value: '''
        raise NotImplementedError()

    @overload
    def autoFitColumns(self) -> None:
        '''Autofits all columns in this worksheet.'''
        raise NotImplementedError()

    @overload
    def autoFitColumns(self, options : AutoFitterOptions) -> None:
        '''Autofits all columns in this worksheet.
        :param options: The auto fitting options'''
        raise NotImplementedError()

    @overload
    def autoFitColumns(self, firstColumn : int, lastColumn : int) -> None:
        '''Autofits the columns width.
        :param firstColumn: First column index.
        :param lastColumn: Last column index.'''
        raise NotImplementedError()

    @overload
    def autoFitColumns(self, firstColumn : int, lastColumn : int, options : AutoFitterOptions) -> None:
        '''Autofits the columns width.
        :param firstColumn: First column index.
        :param lastColumn: Last column index.
        :param options: The auto fitting options'''
        raise NotImplementedError()

    @overload
    def autoFitColumns(self, firstRow : int, firstColumn : int, lastRow : int, lastColumn : int) -> None:
        '''Autofits the columns width.
        :param firstRow: First row index.
        :param firstColumn: First column index.
        :param lastRow: Last row index.
        :param lastColumn: Last column index.'''
        raise NotImplementedError()

    @overload
    def autoFitColumns(self, firstRow : int, firstColumn : int, lastRow : int, lastColumn : int, options : AutoFitterOptions) -> None:
        '''Autofits the columns width.
        :param firstRow: First row index.
        :param firstColumn: First column index.
        :param lastRow: Last row index.
        :param lastColumn: Last column index.
        :param options: The auto fitting options'''
        raise NotImplementedError()

    def getWorkbook(self) -> Workbook:
        '''Gets the workbook object which contains this sheet.'''
        raise NotImplementedError()

    def getTimelines(self) -> TimelineCollection:
        '''Get the Timeline collection in the worksheet'''
        raise NotImplementedError()

    def getOutline(self) -> Outline:
        '''Gets the outline on this worksheet.'''
        raise NotImplementedError()

    def getAutoFilter(self) -> AutoFilter:
        '''Represents auto filter for the specified worksheet.'''
        raise NotImplementedError()

    def getTabId(self) -> int:
        '''Specifies the internal identifier for the sheet.'''
        raise NotImplementedError()

    def getOleObjects(self) -> OleObjectCollection:
        '''Represents a collection of :class:`OleObject` in a worksheet.'''
        raise NotImplementedError()

    @overload
    def autoFitRow(self, rowIndex : int, firstColumn : int, lastColumn : int) -> None:
        '''Autofits the row height.
        :param rowIndex: Row index.
        :param firstColumn: First column index.
        :param lastColumn: Last column index.'''
        raise NotImplementedError()

    @overload
    def autoFitRow(self, rowIndex : int, firstColumn : int, lastColumn : int, options : AutoFitterOptions) -> None:
        '''Autofits the row height.
        :param rowIndex: Row index.
        :param firstColumn: First column index.
        :param lastColumn: Last column index.
        :param options: The auto fitter options'''
        raise NotImplementedError()

    @overload
    def autoFitRow(self, startRow : int, endRow : int, startColumn : int, endColumn : int) -> None:
        '''Autofits row height in a rectangle range.
        :param startRow: Start row index.
        :param endRow: End row index.
        :param startColumn: Start column index.
        :param endColumn: End column index.'''
        raise NotImplementedError()

    @overload
    def autoFitRow(self, rowIndex : int) -> None:
        '''Autofits the row height.
        :param rowIndex: Row index.'''
        raise NotImplementedError()

    def hasAutofilter(self) -> bool:
        '''Indicates whether this worksheet has auto filter.'''
        raise NotImplementedError()

    def replace(self, oldString : str, newString : str) -> int:
        '''Replaces all cells' text with a new string.
        :param oldString: Old string value.
        :param newString: New string value.'''
        raise NotImplementedError()

    def getSlicers(self) -> SlicerCollection:
        '''Get the Slicer collection in the worksheet'''
        raise NotImplementedError()

    def setActiveCell(self, value : str) -> None:
        '''Sets the active cell in the worksheet.
        :param value: '''
        raise NotImplementedError()

    def getShowFormulas(self) -> bool:
        '''Indicates whether to show formulas or their results.'''
        raise NotImplementedError()

    def setShowFormulas(self, value : bool) -> None:
        '''Indicates whether to show formulas or their results.
        :param value: '''
        raise NotImplementedError()

    def getProtection(self) -> Protection:
        '''Represents the various types of protection options available for a worksheet. Supports advanced protection options in ExcelXP and above version.'''
        raise NotImplementedError()

    def setViewType(self, value : int) -> None:
        '''Sets the view type.
        See :class:`ViewType`
        :param value: '''
        raise NotImplementedError()

    def getTransitionEntry(self) -> bool:
        '''Indicates whether the Transition Formula Entry (Lotus compatibility) option is enabled.'''
        raise NotImplementedError()

    def getSparklineGroups(self) -> SparklineGroupCollection:
        '''Gets the sparkline groups in the worksheet.'''
        raise NotImplementedError()

    def getCheckBoxes(self) -> CheckBoxCollection:
        '''Gets a :class:`CheckBox` collection.'''
        raise NotImplementedError()

    def getActiveCell(self) -> str:
        '''Gets the active cell in the worksheet.'''
        raise NotImplementedError()

    def getDisplayRightToLeft(self) -> bool:
        '''Indicates if the specified worksheet is displayed from right to left instead of from left to right.
        Default is false.'''
        raise NotImplementedError()

    def setTabColor(self, value : Color) -> None:
        '''Represents worksheet tab color.
        :param value: '''
        raise NotImplementedError()

    def toString(self) -> str:
        '''Returns a string represents the current Worksheet object.'''
        raise NotImplementedError()

    def getCells(self) -> Cells:
        '''Gets the :class:`Cells` collection.'''
        raise NotImplementedError()

    def removeAllDrawingObjects(self) -> None:
        '''Removes all drawing objects in this worksheet.'''
        raise NotImplementedError()

    def isGridlinesVisible(self) -> bool:
        '''Gets a value indicating whether the gridlines are visible.Default is true.'''
        raise NotImplementedError()

    def isRowColumnHeadersVisible(self) -> bool:
        '''Gets a value indicating whether the worksheet will display row and column headers.
        Default is true.'''
        raise NotImplementedError()

    def setZoom(self, value : int) -> None:
        '''Represents the scaling factor in percentage. It should be between 10 and 400.
        :param value: '''
        raise NotImplementedError()

    def getFirstVisibleColumn(self) -> int:
        '''Represents first visible column index.'''
        raise NotImplementedError()

    def getPaneState(self) -> int:
        '''Indicates whether the pane has horizontal or vertical splits, and whether those splits are frozen.
        See :class:`PaneStateType`'''
        raise NotImplementedError()

    def getFreezedPanes(self) -> list[int]:
        '''Gets the freeze panes.'''
        raise NotImplementedError()

    def setOutlineShown(self, value : bool) -> None:
        '''Indicates whether to show outline.
        :param value: '''
        raise NotImplementedError()

    def setSelected(self, value : bool) -> None:
        '''Indicates whether this worksheet is selected when the workbook is opened.
        :param value: '''
        raise NotImplementedError()

    def getTextBoxes(self) -> TextBoxCollection:
        '''Gets a :class:`TextBox` collection.'''
        raise NotImplementedError()

    def isPageBreakPreview(self) -> bool:
        '''Indicates whether the specified worksheet is shown in normal view or page break preview.'''
        raise NotImplementedError()

    @overload
    def calculateFormula(self, formula : str) -> Object:
        '''Calculates a formula.
        :param formula: Formula to be calculated.
        :returns: Calculated formula result.'''
        raise NotImplementedError()

    @overload
    def calculateFormula(self, formula : str, opts : CalculationOptions) -> Object:
        '''Calculates a formula expression directly.
        :param formula: Formula to be calculated.
        :param opts: Options for calculating formula
        :returns: Calculated result of given formula. The returned object may be of possible types of :meth:`Cell.getValue()`, or ReferredArea.'''
        raise NotImplementedError()

    @overload
    def calculateFormula(self, formula : str, pOpts : FormulaParseOptions, cOpts : CalculationOptions, baseCellRow : int, baseCellColumn : int, calculationData : CalculationData) -> Object:
        '''Calculates a formula expression directly.
        :param formula: Formula to be calculated.
        :param pOpts: Options for parsing formula.
        :param cOpts: Options for calculating formula.
        :param baseCellRow: The row index of the base cell.
        :param baseCellColumn: The column index of the base cell.
        :param calculationData: The calculation data. It is used for the situation
        :returns: Calculated result of given formula. The returned object may be of possible types of :meth:`Cell.getValue()`, or ReferredArea.'''
        raise NotImplementedError()

    @overload
    def calculateFormula(self, options : CalculationOptions, recursive : bool) -> None:
        '''Calculates all formulas in this worksheet.
        :param options: Options for calculation
        :param recursive: True means if the worksheet' cells depend on the cells of other worksheets,'''
        raise NotImplementedError()

    def getPageSetup(self) -> PageSetup:
        '''Represents the page setup description in this sheet.'''
        raise NotImplementedError()

    def addPageBreaks(self, cellName : str) -> None:
        '''Adds page break.
        :param cellName: '''
        raise NotImplementedError()

    def moveTo(self, index : int) -> None:
        '''Moves the sheet to another location in the spreadsheet.
        :param index: Destination sheet index.'''
        raise NotImplementedError()

    def getPivotTables(self) -> PivotTableCollection:
        '''Gets all pivot tables in this worksheet.'''
        raise NotImplementedError()

    def getAllowEditRanges(self) -> ProtectedRangeCollection:
        '''Gets the allow edit range collection in the worksheet.'''
        raise NotImplementedError()

    def getZoom(self) -> int:
        '''Represents the scaling factor in percentage. It should be between 10 and 400.'''
        raise NotImplementedError()

    def getErrorCheckOptions(self) -> ErrorCheckOptionCollection:
        '''Gets error check setting applied on certain ranges.'''
        raise NotImplementedError()

    def setUniqueId(self, value : str) -> None:
        '''Sets the unique id, it is same as {15DB5C3C-A5A1-48AF-8F25-3D86AC232D4F}.
        :param value: '''
        raise NotImplementedError()

    def getViewType(self) -> int:
        '''Gets the view type.
        See :class:`ViewType`'''
        raise NotImplementedError()

    def getAdvancedFilter(self) -> AdvancedFilter:
        '''Gets the settings of advanced filter.'''
        raise NotImplementedError()

    def advancedFilter(self, isFilter : bool, listRange : str, criteriaRange : str, copyTo : str, uniqueRecordOnly : bool) -> None:
        '''Filters data using complex criteria.
        :param isFilter: Indicates whether filtering the list in place.
        :param listRange: The list range.
        :param criteriaRange: The criteria range.
        :param copyTo: The range where copying data to.
        :param uniqueRecordOnly: Only displaying or copying unique rows.'''
        raise NotImplementedError()

    def isVisible(self) -> bool:
        '''Represents if the worksheet is visible.'''
        raise NotImplementedError()

    def getTabColor(self) -> Color:
        '''Represents worksheet tab color.'''
        raise NotImplementedError()

    def getScenarios(self) -> ScenarioCollection:
        '''Gets the collection of :class:`Scenario`.'''
        raise NotImplementedError()

    def isOutlineShown(self) -> bool:
        '''Indicates whether to show outline.'''
        raise NotImplementedError()

    def getVerticalPageBreaks(self) -> VerticalPageBreakCollection:
        '''Gets the :class:`VerticalPageBreakCollection` collection.'''
        raise NotImplementedError()

    def isSelected(self) -> bool:
        '''Indicates whether this worksheet is selected when the workbook is opened.'''
        raise NotImplementedError()

    def setTransitionEvaluation(self, value : bool) -> None:
        '''Indicates whether the Transition Formula Evaluation (Lotus compatibility) option is enabled.
        :param value: '''
        raise NotImplementedError()

    def convertFormulaReferenceStyle(self, formula : str, toR1C1 : bool, baseCellRow : int, baseCellColumn : int) -> str:
        '''Converts the formula reference style.
        :param formula: The formula to be converted.
        :param toR1C1: Which reference style to convert the formula to.
        :param baseCellRow: The row index of the base cell.
        :param baseCellColumn: The column index of the base cell.
        :returns: The converted formula.'''
        raise NotImplementedError()

    def setBackgroundImage(self, value : list[int]) -> None:
        '''Sets worksheet background image.
        :param value: '''
        raise NotImplementedError()

    def getConditionalFormattings(self) -> ConditionalFormattingCollection:
        '''Gets the ConditionalFormattings in the worksheet.'''
        raise NotImplementedError()

    def setCodeName(self, value : str) -> None:
        '''Gets worksheet code name.
        :param value: '''
        raise NotImplementedError()


class WorksheetCollection:
    '''Encapsulates a collection of :meth:`Range.getWorksheet()` objects.'''

    def getWebExtensionTaskPanes(self) -> WebExtensionTaskPaneCollection:
        '''Gets the list of task panes.'''
        raise NotImplementedError()

    def getXmlMaps(self) -> XmlMapCollection:
        '''Gets the XML maps in the workbook.'''
        raise NotImplementedError()

    def getNamedRanges(self) -> list[Range]:
        '''Gets all pre-defined named ranges in the spreadsheet.'''
        raise NotImplementedError()

    @overload
    def add(self, type : int) -> int:
        '''Adds a worksheet to the collection.
        :param type: :class:`SheetType`. Worksheet type.
        :returns: :meth:`Range.getWorksheet()` object index.'''
        raise NotImplementedError()

    @overload
    def add(self) -> int:
        '''Adds a worksheet to the collection.'''
        raise NotImplementedError()

    @overload
    def add(self, sheetName : str) -> Worksheet:
        '''Adds a worksheet to the collection.
        :param sheetName: Worksheet name
        :returns: :meth:`Range.getWorksheet()` object.'''
        raise NotImplementedError()

    def getThreadedCommentAuthors(self) -> ThreadedCommentAuthorCollection:
        '''Gets the list of threaded comment authors.'''
        raise NotImplementedError()

    def setActiveSheetName(self, value : str) -> None:
        '''Represents the name of active worksheet when the spreadsheet is opened.
        :param value: '''
        raise NotImplementedError()

    def clearPivottables(self) -> None:
        '''Clears pivot tables from the spreadsheet.'''
        raise NotImplementedError()

    def getDxfs(self) -> DxfCollection:
        '''Gets the master differential formatting records.'''
        raise NotImplementedError()

    @overload
    def insert(self, index : int, sheetType : int) -> Worksheet:
        '''Insert a worksheet.
        :param index: The sheet index
        :param sheetType: :class:`SheetType`. The sheet type.
        :returns: Returns an inserted worksheet.'''
        raise NotImplementedError()

    @overload
    def insert(self, index : int, sheetType : int, sheetName : str) -> Worksheet:
        '''Insert a worksheet.
        :param index: The sheet index
        :param sheetType: :class:`SheetType`. The sheet type.
        :param sheetName: The sheet name.
        :returns: Returns an inserted worksheet.'''
        raise NotImplementedError()

    def setRefreshAllConnections(self, value : bool) -> None:
        '''Indicates whether refresh all connections on opening file in MS Excel.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setOleSize(self, value : Object) -> None:
        '''Sets displayed size when Workbook file is used as an Ole object.
        :param value: '''
        raise NotImplementedError()

    @overload
    def setOleSize(self, startRow : int, endRow : int, startColumn : int, endColumn : int) -> None:
        '''Sets displayed size when Workbook file is used as an Ole object.
        :param startRow: Start row index.
        :param endRow: End row index.
        :param startColumn: Start column index.
        :param endColumn: End column index.'''
        raise NotImplementedError()

    @overload
    def addCopy(self, sheetName : str) -> int:
        '''Adds a worksheet to the collection and copies data from an existed worksheet.
        :param sheetName: Name of source worksheet.
        :returns: :meth:`Range.getWorksheet()` object index.'''
        raise NotImplementedError()

    @overload
    def addCopy(self, sheetIndex : int) -> int:
        '''Adds a worksheet to the collection and copies data from an existed worksheet.
        :param sheetIndex: Index of source worksheet.
        :returns: :meth:`Range.getWorksheet()` object index.'''
        raise NotImplementedError()

    @overload
    def addCopy(self, source : list[Worksheet], destSheetNames : list[str]) -> None:
        '''Copy a group of worksheets.
        :param source: The source worksheets.
        :param destSheetNames: The names of the copied sheets.'''
        raise NotImplementedError()

    def getNamedRangesAndTables(self) -> list[Range]:
        '''Gets all pre-defined named ranges in the spreadsheet.'''
        raise NotImplementedError()

    @overload
    def removeAt(self, name : str) -> None:
        '''Removes the element at a specified name.
        :param name: The name of the element to remove.'''
        raise NotImplementedError()

    @overload
    def removeAt(self, index : int) -> None:
        '''Removes the element at a specified index.
        :param index: The index value of the element to remove.'''
        raise NotImplementedError()

    def refreshAll(self) -> None:
        '''Refresh all pivot tables and charts with pivot source.'''
        raise NotImplementedError()

    def swapSheet(self, sheetIndex1 : int, sheetIndex2 : int) -> None:
        '''Swaps the two sheets.
        :param sheetIndex1: The first worksheet.
        :param sheetIndex2: The second worksheet.'''
        raise NotImplementedError()

    def getRevisionLogs(self) -> RevisionLogCollection:
        '''Represents revision logs.'''
        raise NotImplementedError()

    def isRefreshAllConnections(self) -> bool:
        '''Indicates whether refresh all connections on opening file in MS Excel.'''
        raise NotImplementedError()

    def sortNames(self) -> None:
        '''Sorts the defined names.'''
        raise NotImplementedError()

    def setXmlMaps(self, value : XmlMapCollection) -> None:
        '''Sets the XML maps in the workbook.
        :param value: '''
        raise NotImplementedError()

    def getSheetByCodeName(self, codeName : str) -> Worksheet:
        '''Gets the worksheet by the code name.
        :param codeName: Worksheet code name.
        :returns: The element with the specified code name.'''
        raise NotImplementedError()

    def getExternalLinks(self) -> ExternalLinkCollection:
        '''Represents external links in a workbook.'''
        raise NotImplementedError()

    @overload
    def registerAddInFunction(self, addInFile : str, functionName : str, lib : bool) -> int:
        '''Adds addin function into the workbook
        :param addInFile: the file contains the addin functions
        :param functionName: the addin function name
        :param lib: whether the given addin file is in the directory or sub-directory of Workbook Add-In library.
        :returns: ID of the data which contains given addin function'''
        raise NotImplementedError()

    @overload
    def registerAddInFunction(self, id : int, functionName : str) -> str:
        '''Adds addin function into the workbook
        :param id: ID of the data which contains addin functions,
        :param functionName: the addin function name
        :returns: URL of the addin file which contains addin functions'''
        raise NotImplementedError()

    @overload
    def getRangeByName(self, rangeName : str) -> Range:
        '''Gets Range object by pre-defined name.
        :param rangeName: Name of range.
        :returns: Range object.<p></p>Returns null if the named range does not exist.'''
        raise NotImplementedError()

    @overload
    def getRangeByName(self, rangeName : str, currentSheetIndex : int, includeTable : bool) -> Range:
        '''Gets :class:`Range` by pre-defined name or table's name
        :param rangeName: Name of range or table's name.
        :param currentSheetIndex: The sheet index. -1 represents global .
        :param includeTable: Indicates whether checking all tables.'''
        raise NotImplementedError()

    def clear(self) -> None:
        '''Clear all worksheets.'''
        raise NotImplementedError()

    def getTableStyles(self) -> TableStyleCollection:
        '''Gets :meth:`WorksheetCollection.getTableStyles()` object.'''
        raise NotImplementedError()

    def getWebExtensions(self) -> WebExtensionCollection:
        '''Gets the list of task panes.'''
        raise NotImplementedError()

    def getOleSize(self) -> Object:
        '''Gets displayed size when Workbook file is used as an Ole object.'''
        raise NotImplementedError()

    def getActiveSheetName(self) -> str:
        '''Represents the name of active worksheet when the spreadsheet is opened.'''
        raise NotImplementedError()

    def getNames(self) -> NameCollection:
        '''Gets the collection of all the Name objects in the spreadsheet.'''
        raise NotImplementedError()

    def getCustomDocumentProperties(self) -> CustomDocumentPropertyCollection:
        '''Returns a :class:`DocumentProperty` collection that represents all the custom document properties of the spreadsheet.'''
        raise NotImplementedError()

    def createUnionRange(self, address : str, sheetIndex : int) -> UnionRange:
        '''Creates a :class:`Range` object from an address of the range.
        :param address: The address of the range.
        :param sheetIndex: The sheet index.
        :returns: A :class:`Range` object'''
        raise NotImplementedError()

    @overload
    def get(self, index : int) -> Worksheet:
        '''Gets the :meth:`Range.getWorksheet()` element at the specified index.
        :param index: The zero based index of the element.
        :returns: The element at the specified index.'''
        raise NotImplementedError()

    @overload
    def get(self, sheetName : str) -> Worksheet:
        '''Gets the :meth:`Range.getWorksheet()` element with the specified name.
        :param sheetName: Worksheet name
        :returns: The element with the specified name.'''
        raise NotImplementedError()

    def createRange(self, address : str, sheetIndex : int) -> Range:
        '''Creates a :class:`Range` object from an address of the range.
        :param address: The address of the range.
        :param sheetIndex: The sheet index.
        :returns: A :class:`Range` object'''
        raise NotImplementedError()

    def setActiveSheetIndex(self, value : int) -> None:
        '''Represents the index of active worksheet when the spreadsheet is opened.
        :param value: '''
        raise NotImplementedError()

    def getBuiltInDocumentProperties(self) -> BuiltInDocumentPropertyCollection:
        '''Returns a :class:`DocumentProperty` collection that represents all the built-in document properties of the spreadsheet.'''
        raise NotImplementedError()

    @overload
    def refreshPivotTables(self) -> None:
        '''Refreshes all the PivotTables in the Excel file.'''
        raise NotImplementedError()

    @overload
    def refreshPivotTables(self, option : PivotTableRefreshOption) -> bool:
        '''Refreshes all the PivotTables in the Excel file.
        :param option: for refreshing data source of the pivot tables.'''
        raise NotImplementedError()

    def getActiveSheetIndex(self) -> int:
        '''Represents the index of active worksheet when the spreadsheet is opened.'''
        raise NotImplementedError()


class WriteProtection:
    '''Specifies write protection settings for a workbook.'''

    def getAuthor(self) -> str:
        '''Gets the author.'''
        raise NotImplementedError()

    def setPassword(self, value : str) -> None:
        '''Sets the protected password to modify the file.
        :param value: '''
        raise NotImplementedError()

    def setAuthor(self, value : str) -> None:
        '''Sets the author.
        :param value: '''
        raise NotImplementedError()

    def validatePassword(self, password : str) -> bool:
        '''Returns true if the specified password is the same as the write-protection password the file was protected with.
        :param password: The specified password.'''
        raise NotImplementedError()

    def isWriteProtected(self) -> bool:
        '''Indicates whether this workbook is write protected.'''
        raise NotImplementedError()

    def getRecommendReadOnly(self) -> bool:
        '''Indicates if the Read Only Recommended option is selected.'''
        raise NotImplementedError()

    def getPassword(self) -> str:
        '''Sets the protected password to modify the file.'''
        raise NotImplementedError()

    def setRecommendReadOnly(self, value : bool) -> None:
        '''Indicates if the Read Only Recommended option is selected.
        :param value: '''
        raise NotImplementedError()


class XAdESType:
    '''Type of XML Advanced Electronic Signature (XAdES).'''

    NONE : XAdESType
    '''XAdES is off.'''

    X_AD_ES : XAdESType
    '''Basic XAdES.'''


class XlsbSaveOptions:
    '''Represents the options for saving xlsb file.'''

    def setLightCellsDataProvider(self, value : LightCellsDataProvider) -> None:
        '''The data provider for saving workbook in light mode.
        :param value: '''
        raise NotImplementedError()

    def setExportAllColumnIndexes(self, value : bool) -> None:
        '''Indicates whether exporting all column indexes for cells.
        :param value: '''
        raise NotImplementedError()

    def getLightCellsDataProvider(self) -> LightCellsDataProvider:
        '''The data provider for saving workbook in light mode.'''
        raise NotImplementedError()

    def getExportAllColumnIndexes(self) -> bool:
        '''Indicates whether exporting all column indexes for cells.'''
        raise NotImplementedError()

    def getCompressionType(self) -> int:
        '''Gets the compression type for ooxml file.
        See :class:`OoxmlCompressionType`'''
        raise NotImplementedError()

    def setCompressionType(self, value : int) -> None:
        '''Sets the compression type for ooxml file.
        See :class:`OoxmlCompressionType`
        :param value: '''
        raise NotImplementedError()


class XlsSaveOptions:
    '''Represents the save options for the Excel 97-2003 file format: xls and xlt.'''

    def setLightCellsDataProvider(self, value : LightCellsDataProvider) -> None:
        '''The data provider for saving workbook in light mode.
        :param value: '''
        raise NotImplementedError()

    def setWpsCompatibility(self, value : bool) -> None:
        '''Indicates whether to make the xls more compatible with WPS.
        :param value: '''
        raise NotImplementedError()

    def isTemplate(self) -> bool:
        ''':deprecated: Use XlsSaveOptions(SaveFormat.Xlt) when it is template, otherwise use XlsSaveOptions().'''
        raise NotImplementedError()

    def getLightCellsDataProvider(self) -> LightCellsDataProvider:
        '''The data provider for saving workbook in light mode.'''
        raise NotImplementedError()

    def getMatchColor(self) -> bool:
        '''Indicates whether matching font color because there are 56 colors in the standard color palette.'''
        raise NotImplementedError()

    def setTemplate(self, value : bool) -> None:
        ''':deprecated: Use XlsSaveOptions(SaveFormat.Xlt) when it is template, otherwise use XlsSaveOptions().'''
        raise NotImplementedError()

    def getWpsCompatibility(self) -> bool:
        '''Indicates whether to make the xls more compatible with WPS.'''
        raise NotImplementedError()

    def setMatchColor(self, value : bool) -> None:
        '''Indicates whether matching font color because there are 56 colors in the standard color palette.
        :param value: '''
        raise NotImplementedError()


class XmlColumnProperty:
    '''Represents Xml Data Binding information.'''


class XmlDataBinding:
    '''Represents Xml Data Binding information.'''

    def getUrl(self) -> str:
        '''Gets source url of this data binding.'''
        raise NotImplementedError()


class XmlLoadOptions:
    '''Represents the options of loading xml.'''

    def setXmlMap(self, value : bool) -> None:
        '''Indicates whether mapping xml to Excel.
        The default value is false.
        :param value: '''
        raise NotImplementedError()

    def setContainsMultipleWorksheets(self, value : bool) -> None:
        '''Indicates whether importing xml as multiple worksheets.
        :param value: '''
        raise NotImplementedError()

    def containsMultipleWorksheets(self) -> bool:
        '''Indicates whether importing xml as multiple worksheets.'''
        raise NotImplementedError()

    def getDateFormat(self) -> str:
        '''Gets the format of date value.'''
        raise NotImplementedError()

    def getNumberFormat(self) -> str:
        '''Gets the format of numeric value.'''
        raise NotImplementedError()

    def getStartCell(self) -> str:
        '''Gets the start cell.'''
        raise NotImplementedError()

    def setIgnoreRootAttributes(self, value : bool) -> None:
        '''Indicates whether ignore attributes of the root element.
        :param value: '''
        raise NotImplementedError()

    def setNumberFormat(self, value : str) -> None:
        '''Sets the format of numeric value.
        :param value: '''
        raise NotImplementedError()

    def getIgnoreRootAttributes(self) -> bool:
        '''Indicates whether ignore attributes of the root element.'''
        raise NotImplementedError()

    def setStartCell(self, value : str) -> None:
        '''Sets the start cell.
        :param value: '''
        raise NotImplementedError()

    def setDateFormat(self, value : str) -> None:
        '''Sets the format of date value.
        :param value: '''
        raise NotImplementedError()

    def setConvertNumericOrDate(self, value : bool) -> None:
        '''Indicates whether converting the value in xml file to numeric or date.
        :param value: '''
        raise NotImplementedError()

    def isXmlMap(self) -> bool:
        '''Indicates whether mapping xml to Excel.
        The default value is false.'''
        raise NotImplementedError()

    def getConvertNumericOrDate(self) -> bool:
        '''Indicates whether converting the value in xml file to numeric or date.'''
        raise NotImplementedError()


class XmlMap:
    '''Represents Xml map information.'''

    def getRootElementName(self) -> str:
        '''Gets root element name.'''
        raise NotImplementedError()

    def getDataBinding(self) -> XmlDataBinding:
        '''Gets an :class:`XmlDataBinding` of this map.'''
        raise NotImplementedError()

    def getName(self) -> str:
        '''Returns or sets the name of the object.'''
        raise NotImplementedError()

    def setName(self, value : str) -> None:
        '''Returns or sets the name of the object.
        :param value: '''
        raise NotImplementedError()


class XmlMapCollection:
    '''A collection of :meth:`ListObject.getXmlMap()` objects that represent XmlMap information.'''

    def clear(self) -> None:
        '''Removes all XmlMaps.'''
        raise NotImplementedError()

    def get(self, index : int) -> XmlMap:
        '''Gets the xml map by the specific index.
        :param index: The index.
        :returns: The xml map'''
        raise NotImplementedError()

    def add(self, url : str) -> int:
        '''Add a :meth:`ListObject.getXmlMap()` by the url/path of a xml/xsd file.
        The following code adds two XmlMaps by a xsd file and a xml file.
        :param url: url/path of a xml/xsd file.
        :returns: :meth:`ListObject.getXmlMap()` object index.'''
        raise NotImplementedError()



class XmlSaveOptions:
    '''Represents the options of saving the workbook as an xml file.'''

    def setDataAsAttribute(self, value : bool) -> None:
        '''Indicates whether exporting data as attributes of element.
        :param value: '''
        raise NotImplementedError()

    def setSheetIndexes(self, value : list[int]) -> None:
        '''Represents the indexes of exported sheets.
        :param value: '''
        raise NotImplementedError()

    def setXmlMapName(self, value : str) -> None:
        '''Indicates whether exporting xml map in the file.
        :param value: '''
        raise NotImplementedError()

    def getDataAsAttribute(self) -> bool:
        '''Indicates whether exporting data as attributes of element.'''
        raise NotImplementedError()

    def getExportArea(self) -> CellArea:
        '''Gets the exporting range.'''
        raise NotImplementedError()

    def getSheetNameAsElementName(self) -> bool:
        '''Indicates whether exporting sheet's name as the name of the element.'''
        raise NotImplementedError()

    def setHasHeaderRow(self, value : bool) -> None:
        '''Indicates whether the range contains header row.
        :param value: '''
        raise NotImplementedError()

    def getXmlMapName(self) -> str:
        '''Indicates whether exporting xml map in the file.'''
        raise NotImplementedError()

    def setExportArea(self, value : CellArea) -> None:
        '''Sets the exporting range.
        :param value: '''
        raise NotImplementedError()

    def hasHeaderRow(self) -> bool:
        '''Indicates whether the range contains header row.'''
        raise NotImplementedError()

    def setSheetNameAsElementName(self, value : bool) -> None:
        '''Indicates whether exporting sheet's name as the name of the element.
        :param value: '''
        raise NotImplementedError()

    def getSheetIndexes(self) -> list[int]:
        '''Represents the indexes of exported sheets.'''
        raise NotImplementedError()


class XpsSaveOptions:
    '''Represents the additional options when saving the file as the Xps.'''

